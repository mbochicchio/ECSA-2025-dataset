/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.HostIdentifierException;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.format.util.AddressTrieOps.AddressTrieAddOps;
import inet.ipaddr.format.util.BinaryTreeNode.KeyIterator;
abstract class AbstractTree<E extends Address> implements AddressTrieAddOps<E> {
	private static final long serialVersionUID = 1L;
	static ResourceBundle bundle;
	
	static {
		//reuse the same properties file
		String propertyFileName = "IPAddressResources";
		String name = HostIdentifierException.class.getPackage().getName() + '.' + propertyFileName;
		try {
			bundle = ResourceBundle.getBundle(name);
		} catch (MissingResourceException e) {
			System.err.println("bundle " + name + " is missing");
		}
	}
	
	static String getMessage(String key) {
		if(bundle != null) {
			try {
				return bundle.getString(key);
				
			} catch (MissingResourceException e1) {}
		}
		return key;
	}
	
	BinaryTreeNode<E> root;
	protected AbstractTree(BinaryTreeNode<E> root) {
		this.root = root;
	}
	/**
	 * Returns the root of this trie
	 * @return
	 */
	public BinaryTreeNode<E> getRoot() {
		return root;
	}
	/**
	 * Returns the number of elements in the tree.  
	 * Only nodes for which {@link BinaryTreeNode#isAdded()} returns true are counted.
	 * When zero is returned, {@link #isEmpty()} returns true.
	 * 
	 * @return
	 */
	public int size() {
		return getRoot().size();
	}
	/**
	 * Returns the number of nodes in the tree, which is always more than the number of elements.
	 * 
	 * @return
	 */
	public int nodeSize() {
		return getRoot().nodeSize();
	}
	/**
	 * Ensures the address is either an individual address or a prefix block subnet.
	 * 
	 * @param <E>
	 * @param addr
	 * @param thro
	 * @return
	 */
	@SuppressWarnings("unchecked")
	static <E extends Address> E checkBlockOrAddress(E addr, boolean thro) {
		if(!addr.isMultiple()) {
			if(!addr.isPrefixed()) {
				return addr;
			}
			return (E) addr.withoutPrefixLength();
		} else if(addr.isSinglePrefixBlock()) {
			return addr;
		} else {
			AddressSegmentSeries series;
			if(addr instanceof IPAddressSegmentSeries) {
				series = ((IPAddressSegmentSeries) addr).assignPrefixForSingleBlock();
			} else {
				Integer newPrefix = addr.getPrefixLengthForSingleBlock();
				series = newPrefix == null ? null : addr.setPrefixLength(newPrefix, false);
			}
			if(series != null) {
				return (E) series;
			}
		}
		if(thro) {
			throw new IllegalArgumentException(getMessage("ipaddress.error.address.not.block"));
		}
		return null;
	}
	/**
	 * Removes all added nodes from the tree, after which {@link #isEmpty()} will return true
	 */
	public void clear() {
		getRoot().clear();
	}
	@Override
	public Iterator<E> iterator() {
		return new KeyIterator<E>(nodeIterator(true));
	}
	@Override
	public Iterator<E> descendingIterator() {
		return new KeyIterator<E>(nodeIterator(false));
	}
	@Override
	public int hashCode() {
		int hashCode = 0;
		Iterator<? extends BinaryTreeNode<E>> these = nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next();
			hashCode += node.hashCode();
		}
	    return hashCode;
	}
	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if(o instanceof AbstractTree) {
			AbstractTree<?> other = (AbstractTree<?>) o;
			if(other.size() != size()) {
				return false;
			}
			Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true),
					others = other.nodeIterator(true);
			while(these.hasNext()) {
				BinaryTreeNode<?> node = these.next(), otherNode = others.next();
				if(!node.equals(otherNode)) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	/**
	 * Returns true if there are not any added nodes within this tree
	 */
	public boolean isEmpty() {
		return size() == 0;
	}
	/**
	 * Returns a visual representation of the tree with one node per line.
	 */
	@Override
	public String toString() {
		return toString(true);
	}
	/**
	 * Returns a visual representation of the tree with one node per line, with or without the non-added keys.
	 */
	public String toString(boolean withNonAddedKeys) {
		return getRoot().toTreeString(withNonAddedKeys, true);
	}
	/**
	 * Copies the trie, but not the keys or values.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public AbstractTree<E> clone() {
		try {
			return (AbstractTree<E>) super.clone();
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Spliterator;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * A binary tree node. 
 * <p>
 * Some binary tree nodes are considered "added" and others are not.
 * Those nodes created for key elements added to the tree are "added" nodes.  
 * Those that are not added are those nodes created to serve as junctions for the added nodes.
 * Only added elements contribute to the size of a tree.  
 * When removing nodes, non-added nodes are removed automatically whenever they are no longer needed,
 * which is when an added node has less than two added sub-nodes.
 * <p>
 * BinaryTreeNode objects have a read-only API, in the sense that they cannot be constructed directly.
 * Instead they are created indirectly by tree operations or by cloning existing nodes.
 * <p>
 * The API does allow you to remove them from trees, or to clone them.  They can also be used to traverse a tree. 
 * <p>
 * Nodes have various properties: the key, parent node, lower sub-node, upper sub-node, "added" property, and size.  
 * The "added" property can change if the node changes status following tree operations.
 * If removed from a tree the parent property can change, and the sub-nodes can change when sub-nodes are removed from the tree,
 * or other nodes are inserted into the tree, changing sub-nodes.  
 * However, none of these can be explicitly changed directly, they can only be changed indirectly by tree operations.
 * The key of a node never changes.
 * 
 * @author scfoley
 *
 * @param <E>
 */
public class BinaryTreeNode<E> implements TreeOps<E> {
	private static final long serialVersionUID = 1L;
	static String getMessage(String key) {
		return AbstractTree.getMessage(key);
	}
	static class Bounds<E> implements Serializable {
		private static final long serialVersionUID = 1L;
		final Comparator<? super E> comparator;
		final E lowerBound, upperBound;
		final boolean lowerInclusive, upperInclusive;
		Bounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			if(comparator == null) {
				throw new NullPointerException();
			}
			this.comparator = comparator;
			this.lowerBound = lowerBound;
			this.upperBound = upperBound;
			this.lowerInclusive = lowerInclusive;
			this.upperInclusive = upperInclusive;
			if(upperBound != null) {
				if(isBelowLowerBound(upperBound)) {
					throw new IllegalArgumentException(getMessage("ipaddress.error.address.lower.exceeds.upper") + " " + lowerBound + ", " + upperBound);
				}
			}
		}
		// throws IllegalArgumentException if expands the existing bounds on either end,
		// returns null if equivalent to the existing bounds
		Bounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return restrict(lowerBound, lowerInclusive, upperBound, upperInclusive, true);
		}
		
		Bounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, boolean thro) {
			// One thing we check is that the new bounds are at least more restrictive (when new bound is specified).
			// Also, when an exclusive bound is adjacent to an inclusive bound, we choose the exclusive bound.
			if(lowerBound != null) {
				BoundsCheck check = compareToLowerBound(lowerBound, lowerInclusive);
				if(check.isLessRestrictive()) {
					if(thro) {
						throw new IllegalArgumentException(getMessage("ipaddress.error.lower.below.range") + " " + lowerBound);
					}
					lowerBound = null;
				} else if(!check.isMoreRestrictive()) {
					// new bound has no effect
					if(check != BoundsCheck.EQUIVALENT_TO_INCLUSIVE) {
						// We prefer exclusive.
						// but if not switching inclusive to exclusive, no point in using the new bounds
						// for EQUIVALENT_TO_UNBOUNDED, SAME and EQUIVALENT_TO_EXCLUSIVE we throw away the new bound
						lowerBound = null;
					} // else EQUIVALENT_TO_INCLUSIVE means the new bound is exclusive, the existing one inclusive, so we choose the new one
				}
			}
			if(upperBound != null) {
				BoundsCheck check = compareToUpperBound(upperBound, upperInclusive);
				if(check.isLessRestrictive()) {
					if(thro) {
						throw new IllegalArgumentException(getMessage("ipaddress.error.lower.above.range") + " " + upperBound);
					}
					upperBound = null;
				} else if(!check.isMoreRestrictive()) {
					// new bound has no effect
					if(check != BoundsCheck.EQUIVALENT_TO_INCLUSIVE) {
						// we prefer exclusive,
						// but if not switching inclusive to exclusive, no point in using the new bounds
						upperBound = null;
					}// else EQUIVALENT_TO_INCLUSIVE means the new bound is exclusive, the existing one inclusive, so we choose the new one
				}
			}
			if(lowerBound == null) {
				if(upperBound == null) {
					return null;
				}
				lowerBound = this.lowerBound;
				lowerInclusive = this.lowerInclusive;
			}
			if(upperBound == null) {
				upperBound = this.upperBound;
				upperInclusive = this.upperInclusive;
			}
			return createBounds(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		// return this if the intersection is equivalent to the existing
		Bounds<E> intersect(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			Bounds<E> newBounds = restrict(lowerBound, lowerInclusive, upperBound, upperInclusive, false);
			if(newBounds == null) {
				return this;
			}
			return newBounds;
		}
		Bounds<E> createBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			return new Bounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		public boolean isInBounds(E addr) {
			return isWithinLowerBound(addr) && isWithinUpperBound(addr);
		}
		public E getLowerBound() {
			return lowerBound;
		}
		public E getUpperBound() {
			return upperBound;
		}
		public boolean lowerIsInclusive() {
			return lowerInclusive;
		}
		public boolean upperIsInclusive() {
			return upperInclusive;
		}
		public boolean isLowerBounded() {
			return lowerBound != null;
		}
		public boolean isUpperBounded() {
			return upperBound != null;
		}
		public boolean isUnbounded() {
			return !isLowerBounded() && !isUpperBounded();
		}
		private int compare(E one, E two) {
			return comparator.compare(one, two);
		}
		public boolean isBelowLowerBound(E addr) {
			return isLowerBounded() && 
					(lowerInclusive ? compare(addr, lowerBound) < 0 :
						compare(addr, lowerBound) <= 0);
		}
		public boolean isWithinLowerBound(E addr) {
			return !isBelowLowerBound(addr);					
		}
		public boolean isAboveUpperBound(E addr) {
			return isUpperBounded() && 
					(upperInclusive ? compare(addr, upperBound) > 0 :
						compare(addr, upperBound) >= 0);
		}
		public boolean isWithinUpperBound(E addr) {
			return !isAboveUpperBound(addr);
		}
		BoundsCheck compareToLowerBound(E addr, boolean inclusive) {
			if(isLowerBounded()) {
				if(inclusive) {
					if(lowerInclusive) {
						// [existing [addr
						return BoundsCheck.convertEquivBoundaryComparison(compare(lowerBound, addr));
					}
					// (existing [addr
					int comp = compare(lowerBound, addr);
					if(comp >= 0) {
						return BoundsCheck.OUTSIDE;
					} else if(isAdjacentAboveLowerBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_EXCLUSIVE;
					}
					return BoundsCheck.INSIDE;
				} else if(lowerInclusive) {
					// [existing (addr
					int comp = compare(lowerBound, addr);
					if(comp <= 0) {
						return BoundsCheck.INSIDE;
					} else if(isAdjacentBelowLowerBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_INCLUSIVE;
					}
					return BoundsCheck.OUTSIDE;
				}
				// (existing (addr
				return BoundsCheck.convertEquivBoundaryComparison(compare(lowerBound, addr));
			}
			if(inclusive && isMin(addr)) {
				return BoundsCheck.EQUIVALENT_TO_UNBOUNDED;
			}
			return BoundsCheck.INSIDE;
		}
		BoundsCheck compareToUpperBound(E addr, boolean inclusive) {
			if(isUpperBounded()) {
				if(inclusive) {
					if(upperInclusive) {
						//existing] addr]
						return BoundsCheck.convertEquivBoundaryComparison(compare(addr, upperBound)); 
					}
					//existing) addr]
					int comp = compare(addr, upperBound);
					if(comp >= 0) {
						return BoundsCheck.OUTSIDE;
					} else if(isAdjacentBelowUpperBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_EXCLUSIVE;
					}
					return BoundsCheck.INSIDE;
				} else if(upperInclusive) {
					//existing] addr)
					int comp = compare(addr, upperBound);
					if(comp <= 0) {
						return BoundsCheck.INSIDE;
					} else if(isAdjacentAboveUpperBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_INCLUSIVE;
					}
					return BoundsCheck.OUTSIDE;
				}
				//existing) addr)
				return BoundsCheck.convertEquivBoundaryComparison(compare(addr, upperBound));
			}
			if(inclusive && isMax(addr)) {
				return BoundsCheck.EQUIVALENT_TO_UNBOUNDED;
			}
			return BoundsCheck.INSIDE;
		}
		static enum BoundsCheck {
			INSIDE(false, true), 
			EQUIVALENT_TO_UNBOUNDED(false, false), // no existing boundary, test boundary is closed at the end of range
			EQUIVALENT_TO_EXCLUSIVE(false, false), // existing boundary is exclusive, test boundary is inclusive and 1 step inside
			EQUIVALENT_TO_INCLUSIVE(false, false), // existing boundary is inclusive, test boundary is exclusive and 1 step outside
			SAME(false, false), 
			OUTSIDE(true, false);
			private boolean less, more;
			BoundsCheck(boolean lessRestrictive, boolean moreRestrictive) {
				less = lessRestrictive;
				more = moreRestrictive;
			}
			boolean isLessRestrictive() {
				return less;
			}
			boolean isMoreRestrictive() {
				return more;
			}
			static BoundsCheck convertEquivBoundaryComparison(int comparison) {
				if(comparison > 0) {
					return OUTSIDE;
				} else if(comparison < 0) {
					return INSIDE;
				}
				return SAME;
			}
		}
		// For discrete types, override the methods below
		boolean isMax(E addr) {
			return false;
		}
		boolean isMin(E addr) {
			return false;
		}
		boolean isAdjacentAboveUpperBound(E addr) {
			return false;
		}
		boolean isAdjacentBelowUpperBound(E addr) {
			return false;
		}
		boolean isAdjacentAboveLowerBound(E addr) {
			return false;
		}
		boolean isAdjacentBelowLowerBound(E addr) {
			return false;
		}
		public String toCanonicalString() {
			return toCanonicalString(" -> ");
		}
		public String toCanonicalString(String separator) {
			Function<? super E, String> stringer = Object::toString;
			return toString(stringer, separator, stringer);
		}
		public String toString(Function<? super E, String> lowerStringer, String separator, Function<? super E, String> upperStringer) {
			return toString(getLowerBound(), lowerIsInclusive(), getUpperBound(), upperIsInclusive(),
					lowerStringer, separator, upperStringer);
		}
		static <E> String toString(
				E lower,
				boolean lowerIsInclusive,
				E upper,
				boolean upperIsInclusive,
				Function<? super E, String> lowerStringer,
				String separator,
				Function<? super E, String> upperStringer) {
			String lowerStr;
			if(lower == null) {
				lowerStr = "";
			} else {
				lowerStr = lowerStringer.apply(lower);
				if(lowerIsInclusive) {
					lowerStr = '[' + lowerStr;
				} else {
					lowerStr = '(' + lowerStr;
				}
			}
			String upperStr;
			if(upper == null) {
				upperStr = "";
			} else {
				upperStr = upperStringer.apply(upper);
				if(upperIsInclusive) {
					upperStr += ']';
				} else {
					upperStr += ')';
				}
			}
			return lowerStr + separator + upperStr;
		}
		@Override
		public String toString() {
			return toCanonicalString();
		}
	}
	static class ChangeTracker implements Serializable {
		private static final long serialVersionUID = 1L;
		static class Change implements Cloneable, Serializable {
			private static final long serialVersionUID = 1L;
			boolean shared;
			private BigInteger big = BigInteger.ZERO;
			private int small;
			void increment() {
				if(++small == 0) {
					big = big.add(BigInteger.ONE);
				}
			}
			@Override
			public boolean equals(Object o) {
				return o instanceof Change && equalsChange((Change) o);
			}
			public boolean equalsChange(Change change) {
				return small == change.small && big.equals(change.big);
			}
			@Override
			public Change clone() {
				try {
					return (Change) super.clone();
				} catch (CloneNotSupportedException cannotHappen) {
					return null;
				}
			}
			@Override
			public String toString() {
				return big + " " + small;
			}
		}
		ChangeTracker() {}
		private Change currentChange = new Change();
		void changedSince(Change change) throws ConcurrentModificationException {
			if(isChangedSince(change)) {
				throw new ConcurrentModificationException();
			}
		}
		boolean isChangedSince(Change otherChange) {
			return !currentChange.equalsChange(otherChange);
		}
		Change getCurrent() {
			Change change = this.currentChange;
			change.shared = true;
			return change;
		}
		void changed() {
			Change change = this.currentChange;
			if(change.shared) {
				change = change.clone();
				change.shared = false;
				change.increment();
				this.currentChange = change;
			} // else nobody is watching the current change, so no need to do anything
		}
		@Override
		public String toString() {
			return "current change: " + currentChange;
		}
	}
	/**
	 * When set to true, the root is always 0.0.0.0/0 or ::/0 and setItem is never called,
	 * so the keys of a node never change.  This can make code that accessed nodes directly more predictable,
	 * a node will never change identity (although for a mapped node, the mapped value can change).
	 * <p>
	 * When set to false, the root of the tree is replaced by whatever node can replace it.
	 * So the tree is one node smaller and the depth is smaller by one.
	 * The down-side is that the root node can change identity, becoming the node for some other value, 
	 * and vice versa, some other valued node can become a root node again.
	 * So it is not advisable to work directly with nodes and change the tree at the same time.
	 */
	protected static boolean FREEZE_ROOT = true;
	// setting size to this value will cause a recalculation on calls to size(),
	// but in normal operation the size value starts at 0 and is never set to this value,
	// at this point it is just a debugging option
	static final int SIZE_UNKNOWN = -1;
	// describes the address or subnet
	private E item;
	private BinaryTreeNode<E> parent, lower, upper;
	int size;
	ChangeTracker changeTracker;
	// some nodes represent elements added to the tree and others are nodes generated internally when other nodes are added
	private boolean added;
	protected BinaryTreeNode(E item) { 
		this.item = item;
	}
	// when FREEZE_ROOT is true, this is never called (and FREEZE_ROOT is always true)
	protected void setKey(E item) {
		this.item = item;
	}
	/**
	 * Gets the key used for placing the node in the tree.
	 * 
	 * @return the key used for placing the node in the tree.
	 */
	public E getKey() {
		return item;
	}
	/**
	 * Returns whether this is the root of the backing tree.
	 * 
	 * @return
	 */
	public boolean isRoot() {
		return parent == null;
	}
	/**
	 * Gets the node from which this node is a direct child node, or null if this is the root.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> getParent() {
		return parent;
	}
	void setParent(BinaryTreeNode<E> parent) {
		this.parent = parent;
	}
	/**
	 * Gets the direct child node whose key is largest in value
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> getUpperSubNode() {
		return upper;
	}
	/**
	 * Gets the direct child node whose key is smallest in value
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> getLowerSubNode() {
		return lower;
	}
	protected void setUpper(BinaryTreeNode<E> upper) {
		this.upper = upper;
		if(upper != null) {
			upper.setParent(this);
		}
	}
	protected void setLower(BinaryTreeNode<E> lower) {
		this.lower = lower;
		if(lower != null) {
			lower.setParent(this);
		}
	}
	/**
	 * Some binary tree nodes are considered "added" and others are not.
	 * Those nodes created for key elements added to the tree are "added" nodes.  
	 * Those that are not added are those nodes created to serve as junctions for the added nodes.
	 * Only added elements contribute to the size of a tree.  
	 * When removing nodes, non-added nodes are removed automatically whenever they are no longer needed,
	 * which is when an added node has less than two added sub-nodes.
	 * 
	 * @return whether this node represents an element added to the tree
	 */
	public boolean isAdded() {
		return added;
	}
	/**
	 * Make this node an added node, which is equivalent to adding the corresponding address to the tree.
	 * If already added, this method has no effect.
	 * <p>
	 * You cannot set an added node to non-added, for that you should remove the node from the tree by calling {@link #remove()}.
	 * A non-added node will only remain in the tree if it needs to in the tree.
	 */
	public void setAdded() {
		if(!added) {
			setNodeAdded(true);
			adjustCount(1);
		}
	}
	protected void setNodeAdded(boolean added) {
		this.added = added;
	}
	/**
	 * Returns the count of nodes added to the sub-tree starting from this node as root and moving downwards to sub-nodes.
	 * This is a constant-time operation since the size is maintained in each node and adjusted with each add and remove operation in the sub-tree.
	 * @return
	 */
	public int size() {
		int storedSize = size;
		if(storedSize == SIZE_UNKNOWN) {
			Iterator<? extends BinaryTreeNode<E>> iterator = containedFirstAllNodeIterator(true);
			while(iterator.hasNext()) {
				BinaryTreeNode<E> next = iterator.next();
				int nodeSize = next.isAdded() ? 1 : 0;
				BinaryTreeNode<E> lower = next.getLowerSubNode();
				if(lower != null) {
					nodeSize += lower.size;
				}
				BinaryTreeNode<E> upper = next.getUpperSubNode();
				if(upper != null) {
					nodeSize += upper.size;
				}
				next.size = nodeSize;
			}
			storedSize = size;
		}
		return storedSize;
	}
	/**
	 * Returns the count of all nodes in the tree starting from this node and extending to all sub-nodes.
	 * Unlike {@link #size()}, this is not a constant-time operation and must visit all sub-nodes of this node.
	 * @return
	 */
	public int nodeSize() {
		int totalCount = 0;
		Iterator<? extends BinaryTreeNode<E>> iterator = iterator(true, false);//nodeIterator();xxx added only xxx;
		while(iterator.hasNext()) {
			totalCount++;
			iterator.next();
		}
		return totalCount;
	}
	void adjustCount(int delta) {
		if(delta != 0) {
			BinaryTreeNode<E> node = this;
			do {
				node.size += delta;
				node = node.getParent();
			} while(node != null);
		}
	}
	/**
	 * Removes this node from the list of added nodes, 
	 * and also removes from the tree if possible.  
	 * If it has two sub-nodes, it cannot be removed from the tree, in which case it is marked as not "added",
	 * nor is it counted in the tree size.
	 * Only added nodes can be removed from the tree.  If this node is not added, this method does nothing.
	 */
	public void remove() {
		if(!isAdded()) {
			return;
		}
		if(FREEZE_ROOT && isRoot()) {
			removed();
		} else if(getUpperSubNode() == null) {
			replaceThis(getLowerSubNode()); // also handles case of lower == null
		} else if(getLowerSubNode() == null) {
			replaceThis(getUpperSubNode());
		} else { // has two sub-nodes
			removed();
		}
	}
	void removed() {
		adjustCount(-1);
		setNodeAdded(false);
		changeTracker.changed();
	}
	/**
	 * Makes the parent of this point to something else, thus removing this and all sub-nodes from the tree
	 * @param replacement
	 */
	void replaceThis(BinaryTreeNode<E> replacement) {
		replaceThisRecursive(replacement, 0);
		changeTracker.changed();
	}
	void replaceThisRecursive(BinaryTreeNode<E> replacement, int additionalSizeAdjustment) {
		if(isRoot()) {
			replaceThisRoot(replacement);
			return;
		}
		BinaryTreeNode<E> parent = getParent();
		if(parent.getUpperSubNode() == this) {
			// we adjust parents first, using the size and other characteristics of ourselves,
			// before the parent severs the link to ourselves with the call to setUpper,
			// since the setUpper call is allowed to change the characteristics of the child,
			// and in some cases this does adjust the size of the child.
			adjustTree(parent, replacement, additionalSizeAdjustment, true);
			parent.setUpper(replacement);
		} else if(parent.getLowerSubNode() == this) {
			adjustTree(parent, replacement, additionalSizeAdjustment, false);
			parent.setLower(replacement);
		} else {
			throw new Error(); // will never reach here, indicates tree is corrupted somehow
		}
	}
	private void adjustTree(BinaryTreeNode<E> parent, BinaryTreeNode<E> replacement, int additionalSizeAdjustment, boolean replacedUpper) {
		int sizeAdjustment = -size;
		if(replacement == null) {
			if(!parent.isAdded() && (!FREEZE_ROOT || !parent.isRoot())) {
				parent.size += sizeAdjustment;
				BinaryTreeNode<E> parentReplacement = 
						replacedUpper ? parent.getLowerSubNode() : parent.getUpperSubNode();
				parent.replaceThisRecursive(parentReplacement, sizeAdjustment);
			} else {
				parent.adjustCount(sizeAdjustment + additionalSizeAdjustment);
			}
		} else {
			parent.adjustCount(replacement.size + sizeAdjustment + additionalSizeAdjustment);
		}
		setParent(null);
	}
	protected void replaceThisRoot(BinaryTreeNode<E> replacement) {
		if(replacement == null) {
			setNodeAdded(false);
			setUpper(null);
			setLower(null);
			if(!FREEZE_ROOT) {
				setKey(null);
			}
			size = 0;
		} else {
			// We never go here when FREEZE_ROOT is true
			setNodeAdded(replacement.isAdded());
			setUpper(replacement.getUpperSubNode());
			setLower(replacement.getLowerSubNode());
			setKey(replacement.getKey());
			size = replacement.size;
		}
	}
	/**
	 * Removes this node and all sub-nodes from the tree, after which isEmpty() will return true.
	 */
	public void clear() {
		replaceThis(null);
	}
	/**
	 * Returns where there are not any elements in the sub-tree with this node as the root.
	 */
	public boolean isEmpty() {
		return !isAdded() && getUpperSubNode() == null && getLowerSubNode() == null;
	}
	/**
	 * Returns whether this node is in the tree (is a node for which {@link #isAdded()} is true)
	 * and additional there are other elements in the sub-tree with this node as the root.
	 */
	public boolean isLeaf() {
		return isAdded() && getUpperSubNode() == null && getLowerSubNode() == null;
	}
	/**
	 * Returns the first (lowest valued) node in the sub-tree originating from this node.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> firstNode() {
		BinaryTreeNode<E> first = this;
		while(true) {
			BinaryTreeNode<E> lower = first.getLowerSubNode();
			if(lower == null) {
				return first;
			}
			first = lower;
		}
	}
	/**
	 * Returns the first (lowest valued) added node in the sub-tree originating from this node,
	 * or null if there are no added entries in this tree or sub-tree
	 * @return
	 */
	public BinaryTreeNode<E> firstAddedNode() {
		BinaryTreeNode<E> first = firstNode();
		if(first.isAdded()) {
			return first;
		}
		return first.nextAddedNode();
	}
	/**
	 * Returns the last (highest valued) node in the sub-tree originating from this node.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> lastNode() {
		BinaryTreeNode<E> last = this;
		while(true) {
			BinaryTreeNode<E> upper = last.getUpperSubNode();
			if(upper == null) {
				return last;
			}
			last = upper;
		}
	}
	/**
	 * Returns the last (highest valued) added node in the sub-tree originating from this node,
	 * or null if there are no added entries in this tree or sub-tree
	 * @return
	 */
	public BinaryTreeNode<E> lastAddedNode() {
		BinaryTreeNode<E> last = lastNode();
		if(last.isAdded()) {
			return last;
		}
		return last.previousAddedNode();
	}
	BinaryTreeNode<E> firstPostOrderNode() {
		BinaryTreeNode<E> next = this, nextNext;
		while(true) {
			nextNext = next.getLowerSubNode();
			if(nextNext == null) {
				nextNext = next.getUpperSubNode();
				if(nextNext == null) {
					return next;
				}
			} 
			next = nextNext;
		}
	}
	BinaryTreeNode<E> lastPreOrderNode() {
		BinaryTreeNode<E> next = this, nextNext;
		while(true) {
			nextNext = next.getUpperSubNode();
			if(nextNext == null) {
				nextNext = next.getLowerSubNode();
				if(nextNext == null) {
					return next;
				}
			} 
			next = nextNext;
		}
	}
	/**
	 * Returns the node that follows this node following the tree order
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> nextNode() {
		return nextNode(null);
	}
//	in-order
//	
//				8x
//		4x					12x
//	2x		6x			10x		14x
//1x 3x		5x 7x		9x 11x	13x 15x
	BinaryTreeNode<E> nextNode(BinaryTreeNode<E> bound) {
		BinaryTreeNode<E> next = getUpperSubNode();
		if(next != null) {
			while(true) {
				BinaryTreeNode<E> nextLower = next.getLowerSubNode();
				if(nextLower == null) {
					return next;
				}
				next = nextLower;
			}
		} else {
			next = getParent();
			if(next == bound) {
				return null;
			}
			BinaryTreeNode<E> current = this;
			while(next != null && current == next.getUpperSubNode()) {
				current = next;
				next = next.getParent();
				if(next == bound) {
					return null;
				}
			}
		}
		return next;
	}
	/**
	 * Returns the node that precedes this node following the tree order.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> previousNode() {
		return previousNode(null);
	}
//	reverse order
//
//				8x
//		12x					4x
//	14x		10x			6x		2x
//15x 13x	11x 9x		7x 5x	3x 1x
	BinaryTreeNode<E> previousNode(BinaryTreeNode<E> bound) {
		BinaryTreeNode<E> previous = getLowerSubNode();
		if(previous != null) {
			while(true) {
				BinaryTreeNode<E> previousUpper = previous.getUpperSubNode();
				if(previousUpper == null) {
					break;
				}
				previous = previousUpper;
			}
		} else {
			previous = getParent();
			if(previous == bound) {
				return null;
			}
			BinaryTreeNode<E> current = this;
			while(previous != null && current == previous.getLowerSubNode()) {
				current = previous;
				previous = previous.getParent();
				if(previous == bound) {
					return null;
				}
			}
		}
		return previous;
	}
	
//	pre order
//				1x
//		2x						9x
//3x		6x				10x		13x
//4x 5x		7x 8x		11x 12x		14x 15x
	// this one starts from root, ends at last node, all the way right
	BinaryTreeNode<E> nextPreOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getLowerSubNode();
		if(next == null) {
			// cannot go left/lower
			next = getUpperSubNode();
			if(next == null) {
				// cannot go right/upper
				BinaryTreeNode<E> current = this;
				next = getParent();
				// so instead, keep going up until we can go right 
				while(next != null) {
					if(next == end) {
						return null;
					}
					if(current == next.getLowerSubNode()) {
						// parent is higher
						BinaryTreeNode<E> nextNext = next.getUpperSubNode();
						if(nextNext != null) {
							return nextNext;
						}
					}
					current = next;
					next = next.getParent();
				}
			}
		}
		return next;
	}
//	reverse post order
//				1x
//		9x					2x
//	13x		10x			6x		3x
//15x 14x	12x 11x		8x 7x	5x 4x
	// this one starts from root, ends at first node, all the way left
	// this is the mirror image of nextPreOrderNode, so no comments
	BinaryTreeNode<E> previousPostOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getUpperSubNode();
		if(next == null) {
			next = getLowerSubNode();
			if(next == null) {
				BinaryTreeNode<E> current = this;
				next = getParent();
				while(next != null) {
					if(next == end) {
						return null;
					}
					if(current == next.getUpperSubNode()) {
						BinaryTreeNode<E> nextNext = next.getLowerSubNode();
						if(nextNext != null) {
							next = nextNext;
							break;
						}
					}
					current = next;
					next = next.getParent();
				}
			}
		}
		return next;
	}
//	reverse pre order
//	
//				15x
//		14x					7x
//	13x		10x			6x		3x
//12x 11x	9x 8x		5x 4x	2x 1x
	// this one starts from last node, all the way right, ends at root
	// this is the mirror image of nextPostOrderNode, so no comments
	BinaryTreeNode<E> previousPreOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getParent();
		if(next == null || next == end) {
			return null;
		}
		if(next.getLowerSubNode() == this) {
			return next;
		}
		BinaryTreeNode<E> nextNext = next.getLowerSubNode();
		if(nextNext == null) {
			return next;
		}
		next = nextNext;
		while(true) {
			nextNext = next.getUpperSubNode();
			if(nextNext == null) {
				nextNext = next.getLowerSubNode();
				if(nextNext == null) {
					return next;
				}
			}
			next = nextNext;
		}
	}
	
//	post order
//				15x
//		7x					14x
//	3x		6x			10x		13x
//1x 2x		4x 5x		8x 9x	11x 12x
	// this one starts from first node, all the way left, ends at root
	BinaryTreeNode<E> nextPostOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getParent();
		if(next == null || next == end) {
			return null;
		}
		if(next.getUpperSubNode() == this) {
			// we are the upper sub-node, so parent is next
			return next;
		}
		// we are the lower sub-node
		BinaryTreeNode<E> nextNext = next.getUpperSubNode();
		if(nextNext == null) {
			// parent has no upper sub-node, so parent is next
			return next;
		}
		// go to parent's upper sub-node
		next = nextNext;
		// now go all the way down until we can go no further, favoring left/lower turns over right/upper
		while(true) {
			nextNext = next.getLowerSubNode();
			if(nextNext == null) {
				nextNext = next.getUpperSubNode();
				if(nextNext == null) {
					return next;
				}
				//next = nextNext;
			} //else {
				next = nextNext;
			//}
		}
	}
	/**
	 * Returns the next node in the tree that is an added node, following the tree order,
	 * or null if there is no such node.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> nextAddedNode() {
		return nextAdded(null, BinaryTreeNode<E>::nextNode);
	}
	/**
	 * Returns the previous node in the tree that is an added node, following the tree order in reverse, 
	 * or null if there is no such node.
	 * 
	 * @return
	 */
	public BinaryTreeNode<E> previousAddedNode() {
		return nextAdded(null, BinaryTreeNode<E>::previousNode);
	}
	private static <E> BinaryTreeNode<E> nextTest(BinaryTreeNode<E> current, BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator, Predicate<BinaryTreeNode<E>> tester) {
		do {
			current = nextOperator.apply(current, end);
			if(current == end || current == null) {
				return null;
			}
		} while(!tester.test(current));
		return current;
	}
	private BinaryTreeNode<E> nextAdded(BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator) {
		return nextTest(this, end, nextOperator, BinaryTreeNode<E>::isAdded);
	}
	
	private BinaryTreeNode<E> nextInBounds(BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator, Bounds<E> bounds) {
		return nextTest(this, end, nextOperator, node -> bounds.isInBounds(node.getKey()));
	}
	/**
	 * Returns an iterator that iterates through the elements of the sub-tree with this node as the root.
	 * The iteration is in sorted element order.
	 * 
	 * @return
	 */
	@Override
	public Iterator<E> iterator() {
		return new KeyIterator<E>(nodeIterator(true));
	}
	/**
	 * Returns an iterator that iterates through the elements of the subtrie with this node as the root.
	 * The iteration is in reverse sorted element order.
	 * 
	 * @return
	 */
	@Override
	public Iterator<E> descendingIterator() {
		return new KeyIterator<E>(nodeIterator(false));
	}
	/**
	 * Iterates through the added nodes of the sub-tree with this node as the root, in forward or reverse tree order.
	 * 
	 * @return
	 */
	@Override
	public Iterator<? extends BinaryTreeNode<E>> nodeIterator(boolean forward) {
		return iterator(forward, true);
	}
	/**
	 * Iterates through all the nodes of the sub-tree with this node as the root, in forward or reverse tree order.
	 * 
	 * @return
	 */
	@Override
	public Iterator<? extends BinaryTreeNode<E>> allNodeIterator(boolean forward) {
		return iterator(forward, false);
	}
	// not public because this class is generic and not aware of address, blocks, prefix lengths, etc
	<C> CachingIterator<? extends BinaryTreeNode<E>, E, C> blockSizeCachingAllNodeIterator() {
		return new BlockSizeCachingNodeIterator<E, C>(this, false, changeTracker);
	}
	// not public because this class is generic and not aware of address, blocks, prefix lengths, etc
	Iterator<? extends BinaryTreeNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst, boolean addedNodesOnly) {
		return new BlockSizeNodeIterator<E>(
				addedNodesOnly ? size() : 0,
				addedNodesOnly,
				this,
				!lowerSubNodeFirst,
				changeTracker);
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containingFirstIterator(boolean forwardSubNodeOrder)  {
		return containingFirstIterator(forwardSubNodeOrder, true);
	}
	
	@Override
	public <C> CachingIterator<? extends BinaryTreeNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder)  {
		return containingFirstIterator(forwardSubNodeOrder, false);
	}
	private <C> CachingIterator<? extends BinaryTreeNode<E>, E, C> containingFirstIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly)  {
		if(forwardSubNodeOrder) {
			return new PreOrderNodeIterator<E, C>(
					true, // forward
					addedNodesOnly, // added only
					this,
					getParent(),
					changeTracker);
		} else {
			return new PostOrderNodeIterator<E, C>(
					false, // forward
					addedNodesOnly, // added only
					this,
					getParent(),
					changeTracker);
		}
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containedFirstIterator(boolean forwardSubNodeOrder)  {
		return containedFirstIterator(forwardSubNodeOrder, true);
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder)  {
		return containedFirstIterator(forwardSubNodeOrder, false);
	}
	
	private Iterator<? extends BinaryTreeNode<E>> containedFirstIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly)  {
		if(forwardSubNodeOrder) {
			return new PostOrderNodeIterator<E, Object>(
					true,
					addedNodesOnly, // added only
					firstPostOrderNode(),
					getParent(),
					changeTracker);
		} else {
			return new PreOrderNodeIterator<E, Object>(
					false,
					addedNodesOnly, // added only
					lastPreOrderNode(),
					getParent(),
					changeTracker);
		}
	}
	private NodeIterator<E> iterator(boolean forward, boolean addedOnly) {
		return new NodeIterator<E>(
				forward,
				addedOnly,
				forward ? firstNode() : lastNode(),
				getParent(),
				changeTracker);
	}
	static class KeyIterator<E> implements Iterator<E> {
		private Iterator<? extends BinaryTreeNode<E>> iterator;
		KeyIterator(Iterator<? extends BinaryTreeNode<E>> iterator) {
			this.iterator = iterator;
		}
		@Override
		public boolean hasNext() {
			return iterator.hasNext();
		}
		@Override
		public E next() {
			return iterator.next().getKey();
		}
		@Override
		public void remove() {
			iterator.remove();
		}
	}
	public static interface CachingIterator<N extends BinaryTreeNode<E>, E, C> extends Iterator<N> {
		/**
		 * After {@link #next()} has returned a node, 
		 * if an object was cached by a call to {@link #cacheWithLowerSubNode(Object)} or {@link #cacheWithUpperSubNode(Object)} 
		 * was called when that node's parent was previously returned by {@link #next()},
		 * then this returns that cached object.
		 * 
		 * @return the cached object
		 */
		C getCached();
		/**
		 * After {@link #next()} has returned a node, 
		 * calling this method caches the provided object with the lower sub-node so that it can 
		 * be retrieved with {@link #getCached()} when the lower sub-node is visited later.
		 * <p>
		 * Returns false if it could not be cached, either because the node has since been removed with a call to {@link #remove()},
		 * because {@link #next()} has not been called yet, or because there is no lower sub node for the node previously returned by {@link #next()}.
		 * <p>
		 * The caching and retrieval is done in constant time.
		 * 
		 * @param object the object to be retrieved later.
		 * 
		 */
		boolean cacheWithLowerSubNode(C object);
		/**
		 * After {@link #next()} has returned a node, 
		 * calling this method caches the provided object with the upper sub-node so that it can 
		 * be retrieved with {@link #getCached()} when the upper sub-node is visited later.
		 * <p>
		 * Returns false if it could not be cached, either because the node has since been removed with a call to {@link #remove()},
		 * because {@link #next()} has not been called yet, or because there is no upper sub node for the node previously returned by {@link #next()}.
		 * <p>
		 * The caching and retrieval is done in constant time.
		 * 
		 * 
		 * @param object the object to be retrieved later.
		 * 
		 * @return
		 */
		public boolean cacheWithUpperSubNode(C object);
	}
	/**
	 * This tree iterator does a binary tree traversal 
	 * in which every node will be visited before the node's sub-nodes are visited.
	 * It will visit nodes in key order of smallest address prefix-length to largest, which is largest block size to smallest.
	 * When prefix lengths match, order will go by prefix value.  
	 * For this comparison, an address with no prefix length is considered to have a prefix length extending to the end of the address.
	 */
	static class BlockSizeNodeIterator<E> extends AbstractNodeIterator<E> {
	
		static class Comp<E extends Address> implements Comparator<BinaryTreeNode<E>> {
			private final boolean reverseBlocksEqualSize;
			Comp(boolean reverseBlocksEqualSize) {
				this.reverseBlocksEqualSize = reverseBlocksEqualSize;
			}
			@Override
			public int compare(BinaryTreeNode<E> node1, BinaryTreeNode<E> node2) {
				E addr1 = node1.getKey();
				E addr2 = node2.getKey();
				if(addr1 == addr2) {
					return 0;
				}
				if(addr1.isPrefixed()) {
					if(addr2.isPrefixed()) {
						int val = addr1.getPrefixLength() - addr2.getPrefixLength();
						if(val == 0) {
							int compVal = compareLowValues(addr1, addr2);
							return reverseBlocksEqualSize ? -compVal : compVal;
						}
						return val;
					}
					return -1;
				}
				if(addr2.isPrefixed()) {
					return 1;
				}
				int compVal = compareLowValues(addr1, addr2);
				return reverseBlocksEqualSize ? -compVal : compVal;
			}
		};
		private static final Comparator<?> COMP = new Comp<>(false), REVERSE_COMP = new Comp<>(true);
		// heap will have either a caching objectwith the node or just the node
		PriorityQueue<BinaryTreeNode<E>> queue;
		private final boolean addedOnly;
		private final Bounds<E> bounds;
		// this one starts from root, ends at last node, all the way right
		BlockSizeNodeIterator(
				int treeSize, // can be zero if calculating size is expensive
				boolean addedOnly,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			this(treeSize, null, addedOnly, start, reverseBlocksEqualSize, changeTracker);
		}
		@SuppressWarnings("unchecked")
		BlockSizeNodeIterator(
				int treeSize, // can be zero if calculating size is expensive
				Bounds<E> bounds,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			super(start, null, changeTracker);
			this.addedOnly = addedOnly;
			this.bounds = bounds;
			Comparator<BinaryTreeNode<E>> comp = 
					(Comparator<BinaryTreeNode<E>>) (reverseBlocksEqualSize ? REVERSE_COMP : COMP);
			if(treeSize > 0) {
				int initialCapacity = treeSize >> 1;
				if(initialCapacity == 0) {
					initialCapacity = 1;
				}
				queue = new PriorityQueue<>(initialCapacity, comp);
			} else {
				queue = new PriorityQueue<>(comp);
			}
			next = getStart(start, null, bounds, addedOnly);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = (currentNode, endNode) -> {
					BinaryTreeNode<E> lower = currentNode.getLowerSubNode();
					if(lower != null) {
						queue.add(lower);
					}
					BinaryTreeNode<E> upper = currentNode.getUpperSubNode();
					if(upper != null) {
						queue.add(upper);
					}
					BinaryTreeNode<E> node = queue.poll();
					return node == endNode ? null : node;
				};
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
	}
	static int compareLowValues(Address one, Address two) {
		return Address.ADDRESS_LOW_VALUE_COMPARATOR.compare(one, two);
	}
	/**
	 * This is a tree iterator that does a binary tree traversal 
	 * in which every node will be visited before the node's sub-nodes are visited.
	 * This tree iterator will visit nodes in key order of smallest address prefix-length first. 
	 * When prefix lengths match, the order will be by prefix value.  
	 * For this comparison, an address with no prefix length is considered to have a prefix length extending to the end of the address.
	 * <p>
	 * This tree iterator allows you to provide iteration context from a parent to its sub-nodes when iterating.
	 * <p>
	 */
	static class BlockSizeCachingNodeIterator<E, C> extends AbstractNodeIterator<E> implements CachingIterator<BinaryTreeNode<E>, E, C> {
		
		static class Comp<E extends Address> implements Comparator<Cached<E, ?>> {
			private final boolean reverseBlocksEqualSize;
			Comp(boolean reverseBlocksEqualSize) {
				this.reverseBlocksEqualSize = reverseBlocksEqualSize;
			}
			@Override
			public int compare(Cached<E, ?> o1, Cached<E, ?> o2) {
				BinaryTreeNode<E> node1 = o1.node, node2 = o2.node;
				E addr1 = node1.getKey(), addr2 = node2.getKey();
				if(addr1 == addr2) {
					return 0;
				}
				if(addr1.isPrefixed()) {
					if(addr2.isPrefixed()) {
						int val = addr1.getPrefixLength() - addr2.getPrefixLength();
						if(val == 0) {
							int compVal = compareLowValues(addr1, addr2);
							return reverseBlocksEqualSize ? -compVal : compVal;
						}
						return val;
					}
					return -1;
				}
				if(addr2.isPrefixed()) {
					return 1;
				}
				int compVal = compareLowValues(addr1, addr2);
				return reverseBlocksEqualSize ? -compVal : compVal;
			}
		};
		static class Cached<E, C> {
			BinaryTreeNode<E> node;
			C cached;
		}
		private static final Comparator<?> COMP = new Comp<>(false), REVERSE_COMP = new Comp<>(true);
		// heap will have the caching object with the node
		private PriorityQueue<Cached<E, C>> queue;
		private C cacheItem;
		private Cached<E, C> nextCachedItem;
		private Cached<E, C> lowerCacheObj, upperCacheObj;
		// this one starts from root, ends at last node, all the way right
		BlockSizeCachingNodeIterator(
				int treeSize,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			super(start, null, changeTracker);
			@SuppressWarnings("unchecked")
			Comparator<Cached<E, C>> comp = (Comparator<Cached<E, C>>) (reverseBlocksEqualSize ? REVERSE_COMP : COMP);
			if(treeSize == 0) {
				queue = new PriorityQueue<>(comp);
			} else {
				queue = new PriorityQueue<>(treeSize >> 1, comp);
			}
			next = getStart(start, null, null, false);
		}
		
		BlockSizeCachingNodeIterator(
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			this(0, start, reverseBlocksEqualSize, changeTracker);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = (currentNode, endNode) -> {
					BinaryTreeNode<E> lower = currentNode.getLowerSubNode();
					if(lower != null) {
						Cached<E, C> cached = new Cached<>();
						cached.node = lower;
						lowerCacheObj = cached;
						queue.add(cached);
					} else {
						lowerCacheObj = null;
					}
					BinaryTreeNode<E> upper = currentNode.getUpperSubNode();
					if(upper != null) {
						Cached<E, C> cached = new Cached<>();
						cached.node = upper;
						upperCacheObj = cached;
						queue.add(cached);
					} else {
						upperCacheObj = null;
					}
					if(nextCachedItem != null) {
						cacheItem = nextCachedItem.cached;
					}
					Cached<E, C> cached =  queue.poll();
					if(cached != null) {
						BinaryTreeNode<E> node = cached.node;
						if(node != endNode) {
							nextCachedItem = cached;
							return node;
						}
						
					}
					nextCachedItem = null;
					return null;
				};
				operator = op;
			}
			return op;
		}
		@Override
		public C getCached() {
			return cacheItem;
		}
		@Override
		public boolean cacheWithLowerSubNode(C object) {
			if(lowerCacheObj != null) {
				lowerCacheObj.cached = object;
				return true;
			}
			return false;
		}
		@Override
		public boolean cacheWithUpperSubNode(C object) {
			if(upperCacheObj != null) {
				upperCacheObj.cached = object;
				return true;
			}
			return false;
		}
	}
	/**
	 * The caching only useful when in reverse order, since you have to visit parent nodes first for it to be useful.
	 * 
	 * @author scfoley
	 *
	 * @param <N>
	 * @param <E>
	 * @param <C>
	 */
	static class PostOrderNodeIterator<E, C> extends SubNodeCachingIterator<E, C> {
		//starts from first node, all the way left, ends at root
		PostOrderNodeIterator(
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> bound,
				ChangeTracker changeTracker) {
			this(null, isForward, addedOnly, start, bound, changeTracker);
		}
		
		PostOrderNodeIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(bounds, isForward, addedOnly, start, end, changeTracker);
		}
		@Override
		void checkCaching() {
			if(isForward) {
				throw new Error();
			}
		}
		@Override
		void populateCacheItem() {
			if(!isForward) {
				super.populateCacheItem();
			}
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = isForward ? BinaryTreeNode<E>::nextPostOrderNode : BinaryTreeNode<E>::previousPostOrderNode;
				// do the added-only filter first, because it is simpler
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
		@Override
		public void remove() {
			if(!isForward || addedOnly) {
				super.remove();
				return;
			}
			// Example:
			// Suppose we are at right sub-node, just visited left.  Next node is parent, but not added.
			// When right is removed, so is the parent, so that the left takes its place.
			// But parent is our next node.  Now our next node is invalid.  So we are lost.
			// This is avoided for iterators that are "added" only.
			throw new UnsupportedOperationException();
		}
	}
	/**
	 * The caching only useful when in forward order, since you have to visit parent nodes first for it to be useful.
	 * @author scfoley
	 *
	 * @param <N>
	 * @param <E>
	 * @param <C>
	 */
	static class PreOrderNodeIterator<E, C> extends SubNodeCachingIterator<E, C> {
		// this one starts from root, ends at last node, all the way right
		PreOrderNodeIterator(
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> bound,
				ChangeTracker changeTracker) {
			this(null, isForward, addedOnly, start, bound, changeTracker);
		}
		PreOrderNodeIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(bounds, isForward, addedOnly, start, end, changeTracker);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = isForward ? BinaryTreeNode<E>::nextPreOrderNode : BinaryTreeNode<E>::previousPreOrderNode;
				// do the added-only filter first, because it is simpler
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
		@Override
		void checkCaching() {
			if(!isForward) {
				throw new Error();
			}
		}
		@Override
		void populateCacheItem() {
			if(isForward) {
				super.populateCacheItem();
			}
		}
		
		@Override
		public void remove() {
			if(isForward || addedOnly) {
				super.remove();
				return;
			}
			// Example:
			// Suppose we are moving in reverse direction, at left sub-node, just visited right.  
			// Neither node has children.
			// Next node is parent, but not added.
			// When left is removed, so is the parent, so that the right takes its place.
			// But parent is our next node, and we already visited right.  
			// Now our next node is invalid.  So we are lost.
			// This is avoided for iterators that are "added" only.
			throw new UnsupportedOperationException();
		}
	}
	static abstract class SubNodeCachingIterator<E, C> extends AbstractNodeIterator<E> implements CachingIterator<BinaryTreeNode<E>, E, C> {
		private static final int STACK_SIZE = IPv6Address.BIT_COUNT + 2; // 129 for prefixes /0 to /128 and also 1 more for non-prefixed
		private C cacheItem;
		
		private E nextKey;
		private C nextCached;
		private Object stack[];
		private int stackIndex = -1;
		
		final Bounds<E> bounds;
		final boolean addedOnly, isForward;
		SubNodeCachingIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(start, end, changeTracker);
			this.isForward = isForward;
			this.addedOnly = addedOnly;
			this.bounds = bounds;
			next = getStart(start, end, bounds, addedOnly);
		}
		@Override
		BinaryTreeNode<E> doNext() {
			BinaryTreeNode<E> result = super.doNext();
			populateCacheItem();
			return result;
		}
		abstract void checkCaching();
		@Override
		public C getCached() {
			checkCaching();
			return cacheItem;
		}
		@SuppressWarnings("unchecked")
		void populateCacheItem() {
			E nextKey = this.nextKey;
			if(nextKey != null && current.getKey() == nextKey) {
				cacheItem = nextCached;
				nextCached = null;
				nextKey = null;
			} else {
				Object stack[] = this.stack;
				if(stack != null) {
					int stackIndex = this.stackIndex;
					if(stackIndex >= 0 && stack[stackIndex] == current.getKey()) {
						cacheItem = (C) stack[stackIndex + STACK_SIZE];
						stack[stackIndex + STACK_SIZE] = null;
						stack[stackIndex] = null;
						this.stackIndex--;
					} else {
						cacheItem = null;
					}
				} else {
					cacheItem = null;
				}
			}
		}
		@Override
		public boolean cacheWithLowerSubNode(C object) {
			return isForward ? cacheWithFirstSubNode(object) : cacheWithSecondSubNode(object);
		}
		@Override
		public boolean cacheWithUpperSubNode(C object) {
			return isForward ? cacheWithSecondSubNode(object) : cacheWithFirstSubNode(object);
		}
		// the sub-node will be the next visited node
		private boolean cacheWithFirstSubNode(C object) {
			checkCaching();
			if(current != null) {
				BinaryTreeNode<E> firstNode = isForward ? current.getLowerSubNode() : current.getUpperSubNode();
				if(firstNode != null) {
					if((addedOnly && !firstNode.isAdded()) || (bounds != null && !bounds.isInBounds(firstNode.getKey()))) {
						firstNode = getToNextOperation().apply(firstNode, current);
					}
					if(firstNode != null) {
						// the lower sub-node is always next if it exists
						nextKey = firstNode.getKey();
						//System.out.println(current + " cached with " + firstNode + ": " + object);
						nextCached = object;
						return true;
					}
				}
			}
			return false;
		}
		// the sub-node will only be the next visited node if there is no other sub-node, 
		// otherwise it might not be visited for a while
		private boolean cacheWithSecondSubNode(C object) {
			checkCaching();
			if(current != null) {
				BinaryTreeNode<E> secondNode = isForward ? current.getUpperSubNode() : current.getLowerSubNode();
				if(secondNode != null) {
					if((addedOnly && !secondNode.isAdded()) || (bounds != null && !bounds.isInBounds(secondNode.getKey()))) {
						secondNode = getToNextOperation().apply(secondNode, current);
					}
					if(secondNode != null) {
						// if there is no lower node, we can use the nextCached field since upper is next when no lower sub-node
						BinaryTreeNode<E> firstNode = isForward ? current.getLowerSubNode() : current.getUpperSubNode();
						if(firstNode == null) {
							nextKey = secondNode.getKey();
							nextCached = object;
						} else {
							if(stack == null) {
								stack = new Object[STACK_SIZE << 1];
							}
							stackIndex++;
							stack[stackIndex] = secondNode.getKey();
							stack[stackIndex + STACK_SIZE] = object;
						}
						return true;
					}
				}
			}
			return false;
		}
	}
	static class NodeIterator<E> extends AbstractNodeIterator<E> {
		final boolean forward, addedOnly;
		NodeIterator(
				boolean forward,
				boolean addedOnly,
				BinaryTreeNode<E> start, // inclusive
				BinaryTreeNode<E> end, // non-inclusive
				ChangeTracker changeTracker) {
			super(start, end, changeTracker);
			this.forward = forward;
			this.addedOnly = addedOnly;
			next = getStart(start, end, null, addedOnly);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = forward ? BinaryTreeNode<E>::nextNode : BinaryTreeNode<E>::previousNode;
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				operator = op;
			}
			return op;
		}
	}
	abstract static class AbstractNodeIterator<E> implements Iterator<BinaryTreeNode<E>> {
		private final ChangeTracker changeTracker;
		private Change currentChange;
		
		BinaryTreeNode<E> current, next;
		BinaryTreeNode<E> end; // a non-null node that denotes the end, possibly parent of the starting node
		
		// takes current node and end as args
		BinaryOperator<BinaryTreeNode<E>> operator;
		AbstractNodeIterator(
				BinaryTreeNode<E> start, // inclusive
				BinaryTreeNode<E> end, // non-inclusive
				ChangeTracker changeTracker) {
			this.end = end;
			this.changeTracker = changeTracker;
			if(changeTracker != null) {
				currentChange = changeTracker.getCurrent();
			}
		}
		abstract BinaryOperator<BinaryTreeNode<E>> getToNextOperation();
		BinaryTreeNode<E> getStart(
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				Bounds<E> bounds,
				boolean addedOnly) {
			if(start == end || start == null) {
				return null;
			}
			if(!addedOnly || start.isAdded()) {
				if(bounds == null || bounds.isInBounds(start.getKey())) {
					return start;
				}
			}
			return toNext(start);
		}
		@Override
		public boolean hasNext() {
			return next != null;
		}
		@Override
		public BinaryTreeNode<E> next() {
			if(!hasNext()) {
				throw new NoSuchElementException();
			}
			return doNext();
		}
		BinaryTreeNode<E> nextNoThrow() {
			if(!hasNext()) {
				return null;
			}
			return doNext();
		}
		BinaryTreeNode<E> doNext() {
			ChangeTracker changeTracker = this.changeTracker;
			if(changeTracker != null) {
				changeTracker.changedSince(currentChange);
			}
			current = next;
			next = toNext(next);
			return current;
		}
		BinaryTreeNode<E> toNext(BinaryTreeNode<E> current) {
			//lastLookAtCurrent(previous);
			BinaryOperator<BinaryTreeNode<E>> op = getToNextOperation();
			BinaryTreeNode<E> result = op.apply(current, end);
			return result;
		}
		@Override
		public void remove() {
			if(current == null) {
                throw new IllegalStateException(getMessage("ipaddress.error.no.iterator.element.to.remove"));
			}
			ChangeTracker changeTracker = this.changeTracker;
			if(changeTracker != null) {
				changeTracker.changedSince(currentChange);
			}
			current.remove();
			current = null;
			if(changeTracker != null) {
				currentChange = changeTracker.getCurrent();
			}
		}
	}
	static class NodeSpliterator<E> implements Spliterator<BinaryTreeNode<E>> {
		private final ChangeTracker changeTracker;
		private Change currentChange;
		
		private final Comparator<? super BinaryTreeNode<E>> comparator;
		
		private static enum Side {
			ALL, BEGINNING, ENDING;
		}
		
		private Side position; // ALL, LOWER, or UPPER
		
		private BinaryTreeNode<E> begin, end, root;
		private NodeIterator<E> iterator;
		private long sizeEstimate;
		private final boolean addedOnly, forward;
		NodeSpliterator(
				boolean forward,
				Comparator<? super BinaryTreeNode<E>> comparator,
				BinaryTreeNode<E> root,
				BinaryTreeNode<E> begin,
				BinaryTreeNode<E> end,
				long size,
				ChangeTracker changeTracker,
				boolean addedOnly) {
			this(forward, comparator, Side.ALL, begin, end, size, changeTracker, addedOnly);
			this.root = root;
		}
		
		private NodeSpliterator(
				boolean forward,
				Comparator<? super BinaryTreeNode<E>> comparator,
				Side position,
				BinaryTreeNode<E> begin,
				BinaryTreeNode<E> end,
				long sizeEstimate,
				ChangeTracker changeTracker,
				boolean addedOnly) {
			this.comparator = comparator;
			this.sizeEstimate = sizeEstimate;
			this.end = end;
			this.begin = begin;
			this.position = position;
			this.changeTracker = changeTracker;
			this.addedOnly = addedOnly;
			this.forward = forward;
			currentChange = changeTracker.getCurrent();
		}
		
		@Override
		public String toString() {
			return "spliterator from " + begin + " to " + end;
		}
		
		private BinaryTreeNode<E> getMiddle()  {
			BinaryTreeNode<E> mid;
			if(position == Side.BEGINNING) {
				mid = forward ? end.getLowerSubNode() : end.getUpperSubNode();
			} else if(position == Side.ENDING) {
				mid = forward ? begin.getUpperSubNode() : begin.getLowerSubNode();
				if(mid != null && end != null && getComparator().compare(mid, end) >= 0) {
					// can only happen with bounded trees, in which there are more nodes to follow,
					// but there is in fact a potential middle node anyway.  In non-bounded trees,
					// the existince of that middle node means there are more nodes to follow.
					return null;
				}
			} else {//splitPosition == ALL
				mid = root;
			}
			return mid;
		}
		
		private BinaryTreeNode<E> nextNode(BinaryTreeNode<E> current, BinaryTreeNode<E> bound) {
			return forward ? current.nextNode(bound) : current.previousNode(bound);
		}
		
		@Override
		public Spliterator<BinaryTreeNode<E>> trySplit() {
			if(begin == null) {
				// nothing to split
				return null;
			}
			changeTracker.changedSince(currentChange);
			BinaryTreeNode<E> mid = getMiddle();
			if(mid == null) {
				return null;
			}
			BinaryTreeNode<E> current;
			if(iterator == null) {
				current = begin;
			} else {
				current = iterator.next;
				if(current == null) {
					return null;
				}
			}
			if(current == end) {
				return null;
			}
			position = Side.ENDING;
			
			// first we check if left split is empty, and if so, we split ourselves (the right split) again
			if((current == mid || getComparator().compare(current, mid) >= 0)) {
				begin = current;
				//the current left split which goes up to mid is empty, so split ourselves again to produce another left split
				return trySplit();
			} else {
				begin = mid;
				if (addedOnly) while(!current.isAdded()) {
					current = nextNode(current, mid);
					if((current == mid || current == null)) {
						//the current left split is empty, so split ourselves again to produce another left split
						return trySplit();
					}
				}
			}
			
			
			// now we check if right split is empty
			BinaryTreeNode<E> next = mid;
			if (addedOnly) while(!next.isAdded()) {
				next = nextNode(next, end);
				if(next == end || next == null) {
					//the current right split is empty, so we copy over the left split to ourselves, and split again
					begin = current;
					end = mid;
					position = Side.BEGINNING;
					if(iterator != null) {
						iterator.end = mid;
					}
					return trySplit();
				}
			}
			
			// at this point we have two non-zero sized spliterators, so we're done
			long sizeEst = sizeEstimate;
			NodeSpliterator<E> lowerSplit = new NodeSpliterator<>(
					forward, comparator, Side.BEGINNING, current, mid, sizeEst >>> 1, changeTracker, addedOnly);
			sizeEstimate = (sizeEst + 1) >>> 1;
			if(iterator != null) {
				lowerSplit.iterator = iterator;
				iterator.end = mid;
			}
			iterator = null;
			return lowerSplit;
		}
		private NodeIterator<E> createIterator() {
			return new NodeIterator<E>(forward, addedOnly, begin, end, changeTracker);
		}
		private NodeIterator<E> provideIterator() {
			changeTracker.changedSince(currentChange);
			NodeIterator<E> iter = iterator;
			if(iter == null) {
				iter = createIterator();
				iterator = iter;
			}
			return iter;
		}
		@Override
		public boolean tryAdvance(Consumer<? super BinaryTreeNode<E>> action) {
			// change tracking exception handled by iterator
			BinaryTreeNode<E> next = provideIterator().nextNoThrow();
			if(next != null) {
				action.accept(next);
				return true;
			} else if(action == null) {
				throw new NullPointerException();
			}
			return false;
		}
		@Override
		public void forEachRemaining(Consumer<? super BinaryTreeNode<E>> action) {
			// change tracking exception handled by iterator
			BinaryTreeNode<E> next = provideIterator().nextNoThrow();
			if(next != null) {
				action.accept(next);
				while(true) {
					next = iterator.nextNoThrow();
					if(next == null) {
						break;
					}
					action.accept(next);
				}
			} else if(action == null) {
				throw new NullPointerException();
			}
	    }
		@Override
		public long estimateSize() {
			return sizeEstimate;
		}
		@Override
		public int characteristics() {
			int characteristics = Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED | Spliterator.NONNULL;
			if(position == Side.ALL) {
				characteristics |= Spliterator.SIZED;
			}
			return characteristics;
        }
        @Override
		public Comparator<? super BinaryTreeNode<E>> getComparator() {
        	return comparator;
        }
	}
	static class KeySpliterator<E> implements Spliterator<E> {
		private final Spliterator<? extends BinaryTreeNode<E>> wrapped;
		private final Comparator<? super E> comparator;
		KeySpliterator(Spliterator<? extends BinaryTreeNode<E>> wrapped,
				Comparator<? super E> comparator) {
			this.wrapped = wrapped;
			this.comparator = comparator;
		}
		private static <E> Consumer<? super BinaryTreeNode<E>> wrapAction(Consumer<? super E> action) {
			return node -> action.accept(node.getKey());
		}
		@Override
		public boolean tryAdvance(Consumer<? super E> action) {
			//return wrapped.tryAdvance(node -> wrapIt(node, action));
			return wrapped.tryAdvance(wrapAction(action));
		}
		@Override
		public void forEachRemaining(Consumer<? super E> action) {
			wrapped.forEachRemaining(wrapAction(action));
	    }
		@Override
		public Comparator<? super E> getComparator() {
			return comparator;
	    }
		@Override
		public Spliterator<E> trySplit() {
			Spliterator<? extends BinaryTreeNode<E>> split = wrapped.trySplit();
			if(split == null) {
				return null;
			}
			return new KeySpliterator<E>(split, comparator);
		}
		@Override
		public long estimateSize() {
			return wrapped.estimateSize();
		}
		@Override
		public long getExactSizeIfKnown() {
			return wrapped.getExactSizeIfKnown();
		}
		@Override
		public int characteristics() {
			return wrapped.characteristics();
		}
		@Override
		public String toString() {
			return wrapped.toString();
		}
	}
	//https://jrgraphix.net/r/Unicode/2500-257F
	//https://jrgraphix.net/r/Unicode/25A0-25FF
	static final String NON_ADDED_NODE_CIRCLE = "\u25cb";
	static final String ADDED_NODE_CIRCLE = "\u25cf";
	
	static final String LEFT_ELBOW = "\u251C\u2500"; 	// |-
	static final String IN_BETWEEN_ELBOWS = "\u2502 "; 	// |
	static final String RIGHT_ELBOW = "\u2514\u2500"; 	// --
	static final String BELOW_ELBOWS = "  ";
	static class Indents {
		final String nodeIndent, subNodeInd;
		
		Indents() {
			this("", "");
		}
		
		Indents(String nodeIndent, String subNodeIndent) {
			this.nodeIndent = nodeIndent;
			this.subNodeInd = subNodeIndent;
		}
	}
	/**
	 * Returns a visual representation of the sub-tree with this node as root, with one node per line.
	 * 
	 * @param withNonAddedKeys whether to show nodes that are not added nodes
	 * @param withSizes whether to include the counts of added nodes in each sub-tree
	 * @return
	 */
	public String toTreeString(boolean withNonAddedKeys, boolean withSizes) {
		StringBuilder builder = new StringBuilder("\n");
		printTree(builder, new Indents(), withNonAddedKeys, withSizes, this.<Indents>containingFirstAllNodeIterator(true));
		return builder.toString();
	}
	void printTree(StringBuilder builder, 
			Indents initialIndents,
			boolean withNonAdded, 
			boolean withSizes,
			CachingIterator<? extends BinaryTreeNode<E>, E, Indents> iterator) {
		while(iterator.hasNext()) {
			BinaryTreeNode<E> next = iterator.next();
			Indents cached = iterator.getCached();
			String nodeIndent, subNodeIndent;
			if(cached == null) {
				nodeIndent = initialIndents.nodeIndent;
				subNodeIndent = initialIndents.subNodeInd;
			} else {
				nodeIndent = cached.nodeIndent;
				subNodeIndent = cached.subNodeInd;
			}
			if(withNonAdded || next.isAdded()) {
				builder.append(nodeIndent).append(next); // appending next adds the ADDED_NODE_CIRCLE first
				if(withSizes) {
					builder.append(" (").append(next.size()).append(')');
				}
				builder.append('\n');
			} else {
				builder.append(nodeIndent).append(NON_ADDED_NODE_CIRCLE + "\n");
			}
			BinaryTreeNode<E> upper = next.getUpperSubNode(), lower = next.getLowerSubNode();
			if(upper != null) {
				if(lower != null) {
					Indents lowerIndents = new Indents(
							subNodeIndent + LEFT_ELBOW,
							subNodeIndent + IN_BETWEEN_ELBOWS);
					iterator.cacheWithLowerSubNode(lowerIndents);
				}
				Indents upperIndents = new Indents(
						subNodeIndent + RIGHT_ELBOW,
						subNodeIndent + BELOW_ELBOWS);
				iterator.cacheWithUpperSubNode(upperIndents);
			} else if(lower != null) {
				Indents lowerIndents = new Indents(
						subNodeIndent + RIGHT_ELBOW,
						subNodeIndent + BELOW_ELBOWS);
				iterator.cacheWithLowerSubNode(lowerIndents);
			}
		}
	}
	/**
	 * Returns a visual representation of this node including the key, with an open circle indicating this node is not an added node,
	 * a closed circle indicating this node is an added node.
	 */
	@Override
	public String toString() {
		return toNodeString(new StringBuilder(50), isAdded(), getKey(),  null).toString();
	}
	static <E, V> StringBuilder toNodeString(StringBuilder builder, boolean isAdded, E key, V value) {
		builder.append(isAdded ? ADDED_NODE_CIRCLE: NON_ADDED_NODE_CIRCLE).append(' ').append(key);
		if(value != null) {
			builder.append(" = ").append(value);
		}
		return builder;
	}
	/**
	 * Clones the node.  Keys remain the same, but the parent node and the lower and upper sub-nodes 
	 * are all set to null.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public BinaryTreeNode<E> clone() {
		try {
			BinaryTreeNode<E> result = (BinaryTreeNode<E>) super.clone();
			result.setParent(null);
			result.setLower(null);
			result.setUpper(null);
			result.size = isAdded() ? 1 : 0;
			result.changeTracker = null;
			return result;
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	@SuppressWarnings("unchecked")
	BinaryTreeNode<E> cloneTreeNode(ChangeTracker changeTracker) {
		try {
			BinaryTreeNode<E> result = (BinaryTreeNode<E>) super.clone();
			result.setParent(null);
			//result.setLower(null);
			//result.setUpper(null);
			result.changeTracker = changeTracker;
			return result;
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	@SuppressWarnings("unchecked")
	BinaryTreeNode<E> cloneTree(ChangeTracker changeTracker, Bounds<E> bounds) {
		BinaryTreeNode<E> rootClone = cloneTreeNode(changeTracker);
		BinaryTreeNode<E> clonedNode = rootClone;
		SubNodeCachingIterator<E, ?> iterator = (SubNodeCachingIterator<E, ?>) clonedNode.containingFirstAllNodeIterator(true);
		boolean recalculateSize = false;
		do {
			BinaryTreeNode<E> lower = clonedNode.getLowerSubNode();
			if(bounds != null) {
				while(true) {
					if(lower == null) {
						break;
					} else if(bounds.isWithinLowerBound(lower.getKey())) {
						if(!lower.isAdded()) {
							BinaryTreeNode<E> next = lower.getLowerSubNode();
							while(bounds.isBelowLowerBound(next.getKey())) {
								next = next.getUpperSubNode();
								if(next == null) {
									lower = lower.getUpperSubNode();
									recalculateSize = true;
									break;
								}
							}
						}
						break;
					}
					recalculateSize = true;
					// outside bounds, try again
					lower = lower.getUpperSubNode();
				}
			}
			if(lower != null) {
				clonedNode.setLower(lower.cloneTreeNode(changeTracker));
			} else {
				clonedNode.setLower(null);
			}
			BinaryTreeNode<E> upper = clonedNode.getUpperSubNode();
			if(bounds != null) {
				while(true) {
					if(upper == null) {
						break;
					} else if(bounds.isWithinUpperBound(upper.getKey())) {
						if(!upper.isAdded()) {
							BinaryTreeNode<E> next = upper.getUpperSubNode();
							while(bounds.isAboveUpperBound(next.getKey())) {
								next = next.getLowerSubNode();
								if(next == null) {
									upper = upper.getLowerSubNode();
									recalculateSize = true;
									break;
								}
							}
						}
						
						break;
					}
					recalculateSize = true;
					// outside bounds, try again
					upper = upper.getLowerSubNode();
				}
			}
			if(upper != null) {
				clonedNode.setUpper(upper.cloneTreeNode(changeTracker));
			} else {
				clonedNode.setUpper(null);
			}
			iterator.next(); // returns current clonedNode
			clonedNode = iterator.next;
		} while(iterator.hasNext() /* basically this checks clonedNode != null */);
		if(!rootClone.isAdded() && !isRoot()) {
			BinaryTreeNode<E> lower = rootClone.getLowerSubNode();
			if(lower == null) {
				rootClone = rootClone.getUpperSubNode();
			} else if(rootClone.getUpperSubNode() == null) {
				rootClone = lower;
			}
		}
		if(recalculateSize && rootClone != null) {
			rootClone.size = SIZE_UNKNOWN;
			rootClone.size();
		}
		return rootClone;
	}
	BinaryTreeNode<E> cloneTreeBounds(Bounds<E> bounds) {
		return cloneTree(new ChangeTracker(), bounds);
	}
	/**
	 * Clones the sub-tree starting with this node as root. 
	 * The nodes are cloned, but their keys and values are not cloned.
	 */
	public BinaryTreeNode<E> cloneTree() {
		return cloneTreeBounds(null);
	}
	/**
	 * The hash code is the hash code of the key value
	 */
	@Override
	public int hashCode() {
		return getKey().hashCode();
    }
	/**
	 * The hash code is the sum of the hash codes of all the added elements in the sub-tree with this node as the root
	 */
	public int treeHashCode()  {
		int hashCode = 0;
		Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next();
			hashCode += node.hashCode();
		}
	    return hashCode;
	}
	/**
	 * Returns whether the key values match those of the given node
	 */
	@Override
	public boolean equals(Object o) {
		if (o == this) {
            return true;
		}
		if(o instanceof BinaryTreeNode<?>) {
			BinaryTreeNode<?> other = (BinaryTreeNode<?>) o;
			return getKey().equals(other.getKey());
		}
		return false;
	}
	/**
	 * Returns whether the sub-tree represented by this node as the root node matches the given sub-tree
	 */
	public boolean treeEquals(BinaryTreeNode<?> other) {
		if (other == this) {
			return true;
		}
		if(other.size() != size()) {
			return false;
		}
		Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true),
				others = other.nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next(), otherNode = others.next();
			if(!node.equals(otherNode)) {
				return false;
			}
		}
		return true;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.CountComparator;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
/**
 * An address, or a collection of multiple addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString} or  {@link inet.ipaddr.MACAddressString}
 * 
 * @custom.core
 * @author sfoley
 *
 */
public abstract class Address implements AddressSegmentSeries {
	private static final long serialVersionUID = 4L;
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public static interface AddressValueProvider {
		
		int getSegmentCount();
		SegmentValueProvider getValues();
		
		default SegmentValueProvider getUpperValues() {
			return getValues();
		}
	}
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	@FunctionalInterface
	public static interface SegmentValueProvider {
		int getValue(int segmentIndex);
	}
	public static final String HEX_PREFIX = "0x";
	public static final String OCTAL_PREFIX = "0";
	public static final char RANGE_SEPARATOR = '-';
	public static final String RANGE_SEPARATOR_STR = String.valueOf(RANGE_SEPARATOR);
	public static final char ALTERNATIVE_RANGE_SEPARATOR = '\u00bb'; //''; javadoc whines about this char
	public static final String ALTERNATIVE_RANGE_SEPARATOR_STR = String.valueOf(ALTERNATIVE_RANGE_SEPARATOR);
	public static final char SEGMENT_WILDCARD = '*';
	public static final String SEGMENT_WILDCARD_STR = String.valueOf(SEGMENT_WILDCARD);
	public static final String ALTERNATIVE_SEGMENT_WILDCARD_STR = "";
	public static final char SEGMENT_SQL_WILDCARD = '%';
	public static final String SEGMENT_SQL_WILDCARD_STR = String.valueOf(SEGMENT_SQL_WILDCARD);
	public static final char SEGMENT_SQL_SINGLE_WILDCARD = '_';
	public static final String SEGMENT_SQL_SINGLE_WILDCARD_STR = String.valueOf(SEGMENT_SQL_SINGLE_WILDCARD);
	public static final AddressComparator DEFAULT_ADDRESS_COMPARATOR = new CountComparator(true);
	public static final AddressComparator ADDRESS_LOW_VALUE_COMPARATOR = new ValueComparator(true, false);
	public static final AddressComparator ADDRESS_HIGH_VALUE_COMPARATOR = new ValueComparator(true, true);
	private static MACAddressNetwork macNetwork;
	private static IPv6AddressNetwork ipv6Network;
	private static IPv4AddressNetwork ipv4Network;
	/* the segments.  For IPv4, each element is actually just 1 byte and the array has 4 elements, 
	 * while for IPv6, each element is 2 bytes and the array has 8 elements. */
	final AddressSection addressSection;
	/* an object encapsulating a string representing the address, which is the one used to construct the address if the address was constructed from a string */
	protected HostIdentifierString fromString;
	/**
	 * Constructs an address.
	 * @param section the address segments
	 */
	protected Address(AddressSection section) {
		addressSection = section;
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	protected Address(Function<Address, AddressSection> supplier) {
		addressSection = supplier.apply(this);
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	public static IPv6AddressNetwork defaultIpv6Network() {
		if(ipv6Network == null) {
			synchronized(Address.class) {
				if(ipv6Network == null) {
					ipv6Network = new IPv6AddressNetwork();
				}
			}
		}
		return ipv6Network;
	}
	public static IPv4AddressNetwork defaultIpv4Network() {
		if(ipv4Network == null) {
			synchronized(Address.class) {
				if(ipv4Network == null) {
					ipv4Network = new IPv4AddressNetwork();
				}
			}
		}
		return ipv4Network;
	}
	
	public static MACAddressNetwork defaultMACNetwork() {
		if(macNetwork == null) {
			synchronized(Address.class) {
				if(macNetwork == null) {
					macNetwork = new MACAddressNetwork();
				}
			}
		}
		return macNetwork;
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	@Override
	public int getSegmentCount() {
		return getSection().getSegmentCount();
	}
	
	@Override
	public int getDivisionCount() {
		return getSection().getDivisionCount();
	}
	
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public AddressSection getSection() {
		return addressSection;
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSection().getSegments(segs);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int index) {
		getSection().getSegments(start, end, segs, index);
	}
	@Override
	public abstract Iterable<? extends Address> getIterable();
	@Override
	public abstract Iterator<? extends Address> iterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> spliterator();
	@Override
	public abstract Stream<? extends Address> stream();
	@Override
	public abstract Iterator<? extends Address> prefixIterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixStream();
	@Override
	public abstract Iterator<? extends Address> prefixBlockIterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixBlockStream();
	@Override
	public abstract Address increment(long increment) throws AddressValueException;
	
	@Override
	public abstract Address incrementBoundary(long increment) throws AddressValueException;
	
	@Override
	public abstract Address getLower();
	
	@Override
	public abstract Address getUpper();
	/**
	 * Returns whether this address represents more than a single individual address, whether it is a subnet.
	 * 
	 * Such addresses include CIDR/IP addresses (eg 1.2.3.0/25) or wildcard addresses (eg 1.2.*.4) or range addresses (eg 1.2.3-4.5)
	 * 
	 * @return whether this address represents more than one address.
	 */
	@Override
	public boolean isMultiple() {
		return getSection().isMultiple();
	}
	/**
	 * Returns whether this address has an associated prefix length
	 * 
	 * @return whether this address has an associated prefix length
	 */
	@Override
	public boolean isPrefixed() {
		return getSection().isPrefixed();
	}
	/**
	 * Returns whether this address is an IP address
	 * 
	 * @return whether this address is an IP address
	 */
	public boolean isIPAddress() {
		return false;
	}
	/**
	 * Returns whether this address is a MAC address
	 * 
	 * @return whether this address is a MAC address
	 */
	public boolean isMACAddress() {
		return false;
	}
	/**
	 * If this address is an IP address, returns that {@link IPAddress}.  Otherwise, returns null.
	 * 
	 * @return the IP address
	 */
	public IPAddress toIPAddress() {
		return null;
	}
	/**
	 * If this address is a MAC address, returns that {@link MACAddress}.  Otherwise, returns null.
	 * 
	 * @return the MAC address
	 */
	public MACAddress toMACAddress() {
		return null;
	}
	/**
	 * the largest number of high bits for which this address represents all addresses with the same set of high bits
	 */
	@Override
	public Integer getPrefixLength() {
		return getSection().getPrefixLength();
	}
	/**
	 * Returns the smallest prefix length possible such that this includes the block of addresses for that prefix.
	 * <p>
	 * If the entire range can be dictated this way, then this method returns the same value as {@link #getPrefixLengthForSingleBlock()}.  
	 * Otherwise, this method will return the minimal possible prefix that can be paired with this address, while {@link #getPrefixLengthForSingleBlock()} will return null.
	 *<p>
	 * In cases where the final bit in this address division series is constant, this returns the bit length of this address division series.
	 *
	 * @return the prefix length
	 */
	@Override
	public int getMinPrefixLengthForBlock() {
		return getSection().getMinPrefixLengthForBlock();
	}
	/**
	 * Returns a prefix length for which the range of this address subnet matches the block of addresses for that prefix.
	 * <p>
	 * If the range can be dictated this way, then this method returns the same value as {@link #getMinPrefixLengthForBlock()}.
	 * <p>
	 * If no such prefix exists, returns null.
	 * <p>
	 * If this segment grouping represents a single value, returns the bit length of this address division series.
	 * <p>
	 * IP address examples:
	 * 1.2.3.4 returns 32
	 * 1.2.*.* returns 16
	 * 1.2.*.0/24 returns 16 in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS, 32 otherwise
	 * 1.2.*.4 returns null
	 * 1.2.252-255.* returns 22
	 * 1.2.3.4/x returns x in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS, 32 otherwise
	 * 1.2.0.0/16 returns 16 in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS or PREFIXED_ZERO_HOSTS_ARE_SUBNETS, 32 otherwise
	 * 
	 * @return the prefix length or null if it does not exist
	 */
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getSection().getPrefixLengthForSingleBlock();
	}
	
	/**
	 * Whether the MAC address or IP address or other form of address is multicast.
	 * 
	 * @see java.net.InetAddress#isMulticastAddress()
	 */
	public abstract boolean isMulticast();
	
	/**
	 * Gets the count of addresses that this address may represent.
	 * 
	 * If this address is not a subnet block of multiple addresses or has no range of values, then there is only one such address.
	 * 
	 * @return
	 */
	@Override
	public BigInteger getCount() {
		return getSection().getCount();
	}
	
	/**
	 * Gets the count of prefixes in this address for the given prefix length.
	 * 
	 * If this address is not a subnet block of multiple addresses or has no range of values, then there is only one.
	 * 
	 * @return
	 */
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return getSection().getPrefixCount(prefixLength);
	}
	/**
	 * If this has a prefix length, the count of the range of values in the prefix.
	 * 
	 * If this has no prefix, returns the same value as {@link #getCount()}
	 * 
	 * @return
	 */
	@Override
	public BigInteger getPrefixCount() {
		return getSection().getPrefixCount();
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		return getSection().getBlockCount(segmentCount);
	}
	@Override
	public byte[] getBytes() {
		return getSection().getBytes();
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getSection().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getSection().getBytes(bytes, index);
	}
	/**
	 * Gets the bytes for the highest address in the range of addresses represented by this address instance.
	 * 
	 * @return
	 */
	@Override
	public byte[] getUpperBytes() {
		return getSection().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getSection().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getSection().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getSection().getValue();
	}
	
	@Override
	public BigInteger getUpperValue() {
		return getSection().getUpperValue();
	}
	@Override
	public boolean isZero() {
		return getSection().isZero();
	}
	
	@Override
	public boolean includesZero() {
		return getSection().includesZero();
	}
	
	@Override
	public boolean isMax() {
		return getSection().isMax();
	}
	
	@Override
	public boolean includesMax() {
		return getSection().includesMax();
	}
	
	@Override
	public boolean isFullRange() {
		return getSection().isFullRange();
	}
	
	/**
	 * Whether the address can be considered a local address (as opposed to a global one)
	 * @return
	 */
	public abstract boolean isLocal();
	
	@Override
	public int hashCode() {
		return getSection().hashCode();
	}
	protected abstract boolean isFromSameString(HostIdentifierString otherString);
	
	public boolean isSameAddress(Address other) {
		return other == this || getSection().equals(other.getSection());
	}
	/**
	 * Two Address objects are equal if they represent the same set of addresses.
	 */
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof Address) {
			Address other = (Address) o;
			if(isFromSameString(other.fromString)) {
				return true;
			}
			return isSameAddress(other);
		}
		return false;
	}
	public boolean prefixEquals(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixEquals(other.getSection());
	}
	/**
	 * Returns whether this is same type and version of the given address and whether it overlaps with the individual addresses in the given address or subnet,
	 * containing at least one individual address common to both.
	 * 
	 * 
	 * @param other
	 * @return
	 */
	public boolean overlaps(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().overlaps(other.getSection());
	}
	/**
	 * Returns whether this is same type and version of the given address and whether it contains all individual addresses in the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean contains(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().contains(other.getSection());
	}
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * Determines how many address elements of a subnet precede the given address element, if the address is in the subnet.
	 * If above the subnet range, it is the distance to the upper boundary added to the subnet address count less one, and if below the subnet range, the distance to the lower boundary.
	 * <p>
	 * In other words, if the given address is not in the subnet but above it, returns the number of addresses preceding the address from the upper subnet boundary, 
	 * added to one less than the total number of subnet addresses.  If the given address is not in the subnet but below it, returns the number of addresses following the address to the lower subnet boundary.
	 * <p>
	 * enumerate returns null when the argument is a multi-valued subnet. The argument must be an individual address.
	 * <p>
	 * When this address is also single-valued, the returned value is the distance (difference) between this address and the argument address.
	 * <p>
	 * enumerate is the inverse of the increment method:
	 * <ul><li>subnet.enumerate(subnet.increment(inc)) = inc</li>
	 * <li>subnet.increment(subnet.enumerate(newAddr)) = newAddr</li></ul>
	 * <p>
	 * If the given address does not have the same version or type as this subnet or address, then null is returned.
	 */
	public abstract BigInteger enumerate(Address other);
	@Override
	public boolean isSequential() {
		return getSection().isSequential();
	}
	/**
	 * Returns a host identifier string representation for this address,
	 * which will be already validated.
	 * 
	 * @return
	 */
	public HostIdentifierString toAddressString() {
		return fromString;
	}
	/**
	 * Writes this address as a single hexadecimal value with always the exact same number of characters, with or without a preceding 0x prefix.
	 * 
	 * If this section represents a range of values outside of the network prefix length, then this is printed as a range of two hex values.
	 */
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		return getSection().toHexString(with0xPrefix);
	}
	/**
	 * The normalized string returned by this method is a common and consistent representation of the address.
	 * <p>
	 * The string returned by this method is unique for each address.
	 */
	@Override
	public String toNormalizedString() {
		return getSection().toNormalizedString();
	}
	
	/**
	 * This produces a canonical string.
	 * <p>
	 * RFC 5952 describes canonical representations for Ipv6
	 * http://en.wikipedia.org/wiki/IPv6_address#Recommended_representation_as_text
	 * http://tools.ietf.org/html/rfc5952
	 * <p>
	 * Each address has a unique canonical string, not counting the prefix.  The prefix can cause two equal addresses to have different strings.
	 */
	@Override
	public String toCanonicalString() {
		return getSection().toCanonicalString();
	}
	
	/**
	 * Produce short strings for the address in the usual address format.
	 * 
	 * Each address has a unique compressed string.
	 * 
	 */
	@Override
	public String toCompressedString() {
		return getSection().toCompressedString();
	}
	
	@Override
	public String toString() {
		return toCanonicalString();
	}
	
	@Override
	public String[] getDivisionStrings() {
		return getSection().getDivisionStrings();
	}
	
	@Override
	public String[] getSegmentStrings() {
		return getSection().getSegmentStrings();
	}
	
	@Override
	public abstract Address reverseSegments();
	
	@Override
	public abstract Address reverseBits(boolean perByte);
	
	@Override
	public abstract Address reverseBytes();
	
	@Override
	public abstract Address reverseBytesPerSegment();
	
	/**
	 * Returns whether the address range has a prefix length and includes the block of values for its prefix length.
	 */
	@Override
	public boolean isPrefixBlock() {
		return getSection().isPrefixBlock();
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return getSection().containsPrefixBlock(prefixLength);
	}
	
	/**
	 * Returns whether the address range the block of values for a single prefix identified by its prefix length.
	 * This is similar to {@link #isPrefixBlock()} except that it returns false when
	 * the subnet has multiple prefixes.
	 * 
	 * For instance, 1.*.*.* /16 return false for this method and returns true for {@link #isPrefixBlock()}
	 */
	@Override
	public boolean isSinglePrefixBlock() {
		return getSection().isSinglePrefixBlock();
	}
	
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return getSection().containsSinglePrefixBlock(prefixLength);
	}
	@Override
	public abstract Address toPrefixBlock();
	
	@Override @Deprecated
	public abstract Address removePrefixLength();
	
	@Override
	public abstract Address withoutPrefixLength();
	
	@Override @Deprecated
	public abstract Address removePrefixLength(boolean zeroed);
	
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract Address adjustPrefixLength(int adjustment);
	@Override
	public abstract Address adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract Address setPrefixLength(int prefixLength);
	
	@Override
	public abstract Address setPrefixLength(int prefixLength, boolean zeroed);
	
	@Deprecated
	@Override
	public abstract Address applyPrefixLength(int networkPrefixLength);
	
	/** 
	 * Checks if the two arrays share the same list of addresses, subnets, or address collections, in any order, using address equality.
	 * The function can handle duplicates, ignoring them.
	 * @param addrs1
	 * @param addrs2
	 * @return
	 */
	public static boolean matchUnordered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		boolean sameLen = len1 == len2;
		boolean result;
		if(len1 == 0 || len2 == 0) {
			result = sameLen;
		} else if(len1 == 1 && sameLen) {
			result = addrs1[0].equals(addrs2[0]);
		} else if(len1 == 2 && sameLen) {
			if(addrs1[0].equals(addrs2[0])) {
				result = addrs1[1].equals(addrs2[1]);
			} else if(result = addrs1[0].equals(addrs2[1])) {
				result = addrs1[1].equals(addrs2[0]);
			}
		} else {
			result = Objects.equals(asSet(addrs1), asSet(addrs2));
		}
		return result;
	}
	
	private static HashSet<Address> asSet(Address addrs[])  {
		int addrLen = addrs.length;
		if(addrLen > 0) {
			HashSet<Address> result = new HashSet<>();
			for(int i = 0; i < addrs.length; i++) {
				Address addr = addrs[i];
				result.add(addr);
			}
			return result;
		}
		return null;
	}
	
	/**
	 * Checks if the two arrays share the same ordered list of addresses, subnets, or address collections, using address equality.
	 * Duplicates are allowed, but must match their counterpart in the other array with each occurrence.
	 * @param addrs1
	 * @param addrs2
	 * @return
	 */
	public static boolean matchOrdered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		if(len1 != len2) {
			return false;
		}
		for(int i = 0; i < len1; i++) {
			if(!addrs1[i].equals(addrs2[i])) {
				return false;
			}
		}
		return true;
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * An IPv6 address trie.
 * 
 * See {@link AddressTrie}  for more details.
 * 
 * @author scfoley
 *
 */
public class IPv6AddressTrie extends AddressTrie<IPv6Address> {
	private static final long serialVersionUID = 1L;
	static final IPv6Address INIT_ROOT = new IPAddressString("::/0").getAddress().toIPv6();
	public IPv6AddressTrie() {
		super(new IPv6TrieNode());
	}
	protected IPv6AddressTrie(AddressBounds<IPv6Address> bounds) {
		super(new IPv6TrieNode(), bounds);
	}
	protected IPv6AddressTrie(IPv6TrieNode root, AddressBounds<IPv6Address> bounds) {
		super(root, bounds);
	}
	@Override
	protected IPv6TrieNode absoluteRoot() {
		return (IPv6TrieNode) super.absoluteRoot();
	}
	@Override
	protected IPv6AddressTrie createNew(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressTrie(bounds);
	}
	@Override
	protected IPv6AddressTrie createSubTrie(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressTrie(absoluteRoot(), bounds);
	}
	@Override
	public IPv6TrieNode getRoot() {
		return (IPv6TrieNode) super.getRoot();
	}
	public static class IPv6TrieNode extends TrieNode<IPv6Address> {
		private static final long serialVersionUID = 1L;
		protected IPv6TrieNode(IPv6Address addr) {
			super(addr);
		}
		public IPv6TrieNode() {
			super(INIT_ROOT);
		} // root node
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv6Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv6TrieNode getUpperSubNode() {
			return (IPv6TrieNode) super.getUpperSubNode();
		}
		@Override
		public IPv6TrieNode getLowerSubNode() {
			return (IPv6TrieNode) super.getLowerSubNode();
		}
		@Override
		public IPv6TrieNode getParent() {
			return (IPv6TrieNode) super.getParent();
		}
		@Override
		protected IPv6TrieNode createNewImpl(IPv6Address addr) {
			return new IPv6TrieNode(addr);
		}
		@Override
		public IPv6TrieNode removeElementsContainedBy(IPv6Address addr) {
			return (IPv6TrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv6TrieNode elementsContainedBy(IPv6Address addr) {
			return (IPv6TrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public IPv6TrieNode elementsContaining(IPv6Address addr) {
			return (IPv6TrieNode) super.elementsContaining(addr);
		}
		
		@Override
		public IPv6TrieNode longestPrefixMatchNode(IPv6Address addr) {
			return (IPv6TrieNode) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv6TrieNode getAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.getAddedNode(addr);
		}
		@Override
		public IPv6TrieNode getNode(IPv6Address addr) {
			return (IPv6TrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> nodeIterator(boolean forward) {
			return (Iterator<IPv6TrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> allNodeIterator(boolean forward) {
			return (Iterator<IPv6TrieNode>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6TrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv6TrieNode>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6TrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv6TrieNode>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv6TrieNode previousAddedNode() {
			return (IPv6TrieNode) super.previousAddedNode();
		}
		@Override
		public IPv6TrieNode nextAddedNode() {
			return (IPv6TrieNode) super.nextAddedNode();
		}
		@Override
		public IPv6TrieNode nextNode() {
			return (IPv6TrieNode) super.nextNode();
		}
		@Override
		public IPv6TrieNode previousNode() {
			return (IPv6TrieNode) super.previousNode();
		}
		@Override
		public IPv6TrieNode lowerAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public IPv6TrieNode floorAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.floorAddedNode(addr);
		}
		@Override
		public IPv6TrieNode higherAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.higherAddedNode(addr);
		}
		@Override
		public IPv6TrieNode ceilingAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv6TrieNode firstNode() {
			return (IPv6TrieNode) super.firstNode();
		}
		@Override
		public IPv6TrieNode lastNode() {
			return (IPv6TrieNode) super.lastNode();
		}
		@Override
		public IPv6TrieNode firstAddedNode() {
			return (IPv6TrieNode) super.firstAddedNode();
		}
		@Override
		public IPv6TrieNode lastAddedNode() {
			return (IPv6TrieNode) super.lastAddedNode();
		}
		
		@Override
		protected IPv6AddressTrie createNewTree() {
			return new IPv6AddressTrie();
		}
		
		@Override
		public IPv6AddressTrie asNewTrie() {
			return (IPv6AddressTrie) super.asNewTrie();
		}
		@Override
		public IPv6TrieNode cloneTree() {
			return (IPv6TrieNode) super.cloneTree();
		}
		@Override
		public IPv6TrieNode clone() {
			return (IPv6TrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6TrieNode && super.equals(o);
		}
		
		static class IPv6TrieKeyData extends TrieKeyData {
			long uint64HighVal, uint64LowVal, mask64HighVal, mask64LowVal, nextBitMask64Val;
			
			@Override
			public boolean is128Bits() {
				return true;
			}
			
			@Override
			public long getUint64LowVal() {
				return uint64LowVal;
			}
			
			@Override
			public long getUint64HighVal() {
				return uint64HighVal;
			}
			@Override
			public long getMask64HighVal() {
				return mask64HighVal;
			}
			
			@Override
			public long getMask64LowVal() {
				return mask64LowVal;
			}
			
			@Override
			public long getNextBitMask64Val() {
				return nextBitMask64Val;
			}
		}
		
		@Override
		protected IPv6TrieKeyData getTrieKeyCache(IPv6Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv6TrieNode removeElementsContainedBy(IPv6Address addr) {
		return (IPv6TrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv6TrieNode elementsContainedBy(IPv6Address addr) {
		return (IPv6TrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public IPv6TrieNode elementsContaining(IPv6Address addr) {
		return (IPv6TrieNode) super.elementsContaining(addr);
	}
	@Override
	public IPv6TrieNode longestPrefixMatchNode(IPv6Address addr) {
		return (IPv6TrieNode) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv6TrieNode getAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.getAddedNode(addr);
	}
	@Override
	public IPv6TrieNode getNode(IPv6Address addr) {
		return (IPv6TrieNode) super.getNode(addr);
	}
	@Override
	public IPv6TrieNode addNode(IPv6Address addr) {
		return (IPv6TrieNode) super.addNode(addr);
	}
	@Override
	public IPv6TrieNode addTrie(TrieNode<IPv6Address> trie) {
		return (IPv6TrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> nodeIterator(boolean forward) {
		return (Iterator<IPv6TrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> allNodeIterator(boolean forward) {
		return (Iterator<IPv6TrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6TrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv6TrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6TrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv6TrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv6TrieNode lowerAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public IPv6TrieNode floorAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.floorAddedNode(addr);
	}
	@Override
	public IPv6TrieNode higherAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.higherAddedNode(addr);
	}
	@Override
	public IPv6TrieNode ceilingAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv6TrieNode firstNode() {
		return (IPv6TrieNode) super.firstNode();
	}
	@Override
	public IPv6TrieNode lastNode() {
		return (IPv6TrieNode) super.lastNode();
	}
	@Override
	public IPv6TrieNode firstAddedNode() {
		return (IPv6TrieNode) super.firstAddedNode();
	}
	@Override
	public IPv6TrieNode lastAddedNode() {
		return (IPv6TrieNode) super.lastAddedNode();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv6AddressTrie && super.equals(o);
	}
	@Override
	public IPv6AddressTrie clone() {
		return (IPv6AddressTrie) super.clone();
	}
	@Override
	public AddedTree<IPv6Address> constructAddedNodesTree() {
		IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>>();
		contructAddedTree(trie);
		return new AddedTree<IPv6Address>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.format.util.AddressTrie.TrieNode.FollowingBits;
import inet.ipaddr.format.util.AddressTrie.TrieNode.KeyCompareResult;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.BinaryTreeNode.BlockSizeNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.Bounds;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.format.util.BinaryTreeNode.Indents;
import inet.ipaddr.format.util.BinaryTreeNode.KeySpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeSpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.PostOrderNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.PreOrderNodeIterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * A compact binary trie (aka compact binary prefix tree, or binary radix trie), for addresses and/or CIDR prefix block subnets.
 * The prefixes in used by the prefix trie are the CIDR prefixes, or the full address in the case of individual addresses with no prefix length.  
 * The elements of the trie are CIDR prefix blocks or addresses.
 * <p>
 * This trie data structure allows you to check an address for containment in many subnets at once, in constant time.  
 * The trie allows you to check a subnet for containment of many smaller subnets or addresses at once, in constant time.
 * The trie allows you to check for equality of a subnet or address with a large number of subnets or addresses at once.
 *<p>
 * The trie can also be used as the backing structure for a {@link AddressTrieSet} which is a {@link java.util.NavigableSet}.
 * Unlike {@link java.util.TreeSet} this data structure provides access to the nodes and the associated subtrie with each node,
 * which corresponds with their associated CIDR prefix block subnets.
 * <p>
 * There is only a single possible trie for any given set of address and subnets.  For one thing, this means they are automatically balanced.
 * Also, this makes access to subtries and to the nodes themselves more useful, allowing for many of the same operations performed on the original trie.  
 * <p>
 * Each node has either a prefix block or a single address as its key.  
 * Each prefix block node can have two sub-nodes, each sub-node a prefix block or address contained by the node.
 * <p>
 * There are more nodes in the trie than there are elements in the set.  
 * A node is considered "added" if it was explicitly added to the trie and is included as an element when viewed as a set.
 * There are non-added prefix block nodes that are generated in the trie as well.
 * When two or more added addresses share the same prefix up until they differ with the bit at index x, 
 * then a prefix block node is generated (if not already added to the trie) for the common prefix of length x,
 * with the nodes for those addresses to be found following the lower 
 * or upper sub-nodes according to the bit at index x + 1 in each address.
 * If that bit is 1, the node can be found by following the upper sub-node, 
 * and when it is 0, the lower sub-node.  
 * <p>
 * Nodes that were generated as part of the trie structure only 
 * because of other added elements are not elements of the represented set.
 * The set elements are the elements that were explicitly added.
 * <p>
 * You can work with parts of the trie, starting from any node in the trie,
 * calling methods that start with any given node, such as iterating or spliterating the subtrie,
 * finding the first or last in the subtrie, doing containment checks with the subtrie, and so on.
 * <p>
 * The binary trie structure defines a natural ordering of the trie elements.  
 * Addresses of equal prefix length are sorted by prefix value.  Addresses with no prefix length are sorted by address value.
 * Addresses of differing prefix length are sorted according to the bit that follows the shorter prefix length in the address with the longer prefix length,
 * whether that bit is 0 or 1 determines if that address is ordered before or after the address of shorter prefix length.
 * <p>
 * The unique and pre-defined structure for a trie means that different means of traversing the trie can be more meaningful.
 * This trie implementation provides 8 different ways of iterating through the trie:
 * <ul><li>1, 2: the natural sorted trie order, forward and reverse (spliterating is also an option for these two orders).  Use {@link #nodeIterator(boolean)}, {@link #iterator()} or {@link #descendingIterator()}.  A comparator is also provided for this order.
 * </li><li>3, 4: pre-order tree traversal, in which parent node is visited before sub-nodes, with sub-nodes visited in forward or reverse order
 * </li><li>5, 6: post-order tree traversal, in which sub-nodes are visited before parent nodes, with sub-nodes visited in forward or reverse order
 * </li><li>7, 8: prefix-block order, in which larger prefix blocks are visited before smaller, and blocks of equal size are visited in forward or reverse sorted order
 * </li></ul>
 * <p>
 * 
 * All of these orderings are useful in specific contexts.
 * <p>
 * You can do lookup and containment checks on all the subnets and addresses in the trie at once, in constant time.
 * A generic trie data structure lookup is O(m) where m is the entry length. 
 * For this trie, which operates on address bits, entry length is capped at 128 bits for IPv6 and 32 bits for IPv4.
 * That makes lookup a constant time operation.  
 * Subnet containment or equality checks are also constant time since they work the same way as lookup, by comparing prefix bits.
 * <p>
 * For a generic trie data structure, construction is O(m * n) where m is entry length and n is the number of addresses,
 * but for this trie, since entry length is capped at 128 bits for IPv6 and 32 bits for IPv4, construction is O(n),
 * in linear proportion to the number of added elements.
 *<p>
 * This trie also allows for constant time size queries (count of added elements, not node count), by storing sub-trie size in each node. 
 * It works by updating the size of every node in the path to any added or removed node.
 * This does not change insertion or deletion operations from being constant time (because tree-depth is limited to address bit count). 
 * At the same this makes size queries constant time, rather than being O(n) time.
 * <p>
 * This class is abstract and has a subclass for each address version or type. 
 * A single trie can use just a single address type or version, since it works with bits alone,
 * and this cannot distinguish between different versions and types in the trie structure. 
 * More specifically, using different address bit lengths would:
 * <ul>
 * <li>break the concept of containment, for example IPv6 address 0::/8 would be considered to contain IPv4 address 0.2.3.4
 * </li><li>break the concept of equality, for example MAC 1:2:3:*:*:* and IPv4 1.2.3.0/24 would be considered the same since they have the same prefix bits and length 
 * </li></ul><p>
 * Instead, you could aggregate multiple subtries to create a collection of multiple address types or versions.
 * You can use the method {@link #toString(boolean, AddressTrie...)} for a String that represents multiple tries as a single tree.
 * <p>
 * Tries are thread-safe when not being modified (elements added or removed), but are not thread-safe when one thread is modifying the trie.
 * For thread safety when modifying, one option is to use {@link Collections#synchronizedNavigableSet(java.util.NavigableSet)} on {@link #asSet()}.
 * <p>
 * 
 * @author scfoley
 *
 * @param <E> the type of the address keys
 */
// Note: We do not allow direct access to tries that have non-null bounds.
// Such tries can only be accessed indirectly through the Set and Map classes.
// Methods like removeElementsContainedBy, elementsContainedBy, elementsContaining, and elementContains (and perhaps a couple others) would be inaccurate,
//	as they do not account for the bounds.
// Those methods used by the Set and Map classes do account for the bounds.
// Also, many methods here give access to the nodes, and the nodes themselves do not account for the bounds.
// That in particular would make things quite confusing for users, in which the trie methods and the node methods produce different results.
//
// So overall, we do not allow direct access to AddressTrie objects that have bounds, mostly because of the potential confusion,
// and because it would force us to alter the API for methods like elementsContainedBy in a way that makes the API inferior.
//
// We do allow the Set and Map classes to produce an AddressTrie even when bounded, 
// but that AddressTrie is a clone of the bounded trie that has only the bounded nodes.
// So, overall, we do provide the same functionality, you just have to generate a new trie from the bounded set or map.
//
// Also, by storing the bounds strictly inside the AddressTrie, we avoid the complications of making the Bounds part of the API,
// which would make all the operations quite tricky and in some cases expensive.
// For instance, here we can cache the bounded root and reuse it.  
// Making the bounds part of the API would also double the API method count and make the API quite cumbersome,
// even if it is not public.
//
// So for all those reasons, the bounds are stored in the tries, but tries with bounds are not directly accessible.
// The API then remains quite full-fledged, with full access to the nodes, while at the same time the Set and Map API
// also remains full-fledged.  Finally, Map and Set users can get a non-bounds trie for any bounded Set or Map,
// should they really want one.
// 
public abstract class AddressTrie<E extends Address> extends AbstractTree<E> {
	private static final long serialVersionUID = 1L;
	protected static class AddressBounds<E extends Address> extends Bounds<E> {
		private static final long serialVersionUID = 1L;
		
		E oneAboveUpperBound, oneBelowUpperBound, oneAboveLowerBound, oneBelowLowerBound;
		
		AddressBounds(E lowerBound, E upperBound, Comparator<? super E> comparator) {
			this(lowerBound, true, upperBound, false, comparator);
		}
		
		AddressBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			super(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
			if(lowerBound != null) {
				checkBlockOrAddress(lowerBound, true);
			}
			if(upperBound != null) {
				checkBlockOrAddress(upperBound, true);
			}
		}
		
		static <E extends Address> AddressBounds<E> createNewBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			if(lowerBound != null) {
				if(lowerInclusive && lowerBound.isZero()) {
					lowerBound = null;
				}
			}
			if(upperBound != null) {
				if(upperInclusive && upperBound.isMax()) {
					upperBound = null;
				}
			}
			if(lowerBound == null && upperBound == null) {
				return null;
			}
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		
		@Override
		AddressBounds<E> createBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		
		@Override
		AddressBounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.restrict(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		
		@Override
		AddressBounds<E> intersect(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.intersect(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		
		
		// matches the value just above the upper bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentAboveUpperBound(E addr) {
			E res = oneAboveUpperBound;
			if(res == null) {
				res = increment(upperBound);
				oneAboveUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just below the lower bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentBelowLowerBound(E addr) {
			E res = oneBelowLowerBound;
			if(res == null) {
				res = decrement(lowerBound);
				oneBelowLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just below the upper bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentBelowUpperBound(E addr) { 
			E res = oneBelowUpperBound;
			if(res == null) {
				res = decrement(upperBound);
				oneBelowUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just above the lower bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentAboveLowerBound(E addr) {
			E res = oneAboveLowerBound;
			if(res == null) {
				res = increment(lowerBound);
				oneAboveLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		@Override
		boolean isMax(E addr) {
			return addr.isMax();
		}
		@Override
		boolean isMin(E addr) {
			return addr.isZero();
		}
		
		@Override
		public String toCanonicalString(String separator) {
			Function<? super E, String> stringer = Address::toCanonicalString;
			return toString(stringer, separator, stringer);
		}
	}
	
	protected static enum Operation {
		// Given an address/subnet key E
	    INSERT, // add node for E if not already there
	    REMAP, // alters nodes based on the existing nodes and their values
	    LOOKUP, // find node for E, traversing all containing elements along the way
	    NEAR, // closest match, going down trie to get element considered closest.
	    	// Whether one thing is closer than another is determined by the sorted order.
	    	// For example, for subnet 1.2.0.0/16, 1.2.128.0 is closest address on the high side, 1.2.127.255 is closest address on the low side
	    CONTAINING, // find a single node whose key contains E
	    ALL_CONTAINING, // list the nodes whose keys contain E
	    INSERTED_DELETE, // remove node for E
	    SUBTREE_DELETE // remove nodes whose keys are contained by E
	}
	
	// not optimized for size, since only temporary, to be used for a single operation
	protected static class OpResult<E extends Address> implements KeyCompareResult, FollowingBits, Serializable {
		private static final long serialVersionUID = 1L;
		E addr;
		
		// whether near is searching for a floor or ceiling
		// a floor is greatest element below addr
		// a ceiling is lowest element above addr
		boolean nearestFloor; 
		
		// whether near cannot be an exact match
		boolean nearExclusive;
		
		Operation op;
		
		OpResult() {}
		
		OpResult(E addr, Operation op) {
			this(addr, op, false, false);
		}
		OpResult(E addr, boolean floor, boolean exclusive) {
			this(addr, Operation.NEAR, floor, exclusive);
		}
		private OpResult(E addr, Operation op, boolean floor, boolean exclusive) {
			this.addr = addr;
			this.op = op;
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
		}
		// do not use with Operation.NEAR, INSERT, REMAP, INSERTED_DELETE, SUBTREE_DELETE
		OpResult<E> reset(E addr, Operation op) {
			this.addr = addr;
			this.op = op;
			return this;
		}
		
		OpResult<E> resetNear(E addr, boolean floor, boolean exclusive) {
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
			return reset(addr, Operation.NEAR);
		}
		
		// Do not use with Operation.NEAR, INSERT, REMAP, INSERTED_DELETE, SUBTREE_DELETE,
		// We'd need to do more cleaning if we did.
		void clean() {
			addr = null;
			op = null;
			
			// contains and lookups
			exists = false;
			existingNode = containing = containingEnd = 
					smallestContaining = largestContaining = 
					containedBy = null;
			
			// near
			nearestFloor = nearExclusive = false;
			nearestNode = backtrackNode = null;
			
			// deletions
			deleted = null;
			
			// adds and puts
			newValue = existingValue = null;
			inserted = added = addedAlready = null;
			// remaps
			remapper = null;
		}
		// lookups:
		// an inserted tree element matches the supplied argument
		// exists is set to true only for "added" nodes
		boolean exists;
		// the matching tree element, when doing a lookup operation, or the pre-existing node for an insert operation
		// existingNode is set for both added and not added nodes
		TrieNode<E> existingNode;
		// the closest tree element, when doing a near operation
		TrieNode<E> nearestNode;
		// if searching for a floor/lower, and the nearest node is above addr, then we must backtrack to get below
		// if searching for a ceiling/higher, and the nearest node is below addr, then we must backtrack to get above
		TrieNode<E> backtrackNode;
		
		// contains:  
		// A linked list of the tree elements, from largest to smallest, 
		// that contain the supplied argument, and the end of the list
		TrieNode<E> containing, containingEnd;
		
		// Of the tree nodes with elements containing the subnet or address,
		// those with the smallest or largest subnet or address
		TrieNode<E> smallestContaining, largestContaining;
		// contained by: 
		// this tree is contained by the supplied argument
		TrieNode<E> containedBy;
		// deletions:
		// this tree was deleted
		TrieNode<E> deleted;
		// adds and puts:
		// new and existing values for add, put and remap operations
		Object newValue, existingValue;
	
		// this added tree node was newly created for an add
		TrieNode<E> inserted;
		// this added tree node previously existed but had not been added yet
		TrieNode<E> added;
		// this added tree node was already added to the trie
		TrieNode<E> addedAlready;
		// remaps:
		Function<?, ?> remapper;
		static <E extends Address> TrieNode<E> getNextAdded(TrieNode<E> node) {
			while(node != null && !node.isAdded()) {
				// Since only one of upper and lower can be populated, whether we start with upper or lower does not matter
				TrieNode<E> next = node.getUpperSubNode();
				if(next == null) {
					node = node.getLowerSubNode();
				} else {
					node = next;
				}
			}
			return node;
		}
		TrieNode<E> getContaining() {
			TrieNode<E> containing = getNextAdded(this.containing);
			this.containing = containing;
			if(containing != null) {
				TrieNode<E> current = containing;
				do {
					TrieNode<E> next = current.getUpperSubNode();
					TrieNode<E> nextAdded;
					if(next == null) {
						next = current.getLowerSubNode();
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setLower(nextAdded);
						}
					} else {
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setUpper(nextAdded);
						}
					}
					current = nextAdded;
				} while(current != null);
			}
			return containing;
		}
		// add to the list of tree elements that contain the supplied argument
		void addContaining(TrieNode<E> containingSub) {
			TrieNode<E> cloned = containingSub.clone();
			if(containing == null) {
				containing = cloned;
			} else {
				Comparator<BinaryTreeNode<E>> comp = nodeComparator();
				if(comp.compare(containingEnd, cloned) > 0) {
					containingEnd.setLower(cloned);
				} else {
					containingEnd.setUpper(cloned);
				}
				containingEnd.adjustCount(1);
			}
			containingEnd = cloned;
		}
		
		//
		//
		//
		// for searching
		
		long followingBits;
		
		@Override
		public void setFollowingBits(long bits) {
			followingBits = bits;
		}
		
		TrieNode<E> node;
		
		@Override
		public void bitsMatch() {
			E existingAddr = node.getKey();
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefixLen = addr.getPrefixLength();
			containedBy = node;
			if(existingPref == null) {
				if(newPrefixLen == null) {
					// note that "added" is already true here, 
					// we can only be here if explicitly inserted already 
					// since it is a non-prefixed full address
					node.handleMatch(this);
				} else if(newPrefixLen == existingAddr.getBitCount()) {
					node.handleMatch(this);
				} else  {
					node.handleContained(this, newPrefixLen);
				}
			} else { 
				// we know newPrefixLen != null since we know all of the bits of newAddr match, 
				// which is impossible if newPrefixLen is null and existingPref not null
				if(newPrefixLen.intValue() == existingPref.intValue()) {
					if(node.isAdded()) {
						node.handleMatch(this);
					} else {
						node.handleNodeMatch(this);
					}
				} else if(existingPref == existingAddr.getBitCount()) { 
					node.handleMatch(this);
				} else { // existing prefix > newPrefixLen
					node.handleContained(this, newPrefixLen);
				}
			}
		}
		@Override
		public void bitsDoNotMatch(int matchedBits) {
			node.handleSplitNode(this, matchedBits);
		}
		@Override
		public FollowingBits bitsMatchPartially() {
			if(node.isAdded()) {
				node.handleContains(this);
				if(op == Operation.CONTAINING) {
					return null;
				}
			}
			return this;
		}
	}
	/**
	 * A comparator that provides the same ordering used by the trie,
	 * an ordering that works with prefix block subnets and individual addresses.
	 * The comparator is consistent with the equality and hashcode of address instances
	 * and can be used in other contexts.  However, it only works with prefix blocks and individual addresses,
	 * not with addresses like 1-2.3.4.5-6 which cannot be differentiated using this comparator from 1.3.4.5
	 * and is thus not consistent with equals and hashcode for subnets that are not CIDR prefix blocks.
	 * <p>
	 * The comparator first compares the prefix of addresses, with the full address value considered the prefix when 
	 * there is no prefix length, ie when it is a single address.  It takes the minimum m of the two prefix lengths and
	 * compares those m prefix bits in both addresses.  The ordering is determined by which of those two values is smaller or larger.
	 * <p>
	 * If those two values match, then it looks at the address with longer prefix.  
	 * If both prefix lengths match then both addresses are equal.
	 * Otherwise it looks at bit m in the address with larger prefix.  If 1 it is larger and if 0 it is smaller than the other.
	 * <p>
	 * When comparing an address with a prefix p and an address without, the first p bits in both are compared, and if equal,
	 * the bit at index p in the non-prefixed address determines the ordering, if 1 it is larger and if 0 it is smaller than the other.
	 * <p>
	 * When comparing an address with prefix length matching the bit count to an address with no prefix, they are considered equal if the bits match.
	 * For instance, 1.2.3.4/32 is equal to 1.2.3.4, and thus the trie does not allow 1.2.3.4/32 in the trie since it is indistinguishable from 1.2.3.4, 
	 * instead 1.2.3.4/32 is converted to 1.2.3.4 when inserted into the trie.
	 * <p>
	 * When comparing 0.0.0.0/0, which has no prefix, to other addresses, the first bit in the other address determines the ordering.
	 * If 1 it is larger and if 0 it is smaller than 0.0.0.0/0.
	 * 
	 * 
	 * @author scfoley
	 *
	 * @param <E>
	 */
	public static class AddressComparator<E extends Address> implements Comparator<E>, Serializable {
		private static final long serialVersionUID = 1L;
		@Override
		public int compare(E o1, E o2) {
			if(o1 == o2) {
				return 0;
			}
			int segmentCount = o1.getSegmentCount();
			int bitsPerSegment = o1.getBitsPerSegment();
			Integer o1Pref = o1.getPrefixLength();
			Integer o2Pref = o2.getPrefixLength();
			int bitsMatchedSoFar = 0;
			int i = 0;
			while(true) {
				AddressSegment segment1 = o1.getSegment(i);
				AddressSegment segment2 = o2.getSegment(i);
				Integer pref1 = getSegmentPrefLen(o1, o1Pref, bitsPerSegment, bitsMatchedSoFar, segment1);
				Integer pref2 = getSegmentPrefLen(o2, o2Pref, bitsPerSegment, bitsMatchedSoFar, segment2);
				int segmentPref2;
				if(pref1 != null) {
					int segmentPref1 = pref1;
					if(pref2 != null && (segmentPref2 = pref2) <= segmentPref1) {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
						if(matchingBits >= segmentPref2) {
							if(segmentPref2 == segmentPref1) {
								// same prefix block
								return 0;
							}
							// segmentPref2 is shorter prefix, prefix bits match, so depends on bit at index segmentPref2
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						}
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref1, bitsPerSegment);
						if(matchingBits >= segmentPref1) {
							if(segmentPref1 < bitsPerSegment) {
								return segment2.isOneBit(segmentPref1) ? -1 : 1;
							} else if(++i == segmentCount) {
								return 1; // o1 with prefix length matching bit count is the bigger
							} // else must check the next segment
						} else {
							return segment1.getSegmentValue() - segment2.getSegmentValue();
						}
					}
				} else if(pref2 != null) {
					segmentPref2 = pref2;
					int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
					if(matchingBits >= pref2) {
						if(segmentPref2 < bitsPerSegment) {
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						} else if(++i == segmentCount) {
							return -1; // o2 with prefix length matching bit count is the bigger
						} // else must check the next segment
					} else {
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					}
				} else {
					int matchingBits = getMatchingBits(segment1, segment2, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { // no match - the current subnet/address is not here
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else if(++i == segmentCount) {
						// same address
						return 0;
					} // else must check the next segment
				}
				bitsMatchedSoFar += bitsPerSegment;
			}
		}
	}
	/**
	 * Returns the next address according to the trie ordering
	 * 
	 * @param <E>
	 * @param addr
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <E extends Address> E increment(E addr) {
		if(addr.isMax()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getUpper().setPrefixLength(ipaddr.getPrefixLength() + 1).toZeroHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(false) + 1));
		}
		
		if(addr.isPrefixed()) {
			return (E) addr.getUpper().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getLower();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isMax()) {
				trailingBitCount += Integer.numberOfTrailingZeros(~seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	/**
	 * Returns the previous address according to the trie ordering
	 * 
	 * @param <E>
	 * @param addr
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <E extends Address> E decrement(E addr) {
		if(addr.isZero()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getLower().setPrefixLength(ipaddr.getPrefixLength() + 1).toMaxHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(true) + 1));
		}
		
		if(addr.isPrefixed()) {
			return (E) addr.getLower().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getUpper();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isZero()) {
				trailingBitCount += Integer.numberOfTrailingZeros(seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	public static class TrieComparator<E extends Address> implements Comparator<BinaryTreeNode<E>>, Serializable {
		private static final long serialVersionUID = 1L;
		Comparator<E> comparator;
		TrieComparator(Comparator<E> comparator) {
			this.comparator = comparator;
		}
		@Override
		public int compare(BinaryTreeNode<E> tree1, BinaryTreeNode<E> tree2) {
			E o1 = tree1.getKey();
			E o2 = tree2.getKey();
			return comparator.compare(o1, o2);
		}
	};
	/**
	 * A node for a compact binary prefix trie whose elements are prefix block subnets or addresses,
	 * 
	 * @author scfoley
	 *
	 * @param <E>
	 */
	public static abstract class TrieNode<E extends Address> extends BinaryTreeNode<E> implements AddressTrieOps<E> {
		private static final long serialVersionUID = 1L;
		protected TrieNode(E item) {
			super(item);
		}
		/**
		 * Returns the node for the subnet block containing this node.
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getParent() {
			return (TrieNode<E>) super.getParent();
		}
		/**
		 * Returns the sub-node whose address is largest in value
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getUpperSubNode() {
			return (TrieNode<E>) super.getUpperSubNode();
		}
		/**
		 * Returns the sub node whose address is smallest in value
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getLowerSubNode() {
			return (TrieNode<E>) super.getLowerSubNode();
		}
		private TrieNode<E> findNodeNear(E addr, boolean below, boolean exclusive) {
			addr = checkBlockOrAddress(addr, true);
			return findNodeNearNoCheck(addr, below, exclusive);
		}
		
		private TrieNode<E> findNodeNearNoCheck(E addr, boolean below, boolean exclusive) {
			OpResult<E> result = new OpResult<>(addr, below, exclusive);
			matchBits(result);
			TrieNode<E> backtrack = result.backtrackNode;
			if(backtrack != null) {
				TrieNode<E> parent = backtrack.getParent();
				while(parent != null && 
						(backtrack == (below ? parent.getLowerSubNode() : parent.getUpperSubNode()))) {
					backtrack = parent;
					parent = backtrack.getParent();
				}
				
				if(parent != null) {
					if(parent.isAdded()) {
						result.nearestNode = parent;
					} else {
						result.nearestNode = (below ? parent.previousAddedNode() : parent.nextAddedNode());
					}
				}
			}
			return result.nearestNode;
		}
		@Override
		public TrieNode<E> previousAddedNode() {
			return (TrieNode<E>) super.previousAddedNode();
		}
		@Override
		public TrieNode<E> nextAddedNode() {
			return (TrieNode<E>) super.nextAddedNode();
		}
		@Override
		public TrieNode<E> nextNode() {
			return (TrieNode<E>) super.nextNode();
		}
		@Override
		public TrieNode<E> previousNode() {
			return (TrieNode<E>) super.previousNode();
		}
		@Override
		public TrieNode<E> firstNode() {
			return (TrieNode<E>) super.firstNode();
		}
		@Override
		public TrieNode<E> firstAddedNode() {
			return (TrieNode<E>) super.firstAddedNode();
		}
		@Override
		public TrieNode<E> lastNode() {
			return (TrieNode<E>) super.lastNode();
		}
		@Override
		public TrieNode<E> lastAddedNode() {
			return (TrieNode<E>) super.lastAddedNode();
		}
		@Override
		public TrieNode<E> lowerAddedNode(E addr) {
			return findNodeNear(addr, true, true);
		}
		TrieNode<E> lowerNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, true);
		}
		@Override
		public E lower(E addr) {
			return getNodeKey(lowerAddedNode(addr));
		}
		@Override
		public TrieNode<E> floorAddedNode(E addr) {
			return findNodeNear(addr, true, false);
		}
		TrieNode<E> floorNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, false);
		}
		@Override
		public E floor(E addr) {
			return getNodeKey(floorAddedNode(addr));
		}
		@Override
		public TrieNode<E> higherAddedNode(E addr) {
			return findNodeNear(addr, false, true);
		}
		TrieNode<E> higherNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, true);
		}
		@Override
		public E higher(E addr) {
			return getNodeKey(higherAddedNode(addr));
		}
		@Override
		public TrieNode<E> ceilingAddedNode(E addr) {
			return findNodeNear(addr, false, false);
		}
		TrieNode<E> ceilingNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, false);
		}
		@Override
		public E ceiling(E addr) {
			return getNodeKey(ceilingAddedNode(addr));
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.allNodeIterator(forward);
		}
		/**
		 * Iterates the added nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * <p>
		 * This iterator supports the {@link java.util.Iterator#remove()} operation.
		 * 
		 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
		 * @return
		 */
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, true);
		}
		/**
		 * Iterates all the nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * <p>
		 * This iterator supports the {@link java.util.Iterator#remove()} operation.
		 * 
		 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
		 * @return
		 */
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, false);
		}
		/**
		 * Iterates all nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * 
		 * @return
		 */
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, true);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, false);
		}
		@SuppressWarnings("unchecked")
		Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> spliterator = new NodeSpliterator<E>(
					forward,
					comp,
					this,
					forward ? firstNode() : lastNode(),
					getParent(),
					size(),
					changeTracker,
					addedNodesOnly /* added only */);
			return (Spliterator<? extends TrieNode<E>>) spliterator;
		}
		@Override
		public Spliterator<E> spliterator() {
			return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
		}
		@Override
		public Spliterator<E> descendingSpliterator() {
			return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
		}
		@Override
		public boolean contains(E addr) {
			return doLookup(addr).exists;
		}
		@Override
		public boolean remove(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.INSERTED_DELETE);
			matchBits(result);
			return result.exists;
		}
		@Override
		public TrieNode<E> getNode(E addr) {
			return doLookup(addr).existingNode;
		}
		@Override
		public TrieNode<E> removeElementsContainedBy(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.SUBTREE_DELETE);
			matchBits(result);
			return result.deleted;
		}
		@Override
		public TrieNode<E> elementsContainedBy(E addr) {
			return doLookup(addr).containedBy;
		}
		// only added nodes are added to the linked list
		@Override
		public TrieNode<E> elementsContaining(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.ALL_CONTAINING);
			matchBits(result);
			return result.getContaining();
		}
		@Override
		public E longestPrefixMatch(E addr) {
			TrieNode<E> node = longestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> longestPrefixMatchNode(E addr) {
			return doLookup(addr).smallestContaining;
		}
		@Override
		public E shortestPrefixMatch(E addr) {
			TrieNode<E> node = shortestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> shortestPrefixMatchNode(E addr) {
			return doElementContains(addr);
		}
		@Override
		public boolean elementContains(E addr) {
			return doElementContains(addr) != null;
		}
		private TrieNode<E> doElementContains(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.CONTAINING);
			matchBits(result);
			return result.largestContaining;
		}
		protected OpResult<E> doLookup(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.LOOKUP);
			matchBits(result);
			return result;
		}
		private void removeSubtree(OpResult<E> result) {
			result.deleted = this;
			clear();
		}
		protected void removeOp(OpResult<E> result) {
			result.deleted = this;
			remove();
		}
		void matchBits(OpResult<E> result) {
			matchBitsFromIndex(0, result);
		}
		// traverses the tree, matching bits with prefix block nodes, until we can match no longer,
		// at which point it completes the operation, whatever that operation is
		void matchBitsFromIndex(int bitIndex, OpResult<E> result) {
			TrieNode<E> matchNode = this; 
			E newAddr = result.addr;
			Operation op = result.op;
			TrieKeyData newKeyData = getTrieKeyCache(newAddr);
			boolean simpleMatch = newKeyData != null && op != Operation.INSERT && op != Operation.NEAR && op != Operation.REMAP;
			E existingAddr = getKey();
			while(true) {
				result.node = matchNode;
				boolean continueToNext = matchAddressBits(simpleMatch, newAddr, existingAddr, bitIndex, result, newKeyData);
				if(continueToNext) {
					int bits = existingAddr.getPrefixLength();
					// matched all node bits up the given count, so move into sub-nodes
					matchNode = matchNode.matchSubNode(bits, result);
					if(matchNode == null) {
						// reached the end of the line
						break;
					}
					// Matched a sub-node.  
					// The sub-node was chosen according to the next bit. 
					// That bit is therefore now a match,
					// so increment the matched bits by 1, and keep going.
					bitIndex = bits + 1;
					existingAddr = matchNode.getKey();
				} else {
					break;
				}
			}
			result.node = null;
		}
		static interface FollowingBits {
			void setFollowingBits(long bits);
		}
		static interface KeyCompareResult {
			void bitsMatch();
			void bitsDoNotMatch(int matchedBits);
			// When this is called, if the returned value is non-null, 
			// then setFollowingBits must be called on the returned instance with either zero or a non-zero value
			// to indicate if the next bit following the prefix length of the node's address is 0 or 1 in the supplied address.
			FollowingBits bitsMatchPartially();
		}
		
		// Providing TrieKeyData for trie keys makes lookup faster.
		// However, it is optional, tries will work without it.
		protected static class TrieKeyData {
			// currently trie optimizations exist for 32 or 128 bits,
			// so providing TrieKeyData for other bit sizes provides no benefit at this time
			public Integer prefixLength;
			// 32 bit key caches must override these 4 methods:
			public boolean is32Bits() {
				return false;
			}
			public int getUint32Val() {
				return 0;
			}
			public int getMask32Val() {
				return 0;
			}
			public int getNextBitMask32Val() {
				return 0;
			}
			// 128 bit key caches must override these 6 methods:
			public boolean is128Bits() {
				return false;
			}
			public long getUint64LowVal() {
				return 0;
			}
			public long getUint64HighVal() {
				return 0;
			}
			public long getMask64HighVal() {
				return 0;
			}
			public long getMask64LowVal() {
				return 0;
			}
			public long getNextBitMask64Val() {
				return 0;
			}
		}
		protected TrieKeyData getTrieKeyCache(E addr) {
			return null;
		}
	
		boolean matchAddressBits(boolean simpleSearch, E newAddr, E existingAddr, int bitIndex, TrieNode.KeyCompareResult handleMatch, TrieKeyData newTrieCache)  {
			
			// this is the optimized path for the case where we do not need to know how many of the initial bits match in a mismatch
			// when we have a match, all bits match
			// when we have a mismatch, we do not need to know how many of the initial bits match
			// So there is no callback for a mismatch here.
			// The non-optimized code has 8 cases, 2 for each fully nested if or else block
			// I have added comments to see how this code matches up to those 8 cases
			if(simpleSearch) {
				TrieKeyData existingTrieCache = getTrieKeyCache(existingAddr);
				if(existingTrieCache != null) {
					if(existingTrieCache.is32Bits()) {
						if(newTrieCache.is32Bits()) {
							int existingVal = existingTrieCache.getUint32Val();
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								int newVal = newTrieCache.getUint32Val();
								if(newVal == existingVal) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										int newMask = newTrieCache.getMask32Val();
										if((newVal & newMask) == (existingVal & newMask)) {
											// rest of case 1 and rest of case 5
											handleMatch.bitsMatch();
										}
									}
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & 0x80000000);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { // optimized case where no matching is required because bit index had advanced by just one
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											int nextBitMask = existingTrieCache.getNextBitMask32Val();
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & nextBitMask);
											return true;
										}
									}
								} else {
									int existingMask = existingTrieCache.getMask32Val();
									int newVal = newTrieCache.getUint32Val();
									if((newVal & existingMask) == (existingVal & existingMask)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												int nextBitMask = existingTrieCache.getNextBitMask32Val();
												followingBits.setFollowingBits(newVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null) {
										int newPrefLenBits = newPrefLen;
										if(existingPrefLenBits > newPrefLenBits) {
											int newMask = newTrieCache.getMask32Val();
											if((newTrieCache.getUint32Val() & newMask) == (existingVal & newMask)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								}
							}
							return false;
						}
					} else if(existingTrieCache.is128Bits()) {
						if(newTrieCache != null && newTrieCache.is128Bits()) {
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								long newLowVal = newTrieCache.getUint64LowVal();
								long existingLowVal = existingTrieCache.getUint64LowVal();
								if(newLowVal == existingLowVal &&
									newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newLowVal & newMaskLow) == (existingLowVal & newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & 0x8000000000000000L);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { // optimized case where no matching is required because bit index had advanced by just one
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											long nextBitMask = existingTrieCache.getNextBitMask64Val();
											if(bitIndex > 63) /* IPv6BitCount - 65 */ {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & nextBitMask);
											} else {
												followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & nextBitMask);
											}
											return true;
										}
									}
								} else if(existingPrefLenBits > 64) {
									long existingMaskLow = existingTrieCache.getMask64LowVal();
									long newLowVal = newTrieCache.getUint64LowVal();
									if((newLowVal & existingMaskLow) == (existingTrieCache.getUint64LowVal() & existingMaskLow)) {
										long existingMaskHigh = existingTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
											if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
												handleMatch.bitsMatch();
											} else {
												FollowingBits followingBits = handleMatch.bitsMatchPartially();
												if(followingBits != null) {
													long nextBitMask = existingTrieCache.getNextBitMask64Val();
													followingBits.setFollowingBits(newLowVal & nextBitMask);
													return true;
												}
											}
										} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
											long newMaskLow = newTrieCache.getMask64LowVal();
											if((newTrieCache.getUint64LowVal() & newMaskLow) == (existingTrieCache.getUint64LowVal() & newMaskLow)) {
												long newMaskHigh = newTrieCache.getMask64HighVal();
												if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
													// rest of case 1 and rest of case 5
													handleMatch.bitsMatch();
												}
											}
										} // else case 4, 7
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newTrieCache.getUint64LowVal()&newMaskLow) == (existingTrieCache.getUint64LowVal()&newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								} else if(existingPrefLenBits == 64) {
									if(newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
										if(newPrefLen != null && newPrefLen <= 64) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & 0x8000000000000000L);
												return true;
											}
										}
									} else {
										if(newPrefLen != null && newPrefLen < 64) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								} else { // existingPrefLen < 64
									long existingMaskHigh = existingTrieCache.getMask64HighVal();
									long newHighVal = newTrieCache.getUint64HighVal();
									if((newHighVal & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												long nextBitMask = existingTrieCache.getNextBitMask64Val();
												followingBits.setFollowingBits(newHighVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskHigh = newTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
											// rest of case 1 and rest of case 5
											handleMatch.bitsMatch();
										}
									} // else case 4, 7
								}
							}
							return false;
						}
					}
				}
			}
			int bitsPerSegment = existingAddr.getBitsPerSegment();
			int bytesPerSegment = existingAddr.getBytesPerSegment();
			int segmentIndex = ParsedAddressGrouping.getHostSegmentIndex(bitIndex, bytesPerSegment, bitsPerSegment);
			int segmentCount = existingAddr.getSegmentCount();
			if(newAddr.getSegmentCount() != segmentCount || bitsPerSegment != newAddr.getBitsPerSegment()) {
				throw new IllegalArgumentException(getMessage("ipaddress.error.mismatched.bit.size"));
			}
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefLen = newAddr.getPrefixLength();
			// this block handles cases like where we matched matching ::ffff:102:304 to ::ffff:102:304/127,
			// and we found a subnode to match, but we know the final bit is a match due to the subnode being lower or upper,
			// so there is actually not more bits to match
			if(segmentIndex >= segmentCount) {
				// all the bits match
				handleMatch.bitsMatch();
				return false;
			}
			int bitsMatchedSoFar = ParsedAddressGrouping.getTotalBits(segmentIndex, bytesPerSegment, bitsPerSegment);
			while(true) {
				AddressSegment existingSegment = existingAddr.getSegment(segmentIndex);
				AddressSegment newSegment = newAddr.getSegment(segmentIndex);
				Integer segmentPref = getSegmentPrefLen(existingAddr, existingPref, bitsPerSegment, bitsMatchedSoFar, existingSegment);
				Integer newSegmentPref = getSegmentPrefLen(newAddr, newPrefLen, bitsPerSegment, bitsMatchedSoFar, newSegment);
				int newPrefixLen;
				if(segmentPref != null) {	
					int segmentPrefLen = segmentPref;
					if(newSegmentPref != null && (newPrefixLen = newSegmentPref) <= segmentPrefLen) {
						int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
						if(matchingBits >= newPrefixLen) { 
							handleMatch.bitsMatch();
						} else {
							// no match - the bits don't match
							// matchingBits < newPrefLen < segmentPrefLen
							handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						}
					} else {
						int matchingBits = getMatchingBits(existingSegment, newSegment, segmentPrefLen, bitsPerSegment);
						if(matchingBits >= segmentPrefLen) { // match - the current subnet/address is a match so far, and we must go further to check smaller subnets
							FollowingBits followingBits = handleMatch.bitsMatchPartially();
							if(followingBits != null) {
								// calculate the followingBitsFlag
								// check if at end of segment, advance to next if so
								if(segmentPrefLen == bitsPerSegment) {
									segmentIndex++;
									if(segmentIndex == segmentCount) {
										return true;
									}
									newSegment = newAddr.getSegment(segmentIndex);
									segmentPrefLen = 0;
								}
								// check the bit for followingBitsFlag
								if(newSegment.isOneBit(segmentPrefLen)) {
									followingBits.setFollowingBits(0x8000000000000000L);
								}
								return true;
							}
							return false;
						}
						// matchingBits < segmentPrefLen - no match - the bits in current prefix do not match the prefix of the existing address
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else if(newSegmentPref != null) {
					newPrefixLen = newSegmentPref;
					int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
					if(matchingBits >= newPrefixLen) { // the current bits match the current prefix, but the existing has no prefix
						handleMatch.bitsMatch();
					} else {
						// no match - the current subnet does not match the existing address
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else {
					int matchingBits = getMatchingBits(existingSegment, newSegment, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { // no match - the current subnet/address is not here
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						return false;
					} else if(++segmentIndex == segmentCount) { // match - the current subnet/address is a match
						// note that "added" is already true here, we can only be here if explicitly inserted already since it is a non-prefixed full address
						handleMatch.bitsMatch();
						return false;
					}
					bitsMatchedSoFar += bitsPerSegment;
				}
			}
		}
		private void handleContained(OpResult<E> result, int newPref) {
			Operation op = result.op;
			if(op == Operation.INSERT) {
				// if we have 1.2.3.4 and 1.2.3.4/32, and we are looking at the last segment,
				// then there are no more bits to look at, and this makes the former a sub-node of the latter.
				// In most cases, however, there are more bits in existingAddr, the latter, to look at.
				replace(result, newPref);
			} else  if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearest(result, newPref);
			} else if(op == Operation.REMAP) {
				remapNonExistingReplace(result, newPref);
			} 
		}
		private boolean handleContains(OpResult<E> result) {
			if(result.op == Operation.CONTAINING) {
				result.largestContaining = this;
				return true;
			} else if(result.op == Operation.ALL_CONTAINING) {
				result.addContaining(this);
				return true;
			}
			result.smallestContaining = this;
			return false;
		}
		private void handleSplitNode(OpResult<E> result, int totalMatchingBits) {
			E newAddr = result.addr;
			Operation op = result.op;	
			if(op == Operation.INSERT) {
				split(result, totalMatchingBits, createNew(newAddr));
			} else if(op == Operation.NEAR) {
				findNearest(result, totalMatchingBits);
			} else if(op == Operation.REMAP) {
				remapNonExistingSplit(result, totalMatchingBits);
			} 
		}
		// a node exists for the given key but the node is not added,
		// so not a match, but a split not required
		private void handleNodeMatch(OpResult<E> result) {
			Operation op = result.op;
			if(op == Operation.LOOKUP) {
				result.existingNode = this;
			} else if(op == Operation.INSERT) {
				existingAdded(result);
			} else if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearestFromMatch(result);
			} else if(op == Operation.REMAP) {
				remapNonAdded(result);
			}
		}
		private void handleMatch(OpResult<E> result) {
			result.exists = true;
			if(!handleContains(result)) {
				Operation op = result.op;
				if(op == Operation.LOOKUP) {
					matched(result);
				} else if(op == Operation.INSERT) {
					matchedInserted(result);
				} else if(op == Operation.INSERTED_DELETE) {
					removeOp(result);
				} else if(op == Operation.SUBTREE_DELETE) {
					removeSubtree(result);
				} else if(op == Operation.NEAR) {
					if(result.nearExclusive) {
						findNearestFromMatch(result);
					} else {
						matched(result);
					}
				} else if(op == Operation.REMAP) {
					remapMatch(result);
				}
			}
		}
		private void remapNonExistingReplace(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				replace(result, totalMatchingBits);
			}
		}
		private void remapNonExistingSplit(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				split(result, totalMatchingBits, createNew(result.addr));
			}
		}
		private TrieNode<E> remapNonExisting(OpResult<E> result) {
			if(remap(result, false)) {
				return createNew(result.addr);
			}
			return null;
		}
		private void remapNonAdded(OpResult<E> result) {
			if(remap(result, false)) {
				existingAdded(result);
			}
		}
		private void remapMatch(OpResult<E> result) {
			result.existingNode = this;
			if(remap(result, true)) {
				matchedInserted(result);
			}
		}
		/**
		 * Remaps the value for a node to a new value.  
		 * This operation, which works on mapped values, is for maps, so this base method here does nothing,
		 * but is overridden in map subclasses.
		 * 
		 * @param result
		 * @param match
		 * @return true if a new node needs to be created (match is null) or added (match is non-null)
		 */
		boolean remap(OpResult<E> result, boolean isMatch) {
			return false;
		}
		// this node matched when doing a lookup
		private void matched(OpResult<E> result) {
			result.existingNode = this;
			result.nearestNode = this;
		}
		// ** overridden by map trie **
		// similar to matched, but when inserting we see it already there.
		// this added node had already been added before
		void matchedInserted(OpResult<E> result) {
			result.existingNode = this;
			result.addedAlready = this;
		}
		// this node previously existed but was not added til now
		private void existingAdded(OpResult<E> result) {
			result.existingNode = this;
			result.added = this;
			added(result);
		}
		// this node is newly inserted and added
		private void inserted(OpResult<E> result) {
			result.inserted = this;
			added(result);
		}
		// ** overridden by map trie **
		void added(OpResult<E> result) {
			setNodeAdded(true);
			adjustCount(1);
			changeTracker.changed();
		}
		/**
		 * The current node and the new node both become sub-nodes of a new block node taking the position of the current node.
		 * 
		 * @param totalMatchingBits
		 * @param newAddr
		 */
		@SuppressWarnings("unchecked")
		private void split(OpResult<E> result, int totalMatchingBits, TrieNode<E> newSubNode) {
			E key = getKey();
			E newBlock;
			if(key.isIPAddress()) {
				newBlock = (E) key.toIPAddress().toPrefixBlock(totalMatchingBits);
			} else {
				newBlock = (E) key.setPrefixLength(totalMatchingBits).toPrefixBlock();
			}
			replaceToSub(newBlock, totalMatchingBits, newSubNode);
			newSubNode.inserted(result);
		}
		/**
		 * The current node is replaced by the new node and becomes a sub-node of the new node.
		 * 
		 * @param totalMatchingBits
		 * @param newAddr
		 */
		private void replace(OpResult<E> result, int totalMatchingBits) {
			result.containedBy = this;
			TrieNode<E> newNode = replaceToSub(result.addr, totalMatchingBits, null);
			newNode.inserted(result);
		}
		/**
		 * The current node is replaced by a new block of the given address.
		 * The current node and given node become sub-nodes.
		 * 
		 * @param newAssignedAddr
		 * @param result
		 * @param totalMatchingBits
		 * @param newSubNode
		 * @return
		 */
		private TrieNode<E> replaceToSub(E newAssignedAddr, int totalMatchingBits, TrieNode<E> newSubNode) {
			TrieNode<E> newNode = createNew(newAssignedAddr);
			newNode.size = size;
			TrieNode<E> parent = getParent();
			if(parent.getUpperSubNode() == this) {
				parent.setUpper(newNode);
			} else if(parent.getLowerSubNode() == this) {
				parent.setLower(newNode);
			}
			E existingAddr = getKey();
			if(totalMatchingBits < existingAddr.getBitCount() && 
					existingAddr.isOneBit(totalMatchingBits)) {
				if(newSubNode != null) {
					newNode.setLower(newSubNode);
				}
				newNode.setUpper(this);
			} else {
				newNode.setLower(this);
				if(newSubNode != null) {
					newNode.setUpper(newSubNode);
				}
			}
			return newNode;
		}
		// only called when lower/higher and not floor/ceiling since for a match ends things for the latter
		private void findNearestFromMatch(OpResult<E> result) {
			if(result.nearestFloor) {
				// looking for greatest element < queried address
				// since we have matched the address, we must go lower again,
				// and if we cannot, we must backtrack
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					// no nearest node yet
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = lower;
						lower = lower.getUpperSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				// looking for smallest element > queried address
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					// no nearest node yet
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = upper;
						upper = upper.getLowerSubNode();
					} while(upper != null);
					result.nearestNode = last;
				}
			}
		}
		private void findNearest(OpResult<E> result, int differingBitIndex) {
			E thisAddr = getKey();
			if(differingBitIndex < thisAddr.getBitCount() && thisAddr.isOneBit(differingBitIndex)) {
				// this element and all below are > than the query address
				if(result.nearestFloor) {
					// looking for greatest element < or <= queried address, so no need to go further
					// need to backtrack and find the last right turn to find node < than the query address again
					result.backtrackNode = this;
				} else {
					// looking for smallest element > or >= queried address
					TrieNode<E> lower = this, last;
					do {
						last = lower;
						lower = lower.getLowerSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				// this element and all below are < than the query address
				if(result.nearestFloor) {
					// looking for greatest element < or <= queried address
					TrieNode<E> upper = this, last;
					do {
						last = upper;
						upper = upper.getUpperSubNode();
					} while(upper != null);
					result.nearestNode = last;
				} else {
					// looking for smallest element > or >= queried address, so no need to go further
					// need to backtrack and find the last left turn to find node > than the query address again
					result.backtrackNode = this;
				}
			}
		}
		/**
		 * Initializes the tree with the given node
		 * 
		 * @param node
		 */
		void init(TrieNode<E> node) {
			E newAddr = node.getKey();
			if(newAddr.getBitCount() > 0 && newAddr.isOneBit(0)) {
				setUpper(node);
			} else {
				setLower(node);
			}
			size = (isAdded() ? 1 : 0) + node.size;
		}
		
		private TrieNode<E> matchSubNode(int bitIndex, OpResult<E> result) {
			E newAddr = result.addr;
			if(!FREEZE_ROOT && isEmpty()) {
				if(result.op == Operation.REMAP) {
					remapNonAdded(result);
				} else if(result.op == Operation.INSERT) {
					setKey(newAddr);
					existingAdded(result);
				}
			} else if(bitIndex >= newAddr.getBitCount()) {
				// we matched all bits, yet somehow we are still going
				// this can only happen when matching 1.2.3.4/32 to 1.2.3.4
				// which should never happen and so we do nothing
			} else if(result.followingBits != 0L) {
				result.setFollowingBits(0);
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					// no match
					Operation op = result.op;
					if(op == Operation.INSERT) {
						upper = createNew(newAddr);
						setUpper(upper);
						upper.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							// With only one sub-node at most, normally that would mean this node must be added.
							// But there is one exception, when we are the non-added root node.
							// So must check for added here.
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								// check if our lower sub-node is there and added.  It is underneath addr too.
								// find the highest node in that direction.
								TrieNode<E> lower = getLowerSubNode();
								if(lower != null) {
									TrieNode<E> res = lower;
									TrieNode<E> next = res.getUpperSubNode();
									while(next != null) {
										res = next;
										next = res.getUpperSubNode();
									}
									result.nearestNode = res;
								}
							}
						} else {
							result.backtrackNode = this;
						}
					} else if(op == Operation.REMAP) {
						upper = remapNonExisting(result);
						if(upper != null) {
							setUpper(upper);
							upper.inserted(result);
						}
					}
				} else {
					return upper;
				}
			} else {
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					// no match
					Operation op = result.op;
					if(op == Operation.INSERT) {
						lower = createNew(newAddr);
						setLower(lower);
						lower.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							result.backtrackNode = this;
						} else {
							// With only one sub-node at most, normally that would mean this node must be added.
							// But there is one exception, when we are the non-added root node.
							// So must check for added here.
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								// check if our upper sub-node is there and added.  It is above addr too.
								// find the highest node in that direction.
								TrieNode<E> upper = getUpperSubNode();
								if(upper != null) {
									TrieNode<E> res = upper;
									TrieNode<E> next = res.getLowerSubNode();
									while(next != null) {
										res = next;
										next = res.getLowerSubNode();
									}
									result.nearestNode = res;
								}
							}
						}
					} else if(op == Operation.REMAP) {
						lower = remapNonExisting(result);
						if(lower != null) {
							setLower(lower);
							lower.inserted(result);
						}
					} 
				} else {
					return lower;
				}
			}
			return null;
		}
		private TrieNode<E> createNew(E newAddr) {
			TrieNode<E> newNode = createNewImpl(newAddr);
			newNode.changeTracker = changeTracker;
			return newNode;
		}
		protected abstract TrieNode<E> createNewImpl(E newAddr);
		
		protected abstract AddressTrie<E> createNewTree();
		/**
		 * Creates a new sub-trie, copying the nodes starting with this node as root. 
		 * The nodes are copies of the nodes in this sub-trie, but their keys and values are not copies.
		 */
		public AddressTrie<E> asNewTrie() {
			AddressTrie<E> newTrie = createNewTree();
			newTrie.addTrie(this);
			return newTrie;
		}
		
		@Override
		public TrieNode<E> cloneTree() {
			return (TrieNode<E>) super.cloneTree();
		}
		@Override
		public TrieNode<E> clone() {
			return (TrieNode<E>) super.clone();
		}
		@Override
		TrieNode<E> cloneTreeBounds(Bounds<E> bounds) {
			return (TrieNode<E>) super.cloneTreeBounds(bounds);
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof TrieNode && super.equals(o);
		}
	}
	static final TrieComparator<?> comparator = new TrieComparator<>(new AddressComparator<>());
	static final TrieComparator<?> reverseComparator = new TrieComparator<>(Collections.reverseOrder(new AddressComparator<>()));
	AddressTrieSet<E> set;
	AddressBounds<E> bounds;
	private TrieNode<E> subRoot; // if bounded, the root of the subtrie, which can change
	private Change subRootChange; // if trie was modified since last check for subroot, must check for new subroot
	protected AddressTrie(TrieNode<E> root) {
		super(root);
		root.changeTracker = new ChangeTracker();
	}
	protected AddressTrie(TrieNode<E> root, AddressBounds<E> bounds) {
		super(root);
		if(root.changeTracker == null) {
			root.changeTracker = new ChangeTracker();
		}
		this.bounds = bounds;
	}
	private static Integer getSegmentPrefLen(
			AddressSegmentSeries addr,
			Integer prefLen,
			int bitsPerSegment,
			int bitsMatchedSoFar,
			AddressSegment segment) {
		if(segment instanceof IPAddressSegment) {
			return ((IPAddressSegment) segment).getSegmentPrefixLength();
		} else if(prefLen != null) {
			Integer result = prefLen - bitsMatchedSoFar;
			if(result <= bitsPerSegment) {
				if(result < 0) {
					result = 0;
				}
				return result;
			}
		}
		return null;
	}
	private static int getMatchingBits(AddressSegment segment1, AddressSegment segment2, int maxBits, int bitsPerSegment) {
		if(maxBits == 0) {
			return 0;
		}
		int val1 = segment1.getSegmentValue();
		int val2 = segment2.getSegmentValue();
		int xor = val1 ^ val2;
		switch(bitsPerSegment) {
		case IPv4Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosByte(xor);
		case IPv6Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosShort(xor);
		default:
			return Integer.numberOfLeadingZeros(xor) + bitsPerSegment - Integer.SIZE;
		}
	}
	private static int numberOfLeadingZerosShort(int i) {
		int half = i >>> 8;
		if(half == 0) {
			return 8 + numberOfLeadingZerosByte(i & 0xff);
		}
		return numberOfLeadingZerosByte(half);
	}
	private static int numberOfLeadingZerosByte(int i) {
		if (i <= 0) {
			if(i == 0){
				return 8;
			}
			return 0;
		}
		int n = 1;
		if (i >>> 4 == 0) { n += 4; i <<= 4; }
		if (i >>> 6 == 0) { n += 2; i <<= 2; }
		n -= i >>> 7;
		return n;
	}
	@Override
	public boolean isEmpty() {
		if(bounds == null) {
			return super.isEmpty();
		}
		// we avoid calculating size for bounded tries
		return firstAddedNode() == null;
    }
	/**
	 * Returns the number of nodes in the trie, which is more than the number of added elements.
	 * 
	 * @return
	 */
	@Override
	public int nodeSize() {
		if(bounds == null) {
			return super.nodeSize();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = allNodeIterator(true);
		while(iterator.hasNext()) {
			totalCount++;
			iterator.next();
		}
		return totalCount;
	}
	@Override
	public int size() {
		if(bounds == null) {
			return super.size();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = nodeIterator(true);
		while(iterator.hasNext()) {
			TrieNode<E> node = iterator.next();
			if(node.isAdded() && bounds.isInBounds(node.getKey())) {
				totalCount++;
			}
		}
		return totalCount;
	}
	
	@Override
	public boolean add(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		return !result.exists;
	}
	static void throwOutOfBounds() {
		throw new IllegalArgumentException(getMessage("ipaddress.error.address.out.of.range"));
	}
	protected void adjustRoot(E addr) {}
	@Override
	public TrieNode<E> addNode(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		TrieNode<E> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return node;
	}
	static abstract class SubNodesMapping<E extends Address, N extends SubNodesMapping<E, N>> {
		// subNodes is the list of direct and indirect added sub-nodes in the original trie
		ArrayList<AssociativeTrieNode<E, N>> subNodes;
		
		abstract Object getUnderlyingValue();
	}
	
	protected static class SubNodesMappingBasic<E extends Address> extends SubNodesMapping<E, SubNodesMappingBasic<E>> {
		
		@Override
		Object getUnderlyingValue() {
			return null;
		}
	}
	
	
	/**
	 * Provides an associative trie in which the root and each added node are mapped to a list of their respective direct added nodes.
	 * This trie provides an alternative non-binary tree structure of the added nodes.
	 * It is used by {@link #toAddedNodesTreeString()} to produce a string showing the alternative structure.
	 * If there are no non-added nodes in this trie, then the alternative tree structure provided by this method is the same as the original trie.
	 *
	 * @return
	 */
	public abstract AddedTreeBase<E, ? extends SubNodesMapping<E, ? extends SubNodesMapping<E, ?>>> constructAddedNodesTree(); 
	/**
	* Constructs a trie in which added nodes are mapped to their list of added sub-nodes.
	* This trie provides an alternative non-binary tree structure of the added nodes.
	* It is used by ToAddedNodesTreeString to produce a string showing the alternative structure.
	* If there are no non-added nodes in this trie, 
	* then the alternative tree structure provided by this method is the same as the original trie.
	* 
	* @return
	*/
	protected void contructAddedTree(AssociativeAddressTrie<E, SubNodesMappingBasic<E>> emptyTrie) {
		emptyTrie.addTrie(absoluteRoot()); // does not add values
		
		CachingIterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>, E, 
				AssociativeTrieNode<E, SubNodesMappingBasic<E>>> cachingIterator =
				emptyTrie.containingFirstAllNodeIterator(true);
		
		while(cachingIterator.hasNext()) {
			AssociativeTrieNode<E, SubNodesMappingBasic<E>> newNext = cachingIterator.next(), parent;
			
			// populate the values from the original trie into the new trie
			newNext.setValue(new SubNodesMappingBasic<E>());
			
			// cache this node with its sub-nodes
			cachingIterator.cacheWithLowerSubNode(newNext);
			cachingIterator.cacheWithUpperSubNode(newNext);
			
			// the cached object is our parent
			if(newNext.isAdded()) {
				parent = cachingIterator.getCached();
				if(parent != null) {
					// find added parent, or the root if no added parent
					// this part would be tricky if we accounted for the bounds,
					// maybe we'd have to filter on the bounds, and also look for the sub-root
					while(!parent.isAdded()) {
						AssociativeTrieNode<E, SubNodesMappingBasic<E>> parentParent = parent.getParent();
						if(parentParent == null) {
							break;
						}
						parent = parentParent;
					}
					// store ourselves with that added parent or root
					SubNodesMappingBasic<E> mappedNodes = parent.getValue();
					ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>> addedSubs = mappedNodes.subNodes;
					if(addedSubs == null) {
						addedSubs = new ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>>(newNext.size() - 1);
						mappedNodes.subNodes = addedSubs;
					}
					addedSubs.add(newNext);
				} // else root
			}
		}
		SubNodesMappingBasic<E> value = emptyTrie.getRoot().getValue();
		if(value != null && value.subNodes != null) {
			value.subNodes.trimToSize();
		}
		Iterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>> iter = emptyTrie.allNodeIterator(true);
		while(iter.hasNext()) {
			SubNodesMappingBasic<E> list = iter.next().getValue();
			if(list != null && list.subNodes != null) {
				list.subNodes.trimToSize();
			}
		}
	}
	/**
	 * Provides a flattened version of the trie showing only the contained added nodes and their containment structure, which is non-binary.
	 * The root node is included, which may or may not be added.
	 * <p>
	 * See {@link #constructAddedNodesTree()}
	 * 
	 * @return
	 */
	public abstract String toAddedNodesTreeString();
	
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeAddressTrie<E, N> addedTree) {
		AssociativeTrieNode<E, N> root = addedTree.absoluteRoot();
		return toAddedNodesTreeString(root);
	}
	
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeTrieNode<E, N> root) {
		class IndentsNode {
			Indents indents;
			AssociativeTrieNode<E, N> node;
			IndentsNode(Indents indents, AssociativeTrieNode<E, N> node) {
				this.indents = indents;
				this.node = node;
			}
		}
		
		Deque<IndentsNode> stack = null;
		StringBuilder builder = new StringBuilder();
		builder.append('\n');
		AssociativeTrieNode<E, N> nextNode = root;
		String nodeIndent = "", subNodeIndent = "";
		IndentsNode nextItem;
		while(true) {
			SubNodesMapping<E, N> nextNodeList = nextNode.getValue();
			TrieNode.toNodeString(builder.append(nodeIndent), nextNode.isAdded(), nextNode.getKey(), nextNodeList.getUnderlyingValue()).append('\n');
			ArrayList<AssociativeTrieNode<E, N>> nextNodes = nextNodeList.subNodes;
			if(nextNodes != null && nextNodes.size() > 0) {
				
				AssociativeTrieNode<E, N> nNode, next;
				int i = nextNodes.size() - 1;
				Indents lastIndents = new Indents(
						subNodeIndent + BinaryTreeNode.RIGHT_ELBOW,
						subNodeIndent + BinaryTreeNode.BELOW_ELBOWS);
				nNode = nextNodes.get(i);
				next = nNode;
				if(stack == null) {
					stack = new ArrayDeque<>(root.size());
				}
				stack.addFirst(new IndentsNode(lastIndents, next));
				if(nextNodes.size() > 1) {
					Indents firstIndents = new Indents(
							subNodeIndent + BinaryTreeNode.LEFT_ELBOW,
							subNodeIndent + BinaryTreeNode.IN_BETWEEN_ELBOWS);
					for(--i; i >= 0; i--) {
						nNode = nextNodes.get(i);
						next = nNode;
						stack.addFirst(new IndentsNode(firstIndents, next));
					}
				}
			}
			if(stack == null) {
				break;
			}
			nextItem = stack.pollFirst();
			if(nextItem == null) {
				break;
			}
			nextNode = nextItem.node;
			Indents nextIndents = nextItem.indents;
			nodeIndent = nextIndents.nodeIndent;
			subNodeIndent = nextIndents.subNodeInd;
		}
		return builder.toString();
	}
	TrieNode<E> addNode(OpResult<E> result, TrieNode<E> fromNode, TrieNode<E> nodeToAdd, boolean withValues) {
		fromNode.matchBitsFromIndex(fromNode.getKey().getPrefixLength(), result);
		TrieNode<E> node = result.existingNode;
		return node == null ? result.inserted : node;
	}
	
	// Note: this method not called from sets or maps, so bounds does not apply
	TrieNode<E> addTrie(TrieNode<E> tree, boolean withValues) {
		CachingIterator<? extends TrieNode<E>, E, TrieNode<E>> iterator = 
				tree.containingFirstAllNodeIterator(true);
		TrieNode<E> toAdd = iterator.next();
		OpResult<E> result = new OpResult<>(toAdd.getKey(), Operation.INSERT);
		TrieNode<E> firstNode;
		TrieNode<E> root = absoluteRoot();
		boolean firstAdded = toAdd.isAdded();
		boolean addedOne = false;
		if(firstAdded) {
			addedOne = true;
			adjustRoot(toAdd.getKey());
			firstNode = addNode(result, root, toAdd, withValues);
		} else {
			firstNode = root;
		}
		TrieNode<E> lastAddedNode = firstNode;
		while(iterator.hasNext()) {
			iterator.cacheWithLowerSubNode(lastAddedNode);
			iterator.cacheWithUpperSubNode(lastAddedNode);
			toAdd = iterator.next();
			TrieNode<E> cachedNode = iterator.getCached();
			if(toAdd.isAdded()) {
				E addrNext = toAdd.getKey();
				if(!addedOne) {
					addedOne = true;
					adjustRoot(addrNext);
				}
				result.addr = addrNext;
				result.existingNode = null;
				result.inserted = null;
				result.setFollowingBits(0);
				lastAddedNode = addNode(result, cachedNode, toAdd, withValues);
			} else {
				lastAddedNode = cachedNode;
			}
		}
		if(!firstAdded) {
			firstNode = getNode(tree.getKey());
		}
		return firstNode;
	}
	@Override
	public TrieNode<E> addTrie(TrieNode<E> trie) {
		return addTrie(trie, false);
	}
	@Override
	public boolean contains(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().contains(addr);
	}
	@Override
	public boolean remove(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().remove(addr);
	}
	
	// The following four methods do not work when there are bounds, 
	// and have counterparts to be used from sets and maps
	@Override
	public TrieNode<E> removeElementsContainedBy(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().removeElementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContainedBy(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContaining(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementsContaining(addr);
	}
	
	@Override
	public E longestPrefixMatch(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatch(addr);
	}
	// only added nodes are added to the linked list
	@Override
	public TrieNode<E> longestPrefixMatchNode(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatchNode(addr);
	}
	@Override
	public E shortestPrefixMatch(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatch(addr);
	}
	@Override
	public TrieNode<E> shortestPrefixMatchNode(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatchNode(addr);
	}
	@Override
	public boolean elementContains(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementContains(addr);
	}
	// Is this subtrie affected by the "reverse" setting?  Well, we are gonna wrap it, so wrap it with the same reverse setting.
	@SuppressWarnings("unchecked")
	AddressTrie<E> elementsContainedByToSubTrie(E addr) {
		// We just construct a subtrie with bounds determined by the prefix block of E, nothing more is needed here
		AddressBounds<E> newBounds;
		E lower = (E) addr.getLower().withoutPrefixLength();
		E upper = (E) addr.getUpper().withoutPrefixLength();
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(lower, true, upper, true, comparator());
		} else {
			newBounds = bounds.intersect(lower, true, upper, true);
		}
		if(newBounds == bounds) {
			return this;
		}
		return createSubTrie(newBounds);
	}
	AddressTrie<E> elementsContainingToTrie(E addr) {
		if(isEmpty()) {
			return this;
		}
		// this creates a completely new linked list of nodes with just the containing elements
		// then create an AddressTrie around then with the same bounds
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return createNew(bounds);
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); // creates the new containing linked list
		if(node == null) {
			return createNew(bounds);
		}
		if (size() == node.size()) {
			return this;
		}
		return createNewSameBoundsFromList(node);
	}
	boolean elementContainsBounds(E addr) {
		if(bounds == null) {
			return elementContains(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return false;
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); // creates the new containing linked list
		if(node == null) {
			return false;
		}
		// Now we need to know if any of the nodes are within the bounds
		return !createNewSameBoundsFromList(node).isEmpty();
	}
	TrieNode<E> smallestElementContainingBounds(E addr) {
		if(bounds == null) {
			return longestPrefixMatchNode(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		TrieNode<E> node = subRoot.longestPrefixMatchNode(addr);
		if(node == null) {
			return null;
		}
		if(!bounds.isInBounds(node.getKey())) {
			node = subRoot.elementsContaining(addr); // creates the new containing linked list
			TrieNode<E> next, lastInBounds = bounds.isInBounds(node.getKey()) ? node : null;
			do {
				if((next = node.getLowerSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				} else if((next = node.getUpperSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				}
			} while(next != null);
			node = lastInBounds;
		}
		return node;
	}
	E longestPrefixMatchBounds(E addr) {
		TrieNode<E> node = smallestElementContainingBounds(addr);
		return node == null ? null : node.getKey();
	}
	// creates a new one-node trie with a new root and the given bounds
	protected abstract AddressTrie<E> createNew(AddressBounds<E> bounds);
	// create a trie with the same root as this one, but different bounds
	protected abstract AddressTrie<E> createSubTrie(AddressBounds<E> bounds);
	private AddressTrie<E> createNewSameBoundsFromList(TrieNode<E> node) {
		AddressTrie<E> newTrie = createNew(bounds);
		TrieNode<E> root = newTrie.absoluteRoot();
		if(node.getKey().equals(root.getKey())) {
			newTrie.root = node;
		} else {
			root.init(node);
		}
		ChangeTracker tracker = root.changeTracker;
		node.changeTracker = tracker;
		TrieNode<E> next = node;
		while(true) {
			TrieNode<E> lower = next.getLowerSubNode();
			if(lower == null) {
				next = next.getUpperSubNode();
				if(next == null) {
					break;
				}
			} else {
				next = lower;
			}
			next.changeTracker = tracker;
		}
		// change tracker needs to be in place before calculating size, which requires an iterator, which uses change tracker
		newTrie.root.size = BinaryTreeNode.SIZE_UNKNOWN;
		newTrie.root.size();
		return newTrie;
	}
	@Override
	public TrieNode<E> getNode(E addr) {
		TrieNode<E> subRoot;
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return null;
			}
			subRoot = getRoot();
			if(subRoot == null) {
				return null;
			}
		} else {
			subRoot = absoluteRoot();
		}
		return subRoot.getNode(addr);
	}
	@Override
	public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
		if(bounds != null) {
			// This cannot work with bounds because we need to find the iterator boundary using ceiling/floor/high/lower,
			// which only work with added nodes.  Other iterators which filter based on the bounds can work.
			// Should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().allNodeIterator(forward);
	}
	/**
	 * Iterates the added nodes in the trie, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeNodeIterator(lowerSubNodeFirst);
		} else {
			iterator = new BlockSizeNodeIterator<E>(
					size(),
					bounds,
					true,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	/**
	 * Iterates all nodes in the trie, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeAllNodeIterator(lowerSubNodeFirst);
		} else { // at this time this is unreachable, we do not call this from set or map
			iterator = new BlockSizeNodeIterator<E>(
					0,
					bounds,
					false,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	/**
	 * Iterates all nodes, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @return
	 */
	public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstIterator(forwardSubNodeOrder);
		} else {
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					true,
					true, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					false,
					true, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		CachingIterator<? extends BinaryTreeNode<E>, E, C> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstAllNodeIterator(forwardSubNodeOrder);
		} else { // at this time this is unreachable, we do not call this from set or map
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, C>(
					bounds,
					true,
					false, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, C>(
					bounds,
					false,
					false, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (CachingIterator<? extends TrieNode<E>, E, C>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, true);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	private Iterator<? extends BinaryTreeNode<E>> containedFirstBoundedIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(forwardSubNodeOrder) {
			BinaryTreeNode<E> startNode = absoluteRoot().firstPostOrderNode();
			iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					true, // forward
					addedNodesOnly, // added only
					startNode,
					null,
					absoluteRoot().changeTracker);
		} else {
			BinaryTreeNode<E> startNode = absoluteRoot().lastPreOrderNode();
			iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					false, // forward
					addedNodesOnly, // added only
					startNode,
					null,
					absoluteRoot().changeTracker);
		}
		return iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstAllNodeIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, false);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public Spliterator<E> spliterator() {
		return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
	}
	@Override
	public Spliterator<E> descendingSpliterator() {
		return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
	}
	@Override
	public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, true);
	}
	@Override
	public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
		if(bounds != null) {
			// This cannot work with bounds because we need to find the iterator boundary using ceiling/floor/high/lower,
			// which only work with added nodes.  Other iterators which filter based on the bounds can work.
			// Should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().nodeSpliterator(forward, false);
	}
	@SuppressWarnings("unchecked")
	Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
		Spliterator<? extends TrieNode<E>> spliterator;
		if(bounds == null) {
			spliterator = absoluteRoot().nodeSpliterator(forward, addedNodesOnly);
		} else {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> split = new NodeSpliterator<E>(
					forward,
					comp,
					getRoot(),
					forward ? firstAddedNode() : lastAddedNode(),
					forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
					size(),
					absoluteRoot().changeTracker,
					addedNodesOnly);
			spliterator = (Spliterator<? extends TrieNode<E>>) split;
		}
		return spliterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().nodeIterator(forward);
		} else {
			iterator = new NodeIterator<E>(
				forward,
				true,
				forward ? firstAddedNode() : lastAddedNode(),
				forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
				absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public TrieNode<E> firstNode() {
		return absoluteRoot().firstNode();
	}
	@Override
	public TrieNode<E> firstAddedNode() {
		if(bounds == null) {
			return absoluteRoot().firstAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isLowerBounded() ?
				(bounds.lowerInclusive ? subRoot.ceilingNodeNoCheck(bounds.lowerBound) : subRoot.higherNodeNoCheck(bounds.lowerBound)) :
					subRoot.firstAddedNode();
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingUpperBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isUpperBounded()) {
			return bounds.upperInclusive ? subRoot.higherNodeNoCheck(bounds.upperBound) : subRoot.ceilingNodeNoCheck(bounds.upperBound);//floorNodeBounded(bounds.lowerBound);
		}
		return subRoot.getParent();
	}
	@Override
	public TrieNode<E> lastNode() {
		return absoluteRoot().lastNode();
	}
	@Override
	public TrieNode<E> lastAddedNode() {
		if(bounds == null) {
			return absoluteRoot().lastAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isUpperBounded() ?
					(bounds.upperInclusive ? 
							subRoot.floorNodeNoCheck(bounds.upperBound) : subRoot.lowerNodeNoCheck(bounds.upperBound)) : 
						subRoot.lastAddedNode();
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingLowerBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isLowerBounded()) {
			return bounds.lowerInclusive ? subRoot.lowerNodeNoCheck(bounds.lowerBound) : subRoot.floorNodeNoCheck(bounds.lowerBound);
		}
		return subRoot.getParent();
	}
	/**
	 * Returns a comparator for the trie order
	 * 
	 * @return
	 */
	public Comparator<E> getComparator() {
		return comparator();
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> comparator() {
		return (Comparator<E>) comparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> nodeComparator() {
		return (TrieComparator<E>) comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> reverseComparator() {
		return (Comparator<E>) reverseComparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> reverseNodeComparator() {
		return (TrieComparator<E>) reverseComparator;
	}
	/**
	 * Returns a java.util.NavigableSet that uses this as the backing data structure.
	 * Added elements of this trie are the elements in the set.
	 * 
	 * @return
	 */
	public AddressTrieSet<E> asSet() {
		AddressTrieSet<E> set = this.set;
		if(set == null) {
			set = new AddressTrieSet<E>(this);
		}
		return set;
	}
	protected TrieNode<E> absoluteRoot() {
		return (TrieNode<E>) root;
	}
	@Override
	public TrieNode<E> getRoot() {
		if(bounds == null) {
			return absoluteRoot();
		}
		if(subRootChange != null && !absoluteRoot().changeTracker.isChangedSince(subRootChange)) {
			// was previously calculated and there has been no change to the trie since then
			return subRoot;
		}
		TrieNode<E> current = absoluteRoot();
		do {
			E currentKey = current.getKey();
			if(bounds.isLowerBounded() && bounds.isBelowLowerBound(currentKey)) {
				current = current.getUpperSubNode();
			} else if(bounds.isUpperBounded() && bounds.isAboveUpperBound(currentKey)) {
				current = current.getLowerSubNode();
			} else {
				// inside the bounds
				break;
			}
		} while(current != null);
		subRootChange = absoluteRoot().changeTracker.getCurrent();
		subRoot = current;
		return current;
	}
	@Override
	public TrieNode<E> lowerAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().lowerAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return lowerNodeBounded(addr);
	}
	private TrieNode<E> lowerNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.lowerNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E lower(E addr) {
		return getNodeKey(lowerAddedNode(addr));
	}
	@Override
	public TrieNode<E> floorAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().floorAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return floorNodeBounded(addr);
	}
	private TrieNode<E> floorNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.floorNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E floor(E addr) {
		return getNodeKey(floorAddedNode(addr));
	}
	@Override
	public TrieNode<E> higherAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().higherAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return higherNodeBounded(addr);
	}
	private TrieNode<E> higherNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.higherNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E higher(E addr) {
		return getNodeKey(higherAddedNode(addr));
	}
	@Override
	public TrieNode<E> ceilingAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().ceilingAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return ceilingNodeBounded(addr);
	}
	private TrieNode<E> ceilingNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.ceilingNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E ceiling(E addr) {
		return getNodeKey(ceilingAddedNode(addr));
	}
	static <E extends Address> E getNodeKey(TrieNode<E> node) {
		return (node == null) ? null : node.getKey();
	}
	@Override
	public void clear() {
		if(bounds == null) {
			super.clear();
		} else {
			Iterator<? extends BinaryTreeNode<E>> iterator = nodeIterator(true);
			while(iterator.hasNext()) {
				BinaryTreeNode<E> node = iterator.next();
				if(bounds.isInBounds(node.getKey())) {
					iterator.remove();
				}
			}
		}
	}
	@Override
	public AddressTrie<E> clone() {
		AddressTrie<E> result = (AddressTrie<E>) super.clone();
		result.set = null;
		if(bounds == null) {
			result.root = getRoot().cloneTree();
		} else {
			TrieNode<E> root = absoluteRoot();
			if(bounds.isInBounds(root.getKey())) {
				result.root = root.cloneTreeBounds(bounds);
			} else {
				// clone the root ourselves, then clone the trie starting from the subroot, and make it a child of the root
				BinaryTreeNode<E> clonedRoot = root.cloneTreeNode(new ChangeTracker()); // clone root node only
				result.root = clonedRoot;
				clonedRoot.setNodeAdded(false); // not in bounds, so not part of new trie
				clonedRoot.setLower(null);
				clonedRoot.setUpper(null);
				TrieNode<E> subRoot = getRoot();
				if(subRoot != null) {
					TrieNode<E> subCloned = subRoot.cloneTreeBounds(bounds);
					if(subCloned != null) {
						result.absoluteRoot().init(subCloned);// attach cloned sub-root to root
					} else {
						clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
					}
				} else {
					clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
				}
			}
			result.bounds = null;
		}
		return result;
	}
	/**
	 * Returns whether the given argument is a trie with a set of nodes that equal the set of nodes in this trie
	 */
	@Override
	public boolean equals(Object o) {
		return o instanceof AddressTrie && super.equals(o);
	}
	@Override
	public String toString() {
		if(bounds == null) {
			return super.toString();
		}
		return toString(true);
	}
	String noBoundsString() { // useful for debugging
		return absoluteRoot().toTreeString(true, true);
	}
	@Override
	public String toString(boolean withNonAddedKeys) {
		if(bounds == null) {
			return super.toString(withNonAddedKeys);
		}
		StringBuilder builder = new StringBuilder("\n");
		printTree(builder, new Indents(), withNonAddedKeys);
		return builder.toString();
	}
	void printTree(StringBuilder builder, Indents indents, boolean withNonAddedKeys) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return;
		}
		subRoot.printTree(builder, indents, withNonAddedKeys, true, 
				this.<Indents>containingFirstAllNodeIterator(true));
	}
	/**
	 * Produces a visual representation of the given tries joined by a single root node, with one node per line.
	 * 
	 * @param withNonAddedKeys
	 * @param tries
	 * @return
	 */
	public static String toString(boolean withNonAddedKeys, AddressTrie<?> ...tries) {
		int totalEntrySize = 0;
		for(int i=0; i < tries.length; i++) {
			totalEntrySize += tries[i].size();
		}
		StringBuilder builder = new StringBuilder(totalEntrySize * 120);
		builder.append('\n').append(BinaryTreeNode.NON_ADDED_NODE_CIRCLE);
		boolean isEmpty = tries == null;
		if(!isEmpty) {
			AddressTrie<?> lastTree = null;
			int lastTreeIndex;
			for(lastTreeIndex = tries.length - 1; lastTreeIndex >= 0; lastTreeIndex--) {
				if(tries[lastTreeIndex] != null) {
					lastTree = tries[lastTreeIndex];
					break;
				}
			}
			isEmpty = lastTree == null;
			if(!isEmpty) {
				int totalSize = lastTree.size();
				for(int i = 0; i < lastTreeIndex; i++) {
					AbstractTree<?> tree = tries[i];
					if(tree != null) {
						totalSize += tree.size();
					}
				}
				if(withNonAddedKeys) {
					builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (").append(totalSize).append(')');
				}
				builder.append('\n');
				for(int i = 0; i < lastTreeIndex; i++) {
					AddressTrie<?> tree = tries[i];
					if(tree != null) {
						tree.printTree(builder, new Indents(BinaryTreeNode.LEFT_ELBOW, BinaryTreeNode.IN_BETWEEN_ELBOWS), withNonAddedKeys);
					}
				}
				lastTree.printTree(builder, new Indents(BinaryTreeNode.RIGHT_ELBOW, BinaryTreeNode.BELOW_ELBOWS), withNonAddedKeys);
			}
		}
		if(isEmpty) {
			if(withNonAddedKeys) {
				builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (0)");
			}
			builder.append('\n');
		}
		return builder.toString();
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6AddressCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
/**
 * An IPv6 address, or a subnet of multiple IPv6 addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * You can construct an IPv6 address from a byte array, from a BigInteger, from a {@link inet.ipaddr.Address.SegmentValueProvider}, 
 * from Inet6Address, from MACAddress, from an {@link IPv6AddressSection} of 8 segments, or from an array of 8  {@link IPv6AddressSegment} objects.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * <p>
 * An IPv6 address can have an associated zone, typically either a network interface name or a positive integer.
 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
 * <ul>
 * <li>They are used with link-local addresses fe80::/10 to distinguish two interfaces to the link-local network, this is known as the zone id.
 * </li><li>They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
 * </li></ul>
 * <p>
 * A zone that consists of a scope id is called a scoped zone.
 * @custom.core
 * @author sfoley
 */
/*
 * rfc 6890 and the earlier 5156 has details on some of the special addresses
 * 
 * For some of the various pre-specified IPv6 address formats (IPv4 mapped, IPv4 translated, IPv4 compatible, etc), 
 * see gestioip.net/docu/ipv6_address_examples.html
 * 
 * A nice summary of IPV6 formats at https://technet.microsoft.com/en-us/library/cc757359(v=ws.10).aspx
 * https://technet.microsoft.com/en-us/library/dd379548(v=ws.10).aspx
 */
public class IPv6Address extends IPAddress implements Iterable<IPv6Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = ':';
	public static final char ZONE_SEPARATOR = '%';
	public static final char ALTERNATIVE_ZONE_SEPARATOR = '\u00a7';//''; javadoc whines about this char 
	public static final char UNC_SEGMENT_SEPARATOR = '-';
	public static final char UNC_ZONE_SEPARATOR = 's';
	public static final char UNC_RANGE_SEPARATOR = ALTERNATIVE_RANGE_SEPARATOR;
	public static final String UNC_RANGE_SEPARATOR_STR = String.valueOf(UNC_RANGE_SEPARATOR);
	public static final String UNC_SUFFIX = ".ipv6-literal.net";
	public static final String REVERSE_DNS_SUFFIX = ".ip6.arpa";
	public static final String REVERSE_DNS_SUFFIX_DEPRECATED = ".ip6.int";
	public static final int BITS_PER_SEGMENT = 16;
	public static final int BYTES_PER_SEGMENT = 2;
	public static final int SEGMENT_COUNT = 8;
	public static final int MIXED_REPLACED_SEGMENT_COUNT = 2; //IPv4Address.BYTE_COUNT / BYTES_PER_SEGMENT;
	public static final int MIXED_ORIGINAL_SEGMENT_COUNT = 6; //SEGMENT_COUNT - MIXED_REPLACED_SEGMENT_COUNT
	public static final int BYTE_COUNT = 16;
	public static final int BIT_COUNT = 128;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int BASE_85_RADIX = 85;
	public static final int MAX_VALUE_PER_SEGMENT = 0xffff;
	/* 
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 and distinguishes two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * 
	 * A zone that consists of a scope id is called a scoped zone.
	 */
	private final IPv6Zone zone;
	/**
	 * A reference to a scope id by number or a network interface by name.
	 * <p>
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 to distinguish two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * <p>
	 * A zone that consists of a scope id is called a scoped zone.
	 * <p>
	 * An IPv6 zone will reference an interface by a scoped identifier number or by interface name based on how it was constructed.
	 * If constructed with a numeric identifier, whether integer or string, it will always reference by scoped identifier.
	 * Otherwise, it will always reference by interface name.
	 * <p>
	 * Once constructed, it will always reference using the same method, either interface name or scope id.  
	 * To reference by the other method you must use a different IPv6Zone instance.
	 * <p>
	 * Even though it will always reference using the same method, 
	 * you can use the IPv6Zone instance to look up the scope id if the instance references by interface name,
	 * or to look up the associated interface if the instance references by scope id.
	 * 
	 * 
	 * @custom.core
	 * @author scfoley
	 *
	 */
	public static class IPv6Zone implements Serializable {
		private static final long serialVersionUID = 1L;
		
		String zoneStr;
		private int scopeId;
		private transient NetworkInterface networkInterface;
		private Boolean referencesInterface;
		
		/**
		 * Constructs a zone that will use the given zone string, 
		 * either a non-negative integer indicating a scope identifier, 
		 * or the name of a network interface.
		 * <p>
		 * A scope identifier is indicated by a sequence of decimal digits.
		 * <p>
		 * To create an InetAddress by pairing this zone with an IPv6Address instance,
		 * an interface name must reference an existing interface, otherwise the InetAddress cannot be created.
		 * <p>
		 * See {@link java.net.NetworkInterface}  to get a list of existing interfaces or to look up interfaces by name.
		 * 
		 * @param zoneStr
		 */
		public IPv6Zone(String zoneStr) {
			if(zoneStr == null) {
				throw new NullPointerException();
			}
			this.zoneStr = zoneStr.trim();
			scopeId = -1;
		}
		
		/**
		 * Constructs a zone that will use a scope identifier with the address.
		 * 
		 * @param scopeId
		 */
		public IPv6Zone(int scopeId) {
			if(scopeId < 0) {
				throw new IllegalArgumentException();
			}
			this.scopeId = scopeId;
			referencesInterface = Boolean.FALSE;
		}
		
		/**
		 * Constructs a zone that will use an interface name with the address.
		 * 
		 * @param networkInterface
		 */
		public IPv6Zone(NetworkInterface networkInterface) {
			if(networkInterface == null) {
				throw new NullPointerException();
			}
			this.networkInterface = networkInterface;
			referencesInterface = Boolean.TRUE;
			scopeId = -1;
			zoneStr = networkInterface.getName();
		}
		
		/**
		 * Whether this zone references a network interface.
		 * 
		 * @return
		 */
		public boolean referencesIntf() {
			if(referencesInterface == null) {
				scopeId = checkIfScope(zoneStr);
				referencesInterface = scopeId < 0;
			}
			return referencesInterface;
		}
		
		/**
		 * Whether this zone references a scope identifier.
		 * 
		 * @return
		 */
		public boolean referencesScopeId() {
			return !referencesIntf();
		}
		/**
		 * If this zone references a network interface, returns that interface, 
		 * or null if no interface with the given name exists on the system.
		 * 
		 * If this zone references a scope id, returns the associated interface.
		 * 
		 * @return
		 */
		public NetworkInterface getAssociatedIntf() {
			try {
				if(referencesIntf()) {
					if(networkInterface == null) {
						networkInterface = NetworkInterface.getByName(zoneStr);
					}
				} else {
					if(networkInterface == null) {
						Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
						top:
						while(interfaces.hasMoreElements()) {
							NetworkInterface nif = interfaces.nextElement();
							Enumeration<InetAddress> addrs = nif.getInetAddresses();
							while(addrs.hasMoreElements()) {
								InetAddress addr = addrs.nextElement();
								if(addr instanceof Inet6Address) {
									Inet6Address inetAddr = (Inet6Address) addr;
									if(inetAddr.getScopeId() == scopeId) {
										networkInterface = nif;
										break top;
									}
								}
							}
						}
					}
				}
			} catch(SocketException e) {}
			return networkInterface;
		}
		
		/**
		 * Returns the MAC address of the associated interface
		 * 
		 * @return
		 */
		public MACAddress getAssociatedIntfMacAddr() {
			NetworkInterface intf = getAssociatedIntf();
			try {
				if(intf != null) {
					byte bytes[] = intf.getHardwareAddress();
					if(bytes != null) {
						return new MACAddress(bytes);
					}
				}
			} catch(SocketException e) {}
			return null;
		}
		/**
		 * If this zone references a scoped identifier, returns that identifier.
		 * <p>
		 * If this zone references a network interface, returns the scope identifier for the addresses of that interface,
		 * or -1 if the referenced interface cannot be found on the system, or no single scope identifier was assigned.
		 * 
		 * @return
		 */
		public int getAssociatedScopeId() {
			if(referencesIntf()) {
				if(scopeId == -1) {
					NetworkInterface nif = getAssociatedIntf();
					if(nif != null) {
						Enumeration<InetAddress> addrs = nif.getInetAddresses();
						int newScopeId = -1;
						while(addrs.hasMoreElements()) {
							InetAddress addr = addrs.nextElement();
							if(addr instanceof Inet6Address) {
								Inet6Address inetAddr = (Inet6Address) addr;
								int sid = inetAddr.getScopeId();
								if(sid != 0) {
									if(newScopeId != -1 && sid != newScopeId) {
										// multiple scope ids for the interface
										newScopeId = -1;
										break;
									}
									newScopeId = sid;
								}
							}
						}
						if(newScopeId != -1) {
							this.scopeId = newScopeId;
						}
					}
				}
			}
			return scopeId;
		}
		
		@Override
		public int hashCode() {
			return toString().hashCode();
		}
		
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6Zone && toString().equals(o.toString());
		}
		
		public String getName() {
			if(zoneStr == null) {
				if(referencesIntf()) {
					zoneStr = networkInterface.getName();
				} else {
					zoneStr = IPv6AddressSegment.toUnsignedString(scopeId, 10,
							new StringBuilder(IPv6AddressSegment.toUnsignedStringLength(scopeId, 10))).toString();
				}
			}
			return zoneStr;
		}
	
		@Override
		public String toString() {
			return getName();
		}
		
		static int checkIfScope(String zoneStr) {
			long digits = 0;
			for(int i = 0, len = zoneStr.length(); i < len; i++) {
				char c = zoneStr.charAt(i);
				int digit = Character.digit(c, 10);
				if(digit < 0) {
					return -1;
				}
				digits = (digits * 10) + digit;
				if(digits > Integer.MAX_VALUE) {
					return -1;
				}
			}
			return (int) digits;
		}
	}
	private transient IPv6StringCache stringCache;
	
	private transient IPv6TrieKeyData cachedTrieKeyData;
	transient IPv6AddressCache addressCache;
	IPv6Address(IPv6AddressSection section, CharSequence zone, boolean checkZone) throws AddressValueException {
		this(section, checkZone ? 
					checkZone(zone) : 
					(zone != null && zone.length() > 0 ? 
							new IPv6Zone(zone.toString()) :
							null));
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * @throws AddressValueException if segment count is not 8 or zone is invalid
	 * @param section
	 * @param zone
	 */
	public IPv6Address(IPv6AddressSection section, IPv6Zone zone) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", section.getSegmentCount());
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
		this.zone = zone;
	}
	
	/**
	 * @deprecated use {@link #IPv6Address(IPv6AddressSection, IPv6Zone)}
	 * @throws AddressValueException if segment count is not 8 or zone is invalid
	 * @param section
	 * @param zone
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSection section, CharSequence zone) throws AddressValueException {
		this(section, zone, true);
	}
	
	public IPv6Address(IPv6AddressSection section) throws AddressValueException {
		this(section, (CharSequence) null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * @throws AddressValueException if segment count is not 8
	 * @param segments the address segments
	 */
	public IPv6Address(IPv6AddressSegment[] segments) throws AddressValueException {
		this(segments, null, null);
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @throws AddressValueException if segment count is not 8
	 * @param segments the address segments
	 * @param networkPrefixLength
	 * @throws AddressValueException if network prefix length invalid
	 */
	public IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, networkPrefixLength, null);
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @deprecated use {@link #IPv6Address(IPv6AddressSegment[], IPv6Zone)}
	 * @param segments the address segments
	 * @param zone the zone or scope id
	 * 
	 * @throws AddressValueException if segment count is not 8 or the zone invalid
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSegment[] segments, CharSequence zone) throws AddressValueException {
		this(segments, checkZone(zone));
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @param segments the address segments
	 * @param zone the zone or scope id
	 * 
	 * @throws AddressValueException if segment count is not 8 or the zone invalid
	 */
	public IPv6Address(IPv6AddressSegment[] segments, IPv6Zone zone) throws AddressValueException {
		this(segments, null, zone);
	}
	private IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(segments, networkPrefixLength));
		if(segments.length != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", segments.length);
		}
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param inet6Address the java.net address object
	 */
	public IPv6Address(Inet6Address inet6Address) {
		this(inet6Address, inet6Address.getAddress(), null, getZone(inet6Address));
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param inet6Address the java.net address object
	 */
	public IPv6Address(Inet6Address inet6Address, Integer networkPrefixLength) {
		this(inet6Address, inet6Address.getAddress(), networkPrefixLength, getZone(inet6Address));
	}
	
	private IPv6Address(Inet6Address inet6Address, byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, 0, bytes.length, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
		getSection().setInetAddress(inet6Address);
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @deprecated use {@link #IPv6Address(byte[], IPv6Zone)}
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @throws AddressValueException if byte range invalid or zone invalid
	 */
	@Deprecated
	public IPv6Address(byte[] bytes, CharSequence zone) throws AddressValueException {
		this(bytes, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @throws AddressValueException if byte range invalid or zone invalid
	 */
	public IPv6Address(byte[] bytes, IPv6Zone zone) throws AddressValueException {
		this(bytes, null, zone);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 */
	public IPv6Address(byte[] bytes) throws AddressValueException {
		this(bytes, null, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * Similar to {@link #IPv6Address(byte[])} except that you can specify the start and end of the address in the given byte array.
	 * @throws AddressValueException if byte range invalid
	 */
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @param networkPrefixLength the CIDR prefix, which can be null for no prefix length
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 */
	public IPv6Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, networkPrefixLength, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * Similar to {@link #IPv6Address(byte[], Integer)} except that you can specify the start and end of the address in the given byte array.
	 */
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
	}
	
	/**
	 * Constructs an IPv6 address.  
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * This means that you can end up with the same address from two different values of BigInteger, one positive and one negative.
	 * For instance, -1 and ffffffffffffffffffffffffffffffff are represented by the two's complement byte arrays [ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] 
	 * and [0,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] respectively.
	 * Both create the address ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
	 * <p>
	 * In fact, the two's complement byte array [ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] can be shortened to [ff], the former being the sign-extension of the latter.
	 * So the byte array [ff] also creates the address ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff.
	 * <p>
	 * When using positive integers you end up with the results you expect, the magnitude of the big integer becomes the address.
	 * <p>
	 * When ranging over all 16-byte arrays and constructing BigInteger from those arrays, you range over all possible addresses.
	 * <p>
	 * @throws AddressValueException if value is outside the range of potential values
	 * @param val must be an IPv6 address value.
	 * @throws AddressValueException if val is invalid
	 */
	public IPv6Address(BigInteger val) throws AddressValueException {
		this(val, null, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address.  
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * 
	 * @param val
	 * @param networkPrefixLength
	 * @throws AddressValueException if val is invalid
	 */
	public IPv6Address(BigInteger val, Integer networkPrefixLength) throws AddressValueException {
		this(val, networkPrefixLength, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * @deprecated use {@link #IPv6Address(BigInteger, IPv6Zone)}
	 * @param val
	 * @param zone
	 * @throws AddressValueException if val is invalid or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(BigInteger val, CharSequence zone) throws AddressValueException {
		this(val, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * @param val
	 * @param zone
	 * @throws AddressValueException if val is invalid or if zone is invalid
	 */
	public IPv6Address(BigInteger val, IPv6Zone zone) throws AddressValueException {
		this(val, null, zone);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @deprecated use {@link #IPv6Address(BigInteger, Integer, IPv6Zone)}
	 * @param val must be an IPv6 address value
	 * @param networkPrefixLength the CIDR prefix length, which can be null for no prefix length
	 * @param zone the zone or scope id
	 * @throws AddressValueException if value is outside the range of potential values, or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(BigInteger val, Integer networkPrefixLength, CharSequence zone) throws AddressValueException {	
		this(val, networkPrefixLength, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param val must be an IPv6 address value
	 * @param networkPrefixLength the CIDR prefix length, which can be null for no prefix length
	 * @param zone the zone or scope id
	 * @throws AddressValueException if value is outside the range of potential values, or if zone is invalid
	 */
	public IPv6Address(BigInteger val, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {	
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSectionInternal(val.toByteArray(), IPv6Address.SEGMENT_COUNT, networkPrefixLength, false));
		this.zone = zone;
	}
	
	private IPv6Address(byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength, zone);
	}
	
	private IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 * 
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 * @throws AddressValueException if zone invalid
	 */
	public IPv6Address(long highBytes, long lowBytes, IPv6Zone zone) throws AddressValueException {
		this(highBytes, lowBytes, null, zone);
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 *
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 */
	public IPv6Address(long highBytes, long lowBytes) throws AddressValueException {
		this(highBytes, lowBytes, null, null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 * @param networkPrefixLength the CIDR prefix, which can be null for no prefix length
	 */
	public IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength) throws AddressValueException {
		this(highBytes, lowBytes, networkPrefixLength, null);
	}
	private IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(highBytes, lowBytes, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, networkPrefixLength, null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * 
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null, null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param valueProvider supplies the 2 byte value for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv6Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * 
	 * @param valueProvider supplies the 2 byte value for each segment
	 */
	public IPv6Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @deprecated use {@link #IPv6Address(Address.SegmentValueProvider, Address.SegmentValueProvider, IPv6Zone)}
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @throws AddressValueException if zone is invalid
	 */
	@Deprecated
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, CharSequence zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @throws AddressValueException if zone is invalid
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, IPv6Zone zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, null, zone);
	}
	
	private IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
		this.zone = zone;
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address section and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied MAC section is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied section is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * If the supplied section neither 6 nor 8 bytes, or if the 8-byte section does not have required EUI-64 format of xx-xx-ff-fe-xx-xx,
	 * {@link IncompatibleAddressException} will be thrown.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * Only the first 8 bytes (4 segments) of the IPv6Address are used to construct the address.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * 
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @param prefix an address from which the first four segments will be used as the same initial segments in the returned address
	 * @param eui
	 */
	public IPv6Address(IPv6Address prefix, MACAddress eui) throws IncompatibleAddressException {
		this(prefix.getSection(), eui.getSection());
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address section and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied MAC section is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied section is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * If the supplied section neither 6 nor 8 bytes, or if the 8-byte section does not have required EUI-64 format of xx-xx-ff-fe-xx-xx,
	 * {@link IncompatibleAddressException} will be thrown.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * The IPv6 address section must be 8 bytes.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the IPv6 section is the wrong size or structure
	 * @param section
	 * @param eui
	 */
	public IPv6Address(IPv6AddressSection section, MACAddress eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui.getSection());
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied address is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied address is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * The IPv6 address section must be 8 bytes.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure
	 * @param section
	 * @param eui
	 */
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * 
	 * @deprecated use {@link #IPv6Address(IPv6AddressSection, MACAddressSection, IPv6Zone)}
	 * @param section
	 * @param eui
	 * @param zone
	 * @throws IncompatibleAddressException  if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure, or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, CharSequence zone) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * 
	 * @param section
	 * @param eui
	 * @param zone
	 * @throws IncompatibleAddressException  if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure, or if zone is invalid
	 */
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, IPv6Zone zone) throws IncompatibleAddressException, AddressValueException  {
		super(thisAddress -> toFullEUI64Section(section, eui, ((IPv6Address) thisAddress).getDefaultCreator(), ((IPv6Address) thisAddress).getMACNetwork().getAddressCreator()));
		this.zone = zone;
	}
	
	static IPv6Zone checkZone(CharSequence zone) throws AddressValueException {
		if(zone == null) {
			return null;
		}
		String zoneStr = zone.toString().trim();
		if(zone.length() == 0) {
			return null;
		}
		int invalidIndex = Validator.validateZone(zoneStr);
		if(invalidIndex >= 0) {
			throw new AddressValueException("ipaddress.error.invalid.zone", invalidIndex);
		}
		return new IPv6Zone(zoneStr);
	}
	IPv6AddressCreator getDefaultCreator() {
		return getNetwork().getAddressCreator();
	}
	IPv6AddressCreator getCreator() {
		IPv6AddressCreator defaultCreator = getDefaultCreator();
		if(!hasZone()) {
			return defaultCreator;
		}
		IPv6AddressCreator creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {// using a lambda for this one results in a big performance hit, so we use anonymous class
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(segments, zone); /* address creation */
			}
			@Override
			public IPv6Address createAddress(IPv6AddressSection section) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(section, zone); /* address creation */
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		return creator;
	}
	private static IPv6Zone getZone(Inet6Address inet6Address) {
		NetworkInterface networkInterface = inet6Address.getScopedInterface();
		if(networkInterface != null) {
			return new IPv6Zone(networkInterface);
		}
		int scopeId = inet6Address.getScopeId();
		if(scopeId != 0) {
			return new IPv6Zone(scopeId);
		}
		return null;
	}
	private static IPv6AddressSection toFullEUI64Section(IPv6AddressSection section, MACAddressSection eui, IPv6AddressCreator creator, MACAddressCreator macCreator) throws AddressValueException, IncompatibleAddressException {
		boolean euiIsExtended = eui.isExtended();
		if(eui.addressSegmentIndex != 0) {
			throw new AddressPositionException(eui, eui.addressSegmentIndex);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section, section.addressSegmentIndex);
		}
		if(section.getSegmentCount() < 4) {
			throw new AddressValueException(section, "ipaddress.mac.error.not.eui.convertible");
		}
		if(eui.getSegmentCount() != (euiIsExtended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(eui, "ipaddress.mac.error.not.eui.convertible");
		}
		IPv6AddressSegment segments[] = creator.createSegmentArray(8);
		section.getSegments(0, 4, segments, 0);
		Integer prefLength = section.getNetworkPrefixLength();
		Integer prefixLength = prefLength != null && (prefLength <= 64) ? prefLength : null;
		toEUI64Segments(segments, 4, eui, 0, eui.isExtended(), creator, macCreator, prefixLength);
		return creator.createSectionInternal(segments);
	}
	
	static IPv6AddressSegment[] toEUI64Segments(
			IPv6AddressSegment segments[],
			int ipv6StartIndex,
			MACAddressSection eui,
			int euiStartIndex,
			boolean isExtended,
			IPv6AddressCreator creator,
			MACAddressCreator macCreator,
			Integer prefixLength) 
					throws IncompatibleAddressException {
		int euiSegmentIndex = 0;
		int euiSegmentCount = eui.getSegmentCount();
		MACAddressSegment seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
		seg0 = (euiStartIndex == 0 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg1 = (euiStartIndex <= 1 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg2 = (euiStartIndex <= 2 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg3 = (euiStartIndex <= 3 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg4 = (euiStartIndex <= 4 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg5 = (euiStartIndex <= 5 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg6 = (euiStartIndex <= 6 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg7 = (euiStartIndex <= 7 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex) : null;
		boolean isNotNull;
		MACAddressSegment zeroSegment = macCreator.createSegment(0);
		MACAddressSegment ffSegment = macCreator.createSegment(0xff);
		MACAddressSegment feSegment = macCreator.createSegment(0xfe);
		Integer currentPrefix = null;
		if(prefixLength != null) {
			//since the prefix comes from the ipv6 section and not the MAC section, any segment prefix for the MAC section is 0 or null
			//prefixes across segments have the pattern: null, null, ..., null, 0-16, 0, 0, ..., 0
			//So if the overall prefix is 0, then the prefix of every segment is 0
			currentPrefix = 0;
		}
		if((isNotNull = (seg0 != null)) || seg1 != null) {
			if(isNotNull) {
				if(seg1 == null) {
					seg1 = zeroSegment;
				}
			} else {
				seg0 = zeroSegment;
			}
			segments[ipv6StartIndex++] = join(creator, seg0, seg1, true /* only this first one gets the flipped bit */, currentPrefix);
		}
		
		//join 2 and 3 
		if(isExtended) {
			if((isNotNull = (seg2 != null)) || seg3 != null) {
				if(!isNotNull) {
					seg2 = zeroSegment;
					if(!seg3.matches(0xff)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
				}
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(!seg4.matches(0xfe)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				}
				segments[ipv6StartIndex++] = join(creator, feSegment, seg5, currentPrefix);
			}
		} else {
			if(seg2 != null) {
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if(seg3 != null) {
				segments[ipv6StartIndex++] = join(creator, feSegment, seg3, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				} else {
					seg4 = zeroSegment;
				}
				segments[ipv6StartIndex++] = join(creator, seg4, seg5, currentPrefix);
			}
		}
		if((isNotNull = (seg6 != null)) || seg7 != null) {
			if(isNotNull) {
				if(seg7 == null) {
					seg7 = zeroSegment;
				}
			} else {
				seg6 = zeroSegment;
			}
			segments[ipv6StartIndex] = join(creator, seg6, seg7, currentPrefix);
		}
		return segments;
	} 
	
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, Integer prefixLength) {
		return join(creator, macSegment0, macSegment1, false, prefixLength);
	}
	
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, boolean flip, Integer prefixLength) {
		if(macSegment0.isMultiple()) {
			// if the high segment has a range, the low segment must match the full range, 
			// otherwise it is not possible to create an equivalent range when joining
			if(!macSegment1.isFullRange()) {
				throw new IncompatibleAddressException(macSegment0, macSegment1, "ipaddress.error.invalidMACIPv6Range");
			}
		}
		int lower0 = macSegment0.getSegmentValue();
		int upper0 = macSegment0.getUpperSegmentValue();
		if(flip) {
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				throw new IncompatibleAddressException(macSegment0, "ipaddress.mac.error.not.eui.convertible");
			}
			lower0 ^= mask2ndBit;//flip the universal/local bit
			upper0 ^= mask2ndBit;
		}
		return creator.createSegment(
				(lower0 << 8) | macSegment1.getSegmentValue(), 
				(upper0 << 8) | macSegment1.getUpperSegmentValue(),
				prefixLength);
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return defaultIpv6Network();
	}
	
	public MACAddressNetwork getMACNetwork() {
		return defaultMACNetwork();
	}
	
	public IPv4AddressNetwork getIPv4Network() {
		return defaultIpv4Network();
	}
	@Override
	public IPv6AddressSection getSection() {
		return (IPv6AddressSection) super.getSection();
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	
	@Override
	public IPv6AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public boolean isEUI64() {
		return getSection().isEUI64();
	}
	public MACAddress toEUI(boolean extended) {
		MACAddressSection section = getSection().toEUI(extended);
		if(section == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return creator.createAddress(section);
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv6StringBuilderOptions.from(options));
	}
	
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv4Address ipv4Addr = getConverted(options);
		if(ipv4Addr != null) {
			IPAddressStringDivisionSeries ipv4Parts[] = ipv4Addr.getParts(options.ipv4ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv4Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv4Parts,  0, parts, tmp.length, ipv4Parts.length);
		}
		return parts;
	}
	
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	
	void cache(IPv6Address lower, IPv6Address upper) {
		if((lower != null || upper != null) && getSection().getSingleLowestOrHighestSection() == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv6AddressCache cache = addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = addressCache;
					boolean create = (cache == null);
					if(create) {
						addressCache = cache = new IPv6AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	private IPv6Address getLowestOrHighest(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection currentSection = getSection();
		IPv6AddressSection sectionResult = currentSection.getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == currentSection) {
			return this;
		} else if(sectionResult == null) {
			return null;
		}
		IPv6Address result = null;
		IPv6AddressCache cache = addressCache;
		if(cache == null || 
			(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addressCache;
				boolean create = (cache == null);
				if(create) {
					addressCache = cache = new IPv6AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	
	@Override
	public IPv6Address getLowerNonZeroHost() {
		return getLowestOrHighest(true, true);
	}
	
	@Override
	public IPv6Address getLower() {
		return getLowestOrHighest(true, false);
	}
	
	@Override
	public IPv6Address getUpper() {
		return getLowestOrHighest(false, false);
	}
	/**
	 * Returns a pair of longs with the lower address value in the range of this individual address or subnet.
	 * The high bits are in the first element, the low bits in the second.
	 * 
	 * @return
	 */
	public long[] longValues() {
		return getSection().longValues();
	}
	/**
	 * Returns a pair of longs with the upper address value in the range of this individual address or subnet.
	 * The high bits are in the first element, the low bits in the second.
	 * 
	 * @return
	 */
	public long[] upperLongValues() {
		return getSection().upperLongValues();
	}
	IPv6TrieKeyData getTrieKeyCache() {
		IPv6TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv6TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			long vals[] = longValues();
			keyData.uint64HighVal = vals[0];
			keyData.uint64LowVal = vals[1];
			if(prefLen != null) {
				int bits = prefLen;
				IPv6Address mask = getNetwork().getNetworkMask(bits, false);
				vals = mask.longValues();
				keyData.mask64HighVal = vals[0];
				keyData.mask64LowVal = vals[1];
				if(bits > 63) {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> (bits - 64);
				} else {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> bits;
				}
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the same number of segments starting at replacementStartIndex from the replacement section
	 * 
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementIndex
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv6Address replace(int startIndex, int endIndex, IPv6Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	/**
	 * Replaces segments starting from startIndex with as many segments as possible from the replacement section
	 * 
	 * @param startIndex
	 * @param replacement
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv6Address replace(int startIndex, IPv6AddressSection replacement) {
		int replacementCount = Math.min(IPv6Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv6Address reverseBits(boolean perByte) {
		return getCreator().createAddress(getSection().reverseBits(perByte));
	}
	@Override
	public IPv6Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv6Address reverseBytesPerSegment() {
		return checkIdentity(getSection().reverseBytesPerSegment());
	}
	@Override
	public IPv6Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getCreator());
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), true);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator() {
		return getSection().prefixIterator(this, getCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getCreator(), segmentCount);
	}
	
	@Override
	public AddressComponentSpliterator<IPv6Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getCreator(), segmentCount);
	}
	
	@Override
	public Stream<IPv6Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6Address> sequentialBlockIterator() {
		return (Iterator<IPv6Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6Address> sequentialBlockStream() {
		return (Stream<IPv6Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		return getSection().iterator(this, getCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> spliterator() {
		return getSection().spliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> nonZeroHostIterator() {
		Predicate<IPv6AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = segments -> getSection().isZeroHost(segments, prefLength);
		}
		return getSection().iterator(this, getCreator(), excludeFunc);
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	public IPv6Address increment(BigInteger increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	
	@Override
	public IPv6Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	/**
	 * If this address is IPv4 convertible, returns that address.
	 * Otherwise, returns null.
	 * <p>
	 * You can also use {@link #isIPv4Convertible()} to determine convertibility.  Both use an instance of {@link IPAddressConverter.DefaultAddressConverter} which uses IPv4-mapped address mappings from rfc 4038.
	 * <p>
	 * Override this method and {@link IPv6Address#isIPv4Convertible()} if you wish to map IPv6 to IPv4 according to the mappings defined by
	 * in {@link IPv6Address#isIPv4Compatible()}, {@link IPv6Address#isIPv4Mapped()}, {@link IPv6Address#is6To4()} or by some other mapping.
	 * <p>
	 * For the reverse mapping, see {@link IPv4Address#toIPv6()} 
	 */
	@Override
	public IPv4Address toIPv4() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv4(this);
	}
	
	@Override
	public IPv6Address toIPv6() {
		return this;
	}
	
	@Override
	public boolean isIPv6() {
		return true;
	}
	
	/**
	 * Determines whether this address can be converted to IPv4. 
	 * Override this method to convert in your own way.
	 * The default behaviour is to use isIPv4Mapped()
	 * 
	 * You should also override {@link #toIPv4()} to match the conversion.
	 * 
	 * @return
	 */
	@Override
	public boolean isIPv4Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv4Convertible(this);
	}
	
	@Override
	public boolean isIPv6Convertible() {
		return true;
	}
	/**
	 * ::ffff:x:x/96 indicates IPv6 address mapped to IPv4
	 */
	public IPv4AddressSection toMappedIPv4Segments() {
		if(isIPv4Mapped()) {
			return getSection().getEmbeddedIPv4AddressSection();
		}
		return null;
	}
	/**
	 * Returns the second and third segments as an {@link IPv4Address}.
	 * 
	 * This can be used for IPv4 or for IPv6 6to4 addresses convertible to IPv4.
	 * 
	 * @return the address
	 */
	public IPv4Address get6To4IPv4Address() {
		return getEmbeddedIPv4Address(2);
	}
	/**
	 * Returns the embedded {@link IPv4Address} in the lowest (least-significant) two segments.
	 * This is used by IPv4-mapped, IPv4-compatible, ISATAP addresses and 6over4 addresses
	 * 
	 * @return the embedded {@link IPv4Address}
	 */
	public IPv4Address getEmbeddedIPv4Address() {
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection()); /* address creation */
	}
	
	/**
	 * Produces an IPv4 address from any sequence of 4 bytes in this IPv6 address.
	 * 
	 * @param byteIndex the byte index to start
	 * @throws IndexOutOfBoundsException if the index is less than zero or bigger than 7
	 * @return
	 */
	public IPv4Address getEmbeddedIPv4Address(int byteIndex) {
		if(byteIndex == IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT * IPv6Address.BYTES_PER_SEGMENT) {
			return getEmbeddedIPv4Address();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection(byteIndex, byteIndex + IPv4Address.BYTE_COUNT)); /* address creation */
	}
	
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			/*
			 [RFC4291][RFC7346]
			 11111111|flgs|scop 
				scope 4 bits
				 1  Interface-Local scope
		         2  Link-Local scope
		         3  Realm-Local scope
		         4  Admin-Local scope
		         5  Site-Local scope
		         8  Organization-Local scope
		         E  Global scope
			 */
			IPv6AddressSegment firstSeg = getSegment(0);
			if(firstSeg.matchesWithMask(8, 0xf)) {
				return true;
			}
			if(firstSeg.getValueCount() <= 5 && 
					(firstSeg.getSegmentValue() & 0xf) >= 1 && (firstSeg.getUpperSegmentValue() & 0xf) <= 5) {
				//all values fall within the range from interface local to site local
				return true;
			}
			
			//source specific multicast
			//rfc4607 and https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml
			//FF3X::8000:0 - FF3X::FFFF:FFFF	Reserved for local host allocation	[RFC4607]
			if(firstSeg.matchesWithPrefixMask(0xff30, 12) && getSegment(6).matchesWithPrefixMask(0x8000, 1)) {
				return true;
			}
		}
		return isLinkLocal() || isSiteLocal() || isUniqueLocal() || isAnyLocal();
	}
	
	/**
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	@Override
	public boolean isLinkLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(2, 0xf)) || // ffx2::/16
				//1111 1110 10 .... fe8x currently only in use
				firstSeg.matchesWithPrefixMask(0xfe80, 10);
	}
	
	/**
	 * @see java.net.InetAddress#isSiteLocalAddress()
	 */
	public boolean isSiteLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(5, 0xf)) ||  // ffx5::/16
				//1111 1110 11 ...
				firstSeg.matchesWithPrefixMask(0xfec0, 10); // deprecated RFC 3879
	}
	
	public boolean isUniqueLocal() {
		//RFC 4193
		return getSegment(0).matchesWithPrefixMask(0xfc00, 7);
	}
	
	/**
	 * Whether the address is IPv4-mapped
	 * 
	 * ::ffff:x:x/96 indicates IPv6 address mapped to IPv4
	 */
	public boolean isIPv4Mapped() {
		//::ffff:x:x/96 indicates IPv6 address mapped to IPv4
		if(getSegment(5).matches(IPv6Address.MAX_VALUE_PER_SEGMENT)) {
			for(int i = 0; i < 5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	
	/**
	 * Whether the address is IPv4-compatible
	 * 
	 * @see java.net.Inet6Address#isIPv4CompatibleAddress()
	 */
	public boolean isIPv4Compatible() {
		return getSegment(0).isZero() && getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() && getSegment(5).isZero();
	}
	
	/**
	 * Whether the address is IPv6 to IPv4 relay
	 * @see #get6To4IPv4Address()
	 */
	public boolean is6To4() {
		//2002::/16
		return getSegment(0).matches(0x2002);
	}
	
	/**
	 * Whether the address is 6over4
	 */
	public boolean is6Over4() {
		return getSegment(0).matches(0xfe80) && 
				getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() &&
				getSegment(5).isZero();
	}
	
	/**
	 * Whether the address is Teredo
	 */
	public boolean isTeredo() {
		//2001::/32
		return getSegment(0).matches(0x2001) && getSegment(1).isZero();
	}
	/**
	 * Whether the address is ISATAP
	 */
	public boolean isIsatap() {
		// 0,1,2,3 is fe80::
		// 4 can be 0200
		return getSegment(0).matches(0xfe80) &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero() &&
				(getSegment(4).isZero() || getSegment(4).matches(0x200)) && 
				getSegment(5).matches(0x5efe);
	}
	
	/**
	 * 
	 * @return Whether the address is IPv4 translatable as in rfc 2765
	 */
	public boolean isIPv4Translatable() { //rfc 2765  
		//::ffff:0:x:x/96 indicates IPv6 addresses translated from IPv4
		return getSegment(4).matches(0xffff) && 
				getSegment(5).isZero() &&
				getSegment(0).isZero() &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero();
	}
	
	/**
	 * Whether the address has the well-known prefix for IPv4 translatable addresses as in rfc 6052 and 6144
	 * @return
	 */
	public boolean isWellKnownIPv4Translatable() { //rfc 6052 rfc 6144
		//64:ff9b::/96 prefix for auto ipv4/ipv6 translation
		if(getSegment(0).matches(0x64) && getSegment(1).matches(0xff9b)) {
			for(int i=2; i<=5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	
	@Override
	public boolean isMulticast() {
		// 11111111...
		return getSegment(0).matchesWithPrefixMask(0xff00, 8);
	}
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	@Override
	public boolean isLoopback() {
		//::1
		int i=0;
		for(; i < getSegmentCount() - 1; i++) {
			if(!getSegment(i).isZero()) {
				return false;
			}
		}
		return getSegment(i).matches(1);
	}
	
	@Override
	public IPv6Address intersect(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6Address otherAddr = convertArg(other);
		IPv6AddressSection section = thisSection.intersect(otherAddr.getSection());
		if(section == null) {
			return null;
		}
		//if they have the same zone, then use it in the intersection, otherwise ignore the zones
		IPv6AddressCreator creator = isSameZone(otherAddr) ? getCreator() : getDefaultCreator();
		IPv6Address result = creator.createAddress(section);
		return result;
	}
	
	@Override
	public IPv6Address[] subtract(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv6Address result[] = new IPv6Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = getCreator().createAddress(sections[i]); /* address creation */
		}
		return result;
	}
	private IPv6Address checkIdentity(IPv6AddressSection newSection) {
		if(newSection == getSection()) {
			return this;
		}
		return getCreator().createAddress(newSection);
	}
	
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength) throws PrefixLenException {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv6Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength() {
		return removePrefixLength(true);
	}
	
	@Override
	public IPv6Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	
	@Override @Deprecated
	public IPv6Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	protected IPv6Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv6Address converted = arg.toIPv6();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	
	@Override
	public IPv6Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv6Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv6Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	
	@Override
	public IPv6Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv6Address toMaxHost() {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	
	@Override
	public IPv6Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	
	@Override
	public IPv6Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv6Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	
	@Override
	public IPv6Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv6Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	
	@Override
	public IPv6Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address getHostMask() {
		return (IPv6Address) super.getHostMask();
	}
	@Override
	public IPv6Address getNetworkMask() {
		return (IPv6Address) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	
	@Override
	public IPv6Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv6Address assignPrefixForSingleBlock() {
		return (IPv6Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6Address assignMinPrefixForBlock() {
		return (IPv6Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return (IPv6Address) IPv6AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv6Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv6AddressSection.coverWithPrefixBlock(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	/**
	 * Produces an array of prefix blocks that cover the same set of addresses as this.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(true);
		return list.toArray(new IPv6Address[list.size()]);
	}
	
	@Override
	public IPv6Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::assignPrefixForSingleBlock,
				IPv6Address::withoutPrefixLength,
				getCreator()::createAddressArray);
	}
	
	/**
	 * Produces an array of blocks that are sequential that cover the same set of addresses as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv6Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6Address[] { withoutPrefixLength().removeZone() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(false);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::withoutPrefixLength,
				getDefaultCreator());
	}
	@Override
	public IPv6AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv6Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]).removeZone();
		}
		converted[0] = removeZone();
		return converted;
	}
	
	@Override
	public IPv6Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		addresses = addresses.clone();
		for(int i = 0; i < addresses.length; i++) {
			addresses[i] = convertArg(addresses[i]).removeZone();
		}
		
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getDefaultCreator());
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getDefaultCreator()::createSequentialBlockAddress;
	}
	/**
	 * Returns whether {@link #getZone()} returns a non-null value
	 * 
	 * @return
	 */
	public boolean hasZone() {
		return zone != null;
	}
	/**
	 * The zone or scope id string, which as a string is typically appended to an address with a '%', eg fe80::71a3:2b00:ddd3:753f%16
	 * 
	 * If there is no zone or scope id, returns null.
	 * <p>
	 * See {@link #getIPv6Zone()}
	 * 
	 * @return
	 */
	public String getZone() {
		return getZoneString();
	}
	/**
	 * Returns a new address with the same address values but with the supplied zone.
	 * If the supplied zone is null, equivalent to calling {@link #removeZone()}
	 * 
	 * @param newZone
	 * @return
	 */
	public IPv6Address setZone(IPv6Zone newZone) {
		if(newZone == null) {
			return removeZone();
		}
		return getDefaultCreator().createAddress(getSection(), newZone); /* address creation */
	}
	
	/**
	 * Returns the zone or scope id, consisting of a network interface name or a positive integer scope identifier.
	 * 
	 * If there is no zone or scope id, returns null
	 * <p>
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 and distinguishes two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * 
	 * A zone that consists of a scope id is called a scoped zone.
	 * 
	 * See {@link #getZone()}
	 * 
	 * @return
	 */
	public IPv6Zone getIPv6Zone() {
		return zone;
	}
	/**
	 * Returns the equivalent address but with no zone.
	 * 
	 * @return
	 */
	public IPv6Address removeZone() {
		if(hasZone()) {
			return getDefaultCreator().createAddress(getSection()); /* address creation */
		}
		return this;
	}
	protected boolean hasNoValueCache() {
		if(addressCache == null) {
			synchronized(this) {
				if(addressCache == null) {
					addressCache = new IPv6AddressCache();
					return true;
				}
			}
		}
		return false;
	}
	
	/**
	 * Converts the lowest value of this address and the associated zone to an Inet6Address. 
	 * <p>
	 * Address with a zone should check for null.
	 * <p>
	 * This will return null if this IPv6 Address has a zone (available from {@link #getIPv6Zone()}),
	 * that zone references a network interface ({@link IPv6Zone#referencesInterface} is true) 
	 * and that network interface (from {@link IPv6Zone#getAssociatedIntf()}) is an IPv4-only interface,
	 * or that interface is not entirely link-local and this address is link-local, 
	 * or that interface is not entirely site-local and this address is site-local.
	 * <p>
	 * This will return null if this IPv6 Address has a zone (available from {@link #getIPv6Zone()}) and:
	 * <ul>
	 * <li>the zone is a scoped id and the address is a global IPv6 address.</li>
	 * <li>the zone specifies an interface that does not exist on this host.</li>
	 * <li>the zone specifies an interface that is IPv4 only.</li>
	 * <li>the zone specifies an interface that is not entirely link-local and this address is link-local.</li>
	 * <li>the zone specifies an interface that is not entirely site-local and this address is site-local.</li>
	 * </ul>
	 * In those cases, the corresponding Java SDK methods such as {@link Inet6Address#getByAddress(String, byte[], NetworkInterface)} 
	 * will throw UnknownHostException when constructed with the same network interface.
	 * <p>
	 * If this address is IPv4-mapped, then any associated zone will be discarded, 
	 * because it is not possible to create an IPv4-mapped Inet6Address with a zone.
	 */
	@Override
	public Inet6Address toInetAddress() {
		if(hasZone()) {
			//we cache the address in here and not in the address section if there is a zone
			Inet6Address result;
			if(hasNoValueCache() || (result = addressCache.inetAddress) == null) {
				addressCache.inetAddress = result = (Inet6Address) toInetAddressImpl();
			}
			return result;
		}
		return (Inet6Address) super.toInetAddress();
	}
	
	@Override
	public Inet6Address toUpperInetAddress() {
		return (Inet6Address) super.toUpperInetAddress();
	}
	@Override
	protected Inet6Address toInetAddressImpl() {
		Inet6Address result;
		byte bytes[] = getSection().getBytesInternal();
		try {
			if(hasZone()) {
				if(zone.referencesScopeId()) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedScopeId());
				} else if(zone.referencesIntf() && zone.getAssociatedIntf() != null) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedIntf());
				} else {
					// When the original zone was provided as a string, we use that here.
					// There is no related function that takes a string as third arg, so we reconstruct the address string.
					//
					// When interface name is not known as an interface on the current host, this throws UnknownHostException
					//
					// We need to drop the prefix, and we also need to use the lower address so no wildcards
					//
					// Note that this call to getLower() assumes we want the lower address.  
					// Since toUpperInetAddress calls getUpper().toInetAddress, this works.
					IPv6Address adjusted = getLower().withoutPrefixLength();
					InetAddress resultIP = InetAddress.getByName(adjusted.toNormalizedString());
					if(resultIP instanceof Inet6Address) {
						result = (Inet6Address) resultIP;
					} else {
						// the InetAddress code is throwing away the interface name because the address is IPv4-mapped
						// so the only way to get an IPv6 address, any address at all in fact, requires that we throw it away
						result = Inet6Address.getByAddress(null, bytes, null);
					}
				}
			} else {
				result = Inet6Address.getByAddress(null, bytes, null);
			}
		} catch(UnknownHostException e) {
			result = null;
		}
		return result;
	}
	
	@Override
	@Deprecated
	public IPv6AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv6AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		IPv6Address thiz = removeZone().withoutPrefixLength();
		return new IPv6AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	
	@Override
	public int hashCode() {
		int result = super.hashCode();
		if(hasZone()) {
			result *= zone.getName().hashCode();
		}
		return result;
	}
	
	@Override
	public boolean isSameAddress(Address other) {
		return other instanceof IPv6Address && super.isSameAddress(other) && isSameZone((IPv6Address) other);
	}
	
	private boolean isSameZone(IPv6Address otherIPv6Address) {
		return Objects.equals(zone, otherIPv6Address.zone);
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet overlaps the given address
	 */
	@Override
	public boolean overlaps(Address other) {
		if(super.overlaps(other)) {
			//must check the zone too
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					//if it has a zone, then it does not overlap addresses from other zones
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet contains the given address
	 */
	@Override
	public boolean contains(Address other) {
		if(super.contains(other)) {
			//must check the zone too
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					//if it has a zone, then it does not contain addresses from other zones
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv6Address) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv6()) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	//////////////// string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getIPv4Network()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().toParams();
	}
	
	private boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					if(hasZone()) {
						stringCache = new IPv6StringCache();
						return true;
					} else {
						//when there is no zone, the section and address strings are the same, so we use the same cache
						IPv6AddressSection section = getSection();
						boolean result = section.hasNoStringCache();
						stringCache = section.getStringCache();
						return result;
					}
				}
			}
		}
		return false;
	}
	
	/**
	 * Produces a string in which the lower 4 bytes are expressed as an IPv4 address and the remaining upper bytes are expressed in IPv6 format.
	 * 
	 * This the mixed IPv6/IPv4 format described in RFC 1884 https://tools.ietf.org/html/rfc1884
	 * 
	 * @return
	 */
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.mixedString) == null) {
			if(hasZone()) {
				stringCache.mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
			} else {
				result = getSection().toMixedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * This produces a canonical string.
	 * 
	 * RFC 5952 describes canonical representations.
	 * http://en.wikipedia.org/wiki/IPv6_address#Recommended_representation_as_text
	 * http://tools.ietf.org/html/rfc5952
	 * 
	 * If this has a prefix length, that will be included in the string.
	 */
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			if(hasZone()) {
				stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
			} else {
				result = getSection().toCanonicalString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			if(hasZone()) {
				stringCache.fullString = result = toNormalizedString(IPv6StringCache.fullParams);
			} else {
				result = getSection().toFullString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 * 
	 * @param lowerValueProvider
	 * @param upperValueProvider
	 * @param prefixLength
	 * @param zone
	 * @param network use {@link #defaultIpv6Network()} if there is no custom network in use
	 * @return
	 */
	public static String toNormalizedString(IPv6AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, zone);
	}
	/**
	 * The normalized string returned by this method is consistent with java.net.Inet6address.
	 * 
	 * IPs are not compressed nor mixed in this representation.  If this has a prefix length, that will be included in the string.
	 */
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedString) == null) {
			if(hasZone()) {
				stringCache.normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
			} else {
				result = getSection().toNormalizedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * This compresses the maximum number of zeros and/or host segments with the IPv6 compression notation '::'
	 */
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedString) == null) {
			if(hasZone()) {
				stringCache.compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
			} else {
				result = getSection().toCompressedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	
	//note this string is used by hashCode
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			if(hasZone()) {
				stringCache.normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
			} else {
				result = getSection().toNormalizedWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * The base 85 string is described by RFC 1924
	 * @return
	 */
	public String toBase85String() throws IncompatibleAddressException {
		//first we see if we obtained this address from a base 85 string
		//in the case of a prefix, applying the prefix changes the value
		IPAddressString originator = getAddressfromString();
		if(originator != null && (!isPrefixed() || getNetworkPrefixLength() == IPv6Address.BIT_COUNT) && 
				originator.isBase85IPv6()) {
			return originator.toString();
		}
		String result;
		if(hasNoStringCache() || (result = stringCache.base85String) == null) {
			if(hasZone()) {
				stringCache.base85String = result = getSection().toBase85String(getZone());
			} else {
				result = getSection().toBase85String();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalWildcardString) == null) {
			if(hasZone()) {
				stringCache.canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
			} else {
				result = getSection().toCanonicalWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedWildcardString) == null) {
			if(hasZone()) {
				stringCache.compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
			} else {
				result = getSection().toCompressedWildcardString();//the cache is shared with the section, so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			if(hasZone()) {
				stringCache.sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
			} else {
				result = getSection().toSQLWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			if(hasZone()) {
				result = getSection().toHexString(with0xPrefix, zone.getName());
				if(with0xPrefix) {
					stringCache.hexStringPrefixed = result;
				} else {
					stringCache.hexString = result;
				}
			} else {
				result = getSection().toHexString(with0xPrefix);//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	private String getZoneString() {
		return hasZone() ? zone.getName() : null;
	}
	
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = stringCache.binaryString) == null) {
			if(hasZone()) {
				result = getSection().toBinaryString(zone.getName());
				stringCache.binaryString = result;
			} else {
				result = getSection().toBinaryString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			if(hasZone()) {
				result = getSection().toSegmentedBinaryString(zone.getName());
				stringCache.segmentedBinaryString = result;
			} else {
				result = getSection().toSegmentedBinaryString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? stringCache.octalStringPrefixed : stringCache.octalString)) == null) {
			if(hasZone()) {
				result = getSection().toOctalString(with0Prefix, zone.getName());
				if(with0Prefix) {
					stringCache.octalStringPrefixed = result;
				} else {
					stringCache.octalString = result;
				}
			} else {
				result = getSection().toOctalString(with0Prefix);//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.networkPrefixLengthString) == null) {
			if(hasZone()) {
				stringCache.networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
			} else {
				result = getSection().toPrefixLengthString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toConvertedString() {
		if(isIPv4Convertible()) {
			return toMixedString();
		}
		return toNormalizedString();
	}
	
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	
	public String toNormalizedString(IPv6StringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	/**
	 * Constructs a string representing this address according to the given parameters
	 * 
	 * @param keepMixed if this address was constructed from a string with mixed representation (a:b:c:d:e:f:1.2.3.4), whether to keep it that way (ignored if makeMixed is true in the params argument)
	 * @param params the parameters for the address string
	 */
	public String toNormalizedString(boolean keepMixed, IPv6StringOptions params) {
		if(keepMixed && fromString != null && getAddressfromString().isMixedIPv6() && !params.makeMixed()) {
			params = new IPv6StringOptions(
					params.base,
					params.expandSegments,
					params.wildcardOption,
					params.wildcards,
					params.segmentStrPrefix,
					true,
					params.ipv4Opts,
					params.compressOptions,
					params.separator,
					params.zoneSeparator,
					params.addrLabel,
					params.addrSuffix,
					params.reverse,
					params.splitDigits,
					params.uppercase);
		}
		return toNormalizedString(params);
	}
	
	@Override
	public String toUNCHostName() {
		String result;
		if(hasNoStringCache() || (result = stringCache.uncString) == null) {
			//it seems for unc hosts we not only replace the zone character % with s and the segment separator : with -,
			//we do the same for any such characters appearing in the zone itself as well
			//see https://blogs.msdn.microsoft.com/oldnewthing/20100915-00/?p=12863/
			String newZone;
			if(hasZone()) {
				newZone = zone.getName().replace(IPv6Address.ZONE_SEPARATOR, IPv6Address.UNC_ZONE_SEPARATOR).replace(IPv6Address.SEGMENT_SEPARATOR, IPv6Address.UNC_SEGMENT_SEPARATOR);
			} else {
				newZone = null;
			}
			stringCache.uncString = result = getSection().toNormalizedString(IPv6StringCache.uncParams, newZone);
		}
		return result;
	}
	
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv6StringBuilderOptions.from(opts));
	}
	private IPv4Address getConverted(IPv6StringBuilderOptions opts) {
		if(!hasZone() && opts.includes(IPv6StringBuilderOptions.IPV4_CONVERSIONS)) {//we cannot convert to ipv4 if there is a zone
			IPv4AddressConverter converter = opts.converter;
			return converter.toIPv4(this);
		}
		return null;
	}
	
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		IPv6StringCollection coll = getSection().toStringCollection(opts, getZoneString());
		IPv4Address ipv4Addr = getConverted(opts);
		if(ipv4Addr != null) {
			IPAddressPartStringCollection ipv4StringCollection = ipv4Addr.toStringCollection(opts.ipv4ConverterOptions);
			coll.addAll(ipv4StringCollection);
		}
		return coll;
	}
	
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public interface IPv6AddressConverter {
		/**
		 * If the given address is IPv6, or can be converted to IPv6, returns that {@link IPv6Address}.  Otherwise, returns null.
		 */
		IPv6Address toIPv6(IPAddress address);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.IPAddressConverter.DefaultAddressConverter;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSection.TriFunction;
import inet.ipaddr.format.IPAddressRange;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * A single IP address, or a subnet of multiple addresses.  Subnets have one or more segments that are a range of values.
 * <p>
 * IPAddress objects are immutable and cannot change values.  This also makes them thread-safe.
 * <p>
 * String creation:<br>
 * There are various methods used to construct standard address string such as {@link #toCanonicalString()} or {@link #toNormalizedString()}
 * <p>
 * There are also several public classes used to create customized IP address strings.
 * For single strings from an address or address section, you use {@link IPStringOptions} or {@link inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions} along with {@link #toNormalizedString(IPAddressSection.IPStringOptions)}.
 * Or you use one of the methods like {@link #toCanonicalString()} which does the same.
 * <p>
 * For string collections from an address or address section, use {@link inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions}, {@link inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions}, {@link IPStringBuilderOptions} along with {@link #toStringCollection(IPAddressSection.IPStringBuilderOptions)} or {@link #toStrings(IPAddressSection.IPStringBuilderOptions)}.
 * Or you use one of the methods {@link #toStandardStringCollection()}, {@link #toAllStringCollection()}, {@link #toStandardStrings()}, {@link #toAllStrings()} which does the same.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * 
 * @custom.core
 * @author sfoley
 * 
 */
/*
 * Internal details of how this works:
 * 
 * 1. Building single strings steps:
 * StringOptions, IPv6StringOptions provides options for a user to specify a single string to be produced for a given address or section of an address.
 *  When calling toNormalizedString, each is mapped to a single IPv4StringParams/IPv6StringParams/StringParams object used to construct the string.
 *  Each IPv4StringParams/IPv6StringParams/StringParams constructs a single string with its toString method
 *  
 * 
 * 2. Building string collection steps:
 *  IPv4StringBuilderOptions, IPv6StringBuilderOptions, IPStringBuilderOptions provides options to create a set of multiple strings from a single IP Address or section of an address.
 * 	toStringCollection constructs a IPv6StringBuilder/IPv4StringBuilder/IPAddressStringBuilder for that address section
 *  The builder translates the options to a series of IPv4StringParams/IPv6StringParams/StringParams in addAllVariations
 *  When the set is being created, it will use each IPv4StringParams/IPv6StringParams/StringParams object to construct each unique string, using their toString method
 * 
 * 
 * Non-public classes:
 * IPv6StringParams, IPv4StringParams and the base classes StringParams and IPAddressPartStringParams: 
 * 	Used by both single string creation or creating collections of strings, these are not public.
 * IPv6StringBuilder/IPv4StringBuilder/IPAddressStringBuilder, used to create collections of strings, are not public either
 *
 */
public abstract class IPAddress extends Address implements IPAddressSegmentSeries, IPAddressRange {
	private static final long serialVersionUID = 4L;
	/**
	 * @author sfoley
	 *
	 */
	public static enum IPVersion {
		IPV4,
		IPV6;
		
		public boolean isIPv4() {
			return this == IPV4;
		}
		
		public boolean isIPv6() {
			return this == IPV6;
		}
		
		@Override
		public String toString() {
			return isIPv4() ? "IPv4" : "IPv6";
		}
	}
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public static interface IPAddressValueProvider extends AddressValueProvider {
		IPVersion getIPVersion();
		
		default Integer getPrefixLength() {
			return null;
		}
		
		default String getZone() {
			return null;
		}
	}
	public static final char PREFIX_LEN_SEPARATOR = '/';
	public static final String BINARY_STR_PREFIX = "0b";
	
	/**
	 * The default way by which addresses are converted, initialized to an instance of {@link DefaultAddressConverter}
	 */
	public static final IPAddressConverter DEFAULT_ADDRESS_CONVERTER = new DefaultAddressConverter();
	
	/* a Host representing the address, which is the one used to construct the address if the address was resolved from a Host.  
	 * Note this is different than if the Host was an address itself, in which case the Host holds a reference to the address
	 * but there is no backwards reference to the Host.
	 */
	HostName fromHost;
	
	/* a Host representing the canonical host for this address */
	private HostName canonicalHost;
	
	/**
	 * Represents an IP address or a set of addresses.
	 * @param section the address segments
	 */
	protected IPAddress(IPAddressSection section) {
		super(section);
	}
	
	protected IPAddress(Function<Address, AddressSection> supplier) {
		super(supplier);
	}
	/**
	 * Generates an IPAddressString object for this IPAddress object.
	 * <p>
	 * This same IPAddress object can be retrieved from the resulting IPAddressString object using {@link IPAddressString#getAddress()}
	 * <p>
	 * In general, users are intended to create IPAddress objects from IPAddressString objects, 
	 * while the reverse direction is generally not all that useful.
	 * <p>
	 * However, the reverse direction can be useful under certain circumstances.
	 * <p>
	 * Not all IPAddressString objects can be converted to IPAddress objects, 
	 * as is the case with IPAddressString objects corresponding to the types IPType.INVALID and IPType.EMPTY.
	 * <p>
	 * Not all IPAddressString objects can be converted to IPAddress objects without specifying the IP version, 
	 * as is the case with IPAddressString objects corresponding to the types IPType.PREFIX and  IPType.ALL.
	 * <p>
	 * So in the event you wish to store a collection of IPAddress objects with a collection of IPAddressString objects,
	 * and not all the IPAddressString objects can be converted to IPAddress objects, then you may wish to use a collection
	 * of only IPAddressString objects, in which case this method is useful.
	 * 
	 * @return an IPAddressString object for this IPAddress.
	 */
	@Override
	public IPAddressString toAddressString() {
		if(fromString == null) {
			IPAddressStringParameters params = createFromStringParams();
			fromString = new IPAddressString(toCanonicalString(), this, params); /* address string creation */
		}
		return getAddressfromString();
	}
	
	protected abstract IPAddressStringParameters createFromStringParams();
	
	protected IPAddressString getAddressfromString() {
		return (IPAddressString) fromString;
	}
	/**
	 * If this address was resolved from a host, returns that host.  Otherwise, does a reverse name lookup.
	 */
	public HostName toHostName() {
		HostName host = fromHost;
		if(host == null) {
			fromHost = host = toCanonicalHostName();
		}
		return host;
	}
	void cache(HostIdentifierString string) {
		if(string instanceof HostName) {
			fromHost = (HostName) string;
			fromString = new IPAddressString(fromHost.toString(), this, fromHost.validationOptions.addressOptions);
		} else if(string instanceof IPAddressString) {
			fromString = (IPAddressString) string;
		}
	}
	protected IPAddressProvider getProvider() {
		if(isPrefixed()) {
			if(getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() || !isPrefixBlock()) {
				return IPAddressProvider.getProviderFor(this, withoutPrefixLength()); 
			}
			return IPAddressProvider.getProviderFor(this, toZeroHost(true).withoutPrefixLength());
		}
		return IPAddressProvider.getProviderFor(this, this);
	}
	
	/**
	 * Does a reverse name lookup to get the canonical host name.
	 * Note that the canonical host name may differ on different systems, as it aligns with {@link InetAddress#getCanonicalHostName()}
	 * In particular, on some systems the loopback address has canonical host localhost and on others the canonical host is the same loopback address.
	 */
	public HostName toCanonicalHostName() {
		HostName host = canonicalHost;
		if(host == null) {
			if(isMultiple()) {
				throw new IncompatibleAddressException(this, "ipaddress.error.unavailable.numeric");
			}
			InetAddress inetAddress = toInetAddress();
			String hostStr = inetAddress.getCanonicalHostName();//note: this does not return ipv6 addresses enclosed in brackets []
			if(hostStr.equals(inetAddress.getHostAddress())) {
				//we got back the address, so the host is me
				host = new HostName(hostStr, new ParsedHost(hostStr, getProvider()));
				host.resolvedAddresses = new IPAddress[] {this};
			} else {
				//the reverse lookup succeeded in finding a host string
				//we might not be the default resolved address for the host, so we don't set that field
				host = new HostName(hostStr);
			}
		}
		return host;
	}
	
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	/**
	 * Returns the address as an address section comprising all segments in the address.
	 * @return
	 */
	@Override
	public IPAddressSection getSection() {
		return (IPAddressSection) super.getSection();
	}
	@Override
	public IPAddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPAddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	/**
	 * Returns all the ways of breaking this address down into segments, as selected.
	 * @return
	 */
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return new IPAddressStringDivisionSeries[] { getSection() };
	}
	
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	
	static int getMaxSegmentValue(IPVersion version) {
		return IPAddressSegment.getMaxSegmentValue(version);
	}
	
	@Override
	public BigInteger getNonZeroHostCount() {
		return getSection().getNonZeroHostCount();
	}
	@Override
	public int getBytesPerSegment() {
		return IPAddressSegment.getByteCount(getIPVersion());
	}
	
	static int getBytesPerSegment(IPVersion version) {
		return IPAddressSegment.getByteCount(version);
	}
	
	@Override
	public int getBitsPerSegment() {
		return IPAddressSegment.getBitCount(getIPVersion());
	}
	
	static int getBitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTE_COUNT : IPv6Address.BYTE_COUNT;
	}
	
	public static int getSegmentCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
	}
	
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT;
	}
	protected abstract IPAddress convertArg(IPAddress arg) throws AddressConversionException;
	
	/**
	 * Finds the lowest and highest single-valued address from the given addresses and subnets and this one,
	 * calling the given BiFunction with the lowest as first argument and the highest as second.
	 * It returns the result returned from the call to the BiFunction.
	 * <p>
	 * For instance, given the IPv4 addresses 1.2.0.0/16 and 1.3.4.5, the lowest is 1.2.0.0 and the highest is 1.3.4.5.
	 * Given the addresses 1.2.0.0/16 and 1.1.4.5, the lowest is 1.1.4.5 and the highest is 1.2.255.255.
	 * <p>
	 * If one of the given addresses or subnets is a different version than this, 
	 * then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * This can be useful for methods that require a range as input, 
	 * like {@link IPAddress#spanWithPrefixBlocks(IPAddress)}, {@link IPAddress#spanWithSequentialBlocks(IPAddress)}, 
	 * {@link IPAddress#coverWithPrefixBlock(IPAddress)}, or {@link IPAddress#toSequentialRange(IPAddress)}.<p>
	 * For instance, to cover multiple addresses with a prefix block:<br><code>
	 * IPAddress coveringAddress = address0.applyToBounds(IPAddress::coverWithPrefixBlock, address1, address2, address3, ...);
	 * </code>
	 */
	public <V> V applyToBounds(BiFunction<? super IPAddress, ? super IPAddress, V> func, IPAddress ...series) {
		AddressComparator lowComparator = Address.ADDRESS_LOW_VALUE_COMPARATOR;
		AddressComparator highComparator = Address.ADDRESS_HIGH_VALUE_COMPARATOR;
		IPAddress lowest = this;
		IPAddress highest = this;
		for(int i = 0; i < series.length; i++) {
			IPAddress next = series[i];
			if(next == null) {
				continue;
			}
			next = convertArg(next);
			if(lowComparator.compare(next, lowest) < 0) {
				lowest = next;
			}
			if(highComparator.compare(next, highest) > 0) {
				highest = next;
			}
		}
		return func.apply(lowest.getLower(), highest.getUpper());
	}
	
	@Override
	public abstract IPAddress getLowerNonZeroHost();
	@Override
	public abstract IPAddress getLower();
	
	@Override
	public abstract IPAddress getUpper();
	
	@Override
	public abstract IPAddress reverseBits(boolean perByte);
	
	@Override
	public abstract IPAddress reverseBytes();
	
	@Override
	public abstract IPAddress reverseBytesPerSegment();
	
	@Override
	public abstract IPAddress reverseSegments();
	
	@Override
	public abstract Iterator<? extends IPAddress> iterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> spliterator();
	@Override
	public abstract Stream<? extends IPAddress> stream();
	@Override
	public abstract Iterator<? extends IPAddress> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddress> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixStream();
		
	@Override
	public abstract Iterator<? extends IPAddress> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixBlockStream();
		
	@Override
	public abstract Iterator<? extends IPAddress> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddress> blockStream(int segmentCount);
	
	@Override
	public Iterator<? extends IPAddress> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddress> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddress> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
		
	@Override
	public BigInteger getSequentialBlockCount() {
		return getSection().getSequentialBlockCount();
	}
	
	/**
	 * @return an object to iterate over the individual addresses represented by this object.
	 */
	@Override
	public abstract Iterable<? extends IPAddress> getIterable();
	@Override
	public abstract IPAddress increment(long increment) throws AddressValueException;
	@Override
	public abstract IPAddress incrementBoundary(long increment) throws AddressValueException;
	
	@Override
	public boolean isIPAddress() {
		return true;
	}
	@Override
	public IPAddress toIPAddress() {
		return this;
	}
	public boolean isIPv4() {
		return false;
	}
	
	public boolean isIPv6(){
		return false;
	}
	
	@Override
	public IPVersion getIPVersion() {
		return getSection().getIPVersion();
	}
	
	/**
	 * If this address is IPv4, or can be converted to IPv4, returns that {@link IPv4Address}.  Otherwise, returns null.
	 * 
	 * @see #isIPv4Convertible()
	 * @return the address
	 */
	public IPv4Address toIPv4() {
		return null;
	}
	
	/**
	 * 
	 * @return If this address is IPv6, or can be converted to IPv6, returns that {@link IPv6Address}.  Otherwise, returns null.
	 * 
	 * @see #isIPv6Convertible()
	 * @return the address
	 */
	public IPv6Address toIPv6() {
		return null;
	}
	/**
	 * Determines whether this address can be converted to IPv4, if not IPv4 already.  
	 * Override this method to convert in your own way.  If IPv6, the default behaviour
	 * is to convert by IPv4 mapping, see {@link IPv6Address#isIPv4Mapped()}
	 * 
	 * You should also override {@link #toIPv4()} to match the conversion.
	 * 
	 * This method returns true for all IPv4 addresses.
	 * 
	 * @return
	 */
	public abstract boolean isIPv4Convertible();
	/**
	 * Determines whether an address can be converted to IPv6, if not IPv6 already. 
	 * Override this method to convert in your own way.  The default behaviour
	 * is to convert by IPv4 mapping, see {@link IPv4Address#getIPv4MappedAddress()}
	 * 
	 * You should also override {@link #toIPv6()} to match the conversion.
	 * 
	 * This method returns true for all IPv6 addresses.
	 * 
	 * @return
	 */
	public abstract boolean isIPv6Convertible();
	
	/**
	 * Returns whether the address is link local, whether unicast or multicast.
	 * 
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	public abstract boolean isLinkLocal();
	/**
	 * Returns true if the address is link local, site local, organization local, administered locally, or unspecified.
	 * This includes both unicast and multicast.
	 */
	@Override
	public abstract boolean isLocal();
	
	/**
	 * The unspecified address is the address that is all zeros.
	 * 
	 * @return
	 */
	public boolean isUnspecified() {
		return isZero();
	}
	
	/**
	 * Returns whether this address is the address which binds to any address on the local host.
	 * This is the address that has the value of 0, aka the unspecified address.
	 * 
	 * @see java.net.InetAddress#isAnyLocalAddress()
	 */
	public boolean isAnyLocal() {
		return isZero();
	}
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	public abstract boolean isLoopback();
	/**
	 * Converts the highest value of this address to an InetAddress.
	 * If this consists of just a single address and not a subnet, this is equivalent to {@link #toInetAddress()}
	 */
	public InetAddress toUpperInetAddress() {
		return getUpper().toInetAddress();
	}
	
	/**
	 * Converts the lowest value of this address to an InetAddress
	 */
	public InetAddress toInetAddress() {
		return getSection().toInetAddress(this);
	}
	protected InetAddress toInetAddressImpl() {
		try {
			return InetAddress.getByAddress(getSection().getBytesInternal());
		} catch(UnknownHostException e) { /* will never reach here */ return null; }
	}
	
	/**
	 * Creates a sequential range instance from the lowest and highest addresses in this subnet
	 * <p>
	 * The two will represent the same set of individual addresses if and only if {@link #isSequential()} is true.
	 * To get a series of ranges that represent the same set of individual addresses use the {@link #sequentialBlockIterator()} (or {@link #prefixIterator()}),
	 * and apply this method to each iterated subnet.
	 * <p>
	 * If this represents just a single address then the returned instance covers just that single address as well.
	 * 
	 * @return
	 */
	@Override
	public abstract IPAddressSeqRange toSequentialRange();
	/**
	 * Creates a sequential range instance from this and the given address, 
	 * spanning from the lowest to the highest addresses in the two subnets
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, create a range from lowest to highest with:<br>
	 * <code>
	 * IPAddressSeqRange range = subnet0.applyToBounds(IPAddress::toSequentialRange, subnet1, subnet2, ...);
	 * </code>
	 * <p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @deprecated use {@link #spanWithRange(IPAddress)}
	 * @param other
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSeqRange toSequentialRange(IPAddress other) throws AddressConversionException;
	
	public boolean matches(IPAddressString otherString) {
		//before converting otherString to an address object, check if the strings match
		if(isFromSameString(otherString)) {
			return true;
		}
		IPAddress otherAddr = otherString.getAddress();
		return otherAddr != null && isSameAddress(otherAddr);
	}
	@Override
	protected boolean isFromSameString(HostIdentifierString other) {
		if(fromString != null && other instanceof IPAddressString) {
			IPAddressString fromString = (IPAddressString) this.fromString;
			IPAddressString otherString = (IPAddressString) other;
			return (fromString == otherString || 
					(fromString.fullAddr.equals(otherString.fullAddr) &&
					// We do not call equals() on the validation options, this is intended as an optimization,
					// and probably better to avoid going through all the validation options here
					fromString.validationOptions == otherString.validationOptions));
		}
		return false;
	}
	
	/**
	 * Returns true if this address overlaps the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddress other) {
		return super.overlaps(other);
	}
	
	/**
	 * Returns true if this address overlaps the given sequential range
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddressSeqRange other) {
		return other.overlaps(this);
	}
	
	/**
	 * Returns whether this contains all values of the given address or subnet
	 * <p>
	 * Implements the same method in {@link IPAddressRange}.
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean contains(IPAddress other) {
		return super.contains(other);
	}
	/**
	 * Returns whether this address contains the non-zero host addresses in the other address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean containsNonZeroHosts(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().containsNonZeroHosts(other.getSection());
	}
	
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * For more details, see the equivalent method {@link #enumerate(Address)}.
	 * This method satisfies the implementation of {@link IPAddressRange}.
	 * 
	 */
	@Override
	public abstract BigInteger enumerate(IPAddress other);
	/**
	 * Returns whether the prefix of this address contains all values of the same bits in the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixContains(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixContains(other.getSection());
	}
	
	/**
	 * Returns whether this address has a prefix length and if so, whether the host section is zero for this address or all addresses in this subnet.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost() {
		return getSection().isZeroHost();
	}
	
	/**
	 * Returns whether the host is zero for the given prefix length for this address or all addresses in this subnet.
	 * If this address already has a prefix length, then that prefix length is ignored.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost(int networkPrefixLength) {
		return getSection().isZeroHost(networkPrefixLength);
	}
	@Override
	public boolean contains(IPAddressSeqRange otherRange) {
		return otherRange.isContainedBy(this);
	}
	/**
	 * Applies the mask to this address and then compares values with the given address
	 * 
	 * @param mask
	 * @param other
	 * @return
	 */
	public boolean matchesWithMask(IPAddress other, IPAddress mask) {
		return getSection().matchesWithMask(other.getSection(), mask.getSection());
	}
	//////////////// string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Allows for the creation of a normalized string without creating a full IP address object first.
	 * Instead you can implement the {@link IPAddressValueProvider} interface in whatever way is most efficient.
	 * The string is appended to the provided {@link StringBuilder} instance.
	 * 
	 * @param provider
	 * @param builder
	 */
	public static void toNormalizedString(IPAddressValueProvider provider, StringBuilder builder) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			toNormalizedString(defaultIpv4Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv4Address.SEGMENT_COUNT,  IPv4Address.BYTES_PER_SEGMENT,  IPv4Address.BITS_PER_SEGMENT,  IPv4Address.MAX_VALUE_PER_SEGMENT,  IPv4Address.SEGMENT_SEPARATOR,  IPv4Address.DEFAULT_TEXTUAL_RADIX, null, builder);
		} else if(version.isIPv6()) {
			toNormalizedString(defaultIpv6Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv6Address.SEGMENT_COUNT, IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT, IPv6Address.MAX_VALUE_PER_SEGMENT, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.DEFAULT_TEXTUAL_RADIX, provider.getZone(), builder);
		} else {
			throw new IllegalArgumentException();
		}
	}
	/**
	 * Allows for the creation of a normalized string without creating a full IP address object first.
	 * Instead you can implement the {@link IPAddressValueProvider} interface in whatever way is most efficient.
	 * 
	 * @param provider
	 */
	public static String toNormalizedString(IPAddressValueProvider provider) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			return IPv4Address.toNormalizedString(defaultIpv4Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength());
		} else if(version.isIPv6()) {
			return IPv6Address.toNormalizedString(defaultIpv6Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), provider.getZone());
		}
		throw new IllegalArgumentException();
	}
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 */
	protected static String toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone) {
		int length = toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				null);
		StringBuilder builder = new StringBuilder(length);
		toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				builder);
		IPAddressSection.checkLengths(length, builder);
		return builder.toString();
	}
	protected static int toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone,
			StringBuilder builder) {
		int segmentIndex, count;
		segmentIndex = count = 0;
		boolean adjustByPrefixLength;
		if(prefixLength != null && prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			if(prefixLength <= 0) {
				adjustByPrefixLength = true;
			} else {
				int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
				adjustByPrefixLength = prefixLength < totalBitCount;
			}
		} else {
			adjustByPrefixLength = false;
		}
		while(true) {
			Integer segmentPrefixLength = IPAddressSection.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(adjustByPrefixLength && segmentPrefixLength != null && segmentPrefixLength == 0) {
				if(builder == null) {
					count++;
				} else {
					builder.append('0');
				}
			} else {
				int value = 0, value2 = 0;
				if(lowerValueProvider == null) {
					value = upperValueProvider.getValue(segmentIndex);
				} else {
					value = lowerValueProvider.getValue(segmentIndex);
					if(upperValueProvider != null) {
						value2 = upperValueProvider.getValue(segmentIndex);
					}
				}
				if(lowerValueProvider == null || upperValueProvider == null) {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						value &= ~0 << (bitsPerSegment - segmentPrefixLength);
					}
					if(builder == null) {
						count += IPAddressSegment.toUnsignedStringLength(value, radix);
					} else {
						IPAddressSegment.toUnsignedString(value, radix, builder);
					}
				} else {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						int mask = ~0 << (bitsPerSegment - segmentPrefixLength);
						value &= mask;
						value2 &= mask;//255, mask is -2147483648, segmentPrefixLength is 7, bitsPer
					}
					if(value == value2) {
						if(builder == null) {
							count += IPAddressSegment.toUnsignedStringLength(value, radix);
						} else {
							IPAddressSegment.toUnsignedString(value, radix, builder);
						}
					} else {
						if(value > value2) {
							int tmp = value2;
							value2 = value;
							value = tmp;
						} 
						if(value == 0 && value2 == segmentMaxValue) {
							if(builder == null) {
								count += IPAddress.SEGMENT_WILDCARD_STR.length();
							} else {
								builder.append(IPAddress.SEGMENT_WILDCARD_STR);
							}
						} else {
							if(builder == null) {
								count += IPAddressSegment.toUnsignedStringLength(value, radix) + 
										IPAddressSegment.toUnsignedStringLength(value2, radix) + 
										IPAddress.RANGE_SEPARATOR_STR.length();
							} else {
								IPAddressSegment.toUnsignedString(value2, radix, IPAddressSegment.toUnsignedString(value, radix, builder).append(IPAddress.RANGE_SEPARATOR_STR));
							}
						}
					}
				}
			}
			if(++segmentIndex >= segmentCount) {
				break;
			}
			if(builder != null) {
				builder.append(separator);
			} // else counting the separators happens just once outside the loop, just below
		}
		if(builder == null) {
			count += segmentCount; // separators
			--count; // no ending separator
		}
		if(zone != null && zone.length() > 0) {
			if(builder == null) {
				count += zone.length() + 1;
			} else {
				builder.append(IPv6Address.ZONE_SEPARATOR).append(zone);
			}
		}
		if(prefixLength != null) {
			if(builder == null) {
				count += IPAddressSegment.toUnsignedStringLength(prefixLength, 10) + 1;
			} else {
				builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(prefixLength);
			}
		} 
		return count;
	}
	
	/**
	 * This produces a string with no compressed segments and all segments of full length,
	 * which is 4 characters for IPv6 segments and 3 characters for IPv4 segments.
	 * 
	 * Each address has a unique full string, not counting CIDR the prefix, which can give two equal addresses different strings.
	 */
	@Override
	public String toFullString() {
		return getSection().toFullString();
	}
	
	protected void cacheNormalizedString(String str) {
		getSection().cacheNormalizedString(str);
	}
	
	/**
	 * Produces a consistent subnet string that looks like 1.2.*.* or 1:2::/16
	 * 
	 * In the case of IPv4, this means that wildcards are used instead of a network prefix when a network prefix has been supplied.
	 * In the case of IPv6, when a network prefix has been supplied, the prefix will be shown and the host section will be compressed with ::.
	 */
	@Override
	public String toSubnetString() {
		return getSection().toSubnetString();
	}
	
	/**
	 * This produces a string similar to the normalized string but avoids the CIDR prefix.
	 * CIDR addresses will be shown with wildcards and ranges instead of using the CIDR prefix notation.
	 */
	@Override
	public String toNormalizedWildcardString() {
		return getSection().toNormalizedWildcardString();
	}
	
	/**
	 * This produces a string similar to the canonical string but avoids the CIDR prefix.
	 * Addresses with a network prefix length will be shown with wildcards and ranges instead of using the CIDR prefix length notation.
	 * IPv6 addresses will be compressed according to the canonical representation.
	 */
	@Override
	public String toCanonicalWildcardString() {
		return getSection().toCanonicalWildcardString();
	}
	
	/**
	 * This is similar to toNormalizedWildcardString, avoiding the CIDR prefix, but with compression as well.
	 */
	@Override
	public String toCompressedWildcardString() {
		return getSection().toCompressedWildcardString();
	}
	
	
	/**
	 * This is the same as the string from toNormalizedWildcardString except that 
	 * it uses {@link IPAddress#SEGMENT_SQL_WILDCARD} instead of {@link IPAddress#SEGMENT_WILDCARD} and also uses {@link IPAddress#SEGMENT_SQL_SINGLE_WILDCARD}
	 */
	@Override
	public String toSQLWildcardString() {
		 return getSection().toSQLWildcardString();
	}
	
	/**
	 * Returns a string with a CIDR network prefix length if this address has a network prefix length.
	 * For IPv6, the host section will be compressed with ::, for IPv4 the host section will be zeros.
	 * @return
	 */
	@Override
	public String toPrefixLengthString() {
		return getSection().toPrefixLengthString();
	}
	
	/**
	 * Returns a mixed string if it represents a convertible IPv4 address, returns the normalized string otherwise.
	 * @return
	 */
	public String toConvertedString() {
		return toNormalizedString();
	}
	
	/**
	 * Generates the Microsoft UNC path component for this address
	 * 
	 * @return
	 */
	public abstract String toUNCHostName();
	
	/**
	 * Generates the reverse DNS lookup string<p>
	 * For 8.255.4.4 it is 4.4.255.8.in-addr.arpa<br>
	 * For 2001:db8::567:89ab it is b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa
	 * 
	 *
	 * @throws IncompatibleAddressException if this address is a subnet
	 * @return
	 */
	@Override
	public String toReverseDNSLookupString() {
		return getSection().toReverseDNSLookupString();
	}
	
	/**
	 * Writes this address as a single binary value with always the exact same number of characters
	 * <p>
	 * If this section represents a range of values not corresponding to a prefix, then this is printed as a range of two hex values.
	 */
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		return getSection().toBinaryString();
	}
	
	/**
	 * Writes this address as a single octal value with always the exact same number of characters, with or without a preceding 0 prefix.
	 * <p>
	 * If this section represents a range of values not corresponding to a prefix, then this is printed as a range of two hex values.
	 */
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		return getSection().toOctalString(with0Prefix);
	}
	
	/**
	 * Constructs a string representing this address according to the given parameters
	 * 
	 * @throws IncompatibleAddressException for cases in which the requested string cannot be produced, which can generally only occur with specific strings from specific subnets.
	 * 
	 * @param params the parameters for the address string
	 */
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params);
	}
	
	/**
	 * Returns at most a few dozen string representations:
	 * 
	 * -mixed (1:2:3:4:5:6:1.2.3.4)
	 * -full compressions (a:0:b:c:d:0:e:f or a::b:c:d:0:e:f or a:0:b:c:d::e:f)
	 * -full leading zeros (000a:0000:000b:000c:000d:0000:000e:000f)
	 * -all uppercase and all lowercase (a::a can be A::A)
	 * -combinations thereof
	 * 
	 * @return
	 */
	public String[] toStandardStrings() {
		return toStandardStringCollection().toStrings();
	}
	
	/**
	 * Produces almost all possible string variations
	 * <p>
	 * Use this method with care...  a single IPv6 address can have thousands of string representations.
	 * <p>
	 * Examples:
	 * <ul>
	 * <li>"::" has 1297 such variations, but only 9 are considered standard</li>
	 * <li>"a:b:c:0:d:e:f:1" has 1920 variations, but only 12 are standard</li>
	 * </ul>
	 * <p>
	 * Variations included in this method:
	 * <ul>
	 * <li>all standard variations from {@link #toStandardStrings()}</li>
	 * <li>adding a variable number of leading zeros (::a can be ::0a, ::00a, ::000a)</li>
	 * <li>choosing any number of zero-segments to compress (:: can be 0:0:0::0:0)</li>
	 * <li>mixed representation of all variations (1:2:3:4:5:6:1.2.3.4)</li>
	 * <li>all uppercase and all lowercase (a::a can be A::A)</li>
	 * <li>all combinations of such variations</li>
	 * </ul>
	 * Variations omitted from this method: mixed case of a-f, which you can easily handle yourself with String.equalsIgnoreCase
	 * <p>
	 * @return the strings
	 */
	public String[] toAllStrings() {
		return toAllStringCollection().toStrings();
	}
	
	/**
	 * Rather than using toAllStrings or StandardStrings, 
	 * you can use this method to customize the list of strings produced for this address
	 */
	public String[] toStrings(IPStringBuilderOptions options) {
		return toStringCollection(options).toStrings();
	}
	
	public IPAddressPartStringCollection toStandardStringCollection() {
		return getSection().toStandardStringCollection();
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return getSection().toAllStringCollection();
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return getSection().toStringCollection(options);
	}
	
	public static String toDelimitedSQLStrs(String strs[]) {
		if(strs.length == 0) {
			return "";
		}
		StringBuilder builder = new StringBuilder();
		for(String str : strs) {
			builder.append('\'').append(str).append('\'').append(',');
		}
		return builder.substring(0, builder.length() - 1);
	}
	
	///////////////////// masks and subnets below ///////////////////////
	
	@Override
	public Integer getNetworkPrefixLength() {
		return getSection().getNetworkPrefixLength();
	}
	@Override
	public IPAddress getHostMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLength == null ? 0 : prefLength);
	}
	@Override
	public IPAddress getNetworkMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLength == null ? getBitCount() : prefLength);
	}
	
	@Override
	public boolean includesZeroHost() {
		return getSection().includesZeroHost();
	}
	
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		return getSection().includesZeroHost(networkPrefixLength);
	}
	@Override
	public abstract IPAddress toZeroHost(int prefixLength);
	@Override
	public abstract IPAddress toZeroHost();
	
	protected abstract IPAddress toZeroHost(boolean boundariesOnly);
	
	@Override
	public abstract IPAddress toZeroNetwork();
	
	@Override
	public abstract IPAddress toMaxHost(int prefixLength);
	
	@Override
	public abstract IPAddress toMaxHost();
	
	@Override
	public boolean includesMaxHost() {
		return getSection().includesMaxHost();
	}
	
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		return getSection().includesMaxHost(networkPrefixLength);
	}
	
	/** 
	 * Returns true if the network section of the address spans just a single value 
	 * <p>
	 * For example, return true for 1.2.3.4/16 and false for 1.2-3.3.4/16
	 */
	public boolean isSingleNetwork() {
		return getSection().isSingleNetwork();
	}
	/**
	 * Returns the smallest set of prefix blocks that spans both this and the supplied address or subnet.
	 * @param other
	 * @return
	 */
	protected static <T extends IPAddress> T[] getSpanningPrefixBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixAdder,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = 
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, one, two) -> IPAddressSection.splitIntoPrefixBlocks(one, two));
		return blocks.toArray(arrayProducer.apply(blocks.size()));
	}
	
	private static <T extends IPAddress> T checkPrefixBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixAdder) {
		if(first.contains(other)) {
			return checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	
	static <T extends IPAddressSegmentSeries> T checkPrefixBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixAdder) {
		T result = null;
		if(container.isPrefixed() && container.isSinglePrefixBlock()) {
			result = container;
		} else if(checkEqual && contained.isPrefixed() && container.isMore(contained) == 0 && contained.isSinglePrefixBlock()) {
			result = contained;
		} else {
			result = prefixAdder.apply(container); // the functor is assignPrefixForSingleBlock, which returns null if cannot be a prefix block
		}
		return result;
	}
	
	protected static <T extends IPAddress, S extends IPAddressSegment> T[] getSpanningSequentialBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixRemover,
			IPAddressCreator<T, ?, ?, S, ?> creator) {
		T[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createAddressArray);
		if(result != null) {
			return result;
		}
		SeriesCreator seriesCreator = creator::createSequentialBlockAddress;
		TriFunction<T, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, seriesCreator);
		List<IPAddressSegmentSeries> blocks = IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createAddressArray(blocks.size()));
	}
	
	private static <T extends IPAddress> T[] checkSequentialBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		if(first.contains(other)) {
			return checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	
	static <T extends IPAddressSegmentSeries> T[] checkSequentialBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = null;
		if(!container.isPrefixed()) {
			if(container.isSequential()) {
				result = container;
			}
		} else if(checkEqual && !contained.isPrefixed() && container.equals(contained)) {
			if(contained.isSequential()) {
				result = contained;
			}
		} else if(container.isSequential()) {
			result = prefixRemover.apply(container);
		}
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		return null;
	}
	/**
	 * Returns the subnet associated with the prefix length of this address.  If this address has no prefix length, this address is returned.
	 * <p>
	 * For example, if the address is 1.2.3.4/16 it returns the subnet 1.2.*.* /16
	 */
	@Override
	public abstract IPAddress toPrefixBlock();
	@Override
	public abstract IPAddress toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	/**
	 * Returns the equivalent CIDR address with a prefix length for which the address subnet block matches the range of values in this address.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * 
	 * Examples:<br>
	 * 1.2.3.4 returns 1.2.3.4/32<br>
	 * 1.2.*.* returns 1.2.0.0/16<br>
	 * 1.2.*.0/24 returns 1.2.0.0/16 <br>
	 * 1.2.*.4 returns null<br>
	 * 1.2.252-255.* returns 1.2.252.0/22<br>
	 * 1.2.3.4/x returns the same address<br>
	 * 
	 * @return
	 */
	@Override
	public IPAddress assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		return newPrefix == null ? null : setPrefixLength(newPrefix, false);
	}
	/**
	 * Constructs an equivalent address with the smallest CIDR prefix possible (largest network),
	 * such that the range of values are a set of subnet blocks for that prefix.
	 * 
	 * @return
	 */
	@Override
	public IPAddress assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	/**
	 * If this address is equivalent to the mask for a CIDR prefix block, it returns that prefix length.
	 * Otherwise, it returns null.
	 * A CIDR network mask is all 1 bits in the network section and then all 0 bits in the host section.
	 * A CIDR host mask is all 0 bits in the network section and then all 1 bits in the host section.
	 * The prefix is the length of the network section.
	 * <p>
	 * Also, keep in mind that the prefix length returned by this method is not equivalent to the prefix length used to construct this object.
	 * The prefix length used to construct indicates the network and host section of this address.  
	 * The prefix length returned here indicates the whether the value of this address can be used as a mask for the network and host
	 * section of any other address.  Therefore the two values can be different values, or one can be null while the other is not.
	 * <p>
	 * Just like the mask methods which use the lower value for masking,
	 * this method applies only to the lower value of the range if this address represents multiple values.
	 *
	 * @param network whether to check if we are a network mask or a host mask
	 * @return the prefix length corresponding to this mask, or null if there is no such prefix length
	 */
	public Integer getBlockMaskPrefixLength(boolean network) {
		return getSection().getBlockMaskPrefixLength(network);
	}
	/**
	 * Returns the number of consecutive trailing one or zero bits.
	 * If network is true, returns the number of consecutive trailing zero bits.
	 * Otherwise, returns the number of consecutive trailing one bits.
	 * <p>
	 * This method applies only to the lower value of the range if this address represents multiple values.
	 * 
	 * @param network
	 * @return
	 */
	public int getTrailingBitCount(boolean network) {
		return getSection().getTrailingBitCount(network);
	}
	
	/**
	 * Returns the number of consecutive leading one or zero bits.
	 * If network is true, returns the number of consecutive leading one bits.
	 * Otherwise, returns the number of consecutive leading zero bits.
	 * <p>
	 * This method applies only to the lower value of the range if this address represents multiple values.
	 * 
	 * @param network
	 * @return
	 */
	public int getLeadingBitCount(boolean network) {
		return getSection().getLeadingBitCount(network);
	}
	
	/**
	 * Returns the minimal-size prefix block that covers all the addresses spanning from this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, cover with:<br>
	 * <code>
	 * IPAddress block = subnet0.applyToBounds(IPAddress::coverWithPrefixBlock, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 */
	public abstract IPAddress coverWithPrefixBlock(IPAddress other) throws AddressConversionException;
	/**
	 * Produces the list of prefix block subnets that span from this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * From the list of returned subnets you can recover the original range (this to other) by converting each to IPAddressRange with {@link IPAddress#toSequentialRange()}
	 * and them joining them into a single range with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddress blocks[] = subnet0.applyToBounds(IPAddress::spanWithPrefixBlocks, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddress[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException;
	
	/**
	 * Produces a list of sequential block subnets that span all values from this subnet to the given subnet.
	 * The span will cover the sequence of all addresses from the lowest address in both subnets to the highest address in both subnets.
	 * <p>
	 * Individual block subnets come in the form 1-3.1-4.5.6-8, however that particular subnet is not sequential since address 1.1.5.8 is in the subnet,
	 * the next sequential address 1.1.5.9 is not in the subnet, and a higher address 1.2.5.6 is in the subnet.
	 * Blocks are sequential when the first segment with a range of values is followed by segments that span all values.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * From the list of returned subnets you can recover the original range (this and other) by converting each to IPAddressRange with {@link IPAddress#toSequentialRange()}
	 * and them joining them into a single range with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddress blocks[] = subnet0.applyToBounds(IPAddress::spanWithSequentialBlocks, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddress[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException;
	
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return spanWithBlocks(this, prefixBlocks);
	}
	
	static List<? extends IPAddressSegmentSeries> spanWithBlocks(IPAddressSegmentSeries orig, boolean prefixBlocks) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<IPAddressSegmentSeries>();
		Iterator<? extends IPAddressSegmentSeries> iterator = orig.sequentialBlockIterator();
		while(iterator.hasNext()) {
			IPAddressSegmentSeries sequential = iterator.next();
			if(prefixBlocks) {
				Collections.addAll(list, sequential.spanWithPrefixBlocks());	
			} else {
				Collections.addAll(list, sequential);
			}
		}
		return list;
	}
	
	/**
	 * Produces an IPAddressRange instance that spans this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddressSeqRange range = subnet0.applyToBounds(IPAddress::spanWithRange, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException;
	
	/**
	 * Merges this with the list of addresses to produce the smallest list of prefix blocks.
	 * <p>
	 * For the smallest list of subnets use {@link #mergeToSequentialBlocks(IPAddress...)}.
	 * <p>
	 * If any other address in the list is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()},
	 * which can result in AddressConversionException
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * <p>
	 * The merging process works with sequential blocks.  
	 * CIDR prefix subnets have just a single sequential block, as does individual addresses.  
	 * So this method works efficiently for most conventionally-used subnets.
	 * <p>
	 * For example, the subnet ::*:*:*:1-ffff has 281474976710656 sequential blocks.
	 * Just like you should avoid iterating through such a large number of blocks, 
	 * you should avoid using this method to merge such a subnet, 
	 * rather than a subnet like ::1-ffff:*:*:*:* which has 1 sequential block, 
	 * or the subnet ::1-ffff:1-ffff:*:*:*:* which has 65535 sequential blocks.
	 * You can use {@link #getSequentialBlockCount()} to get the sequential block count.
	 * <p>
	 * There are alternatives ways to merge into prefix blocks available in this library.
	 * Typically this method is most efficient when merging CIDR prefix blocks and/or individual addresses,
	 * which is likely to be the case for most users most of the time.  
	 * It converts to CIDR prefix blocks prior to merging, if not CIDR prefix blocks or individual addresses already.
	 * <p>
	 * When merging a large number of blocks that are not prefix blocks nor individual addresses, 
	 * it may be more efficient to merge first and then convert to CIDR prefix blocks afterwards.
	 * You can use {@link #mergeToSequentialBlocks(IPAddress...)} to merge, 
	 * and then span each merged element in the result with {@link #spanWithPrefixBlocks()},
	 * giving the same result as this method.
	 * <p>
	 * Sequential ranges provide another option.
	 * You can convert to sequential blocks first with {@link #sequentialBlockIterator()}, 
	 * then convert each sequential block to {@link IPAddressSeqRange} with {@link #toSequentialRange()}, 
	 * then join those sequential ranges with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}, 
	 * then convert them to CIDR prefix blocks with {@link IPAddressSeqRange#spanWithPrefixBlocks()},
	 * giving the same result as this method.
	 * <p>
	 * 
	 * @throws AddressConversionException
	 * @param addresses the addresses to merge with this
	 * @return
	 */
	public abstract IPAddress[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		return IPAddressSection.getMergedPrefixBlocks(sections);
	}
	private static final IPv6Address EMPTY_IPV6_ADDRESS[] = {};
	private static final IPv4Address EMPTY_IPV4_ADDRESS[] = {};
	public static class DualIPv4Pv6Arrays {
		public final IPv4Address addressesIPv4[];
		public final IPv6Address addressesIPv6[];
		
		DualIPv4Pv6Arrays(IPv4Address addressesIPv4[], IPv6Address addressesIPv6[]) {
			this.addressesIPv4 = addressesIPv4;
			this.addressesIPv6 = addressesIPv6;
		}
	}
	/**
	 * merges the given set of IP addresses and subnets into a minimal number of prefix blocks.
	 * 
	 * This function complements the MergeToPrefixBlock methods of each IP address type.
	 * Those instance methods attempt to convert arguments that do not match the IP version of the method receiver, while this function does not.
	 * This static method merges every non-null argument into one of the two returned slices.
	 * 
	 * @param addresses
	 * @return
	 */
	public static DualIPv4Pv6Arrays mergeToDualSequentialBlocks(IPAddress ...addresses) {
		Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger = (series) -> {
			SeriesCreator seriesCreator = ((IPAddress) series[0]).getSequentialSeriesCreator();
			return IPAddressSection.getMergedSequentialBlocks(series, seriesCreator);
		};
		return mergeToBlocks(addresses, merger);
	}
	
	protected abstract SeriesCreator getSequentialSeriesCreator();
	
	/**
	 * merges the given set of IP addresses and subnets into a minimal number of prefix blocks.
	 * 
	 * This function complements the MergeToPrefixBlock methods of each IP address type.
	 * Those instance methods attempt to convert arguments that do not match the IP version of the method receiver, while this function does not.
	 * This static method merges every non-null argument into one of the two returned slices.
	 * 
	 * @param addresses
	 * @return
	 */
	public static DualIPv4Pv6Arrays mergeToDualPrefixBlocks(IPAddress ...addresses) {
		return mergeToBlocks(addresses, IPAddressSection::getMergedPrefixBlocks);
	}
	
	private static DualIPv4Pv6Arrays mergeToBlocks(
			IPAddress addresses[], 
			Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger) {
		ArrayList<IPAddress> ipv4List = null;
		ArrayList<IPAddress> ipv6List = null;
		for(int i = 0; i < addresses.length; i++) {
			IPAddress addr = addresses[i];
			if(addr != null) {
				if(addr.isIPv4()) {
					if(ipv4List == null) {
						ipv4List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv4List.add(addr);
				} else if(addr.isIPv6()) {
					if(ipv6List == null) {
						ipv6List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv6List.add(addr);
				}
			}
		}
		IPv4Address addressesIPv4[];
		if(ipv4List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv4List.toArray(new IPAddressSegmentSeries[ipv4List.size()]));
			addressesIPv4 = blocks.toArray(new IPv4Address[blocks.size()]);
		} else {
			addressesIPv4 = EMPTY_IPV4_ADDRESS;
		}
		IPv6Address addressesIPv6[];
		if(ipv6List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv6List.toArray(new IPAddressSegmentSeries[ipv6List.size()]));
			addressesIPv6 = blocks.toArray(new IPv6Address[blocks.size()]);
		} else {
			addressesIPv6 = EMPTY_IPV6_ADDRESS;
		}
		return new DualIPv4Pv6Arrays(addressesIPv4, addressesIPv6);
	}
	/**
	 * Merges this with the list of subnets to produce the smallest list of block subnets that are sequential.
	 * <p>
	 * Block subnets come in the form 1-3.1-4.5.6-8, however that subnet is not sequential since address 1.1.5.8 is in the subnet,
	 * the next sequential address 1.1.5.9 is not in the subnet, and a higher address 1.2.5.6 is in the subnet.
	 * Blocks are sequential when the first segment with a range of values is followed by segments that span all values.
	 * <p>
	 * This list will eliminate overlaps to produce the smallest list of sequential block subnets, which is the same size or smaller than the list of prefix blocks produced by {@link #mergeToPrefixBlocks(IPAddress...)}
	 * <p>
	 * If the incoming blocks are not sequential, the result could be a longer list, since the list is divided into sequential blocks before merging.
	 * <p>
	 * If any other address in the list is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()},
	 * which can result in AddressConversionException
	 * <p>
	 * The resulting array is sorted by lower address, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * <p>
	 * See the javadoc for {@link #mergeToPrefixBlocks(IPAddress...)} for some alternatives for merging subnets.
	 * 
	 * 
	 * @throws AddressConversionException
	 * @param addresses the addresses to merge with this
	 * @return
	 */
	public abstract IPAddress[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException;
	
	protected static <T extends IPAddress, S extends IPAddressSegment> List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], IPAddressCreator<T, ?, ?, S, ?> creator) {
		return IPAddressSection.getMergedSequentialBlocks(sections, creator::createSequentialBlockAddress);
	}
	
	/**
	 * Produces the subnet whose addresses are found in both this and the given subnet argument, or null if no such addresses.
	 * <p>
	 * This is also known as the conjunction of the two sets of addresses.
	 * <p>
	 * If the address is not the same version, the default conversion will be applied using {@link #toIPv4()} or {@link #toIPv6()}, and it that fails, {@link AddressConversionException} will be thrown.
	 * <p>
	 * @param other
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @return the subnet containing the addresses found in both this and the given subnet
	 */
	public abstract IPAddress intersect(IPAddress other) throws AddressConversionException;
	
	/**
	 * Subtract the given subnet from this subnet, returning an array of subnets for the result (the subnets will not be contiguous so an array is required).
	 * <p>
	 * Computes the subnet difference, the set of addresses in this address subnet but not in the provided subnet.  This is also known as the relative complement of the given argument in this subnet.
	 * <p>
	 * If the address is not the same version, the default conversion will be applied using {@link #toIPv4()} or {@link #toIPv6()}, and it that fails, {@link AddressConversionException} will be thrown.
	 * <p>
	 * @param other
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @return the difference
	 */
	public abstract IPAddress[] subtract(IPAddress other) throws AddressConversionException;
	/**
	 * Equivalent to calling {@link #mask(IPAddress, boolean)} with the second argument as false.
	 *<p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress mask(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Applies the given mask to all addresses represented by this IPAddress.
	 * The mask is applied to all individual addresses.
	 * Any existing prefix length is removed beforehand.  If the retainPrefix argument is true, then the existing prefix length will be applied to the result.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If this represents multiple addresses, and applying the mask to all addresses creates a set of addresses
	 * that cannot be represented as a contiguous range within each segment, then {@link IncompatibleAddressException} is thrown.
	 * <p>
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress mask(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Applies the given mask to all addresses represented by this IPAddress while also applying the given prefix length at the same time.
	 * <p>
	 * Any existing prefix length is removed as the mask and new prefix length is applied to all individual addresses.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If this represents multiple addresses, and applying the mask to all addresses creates a set of addresses
	 * that cannot be represented as a contiguous range within each segment, then {@link IncompatibleAddressException} is thrown.
	 * 
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress maskNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	/**
	 * Equivalent to calling {@link #bitwiseOr(IPAddress, boolean)} with the second argument as false.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 @param mask
	 * @return
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 */
	public abstract IPAddress bitwiseOr(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.
	 * <p>
	 * The mask is applied to all individual addresses, similar to how the method {@link #mask(IPAddress, boolean)} applies the bitwise conjunction.
	 * Any existing prefix length is removed beforehand.  If the retainPrefix argument is true, then the existing prefix length will be applied to the result.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If you wish to mask a section of the network, use {@link #bitwiseOrNetwork(IPAddress, int)}
	 * <p>
	 * For instance, you can get the broadcast address for a subnet as follows:
	 * <code>
	 * String addrStr = "1.2.3.4/16";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress hostMask = address.getNetwork().getHostMask(address.getNetworkPrefixLength());//0.0.255.255
	 * IPAddress broadcastAddress = address.bitwiseOr(hostMask); //1.2.255.255
	 * </code>
	 * 
	 * @param mask
	 * @param retainPrefix
	 * @return
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 */
	public abstract IPAddress bitwiseOr(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * Any existing prefix length is dropped for the new prefix length and the mask is applied up to the end the new prefix length.
	 * It is similar to how the {@link #maskNetwork(IPAddress, int)} method does the bitwise conjunction.
	 * 
	 * @param mask
	 * @param networkPrefixLength the new prefix length for the address
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	
	@Override @Deprecated
	public abstract IPAddress removePrefixLength();
	
	@Override @Deprecated
	public abstract IPAddress removePrefixLength(boolean zeroed);
	
	@Override
	public abstract IPAddress withoutPrefixLength();
	
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	/**
	 * Increases or decreases prefix length by the given increment.
	 * <p>
	 * When prefix length is increased, the bits moved within the prefix become zero.
	 * When the prefix is extended beyond the segment series boundary, it is removed.
	 * When a prefix length is decreased, the bits moved outside the prefix become zero,
	 * and if the entire host address contains the zero address, 
	 * then the resulting address is determined {@link IPAddressNetwork#getPrefixConfiguration()}.
	 * <p>
	 * For example, 1.2.0.0/16 adjusted by -8 becomes 1.0.0.0/8.<br>
	 * 1.2.0.0/16 adjusted by 8 becomes 1.2.0.0/24
	 * 
	 * @param adjustment
	 * @return
	 */
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed);
	
	/**
	 * Sets the prefix length while allowing the caller to control whether bits moved in or out of the prefix become zero, 
	 * and whether a zero host for the new prefix bits can be translated into a prefix block.  
	 * The latter behaviour only applies to the default prefix handling configuration,
	 * PREFIXED_ZERO_HOSTS_ARE_SUBNETS.  The methods  {@link #setPrefixLength(int, boolean)} and {@link #setPrefixLength(int)}
	 * use a value of true for zeroed and for zeroHostIsBlock.
	 * <p>
	 * For example, when zeroHostIsBlock is true, applying to 1.2.0.0 the prefix length 16 results in 1.2.*.*&#x2f;16 
	 * <p>
	 * Or if you start with 1.2.0.0&#x2f;24, setting the prefix length to 16 results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16
	 * <p>
	 * When both zeroed and zeroHostIsBlock are true, applying the prefiix length of 16 to 1.2.4.0&#x2f;24 also results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16.
	 * <p>
	 * When both zeroed and zeroHostIsBlock are false, the resulting address always encompasses the same set of addresses as the original,
	 * albeit with a different prefix length.
	 * 
	 * @param prefixLength
	 * @param zeroed
	 * @param zeroHostIsBlock
	 * @return
	 */
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	
	@Deprecated
	@Override
	public abstract IPAddress applyPrefixLength(int networkPrefixLength);
	/**
	 * Returns a clause for matching this address.
	 * <p>
	 * If this address is a subnet, this method will attempt to match every address in the subnet.
	 * Therefore it is much more efficient to use getNetworkSection().getStartsWithSQLClause() for a CIDR subnet.
	 * 
	 * @param builder
	 * @param sqlExpression
	 */
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression) {
		getSection().getStartsWithSQLClause(builder, sqlExpression);
	}
	
	/**
	 * Returns a clause for matching this address.
	 * <p>
	 * Similar to getMatchesSQLClause(StringBuilder builder, String sqlExpression) but allows you to tailor the SQL produced.
	 * 
	 * @param builder
	 * @param sqlExpression
	 * @param translator
	 */
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression, IPAddressSQLTranslator translator) {
		getSection().getStartsWithSQLClause(builder, sqlExpression, translator);
	}
	
	/**
	 * Removes the prefix length from addresses with a prefix length extending to the end of the address.
	 * @return
	 */
	public IPAddress removeBitCountPrefixLength() {
		if(isPrefixed() && getNetworkPrefixLength() == getBitCount()) {
			return this.withoutPrefixLength();
		}
		return this;
	}
}
/*
 * Copyright 2022-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.List;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.SubNodesMappingBasic;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
/** 
 * AddedTree is an alternative non-binary tree data structure originating from a binary trie
 * with the possible exception of the root, which matches the root node of the original.
 * The root may or may not be an added node from the original trie.
 * This tree is also read-only and is generated from the originating trie,
 * but does not change in concert with changes to the original trie.
 */
public class AddedTree<E extends Address> extends AddedTreeBase<E, SubNodesMappingBasic<E>> {
	public AddedTree(AssociativeAddressTrie<E, SubNodesMappingBasic<E>> wrapped) {
		super(wrapped);
	}
	/** 
	 * AddedTreeNode represents a node in an AddedTree.
	 */
	public static class AddedTreeNode<E extends Address> extends AddedTreeNodeBase<E,SubNodesMappingBasic<E>> {
		public AddedTreeNode(AssociativeTrieNode<E, SubNodesMappingBasic<E>> node) {
			super(node);
		}
		
		@Override
		public AddedTreeNode<E>[] getSubNodes() {
			SubNodesMappingBasic<E> value = node.getValue();
			if(value == null) {
				return null;
			}
			List<AssociativeTrieNode<E, SubNodesMappingBasic<E>>> subNodes = value.subNodes;  
			if(subNodes == null || subNodes.size() == 0) {
				return null;
			}
			@SuppressWarnings("unchecked")
			AddedTreeNode<E>[] nodes = (AddedTreeNode<E>[]) new AddedTreeNode[subNodes.size()];
			for(int i = 0; i < nodes.length; i++) {
				nodes[i] = new AddedTreeNode<E>(subNodes.get(i));
			}
			return nodes;
		}
	}
	
	/**
	 * Returns the root of this tree, which corresponds to the root of the originating trie.
	 */
	@Override
	public AddedTreeNode<E> getRoot()  {
		return new AddedTreeNode<E>(wrapped.getRoot());
	}
}
/*
 * Copyright 2022-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.SubNodesMapping;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
abstract class AddedTreeBase<E extends Address, N extends SubNodesMapping<E, N>> {
	AssociativeAddressTrie<E, N> wrapped;
	
	AddedTreeBase(AssociativeAddressTrie<E, N> wrapped) {
		this.wrapped = wrapped;
	}
	
	static abstract class AddedTreeNodeBase<E extends Address, N extends SubNodesMapping<E, N>> {
		
		AssociativeTrieNode<E, N> node;
		public AddedTreeNodeBase(AssociativeTrieNode<E, N> node) {
			this.node = node;
		}
		
		/**
		 * Returns the sub-nodes of this node, which are not the same as the 0, 1 or 2 direct sub-nodes of the originating binary trie.
		 * Instead, these are all the direct or indirect added sub-nodes of the node in the originating trie.
		 * If you can traverse from this node to another node in the originating trie, using a sequence of sub-nodes, 
		 * without any intervening sub-node being an added node, then that other node will appear as a sub-node here.
		 * If there are no sub-nodes, then this method returns null.
		 */
		abstract AddedTreeNodeBase<E,N>[] getSubNodes();
		
		/**
		 * getKey returns the key of this node, which is the same as the key of the corresponding node in the originating trie.
		 * @return
		 */
		public E getKey() {
			return node.getKey();
		}
		
		/**
		 * Returns whether the node was an added node in the original trie.  
		 * This returns true for all nodes except possibly the root, since only added nodes are added to this tree, apart from the root.
		 */
		public boolean isAdded() {
			return node.isAdded();
		}
		
		/**
		 * Returns a visual representation of this node including the key.
		 * If this is the root, it will have an open circle if the root is not an added node.
		 * Otherwise, the node will have a closed circle.
		 */
		@Override
		public String toString() {
			return TrieNode.toNodeString(new StringBuilder(50), node.isAdded(), getKey(), null).toString();
		}
		
		/**
		 * toTreeString returns a visual representation of the sub-tree originating from this node, with one node per line.
		 * @return
		 */
		public String toTreeString() {
			return AddressTrie.toAddedNodesTreeString(node);
		}
	}
	
	/**
	 * Returns the root of this tree, which corresponds to the root of the originating trie.
	 */
	public abstract AddedTreeNodeBase<E,N> getRoot();
	/**
	 * Returns a string representation of the tree, which is the same as the string obtained from
	 * the AddedNodesTreeString method of the originating trie.
	 */
	@Override
	public String toString() {
		return AddressTrie.toAddedNodesTreeString(wrapped.getRoot());
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrieOps.AssociativeAddressTriePutOps;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
/**
 * An address trie in which each node is associated with a value.
 * <p>
 * The trie can also be used as the backing data structure for a {@link AddressTrieMap} which is a {@link java.util.NavigableMap}.
 * Unlike {@link java.util.TreeMap} this data structure provides access to the nodes and the associated sub-trie with each node as the sub-trie root,
 * which corresponds with their associated CIDR prefix block subnets.
 * <p>
 * Use one of the put methods to add nodes with values or to change the values of existing nodes.
 * You can also add to the trie using {@link #add(Address)} and the associated value will be null.  
 * <p>
 * Mapped tries are thread-safe when not being modified (ie mappings added or removed), but are not thread-safe when a thread is modifying the trie.
 * <p>
 * To make them thread-safe during addition and removal you could access them through the collection provided by {@link java.util.Collections#synchronizedMap},
 * applied to the map from {@link #asMap()}
 * 
 * @author scfoley
 *
 * @param <K> the type of the address keys
 * @param <V> the type of the associated values
 */ 
public abstract class AssociativeAddressTrie<K extends Address, V> extends AddressTrie<K> implements AssociativeAddressTriePutOps<K, V> {
	private static final long serialVersionUID = 1L;
	public static abstract class AssociativeTrieNode<K extends Address, V> extends TrieNode<K> implements Map.Entry<K, V>, AssociativeAddressTrieOps<K, V> {
		private static final long serialVersionUID = 1L;
		private V value;
		protected AssociativeTrieNode(K item) {
			super(item);
		}
		@Override
		public V getValue() {
			return value;
		}
		@Override
		public V setValue(V value) {
			V result = getValue();
			this.value = value;
			return result;
		}
		public void clearValue() {
			this.value = null;
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getUpperSubNode() {
			return (AssociativeTrieNode<K,V>) super.getUpperSubNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getLowerSubNode() {
			return (AssociativeTrieNode<K,V>) super.getLowerSubNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getParent() {
			return (AssociativeTrieNode<K,V>) super.getParent();
		}
		@SuppressWarnings("unchecked")
		@Override
		public V get(K addr) {
			AssociativeTrieNode<K,V> node = (AssociativeTrieNode<K,V>) doLookup(addr).existingNode;
			return node == null ? null : node.getValue();
		}
		/**
		 * The hash code is the same as that specified by {@link java.util.Map.Entry#hashCode()}
		 */
		@Override
		public int hashCode() {
			if(value == null) {
				return super.hashCode();
			}
			return super.hashCode() ^ value.hashCode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeAddressTrie<K,V> asNewTrie() {
			return (AssociativeAddressTrie<K, V>) super.asNewTrie();
		}
		
		/**
		 * Clones the subtrie starting with this node as root. 
		 * The nodes are cloned, the keys and values are not cloned.
		 */
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> cloneTree() {
			return (AssociativeTrieNode<K,V>) super.cloneTree();
		}
		/**
		 * Clones the node.  Keys and values are not cloned, but parent node, lower and upper sub-nodes, 
		 * are all set to null.
		 */
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> clone() {
			return (AssociativeTrieNode<K,V>) super.clone();
		}
		/**
		 * Returns whether the key and mapped value match those of the given node
		 */
		@SuppressWarnings("unchecked")
		@Override
		public boolean equals(Object o) {
			if (o == this) {
				return true;
			} else if(o instanceof AssociativeTrieNode<?,?>) {
				AssociativeTrieNode<K,V> other = ((AssociativeTrieNode<K,V>) o);
				return super.equals(o) && Objects.equals(getValue(), other.getValue());
			}
			return false;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> nodeIterator(boolean forward) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> allNodeIterator(boolean forward) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<? extends AssociativeTrieNode<K,V>, K, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<? extends AssociativeTrieNode<K,V>, K, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@Override
		public Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, true);
		}
		@Override
		public Spliterator<? extends AssociativeTrieNode<K,V>> allNodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, false);
		}
		@Override
		@SuppressWarnings("unchecked")
		Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
			return (Spliterator<? extends AssociativeTrieNode<K, V>>) super.nodeSpliterator(forward, addedNodesOnly);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> previousAddedNode() {
			return (AssociativeTrieNode<K,V>) super.previousAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> nextAddedNode() {
			return (AssociativeTrieNode<K,V>) super.nextAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> nextNode() {
			return (AssociativeTrieNode<K,V>) super.nextNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> previousNode() {
			return (AssociativeTrieNode<K,V>) super.previousNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> firstNode() {
			return (AssociativeTrieNode<K,V>) super.firstNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lastNode() {
			return (AssociativeTrieNode<K,V>) super.lastNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> firstAddedNode() {
			return (AssociativeTrieNode<K,V>) super.firstAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lastAddedNode() {
			return (AssociativeTrieNode<K,V>) super.lastAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lowerAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.lowerAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> floorAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.floorAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> higherAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.higherAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> ceilingAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.ceilingAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getAddedNode(K addr) {
			return (AssociativeTrieNode<K,V>) super.getAddedNode(addr);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> removeElementsContainedBy(K addr) {
			return (AssociativeTrieNode<K, V>) super.removeElementsContainedBy(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> elementsContainedBy(K addr) {
			return (AssociativeTrieNode<K, V>) super.elementsContainedBy(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> elementsContaining(K addr) {
			return (AssociativeTrieNode<K, V>) super.elementsContaining(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> longestPrefixMatchNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.longestPrefixMatchNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> shortestPrefixMatchNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.shortestPrefixMatchNode(addr);
		}
		@Override
		@SuppressWarnings("unchecked")
		void matchedInserted(OpResult<K> result) {
			super.matchedInserted(result);
			result.existingValue = getValue();
			setValue((V) result.newValue);
		}
		@Override
		@SuppressWarnings("unchecked")
		void added(OpResult<K> result) {
			super.added(result);
			setValue((V) result.newValue);
		}
		/**
		 * 
		 * @param result
		 * @return true if a new node needs to be created (match is null) or added (match is non-null)
		 */
		@Override
		@SuppressWarnings("unchecked")
		boolean remap(OpResult<K> result, boolean isMatch) {
			Function<? super V, ? extends Object> remapper = (Function<? super V, ? extends Object>) result.remapper;
			Object newValue;
			Change change = changeTracker.getCurrent();
			V existingValue = isMatch ? getValue() : null;
			result.existingValue = existingValue;
			newValue = remapper.apply(existingValue);
			if(newValue == REMAP_ACTION.DO_NOTHING) {
				return false;
			} else if(newValue == REMAP_ACTION.REMOVE_NODE) { 
				if(isMatch) {
					changeTracker.changedSince(change);
					clearValue();
					removeOp(result);
				}
				return false;
			} else if (isMatch) {
				if(newValue != existingValue) {
					changeTracker.changedSince(change);
					result.newValue = newValue;
					return true;
				} // else node already has the value we want
				return false;
			} else {
				result.newValue = newValue;
				return true;
			}
		}
		/**
		 * The node remains in the trie, but is no longer an added node.
		 * Even if the node is removed from the trie, we must remove the value,
		 * this is needed for the compute method, which returns the value (which must be null when we have removed).
		 */
		@Override
		void removed() {
			super.removed();
			clearValue();
		}
		@SuppressWarnings("unchecked")
		@Override
		protected void replaceThisRoot(BinaryTreeNode<K> replacement) {
			super.replaceThisRoot(replacement);
			if(replacement == null) {
				setValue(null);
			} else {
				setValue(((AssociativeTrieNode<K,V>) replacement).getValue());
			}
		}
		@Override
		public String toString() {
			return toNodeString(new StringBuilder(80), isAdded(), getKey(), getValue()).toString();
		}
	}
	static enum REMAP_ACTION { DO_NOTHING, REMOVE_NODE }
	AddressTrieMap<K,V> map;
	public AssociativeAddressTrie(AssociativeTrieNode<K, V> root) {
		super(root);
	}
	protected AssociativeAddressTrie(AssociativeTrieNode<K, V> root, AddressBounds<K> bounds) {
		super(root, bounds);
	}
	@SuppressWarnings("unchecked")
	@Override
	protected AssociativeTrieNode<K, V> absoluteRoot() {
		return (AssociativeTrieNode<K, V>) super.absoluteRoot();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getRoot() {
		return (AssociativeTrieNode<K, V>) super.getRoot();
	}
	@SuppressWarnings("unchecked")
	@Override
	public V put(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		return (V) result.existingValue;
	}
	@Override
	public boolean putNew(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		return !result.exists;
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> addNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	TrieNode<K> addNode(OpResult<K> result, TrieNode<K> fromNode, TrieNode<K> nodeToAdd, boolean withValues) {
		if(withValues && nodeToAdd instanceof AssociativeTrieNode) {
			AssociativeTrieNode<K, V> node = (AssociativeTrieNode<K, V>) nodeToAdd;
			result.newValue = node.getValue();
		}
		return super.addNode(result, fromNode, nodeToAdd, withValues);
	}
	@Override
	public abstract AssociativeAddedTree<K, V> constructAddedNodesTree();
	protected static class SubNodesMappingAssociative<E extends Address, V> extends SubNodesMapping<E, SubNodesMappingAssociative<E, V>> {
		 V value;
		@Override
		Object getUnderlyingValue() {
			return value;
		}
	}
	/**
	* Constructs a trie in which added nodes are mapped to their list of added sub-nodes.
	* This trie provides an alternative non-binary tree structure of the added nodes.
	* It is used by ToAddedNodesTreeString to produce a string showing the alternative structure.
	* If there are no non-added nodes in this trie, 
	* then the alternative tree structure provided by this method is the same as the original trie.
	* 
	* @return
	*/
	protected void contructAssociativeAddedTree(AssociativeAddressTrie<K, SubNodesMappingAssociative<K,V>> emptyTrie) {
		emptyTrie.addTrie(absoluteRoot()); // does not add values
		
		CachingIterator<? extends AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>, K, 
				AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> cachingIterator =
			emptyTrie.containingFirstAllNodeIterator(true);
		
		Iterator<? extends AssociativeTrieNode<K, V>> thisIterator = containingFirstAllNodeIterator(true);
		while(cachingIterator.hasNext()) {
			AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>> newNext = cachingIterator.next(), parent;
			AssociativeTrieNode<K, V> thisNext = thisIterator.next();
			SubNodesMappingAssociative<K,V> mapping = new SubNodesMappingAssociative<K,V>();
			mapping.value = thisNext.getValue();
			
			// populate the values from the original trie into the new trie
			newNext.setValue(mapping);
			
			// cache this node with its sub-nodes
			cachingIterator.cacheWithLowerSubNode(newNext);
			cachingIterator.cacheWithUpperSubNode(newNext);
			
			// the cached object is our parent
			if(newNext.isAdded()) {
				parent = cachingIterator.getCached();
				if(parent != null) {
					// find added parent, or the root if no added parent
					// this part would be tricky if we accounted for the bounds,
					// maybe we'd have to filter on the bounds, and also look for the sub-root
					while(!parent.isAdded()) {
						AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>> parentParent = parent.getParent();
						if(parentParent == null) {
							break;
						}
						parent = parentParent;
					}
					// store ourselves with that added parent or root
					SubNodesMappingAssociative<K, V> mappedNodes = parent.getValue();
					ArrayList<AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> addedSubs = mappedNodes.subNodes;
					if(addedSubs == null) {
						addedSubs = new ArrayList<AssociativeTrieNode<K, SubNodesMappingAssociative<K,V>>>(newNext.size() - 1);
						mappedNodes.subNodes = addedSubs;
					}
					addedSubs.add(newNext);
				} // else root
			}
		}
		SubNodesMappingAssociative<K, V> value = emptyTrie.getRoot().getValue();
		if(value != null && value.subNodes != null) {
			value.subNodes.trimToSize();
		}
		Iterator<? extends AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> iter = emptyTrie.allNodeIterator(true);
		while(iter.hasNext()) {
			SubNodesMappingAssociative<K, V> list = iter.next().getValue();
			if(list != null && list.subNodes != null) {
				list.subNodes.trimToSize();
			}
		}
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> putTrie(AssociativeTrieNode<K, V> trie) {
		return (AssociativeTrieNode<K, V>) addTrie(trie, true);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> putNode(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		TrieNode<K> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return (AssociativeTrieNode<K, V>) node;
	}
	@Override
	public AssociativeTrieNode<K, V> remap(K addr, Function<? super V, ? extends V> remapper) {
		return remapImpl(addr, existingAddr -> {
			V result = remapper.apply(existingAddr);
			return result == null ? REMAP_ACTION.REMOVE_NODE : result;
		});
	}
	@Override
	public AssociativeTrieNode<K, V> remapIfAbsent(K addr, Supplier<? extends V> remapper, boolean insertNull) {
		return remapImpl(addr, existingVal -> {
			if(existingVal == null) {
				V result = remapper.get();
				if(result != null || insertNull) {
					return result;
				}
			}
			return REMAP_ACTION.DO_NOTHING;
		});
	}
	@SuppressWarnings("unchecked")
	private AssociativeTrieNode<K, V> remapImpl(K addr, Function<? super V, ? extends Object> remapper) {
		addr = checkBlockOrAddress(addr, true);
		AssociativeTrieNode<K, V> subRoot;
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
			subRoot = getRoot();
			if(subRoot == null) {
				subRoot = absoluteRoot();
			}
		} else {
			subRoot = absoluteRoot();
		}
		OpResult<K> result = new OpResult<>(addr, Operation.REMAP);
		result.remapper = remapper;
		subRoot.matchBits(result);
		TrieNode<K> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return (AssociativeTrieNode<K, V>) node;
	}
	@Override
	public V get(K addr) {
		AssociativeTrieNode<K,V> subRoot;
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return null;
			}
			subRoot = getRoot();
			if(subRoot == null) {
				return null;
			}
		} else {
			subRoot = absoluteRoot();
		}
		return subRoot.get(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.getAddedNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.getNode(addr);
	}
	
	@SuppressWarnings("unchecked")
	@Override
	AssociativeTrieNode<K, V> smallestElementContainingBounds(K addr) {
		return (AssociativeTrieNode<K, V>) super.smallestElementContainingBounds(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> removeElementsContainedBy(K addr) {
		return (AssociativeTrieNode<K,V>) super.removeElementsContainedBy(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> elementsContainedBy(K addr) {
		return (AssociativeTrieNode<K,V>) super.elementsContainedBy(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> elementsContaining(K addr) {
		return (AssociativeTrieNode<K,V>) super.elementsContaining(addr);
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> longestPrefixMatchNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.longestPrefixMatchNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> shortestPrefixMatchNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.shortestPrefixMatchNode(addr);
	}
	/**
	 * Returns a java.util.NavigableMap backed by this associative trie.
	 * The added elements of this trie are keys for the map, the associated values are the map values.
	 * 
	 * @return
	 */
	public AddressTrieMap<K,V> asMap() {
		AddressTrieMap<K,V> map = this.map;
		if(map == null) {
			map = new AddressTrieMap<K,V>(this);
		}
		return map;
	}
	@Override
	@SuppressWarnings("unchecked")
	AssociativeAddressTrie<K,V> elementsContainedByToSubTrie(K addr) {
		return (AssociativeAddressTrie<K, V>) super.elementsContainedByToSubTrie(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	AssociativeAddressTrie<K,V> elementsContainingToTrie(K addr) {
		return (AssociativeAddressTrie<K, V>) super.elementsContainingToTrie(addr);
	}
	// creates a new one-node trie with a new root and the given bounds
	@Override
	protected abstract AssociativeAddressTrie<K,V> createNew(AddressBounds<K> bounds);
	// create a trie with the same root as this one, but different bounds
	@Override
	protected abstract AssociativeAddressTrie<K,V> createSubTrie(AddressBounds<K> bounds);
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> nodeIterator(boolean forward) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> allNodeIterator(boolean forward) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<? extends AssociativeTrieNode<K, V>, K, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containingFirstIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containingFirstIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> containingFirstAllNodeIterator(boolean lowerSubNodeFirst) {
		return (CachingIterator<? extends AssociativeTrieNode<K, V>, K, C>) super.containingFirstAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
		return (Spliterator<? extends AssociativeTrieNode<K, V>>) super.nodeSpliterator(forward, addedNodesOnly);
	}
	@Override
	public Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, true);
	}
	@Override
	public Spliterator<? extends AssociativeTrieNode<K,V>> allNodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, false);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> firstNode() {
		return (AssociativeTrieNode<K, V>) super.firstNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> lastNode() {
		return (AssociativeTrieNode<K, V>) super.lastNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> firstAddedNode() {
		return (AssociativeTrieNode<K, V>) super.firstAddedNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> lastAddedNode() {
		return (AssociativeTrieNode<K, V>) super.lastAddedNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> lowerAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.lowerAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> floorAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.floorAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> higherAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.higherAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> ceilingAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.ceilingAddedNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeAddressTrie<K, V> clone() {
		AssociativeAddressTrie<K, V> result = (AssociativeAddressTrie<K, V>) super.clone();
		result.map = null;
		return result;
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof AssociativeAddressTrie && super.equals(o);
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
/**
 * An IPv6 address trie in which each node can be associated with a value.
 * 
 * See {@link AssociativeAddressTrie} for more details.
 * 
 * @author scfoley
 *
 * @param <V> the type of the associated values
 */
public class IPv6AddressAssociativeTrie<V> extends AssociativeAddressTrie<IPv6Address, V> {
	private static final long serialVersionUID = 1L;
	private static final IPv6Address INIT_ROOT = IPv6AddressTrie.INIT_ROOT;
	public IPv6AddressAssociativeTrie() {
		super(new IPv6AssociativeTrieNode<V>());
	}
	protected IPv6AddressAssociativeTrie(AddressBounds<IPv6Address> bounds) {
		super(new IPv6AssociativeTrieNode<V>(), bounds);
	}
	protected IPv6AddressAssociativeTrie(IPv6AssociativeTrieNode<V> root, AddressBounds<IPv6Address> bounds) {
		super(root, bounds);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getRoot() {
		return (IPv6AssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected IPv6AssociativeTrieNode<V> absoluteRoot() {
		return (IPv6AssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected IPv6AddressAssociativeTrie<V> createNew(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected IPv6AddressAssociativeTrie<V> createSubTrie(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class IPv6AssociativeTrieNode<V> extends AssociativeTrieNode<IPv6Address, V> {
		private static final long serialVersionUID = 1L;
		protected IPv6AssociativeTrieNode(IPv6Address addr) {
			super(addr);
		}
		public IPv6AssociativeTrieNode() { // root node
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv6Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv6AssociativeTrieNode<V> getUpperSubNode() {
			return (IPv6AssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> getLowerSubNode() {
			return (IPv6AssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> getParent() {
			return (IPv6AssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected IPv6AssociativeTrieNode<V> createNewImpl(IPv6Address addr) {
			return new IPv6AssociativeTrieNode<V>(addr);
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> removeElementsContainedBy(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> elementsContainedBy(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> elementsContaining(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> longestPrefixMatchNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> getAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> getNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv6AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv6AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv6AssociativeTrieNode<V> previousAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.previousAddedNode();
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> nextAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.nextAddedNode();
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> nextNode() {
			return (IPv6AssociativeTrieNode<V>) super.nextNode();
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> previousNode() {
			return (IPv6AssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lowerAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> floorAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> higherAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> ceilingAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> firstNode() {
			return (IPv6AssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lastNode() {
			return (IPv6AssociativeTrieNode<V>) super.lastNode();
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> firstAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lastAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.lastAddedNode();
		}
		
		@Override
		protected IPv6AddressAssociativeTrie<V> createNewTree() {
			return new IPv6AddressAssociativeTrie<V>();
		}
		
		@Override
		public IPv6AddressAssociativeTrie<V> asNewTrie() {
			return (IPv6AddressAssociativeTrie<V>) super.asNewTrie();
		}
		
		@Override
		public IPv6AssociativeTrieNode<V> cloneTree() {
			return (IPv6AssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public IPv6AssociativeTrieNode<V> clone() {
			return (IPv6AssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6AddressAssociativeTrie.IPv6AssociativeTrieNode && super.equals(o);
		}
		@Override
		protected IPv6TrieKeyData getTrieKeyCache(IPv6Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv6AssociativeTrieNode<V> removeElementsContainedBy(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> elementsContainedBy(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> elementsContaining(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	
	@Override
	public IPv6AssociativeTrieNode<V> longestPrefixMatchNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> addNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public IPv6AssociativeTrieNode<V> addTrie(TrieNode<IPv6Address> trie) {
		return (IPv6AssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv6AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv6AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv6AssociativeTrieNode<V> lowerAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> floorAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> higherAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> ceilingAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	
	@Override
	public IPv6AssociativeTrieNode<V> firstNode() {
		return (IPv6AssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> lastNode() {
		return (IPv6AssociativeTrieNode<V>) super.lastNode();
	}
	
	@Override
	public IPv6AssociativeTrieNode<V> firstAddedNode() {
		return (IPv6AssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> lastAddedNode() {
		return (IPv6AssociativeTrieNode<V>) super.lastAddedNode();
	}
	
	@Override
	public IPv6AssociativeTrieNode<V> putNode(IPv6Address addr, V value) {
		return (IPv6AssociativeTrieNode<V>) super.putNode(addr, value);
	}
	
	@Override
	public IPv6AssociativeTrieNode<V> putTrie(AssociativeTrieNode<IPv6Address, V> trie) {
		return (IPv6AssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public IPv6AssociativeTrieNode<V> remap(IPv6Address addr, Function<? super V, ? extends V> remapper) {
		return (IPv6AssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public IPv6AssociativeTrieNode<V> remapIfAbsent(IPv6Address addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (IPv6AssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv6AddressAssociativeTrie && super.equals(o);
	}
	
	@Override
	public IPv6AddressAssociativeTrie<V> clone() {
		return (IPv6AddressAssociativeTrie<V>) super.clone();
	}
	
	@Override
	public AssociativeAddedTree<IPv6Address, V> constructAddedNodesTree() {
		IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<IPv6Address, V>(trie);
	}
	
	@Override
	public String toAddedNodesTreeString() {
		IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format;
import java.io.Serializable;
import java.math.BigInteger;
import inet.ipaddr.Address;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
/**
 * Represents any part of an address, whether divided into the standard arrangement of AddressComponent objects, or whether an alternative arrangement using AddressDivision objects.
 * <p>
 * The basic difference between the AddressComponent hierarchy and the AddressDivision hierarchy is that <br>
 * AddressComponent hierarchy uses<br>
 * <ul><li>standardized/typical arrangement (ie for ipv4, 4 equal segments of 1 byte each, for ipv6, 8 equal segments of 2 bytes each, for mac, 6 or 8 equal segments of 1 byte each)</li>
 * <li>equal size segments</li>
 * <li>segments divided along byte boundaries</li></ul>
 * <p>
 * AddressDivision allows alternative arrangements, such as inet_aton style of presenting ipv4 in fewer divisions, 
 * or base 85 for ipv6 which does not even use a base that is a power of 2 (and hence so subdivisions possibly using bit boundaries), 
 * or the aaa-bbb-ccc-ddd mac format with which segments are not divided along byte boundaries
 * <p>
 * Parsing creates objects in the AddressComponent hierarchy, which can then be used to create alternative arrangements using {@link AddressDivisionGrouping} or {@link AddressStringDivisionSeries}
 * <p>
 * @author sfoley
 *
 */
public interface AddressItem extends Comparable<AddressItem>, Serializable {
	/**
	 * Uses {@link Address#DEFAULT_ADDRESS_COMPARATOR}, an instance of {@link inet.ipaddr.AddressComparator.CountComparator}, to compare any two address items.
	 */
	@Override
	default int compareTo(AddressItem other) {
		return Address.DEFAULT_ADDRESS_COMPARATOR.compare(this, other);
	}
	/**
	 * The count of possible distinct values for this AddressComponent.  If not multiple, this is 1.
	 * Note that an AddressDivisionSeries with no divisions or AddressSection with no segments has a single value of 0.
	 * 
	 * For instance, if this is the ip address series subnet 0::/64, then the count is 2 to the power of 64.
	 * 
	 * If this is a the segment 3-7, then the count is 5.
	 * 
	 * @return
	 */
	default BigInteger getCount() {
		return getUpperValue().subtract(getValue()).add(BigInteger.ONE);
	}
	/**
	 * The count of the number of distinct values within the prefix part of the address item, the bits that appear within the prefix length.
	 * 
	 * @param prefixLength
	 * @return
	 */
	default BigInteger getPrefixCount(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= prefixLength) {
			return getCount();
		}
		int shiftAdjustment = bitCount - prefixLength;
		BigInteger lower = getValue(), upper = getUpperValue();
		return upper.shiftRight(shiftAdjustment).subtract(lower.shiftRight(shiftAdjustment)).add(BigInteger.ONE);
	}
	
	/**
	 * Provides the number of bits comprising this address item
	 * 
	 * @return the number of bits
	 */
	int getBitCount();
	
	/**
	 * Provides the number of bytes required for this address item, rounding up if the bit count is not a multiple of 8
	 * 
	 * @return the number of bytes
	 */
	default int getByteCount() {
		return (getBitCount() + (Byte.SIZE - 1)) >>> 3;
	}
	
	/**
	 * Whether this represents multiple potential values (eg a prefixed address or a segment representing a range of values)
	 */
	default boolean isMultiple() {
		return !getUpperValue().equals(getValue());
	}
	
	/**
	 * 
	 * @return the bytes of the lowest address item represented by this address item
	 */
	byte[] getBytes();
	
	/**
	 * Copies the bytes of the lowest address item represented by this address item into the supplied array,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned.
	 * 
	 * @return the bytes of the lowest address represented by this address item.
	 */
	byte[] getBytes(byte bytes[]);
	
	/**
	 * Copies the bytes of the lowest address item represented by this address item into the supplied array starting at the given index,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned, with the rest of the array contents the same as the original.
	 * 
	 * @return the bytes of the lowest address represented by this address item.
	 */
	byte[] getBytes(byte bytes[], int index);
	
	/**
	 * 
	 * @return the bytes of the largest address item represented by this address item
	 */
	byte[] getUpperBytes();
	
	/**
	 * Copies the bytes of the largest address item represented by this address item into the supplied array,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned, with the rest of the array contents the same as the original.
	 * 
	 * @return the bytes of the largest address represented by this address item.
	 */
	byte[] getUpperBytes(byte bytes[]);
	
	/**
	 * Copies the bytes of the largest address item represented by this address item into the supplied array at the given index,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned.
	 * 
	 * @return the bytes of the largest address represented by this address item.
	 */
	byte[] getUpperBytes(byte bytes[], int index);
	
	/**
	 * Returns the lowest value represented by this address item, the lowest value included in the range of values
	 * 
	 * @return the lowest value represented by this address item
	 */
	BigInteger getValue();
	
	/**
	 * Returns the highest value represented by this address item, the highest value included in the range of values
	 * 
	 * @return the highest value represented by this address item
	 */
	BigInteger getUpperValue();
		
	/**
	 * Returns whether this item matches the value of zero
	 * 
	 * @return whether this item matches the value of zero
	 */
	boolean isZero();
	
	/**
	 * Returns whether this item includes the value of zero within its range
	 * 
	 * @return whether this item includes the value of zero within its range
	 */
	boolean includesZero();
	
	/**
	 * Returns whether this item matches the maximum possible value for the address type or version
	 * 
	 * @return whether this item matches the maximum possible value
	 */
	boolean isMax();
	
	/**
	 * Returns whether this item includes the maximum possible value for the address type or version within its range
	 * 
	 * @return whether this item includes the maximum possible value within its range
	 */
	boolean includesMax();
	
	/**
	 * whether this address item represents all possible values attainable by an address item of this type
	 * 
	 * @return whether this address item represents all possible values attainable by an address item of this type,
	 * or in other words, both includesZero() and includesMax() return true
	 */
	default boolean isFullRange() {
		return includesZero() && includesMax();
	}
	/**
	 * Returns whether the values of this series contains the prefix block for the given prefix length.
	 * <p>
	 * Use {@link #getMinPrefixLengthForBlock()} to determine the smallest prefix length for which this method returns true.
	 * 
	 * @param divisionPrefixLen
	 * @throws PrefixLenException if prefixLength exceeds the bit count or is negative
	 * @return
	 */
	default boolean containsPrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger upper = getUpperValue();
		return AddressDivisionBase.testRange(getValue(), upper, upper, getBitCount(), divisionPrefixLen);
	}
	
	/**
	 * Returns whether the values of this series contains a single prefix block for the given prefix length.
	 * <p>
	 * Use {@link #getPrefixLengthForSingleBlock()} to determine whether there is a prefix length for which this method returns true.
	 * 
	 * @param divisionPrefixLen
	 * @throws PrefixLenException if prefixLength exceeds the bit count or is negative
	 * @return
	 */
	default boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger lower = getValue(), upper = getUpperValue();
		return AddressDivisionBase.testRange(lower, lower, upper, getBitCount(), divisionPrefixLen);
	}
	
	/**
	 * Returns the smallest prefix length possible such that this item includes the block of all values for that prefix length.
	 * <p>
	 * If the entire range can be dictated this way, then this method returns the same value as {@link #getPrefixLengthForSingleBlock()}.  
	 * Otherwise, this method will return the minimal possible prefix that can be paired with this address, while {@link #getPrefixLengthForSingleBlock()} will return null.
	 * <p>
	 * In cases where the final bit is constant so there is no such block, this returns the bit count.
	 *
	 * @return the prefix length
	 */
	default int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		BigInteger lower = getValue(), upper = getUpperValue();
		if(!lower.equals(upper)) {
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				int lowerZeros = Long.numberOfTrailingZeros(low);
				if(lowerZeros == 0) {
					break;
				}
				long up = upper.longValue();
				int upperOnes = Long.numberOfTrailingZeros(~up);
				if(upperOnes == 0) {
					break;
				}
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
				if(prefixedBitCount < longBits) {
					break;
				}
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
			} while(upper.signum() != 0);
		}
		return result;
	}
	
	/**
	 * Returns a prefix length for which the range of this item matches the block of all values for that prefix length.
	 * <p>
	 * If the range can be dictated this way, then this method returns the same value as {@link #getMinPrefixLengthForBlock()}.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * If this item represents a single value, this returns the bit count.
	 * 
	 * @return the prefix length or null
	 */
	default Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		BigInteger lower = getValue(), upper = getUpperValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lower.equals(upper)) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lower.shiftRight(shift).equals(upper.shiftRight(shift))) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		}
		return null;
	}
	/**
	 * Returns the total number of values when ranging across the given number of host bits. 
	 * This is the reverse of {@link #getBitsForCount(long)}.
	 * 
	 * A bitCount of zero or less returns zero.
	 * 
	 * @param bitCount
	 */
	public static BigInteger getBlockSize(int bitCount) {
		return BigInteger.ONE.shiftLeft(bitCount);
	}
	
	/**
	 * BitsForCount returns the number of bits required outside the prefix length 
	 * for a single prefix block to span at least as many addresses as the given count. 
	 * Mathematically, it is the ceiling of the base 2 logarithm of the given count. 
	 * A count of zero or less than zero returns null.
	 * 
	 * See {@link #getBlockSize(int)} for the reverse direction.
	 * 
	 * @param count
	 */
	public static Integer getBitsForCount(long count) {
		if(count <= 0) {
			return null;
		}
		int logBase2 = (Long.SIZE - 1) - Long.numberOfLeadingZeros(count);
		if((~(-1L << logBase2) & count) != 0) {
			logBase2++;
		}
		return logBase2;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
/**
 * Represents a series of address segments, each of equal byte size, the byte size being a whole number of bytes.
 * 
 * Each segment can potentially range over multiple values, and thus this series of segments can represent many different values as well.
 * 
 * 
 * @author sfoley
 *
 */
public interface AddressSegmentSeries extends AddressDivisionSeries, AddressComponent {
	/**
	 * Returns the number of segments in this series.
	 * @return
	 */
	int getSegmentCount();
	
	/**
	 * Returns the number of bits comprising each segment in this series.  Segments in the same series are equal length.
	 * @return
	 */
	int getBitsPerSegment();
	
	/**
	 * Returns the number of bytes comprising each segment in this series.  Segments in the same series are equal length.
	 * @return
	 */
	int getBytesPerSegment();
	
	/**
	 * Returns the maximum possible segment value for this type of address.
	 * 
	 * Note this is not the maximum value of the range of segment values in this specific address,
	 * this is the maximum value of any segment for this address type, and is usually determined by the number of bits per segment.
	 * 
	 * @return  the maximum possible segment value for a series of the same type
	 */
	int getMaxSegmentValue();
	/**
	 * Gets the subsection from the series that comprises all segments
	 * 
	 * @return
	 */
	AddressSection getSection();
	/**
	 * Gets the subsection from the series starting from the given index
	 * 
	 * The first segment is at index 0.
	 * 
	 * @throws IndexOutOfBoundsException if index is negative
	 * @param index
	 * @return
	 */
	AddressSection getSection(int index);
	/**
	 * Gets the subsection from the series starting from the given index and ending just before the give endIndex
	 * 
	 * The first segment is at index 0.
	 * 
	 * @throws IndexOutOfBoundsException if index is negative or endIndex extends beyond the end of the series
	 * @param index
	 * @param endIndex
	 * @return
	 */
	AddressSection getSection(int index, int endIndex);
	/**
	 * Returns the segment from this series at the given index.
	 * 
	 * The first segment is at index 0.  
	 * A segment is an address division, see {@link AddressDivisionSeries#getDivision(int)}, the difference being that all segments in a given series are the same bit count, while divisions can have variable length.
	 * 
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the segment count
	 * 
	 * @return
	 */
	AddressSegment getSegment(int index);
	
	/**
	 * Returns the an array with the values of each segment as they would appear in the normalized with wildcards string.
	 * 
	 * @return
	 */
	String[] getSegmentStrings();
	
	/**
	 * Copies the existing segments into the given array.  The array size should be at least as large as {@link #getSegmentCount()} 
	 * 
	 * @throws IndexOutOfBoundsException if the provided array is too small
	 */
	void getSegments(AddressSegment segs[]);
	
	/**
	 * get the segments from start to end and insert into the segs array at the given index
	 * @param start the first segment index from this series to be included
	 * @param end the first segment index to be excluded
	 * @param segs the target array
	 * @param index where to insert the segments in the segs array
	 */
	void getSegments(int start, int end, AddressSegment segs[], int index);
	
	/**
	 * Returns the segments of this series of segments as an array.  This must create a new array, so for efficiency use {@link #getSegment(int)} and {@link #getSegmentCount()} instead when feasible.
	 * 
	 * @return
	 */
	AddressSegment[] getSegments();
	
	/**
	 * If this represents a series with ranging values, returns a series representing the lower values of the range.
	 * If this represents an series with a single value in each segment, returns this.
	 * 
	 * @return
	 */
	@Override
	AddressSegmentSeries getLower();
	
	/**
	 * If this represents a series with ranging values, returns a series representing the upper values of the range.
	 * If this represents a series with a single value in each segment, returns this.
	 * 
	 * @return
	 */
	@Override
	AddressSegmentSeries getUpper();
	
	/**
	 * Analogous to {@link java.math.BigInteger#testBit},
	 * Computes (this &amp; (1 &lt;&lt; n)) != 0)
	 * 
	 * @see #isOneBit(int)
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param n
	 * @return
	 */
	default boolean testBit(int n) {
		return isOneBit(getBitCount() - (n + 1));
	}
	
	/**
	 * Returns true if the bit in the lower value of this series at the given index is 1, where index 0 is the most significant bit.
	 * 
	 * For example, isOneBit(0) for 128.0.0.0 and isOneBit(31) for 0.0.0.1 are both true, while
	 * isOneBit(31) for 128.0.0.0/24 is false.  isOneBit(0) for 8000:: is true.
	 * 
	 * @see #testBit(int)
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param prefixBitIndex
	 * @return
	 */
	default boolean isOneBit(int prefixBitIndex) {
		int bitsPerSegment = getBitsPerSegment();
		AddressSegment segment = getSegment(prefixBitIndex / bitsPerSegment);
		int segmentBitIndex = prefixBitIndex % bitsPerSegment;
		// doing the calculation here allows us to skip bounds checking in AddressSegment#isOneBit
		int value = segment.getSegmentValue();
		return (value & (1 << (bitsPerSegment - (segmentBitIndex + 1)))) != 0;
	}
	
	@Override
	Iterable<? extends AddressSegmentSeries> getIterable();
	
	@Override
	Iterator<? extends AddressSegmentSeries> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegmentSeries> spliterator();
	@Override
	Stream<? extends AddressSegmentSeries> stream();
	/**
	 * Iterates through the individual prefixes.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	Iterator<? extends AddressSegmentSeries> prefixIterator();
	/**
	 * Partitions and traverses through the individual prefixes for the prefix length of this series.
	 * 
	 * @return
	 */
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixSpliterator();
	/**
	 * Iterates through the individual prefix blocks.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	Iterator<? extends AddressSegmentSeries> prefixBlockIterator();
	/**
	 * Returns a sequential stream of the individual prefixes for the prefix length of this series.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	Stream<? extends AddressSegmentSeries> prefixStream();
	/**
	 * Partitions and traverses through the individual prefix blocks for the prefix length of this series.
	 * 
	 * @return
	 */
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixBlockSpliterator();
	/**
	 * Returns a sequential stream of the individual prefix blocks for the prefix length of this series.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	Stream<? extends AddressSegmentSeries> prefixBlockStream();
	
	/**
	 * Iterates through the individual segments.
	 */
	Iterator<? extends AddressSegment[]> segmentsIterator();
	/**
	 * Partitions and traverses through the individual segment arrays.
	 * 
	 * @return
	 */
	AddressComponentRangeSpliterator<? extends AddressSegmentSeries, ? extends AddressSegment[]> segmentsSpliterator();
	/**
	 * Returns a sequential stream of the individual segment arrays.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	Stream<? extends AddressSegment[]> segmentsStream();
	/**
	 * Returns the series from the subnet that is the given increment upwards into the subnet range, with the increment of 0
	 * returning the first address in the range.
	 * 
	 * <p>
	 * If the subnet has multiple values and the increment exceeds the subnet size, then the 
	 * amount by which it exceeds the size - 1 is added to the upper series of the range (the final iterator value).
	 * <p>
	 * If the increment is negative, it is added to the lower series of the range (the first iterator value).  
	 * <p>
	 * If the subnet is just a single address values, the series is simply incremented by the given value, positive or negative.
	 * <p>
	 * If a subnet has multiple values, a positive increment value is equivalent to the same number of values from the {@link #iterator()}
	 * For instance, a increment of 0 is the first value from the iterator, an increment of 1 is the second value from the iterator, and so on. 
	 * A negative increment added to the subnet count is equivalent to the same number of values preceding the upper bound of the iterator.
	 * For instance, an increment of count - 1 is the last value from the iterator, an increment of count - 2 is the second last value, and so on.
	 * <p>
	 * An increment of size count gives you the series just above the highest series of the subnet.
	 * To get the series just below the lowest series of the subnet, use the increment -1.
	 * 
	 * @param increment
	 * @throws AddressValueException in case of underflow or overflow
	 * @return
	 */
	AddressSegmentSeries increment(long increment) throws AddressValueException;
	/**
	 * If the given increment is positive, adds the value to the upper series ({@link #getUpper()}) in the subnet range to produce a new series.
	 * If the given increment is negative, adds the value to the lower series ({@link #getLower()}) in the subnet range to produce a new series.
	 * If the increment is zero, returns this.
	 * <p>
	 * In the case where the series is a single value, this simply returns the address produced by adding the given increment to this address series.
	 * <p>
	 * 
	 * @param increment
	 * @throws AddressValueException in case of underflow or overflow
	 * @return
	 */
	AddressSegmentSeries incrementBoundary(long increment) throws AddressValueException;
	/**
	 * Produces the canonical representation of the address
	 * @return
	 */
	String toCanonicalString();
	/**
	 * Produces a short representation of the address while remaining within the confines of standard representation(s) of the address
	 * @return
	 */
	String toCompressedString();
	
	/**
	 * Returns a new segment series with the segments reversed.
	 * 
	 * This does not throw {@link IncompatibleAddressException} since all address series can reverse their segments.
	 * 
	 * @return
	 */
	AddressSegmentSeries reverseSegments();
	
	/**
	 * Returns a new segment series with the bits reversed.
	 * 
	 * @throws IncompatibleAddressException if reversing the bits within a single segment cannot be done 
	 * because the segment represents a range, and when all values in that range are reversed, the result is not contiguous.
	 * 
	 * In practice this means that to be reversible the range must include all values except possibly the largest and/or smallest.
	 * 
	 * @return
	 */
	@Override
	AddressSegmentSeries reverseBits(boolean perByte);
	/**
	 * Returns a new segment series with the bytes reversed.
	 * 
	 * @throws IncompatibleAddressException if the segments have more than 1 bytes, 
	 * and if reversing the bits within a single segment cannot be done because the segment represents a range that is not the entire segment range.
	 * 
	 * @return
	 */
	@Override
	AddressSegmentSeries reverseBytes();
	
	/**
	 * Returns a new segment series with the bytes reversed within each segment.
	 * 
	 * @throws IncompatibleAddressException if the segments have more than 1 bytes, 
	 * and if reversing the bits within a single segment cannot be done because the segment represents a range that is not the entire segment range.
	 * 
	 * @return
	 */
	AddressSegmentSeries reverseBytesPerSegment();
	/**
	 * If this series has a prefix length, returns the block for that prefix. Otherwise, this address series is returned.
	 * 
	 * @return the block of address series for the prefix length
	 */
	AddressSegmentSeries toPrefixBlock();
	/**
	 * Removes the prefix length while zeroing out the bits beyond the prefix.
	 * <p>
	 * If the series already has a prefix length, the bits outside the prefix become zero.
	 * Use {@link #withoutPrefixLength()} to remove the prefix length without changing the series values.
	 * <p>
	 * Equivalent to calling removePrefixLength(true)
	 * <p>
	 * @see #withoutPrefixLength() for an alternative which does not change the address series values.
	 * 
	 * @deprecated to remove the prefix length, use {@link #withoutPrefixLength()}, 
	 * 	to remove the prefix length and zero out the bits beyond the prefix, use {@link #adjustPrefixLength(int)}
	 *  with {@link #getBitCount()} as the argument, as in adjustPrefixLength(getBitCount())
	 * 
	 * @return
	 */
	@Deprecated
	AddressSegmentSeries removePrefixLength();
	/**
	 * Provides the same address with no prefix.  The values remain unchanged.
	 * <p>
	 * Use {@link #removePrefixLength()} as an alternative that deletes the host at the same time by zeroing the host values. 
	 */
	AddressSegmentSeries withoutPrefixLength();
	
	/**
	 * Removes the prefix length.   If zeroed is false, the bits that were host bits do not become zero, unlike {@link #removePrefixLength()}
	 * 
	 * @param zeroed whether the bits outside the prefix become zero
	 * @deprecated use {@link #removePrefixLength()} or {@link #withoutPrefixLength()}
	 * @return
	 */
	@Deprecated
	AddressSegmentSeries removePrefixLength(boolean zeroed);
	/**
	 * Increases or decreases prefix length to the next segment boundary.
	 * <p>
	 * Follows the same rules as {@link #adjustPrefixLength(int)}:<br>
	 * When prefix length is increased, the bits moved within the prefix become zero.
	 * When a prefix length is decreased, the bits moved outside the prefix become zero.
	 * To avoid the zeroing behaviour, use {@link #adjustPrefixBySegment(boolean, boolean)} with second arg false.
	 * <p>
	 * @param nextSegment whether to move prefix to previous or following segment boundary
	 * @return
	 */
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment);
	
	/**
	 * Increases or decreases prefix length to the next segment boundary.
	 * 
	 * @param nextSegment whether to move prefix to previous or following segment boundary
	 * @param zeroed whether the bits that move from one side of the prefix to the other become zero or retain their original values
	 * @return
	 */
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	
	/**
	 * Increases or decreases prefix length by the given increment.
	 * <p>
	 * When prefix length is increased, the bits moved within the prefix become zero.
	 * When the prefix is extended beyond the segment series boundary, it is removed.
	 * When a prefix length is decreased, the bits moved outside the prefix become zero.
	 * To avoid the zeroing behaviour, use {@link #adjustPrefixLength(int, boolean)} with second arg false.
	 * 
	 * @param adjustment
	 * @return
	 */
	AddressSegmentSeries adjustPrefixLength(int adjustment);
	
	/**
	 * Increases or decreases prefix length by the given increment.
	 * 
	 * @param zeroed whether the bits that move from one side of the prefix to the other become zero or retain their original values
	 * @param adjustment the increment
	 * @return
	 */
	AddressSegmentSeries adjustPrefixLength(int adjustment, boolean zeroed);
	
	/**
	 * Sets the prefix length.
	 * <p>
	 * If this series has a prefix length, and the prefix length is increased, the bits moved within the prefix become zero.
	 * For an alternative that does not set bits to zero, use {@link #setPrefixLength(int, boolean)} with the second argument as false.
	 * <p>
	 * When the prefix is extended beyond the segment series boundary, it is removed.
	 * <p>
	 * The bits that move from one side of the prefix length to the other (ie bits moved into the prefix or outside the prefix) are zeroed.
	 *
	 * @param prefixLength
	 * @return
	 */
	AddressSegmentSeries setPrefixLength(int prefixLength);
	/**
	 * Sets the prefix length.
	 * <p>
	 * When the prefix is extended beyond the segment series boundary, it is removed.
	 * <p>
	 * @param zeroed whether the bits that move from one side of the prefix length to the other (ie bits moved into the prefix or outside the prefix) are zeroed.
	 * @return
	 */
	AddressSegmentSeries setPrefixLength(int prefixLength, boolean zeroed);
	
	/**
	 * Applies the given prefix length to create a new segment series.
	 * <p>
	 * Similar to {@link #setPrefixLength(int)} except that prefix lengths are never increased. 
	 * When this series already has a prefix length that is less than or equal to the requested prefix length, this series is returned.
	 * <p>
	 * Otherwise the returned series has the given prefix length.
	 * <p>
	 * The bits moved outside the prefix will become zero in the returned series.
	 *
	 * @deprecated use #setPrefixLength(int)
	 * @see #setPrefixLength(int)
	 * @param prefixLength
	 * @return
	 */
	@Deprecated
	AddressSegmentSeries applyPrefixLength(int prefixLength);
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressGenericDivision;
import inet.ipaddr.format.util.AddressComponentSpliterator;
/**
 * Represents a single segment of an address.
 * <p>
 * The current implementations of this class are the most common representations of IPv4, IPv6 and MAC; 
 * segments are 1 byte for Ipv4, they are two bytes for Ipv6, and they are 1 byte for MAC addresses.
 * <p>
 * There are alternative forms of dividing addresses into divisions, such as the dotted representation for MAC like 1111.2222.3333,
 * the embedded IPv4 representation for IPv6 like f:f:f:f:f:f:1.2.3.4, the inet_aton formats like 1.2 for IPv4, and so on.
 * <p>
 * If those alternative representations were to follow the general rules for segment representation, then you could reuse this class
 * for those alternative representations.
 * <p>
 * The general rules are that segments have a whole number of bytes, and in a given address all segments have the same length.
 * <p>
 * When alternatives forms do not follow the general rules for segments,
 * you can use the {@link inet.ipaddr.format.standard.AddressDivision} interface instead.  
 * Divisions do not have the restriction that divisions of an address are equal length and a whole number of bytes.
 * Divisions can be grouped using {@link inet.ipaddr.format.standard.AddressDivisionGrouping}.
 * <p>
 * AddressSegment objects are immutable and thus also thread-safe.
 * 
 * @author sfoley
 *
 */
public interface AddressSegment extends AddressComponent, AddressGenericDivision {
	/**
	 * Returns the count of values in this address segment.
	 * 
	 * @return the same value as {@link #getCount()} as an integer
	 */
	int getValueCount();
	/**
	 * Returns the count of prefix values in this address segment for the given prefix bit count.
	 * 
	 * @return the count of values
	 */
	int getPrefixValueCount(int segmentPrefixLength);
	
	/**
	 * returns the lower value
	 */
	int getSegmentValue();
	/**
	 * returns the upper value
	 */
	int getUpperSegmentValue();
	/**
	 * If this segment represents a range of values, returns a segment representing just the lowest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	AddressSegment getLower();
	/**
	 * If this segment represents a range of values, returns a segment representing just the highest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	AddressSegment getUpper();
	@Override
	AddressSegment reverseBits(boolean perByte);
	@Override
	AddressSegment reverseBytes();
	@Override
	Iterable<? extends AddressSegment> getIterable();
	@Override
	Iterator<? extends AddressSegment> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegment> spliterator();
	@Override
	Stream<? extends AddressSegment> stream();
	boolean matches(int value);
	boolean matchesWithMask(int value, int mask);
	boolean matchesWithMask(int lowerValue, int upperValue, int mask);
	boolean overlaps(AddressSegment other);
	boolean contains(AddressSegment other);
	@Override
	boolean equals(Object other);
	/**
	 * Returns whether the given prefix bits match the same bits of the given segment.
	 * 
	 * @param other
	 * @param prefixLength
	 * @return
	 */
	boolean prefixEquals(AddressSegment other, int prefixLength);
	/**
	 * Analogous to {@link java.math.BigInteger#testBit},
	 * Computes (this &amp; (1 &lt;&lt; n)) != 0), using the lower value of this segment.
	 * 
	 * @see AddressSegmentSeries#testBit(int)
	 * @see #isOneBit(int)
	 * 
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param n
	 * @return
	 */
	default boolean testBit(int n) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(n < 0 || n >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << n)) != 0;
	}
	
	/**
	 * Returns true if the bit in the lower value of this segment at the given index is 1, where index 0 is the most significant bit.
	 * 
	 * @see AddressSegmentSeries#isOneBit(int)
	 * @see #testBit(int)
	 * 
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param segmentBitIndex
	 * @return
	 */
	default boolean isOneBit(int segmentBitIndex) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(segmentBitIndex < 0 || segmentBitIndex >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << (bitCount - (segmentBitIndex + 1)))) != 0;
	}
	/**
	 * Gets the maximum possible value for this type of segment (for the highest range value of this particular segment, use {@link #getUpper()}
	 * 
	 * @return
	 */
	int getMaxSegmentValue();
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4AddressCache;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection;
import inet.ipaddr.ipv4.IPv4AddressTrie.IPv4TrieNode.IPv4TrieKeyData;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
/**
 * An IPv4 address, or a subnet of multiple IPv4 addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * You can construct an IPv4 address from a byte array, from an int, from a {@link inet.ipaddr.Address.SegmentValueProvider}, 
 * from Inet4Address, from an {@link IPv4AddressSection} of 4 segments, or from an array of 4 {@link IPv4AddressSegment} objects.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * 
 * 
 * @custom.core
 * @author sfoley
 *
 */
public class IPv4Address extends IPAddress implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 4L;
	
	public static final char SEGMENT_SEPARATOR = '.';
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int SEGMENT_COUNT = 4;
	public static final int BYTE_COUNT = 4;
	public static final int BIT_COUNT = 32;
	public static final int DEFAULT_TEXTUAL_RADIX = 10;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE = 0xffffffff;
	public static final String REVERSE_DNS_SUFFIX = ".in-addr.arpa";
	
	transient IPv4AddressCache addressCache;
	private transient IPv4TrieKeyData cachedTrieKeyData;
	/**
	 * Constructs an IPv4 address or subnet.
	 * @param segments the address segments
	 * @throws AddressValueException if segments is not length 4
	 */
	public IPv4Address(IPv4AddressSegment[] segments) throws AddressValueException {
		this(segments, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param segments the address segments
	 * @param networkPrefixLength
	 * @throws AddressValueException if segments is not length 4
	 */
	public IPv4Address(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(segments, networkPrefixLength));
		if(getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", getSegmentCount());
		}
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * @param section the address segments
	 * @throws AddressValueException if section does not have 4 segments
	 */
	public IPv4Address(IPv4AddressSection section) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", section.getSegmentCount());
		}
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param address the 4 byte IPv4 address
	 */
	public IPv4Address(int address) {
		this(address, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param address the 4 byte IPv4 address
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(int address, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSectionInternal(address, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address.
	 *
	 * @param inet4Address the java.net address object
	 */
	public IPv4Address(Inet4Address inet4Address, Integer networkPrefixLength) {
		this(inet4Address, inet4Address.getAddress(), networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv4 address.
	 *
	 * @param inet4Address the java.net address object
	 */
	public IPv4Address(Inet4Address inet4Address) {
		this(inet4Address, inet4Address.getAddress(), null);
	}
	
	private IPv4Address(Inet4Address inet4Address, byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, 0, bytes.length, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
		getSection().setInetAddress(inet4Address);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param bytes the 4 byte IPv4 address in network byte order - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then then the bytes are sign-extended to 4 bytes.
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes) throws AddressValueException {
		this(bytes, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * Similar to {@link #IPv4Address(byte[])} except that you can specify the start and end of the address in the given byte array.
	 * 
	 * @param bytes
	 * @throws AddressValueException
	 */
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param bytes the 4 byte IPv4 address in network byte order - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then the bytes are sign-extended to 4 bytes.
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength);
	}
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * Similar to {@link #IPv4Address(byte[],Integer)} except that you can specify the start and end of the address in the given byte array.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param bytes the 4 byte IPv4 address - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then the bytes are sign-extended to 4 bytes.
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param lowerValueProvider supplies the 1 byte lower values for each segment
	 * @param upperValueProvider supplies the 1 byte upper values for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * 
	 * @param lowerValueProvider supplies the 1 byte lower values for each segment
	 * @param upperValueProvider supplies the 1 byte upper values for each segment
	 */
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param valueProvider supplies the 1 byte value for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param valueProvider supplies the 1 byte value for each segment
	 */
	public IPv4Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Override
	public IPv4AddressSection getSection() {
		return (IPv4AddressSection) super.getSection();
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	
	@Override
	public IPv4AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv6Address ipv6Addr = getConverted(options);
		if(ipv6Addr != null) {
			IPAddressStringDivisionSeries ipv6Parts[] = ipv6Addr.getParts(options.ipv6ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv6Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv6Parts,  0, parts, tmp.length, ipv6Parts.length);
		}
		return parts;
	}
	
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	
	@Override
	public boolean isIPv4() {
		return true;
	}
	
	@Override
	public IPv4Address toIPv4() {
		return this;
	}
	
	@Override
	public boolean isIPv4Convertible() {
		return true;
	}
	
	/**
	 * Create an IPv6 mixed address using the given ipv6 segments and using this address for the embedded IPv4 segments
	 * 
	 * @param segs
	 * @return
	 */
	public IPv6Address getIPv6Address(IPv6AddressSegment segs[]) {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		return creator.createAddress(IPv6AddressSection.createSection(creator, segs, this)); /* address creation */
	}
	
	public IPv6Address getIPv4MappedAddress() {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = zero;
		segs[5] = creator.createSegment(IPv6Address.MAX_VALUE_PER_SEGMENT);
		return getIPv6Address(segs);
	}
	
	/**
	 * Override this method to convert in your own way.
	 * The default behaviour uses IPv4-mapped conversion.
	 * 
	 * You should also override {@link #toIPv6()} to match the conversion.
	 * 
	 * @see IPv4Address#toIPv6()
	 */
	@Override
	public boolean isIPv6Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv6Convertible(this);
	}
	
	/**
	 * Returns this address converted to IPv6.
	 * <p>
	 * You can also use {@link #isIPv6Convertible()} to determine convertibility.  Both use an instance of {@link IPAddressConverter.DefaultAddressConverter} which uses IPv4-mapped address mappings from rfc 4038.
	 * <p>
	 * Override this method and {@link IPv6Address#isIPv6Convertible()} if you wish to map IPv4 to IPv6 according to the mappings defined by
	 * in {@link IPv6Address#isIPv4Compatible()}, {@link IPv6Address#isIPv4Mapped()}, {@link IPv6Address#is6To4()} or some other mapping.
	 * <p>
	 * If you override this method, you should also override the {@link IPv4Address#isIPv6Convertible()} method to match this behaviour, 
	 * and potentially also override the reverse conversion {@link IPv6Address#toIPv4()} in your {@link IPv6Address} subclass.
	 */
	@Override
	public IPv6Address toIPv6() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv6(this);
	}
	/**
	 * The broadcast address has the same prefix but a host that is all 1 bits.
	 * If this address or subnet is not prefixed, this returns the address of all 1 bits, the "max" address.
	 * 
	 * @return
	 */
	public IPv4Address toBroadcastAddress() {
		return toMaxHost();
	}
	
	/**
	 * The network address has the same prefix but a zero host.
	 * If this address or subnet is not prefixed, this returns the zero "any" address.
	 * 
	 * @return
	 */
	public IPv4Address toNetworkAddress() {
		return toZeroHost();
	}
	
	void cache(IPv4Address lower, IPv4Address upper) {
		getSection().cache(this, lower, upper);
	}
	
	@Override
	public IPv4Address getLowerNonZeroHost() {
		return getSection().getLowestOrHighest(this, true, true);
	}
	
	@Override
	public IPv4Address getLower() {
		return getSection().getLowestOrHighest(this, true, false);
	}
	
	@Override
	public IPv4Address getUpper() {
		return getSection().getLowestOrHighest(this, false, false);
	}
	
	/**
	 * Returns the address (or lowest value of the address if a subnet) as a signed integer
	 * @return the signed integer lower address value
	 */
	public int intValue() {
		return getSection().intValue();
	}
	
	/**
	 * Returns the address (or highest value of the address if a subnet) as a signed integer
	 * @return the signed integer upper address value
	 */
	public int upperIntValue() {
		return getSection().upperIntValue();
	}
	
	/**
	 * Returns the address (or lowest value of the address if a subnet) as a positive integer
	 * @return the positive integer lower address value
	 */
	public long longValue() {
		return getSection().longValue();
	}
	
	/**
	 * Returns the address (or highest value of the address if a subnet) as a positive integer
	 * @return the positive integer upper address value
	 */
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	
	IPv4TrieKeyData getTrieKeyCache() {
		IPv4TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv4TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			keyData.uint32Val = intValue();
			if(prefLen != null) {
				int bits = prefLen;
				keyData.nextBitMask32Val = 0x80000000 >>> bits;
				keyData.mask32Val = getNetwork().getNetworkMask(bits, false).intValue();
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the same number of segments starting at replacementStartIndex from the replacement section
	 * 
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementIndex
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv4Address replace(int startIndex, int endIndex, IPv4Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	
	/**
	 * Replaces segments starting from startIndex with as many segments as possible from the replacement section
	 * 
	 * @param startIndex
	 * @param replacement
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv4Address replace(int startIndex, IPv4AddressSection replacement) {
		int replacementCount = Math.min(IPv4Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv4Address reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	
	@Override
	public IPv4Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	
	@Override
	public IPv4Address reverseBytesPerSegment() {
		return this;
	}
	
	@Override
	public IPv4Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	
	private IPv4Address checkIdentity(IPv4AddressSection newSection) {
		IPv4AddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	
	@Override
	public IPv4Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv4Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv4Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	
	@Override
	public IPv4Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override
	@Deprecated
	public IPv4Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	
	@Override
	public AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		return getSection().iterator(this, getAddressCreator(), null);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> spliterator() {
		return getSection().spliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> nonZeroHostIterator() {
		Predicate<IPv4AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = s -> getSection().isZeroHost(s, prefLength);
		}
		return getSection().iterator(this, getAddressCreator(), excludeFunc);
	}
	
	@Override
	public Iterator<IPv4Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), true, prefixLength);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getAddressCreator(), segmentCount);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getAddressCreator(), segmentCount);
	}
	
	@Override
	public Stream<IPv4Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4Address> sequentialBlockIterator() {
		return (Iterator<IPv4Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4Address> sequentialBlockStream() {
		return (Stream<IPv4Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public IPv4Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	
	@Override
	public IPv4Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * Equivalent to {@link #enumerate(IPAddress)} but returns a Long rather than a BigInteger.
	 */
	public Long enumerateIPv4(IPv4Address other){
		return IPv4AddressSection.enumerateIPv4(getSection(), other.getSection());
	}
	
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv4Address) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv4()) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	IPv4AddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return defaultIpv4Network();
	}
	
	/**
	 * Returns the IPv6 network used by {@link #getIPv4MappedAddress()} and {@link #getIPv6Address(IPv6AddressSegment[])}
	 * 
	 * @return
	 */
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	@Override
	protected IPv4Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv4Address converted = arg.toIPv4();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv4Address intersect(IPAddress other) throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection section = thisSection.intersect(convertArg(other).getSection());
		if(section == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result = creator.createAddress(section); /* address creation */
		return result;
	}
	
	@Override
	public IPv4Address[] subtract(IPAddress other)  throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result[] = new IPv4Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = creator.createAddress(sections[i]); /* address creation */
		}
		return result;
	}
	
	@Override
	public IPv4Address toZeroHost() {
		return toZeroHost(false);
	}
	
	@Override
	protected IPv4Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv4Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv4Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv4Address toMaxHost() {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();//cached
		}
		return checkIdentity(getSection().createMaxHost());
	}
	
	@Override
	public IPv4Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv4Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv4Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	
	@Override
	public IPv4Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv4Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	
	@Override
	public IPv4Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address getHostMask() {
		return (IPv4Address) super.getHostMask();
	}
	@Override
	public IPv4Address getNetworkMask() {
		return (IPv4Address) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv4AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv4Address assignPrefixForSingleBlock() {
		return (IPv4Address) super.assignPrefixForSingleBlock();
	}
	
	@Override
	public IPv4Address assignMinPrefixForBlock() {
		return (IPv4Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return (IPv4Address) IPv4AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv4Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv4AddressSection.coverWithPrefixBlock(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	/**
	 * Produces an array of prefix blocks that cover the same set of addresses as this.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(true);
		return list.toArray(new IPv4Address[list.size()]);
	}
	
	@Override
	public IPv4Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::assignPrefixForSingleBlock,
				IPv4Address::withoutPrefixLength,
				getAddressCreator()::createAddressArray);
	}
	
	/**
	 * Produces an array of blocks that are sequential that cover the same set of addresses as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv4Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4Address[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(false);
		return list.toArray(new IPv4Address[list.size()]);
	}
	
	@Override
	public IPv4Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::withoutPrefixLength,
				getAddressCreator());
	}
	
	@Override
	public IPv4AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv4Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]);
		}
		converted[0] = this;
		return converted;
	}
	
	@Override
	public IPv4Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator());
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getAddressCreator()::createSequentialBlockAddress;
	}
	@Override
	public Inet4Address toUpperInetAddress() {
		return (Inet4Address) super.toUpperInetAddress();
	}
	
	@Override
	public Inet4Address toInetAddress() {
		return (Inet4Address) super.toInetAddress();
	}
	
	@Override
	@Deprecated
	public IPv4AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv4AddressSeqRange(this, convertArg(other));
	}
	
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		IPv4Address thiz = withoutPrefixLength();
		return new IPv4AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			//1110...
			IPv4AddressSegment seg0 = getSegment(0);
			//http://www.tcpipguide.com/free/t_IPMulticastAddressing.htm
			//rfc4607 and https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml
			
			//239.0.0.0-239.255.255.255 organization local
			if(seg0.matches(239)) {
				return true;
			}
			IPv4AddressSegment seg1 = getSegment(1), seg2 = getSegment(2);
			
			return 
					// 224.0.0.0 to 224.0.0.255 local 
					// includes link local multicast name resolution https://tools.ietf.org/html/rfc4795 224.0.0.252
					(seg0.matches(224) && seg1.isZero() && seg2.isZero())
					
					//232.0.0.1 - 232.0.0.255	Reserved for IANA allocation	[RFC4607]			
					//232.0.1.0 - 232.255.255.255	Reserved for local host allocation	[RFC4607]
									
					|| (seg0.matches(232) && !(seg1.isZero() && seg2.isZero()));
		}
		return isLinkLocal() || isPrivate() || isAnyLocal();
	}
	
	/**
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	@Override
	public boolean isLinkLocal() {
		if(isMulticast()) {
			//224.0.0.252	Link-local Multicast Name Resolution	[RFC4795]
			return getSegment(0).matches(224) && getSegment(1).isZero() && getSegment(2).isZero() &&  getSegment(3).matches(252);
		}
		return getSegment(0).matches(169) && getSegment(1).matches(254);
	}
	/**
	 * Unicast addresses allocated for private use
	 * 
	 * @see java.net.InetAddress#isSiteLocalAddress()
	 */
	public boolean isPrivate() {
		// refer to RFC 1918
        // 10/8 prefix
        // 172.16/12 prefix (172.16.0.0  172.31.255.255)
        // 192.168/16 prefix
		IPv4AddressSegment seg0 = getSegment(0);
		IPv4AddressSegment seg1 = getSegment(1);
		return seg0.matches(10)
			|| (seg0.matches(172) && seg1.matchesWithPrefixMask(16, 4))
			|| (seg0.matches(192) && seg1.matches(168));
	}
	
	@Override
	public boolean isMulticast() {
		// 1110...
		//224.0.0.0/4
		return getSegment(0).matchesWithPrefixMask(0xe0, 4);
	}
	
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	@Override
	public boolean isLoopback() {
		return getSegment(0).matches(127);
	}
	
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public interface IPv4AddressConverter {
		/**
		 * If the given address is IPv4, or can be converted to IPv4, returns that {@link IPv4Address}.  Otherwise, returns null.
		 */
		IPv4Address toIPv4(IPAddress address);
	}
	
	////////////////string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getIPv6Network()).getParentBuilder().toParams();
	}
	
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 * 
	 * @param lowerValueProvider
	 * @param upperValueProvider
	 * @param prefixLength
	 * @param network use {@link #defaultIpv4Network()} if there is no custom network in use
	 * @return
	 */
	public static String toNormalizedString(IPv4AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, null);
	}
	/**
	 * @author sfoley
	 *
	 */
	public static enum inet_aton_radix {
		OCTAL, HEX, DECIMAL;
		
		int getRadix() {
			if(this == OCTAL) {
				return 8;
			} else if(this == HEX) {
				return 16;
			}
			return 10;
		}
		
		String getSegmentStrPrefix() {
			if(this == OCTAL) {
				return "0";
			} else if(this == HEX) {
				return "0x";
			}
			return null;
		}
		
		@Override
		public String toString() {
			if(this == OCTAL) {
				return "octal";
			} else if(this == HEX) {
				return "hexadecimal";
			}
			return "decimal";
		}
	}
	/**
	 * Returns a string like the inet_aton style string
	 * @return
	 */
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		return getSection().toInetAtonString(radix);
	}
	
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		return getSection().toInetAtonString(radix, joinedCount);
	}
	
	@Override
	public String toSegmentedBinaryString() {
		return getSection().toSegmentedBinaryString();
	}
	
	@Override
	public String toUNCHostName() {
		return super.toCanonicalString();
	}
	
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	
	private IPv6Address getConverted(IPv4StringBuilderOptions opts) {
		if(opts.includes(IPv4StringBuilderOptions.IPV6_CONVERSIONS)) {
			IPv6AddressConverter converter = opts.converter;
			return converter.toIPv6(this);
		}
		return null;
	}
	
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4StringCollection coll = new IPv4StringCollection();
		IPAddressPartStringCollection sectionColl = getSection().toStringCollection(opts);
		coll.addAll(sectionColl);
		IPv6Address ipv6Addr = getConverted(opts);
		if(ipv6Addr != null) {
			IPAddressPartStringCollection ipv6StringCollection = ipv6Addr.toStringCollection(opts.ipv6ConverterOptions);
			coll.addAll(ipv6StringCollection);
		}
		return coll;
	}
}
/*
 * Copyright 2022-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.List;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.SubNodesMappingAssociative;
/** 
 * AssociativeAddedTree is similar to AddedTree but originates from an AssociativeTrie.
 * The nodes of this tree have the same values as the corresponding nodes in the original trie.
 */
public class AssociativeAddedTree<E extends Address, V> extends AddedTreeBase<E, SubNodesMappingAssociative<E,V>> {
	public AssociativeAddedTree(AssociativeAddressTrie<E, SubNodesMappingAssociative<E,V>> wrapped) {
		super(wrapped);
	}
	/** 
	 * AssociativeAddedTreeNode represents a node in an AssociativeAddedTree.
	 */
	public static class AssociativeAddedTreeNode<E extends Address, V> extends AddedTreeNodeBase<E,SubNodesMappingAssociative<E,V>> {
		public AssociativeAddedTreeNode(AssociativeTrieNode<E, SubNodesMappingAssociative<E, V>> node) {
			super(node);
		}
		@Override
		public AssociativeAddedTreeNode<E,V>[] getSubNodes() {
			SubNodesMappingAssociative<E, V> value = node.getValue();
			if(value == null) {
				return null;
			}
			List<AssociativeTrieNode<E, SubNodesMappingAssociative<E, V>>> subNodes = value.subNodes;  
			if(subNodes == null || subNodes.size() == 0) {
				return null;
			}
			@SuppressWarnings("unchecked")
			AssociativeAddedTreeNode<E,V>[] nodes = (AssociativeAddedTreeNode<E,V>[]) new AssociativeAddedTreeNode[subNodes.size()];
			for(int i = 0; i < nodes.length; i++) {
				nodes[i] = new AssociativeAddedTreeNode<E,V>(subNodes.get(i));
			}
			return nodes;
		}
	}
	
	/**
	 * Returns the root of this tree, which corresponds to the root of the originating trie.
	 */
	@Override
	public AssociativeAddedTreeNode<E,V> getRoot()  {
		return new AssociativeAddedTreeNode<E, V>(wrapped.getRoot());
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Objects;
import java.util.Queue;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.AddressBounds;
import inet.ipaddr.format.util.AddressTrieSet.Range;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
/**
 * Wraps a {@link inet.ipaddr.format.util.AssociativeAddressTrie} to view it as a Java Collections Framework map, 
 * implementing the {@link java.util.Map}, {@link java.util.SortedMap}, and {@link java.util.NavigableMap} interfaces.
 * <p>
 * Like {@link java.util.TreeMap}, this map is backed by a binary tree and implements the same interfaces that {@link java.util.TreeMap} does.  
 * But there are some significant differences between the two binary tree implementations.
 * <p>
 * A trie is naturally balanced and can only reach a depth corresponding to the number of bits in the keys, 
 * which is 32 for IPv4 and 128 for IPv6 tries.  The TreeMap is balanced using red-black balancing.
 * <p>
 * The {@link inet.ipaddr.format.util.AssociativeAddressTrie} allows you to modify the map entries using {@link java.util.Map.Entry#setValue(Object)},
 * while {@link java.util.TreeMap} does not.  The entries provided by the {@link java.util.TreeMap} are copies of the original nodes,
 * so that the original nodes can be re-purposed.  The nodes are not exposed.
 * <p>
 * In the {@link inet.ipaddr.format.util.AssociativeAddressTrie} nodes are not re-purposed, and in fact they are also exposed.  
 * This enables navigation through the nodes.
 * The node hierarchy has a special meaning, there is only one hierarchy for any given set of addresses, 
 * since it is determined by prefix block subnet containment.  The hierarchy enables certain address-specific containment-based operations,
 * such as subnet deletion or containment checks. 
 * <p>
 * In the trie map, when doing lookups and some other operations, only parts of the address keys are examined at each node in the binary tree search, 
 * rather than comparisons of the whole key, as with {@link java.util.TreeMap}.  
 * The trie map supports only the one comparison representing subnet containment, which is based on bit values and prefix length.
 * The TreeMap is a general-purpose map supporting any natural ordering or Comparator.
 * <p>
 * With the trie map, only addresses that are either individual address or prefix block subnets of the same type and version can be added to the trie,
 * see {@link inet.ipaddr.format.util.AddressTrie.AddressComparator} for a comparator for the ordering.
 * <p>
 * Should you wish to store, in a map, address instances that are not individual address or prefix block subnets,
 * you can use {@link java.util.TreeMap} or any other Java collections framework map to store addresses of any type,
 * or addresses of different versions or types in the same map,
 * since all address items in this library are comparable with a natural ordering.  
 * There are additional orderings provided by this library as well, see {@link inet.ipaddr.AddressComparator}.
 * 
 * 
 * 
 * @author scfoley
 *
 * @param <K> the address type
 * @param <V> the type of the mapped values
 */
public class AddressTrieMap<K extends Address, V> extends AbstractMap<K, V> implements NavigableMap<K, V>, Cloneable, Serializable {
	private static final long serialVersionUID = 1L;
	private AssociativeAddressTrie<K, V> trie; // the backing trie
	private final boolean isReverse;
	private final Range<K> bounds;
	private EntrySet<K,V> entrySet; // cached
	private AddressTrieSet<K> keySet; // cached
	private AddressTrieMap<K, V> descending; // cached
	public AddressTrieMap(AssociativeAddressTrie<K, V> trie) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.map == null) {
			trie.map = this;
		}
	}
	public AddressTrieMap(AssociativeAddressTrie<K, V> trie, Map<? extends K, ? extends V> map) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.map == null) {
			trie.map = this;
		}
		putAll(map);
	}
	AddressTrieMap(AssociativeAddressTrie<K, V> trie, Range<K> bounds, boolean isReverse) {
		this.trie = trie;
		this.bounds = bounds;
		this.isReverse = isReverse;
		if(trie.map == null && !isReverse && bounds == null) {
			trie.map = this;
		}
	}
	boolean isBounded() {
		return bounds != null;
	}
	@Override
	public AddressTrieMap<K, V> descendingMap() {
		AddressTrieMap<K, V> desc = descending;
		if(desc == null) {
			Range<K> reverseBounds = isBounded() ?  bounds.reverse() : null;
			desc = new AddressTrieMap<K, V>(trie, reverseBounds, !isReverse);
			descending = desc;
			desc.descending = this;
		}
		return desc;
	}
	@Override
	public AddressTrieSet<K> descendingKeySet() {
		return descendingMap().keySet();
	}
	/**
	 * Return a trie representing this map.
	 * <p>
	 * If this map has a restricted range, see {@link #hasRestrictedRange()}, 
	 * this generates a new trie corresponding to the map with only the nodes pertaining to the restricted range sub-map.
	 * Otherwise this returns the original backing trie for this map.
	 * <p>
	 * When a new trie is generated, the original backing trie for this map remains the same, it is not changed to the new trie.
	 * <p>
	 * The returned trie will always have the same natural trie ordering,
	 * even if this map has the reverse ordering.
	 * 
	 */
	public AssociativeAddressTrie<K, V> asTrie() {
		if(isBounded()) {
			return trie.clone();
		}
		if(!isReverse) {
			trie.map = this;// in case we constructed the set first, we put a reference back to us
		}
		return trie;
	}
	/**
	 * Returns whether this map is the result of a call to {@link #headMap(Address)}, {@link #tailMap(Address)},
	 * {@link #subMap(Address, Address)} or any of the other methods with the same names.
	 * 
	 * @return
	 */
	public boolean hasRestrictedRange() {
		return isBounded();
	}
	/**
	 * Returns the range if this map has a restricted range, see {@link #hasRestrictedRange()}.  Otherwise returns null.
	 * 
	 * @return
	 */
	public Range<K> getRange() {
		return bounds;
	}
	public static class EntrySet<K extends Address, V> extends AbstractSet<Entry<K,V>> implements Serializable {
		private static final long serialVersionUID = 1L;
		AssociativeAddressTrie<K, V> trie;
		private final boolean isReverse;
		EntrySet(AssociativeAddressTrie<K, V> trie, boolean isReverse) {
			this.trie = trie;
			this.isReverse = isReverse;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<Entry<K,V>> iterator() {
			Iterator<? extends Entry<K, V>> result = trie.nodeIterator(!isReverse);
			return (Iterator<Entry<K, V>>) result;
		}
		/**
		 * Returns an iterator that visits containing subnet blocks before their contained addresses and subnet blocks.
		 * <p>
		 */
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> containingFirstIterator() {
			Iterator<? extends Entry<K, V>> it = trie.containingFirstIterator(!isReverse);
			return (Iterator<Entry<K, V>>) it;
		}
		/**
		 * Returns an iterator that visits contained addresses and subnet blocks before their containing subnet blocks.
		 * @return
		 */
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> containedFirstIterator() {
			Iterator<? extends Entry<K, V>> it = trie.containedFirstIterator(!isReverse);
			return (Iterator<Entry<K, V>>) it;
		}
		/**
		 * Iterates from largest prefix blocks to smallest to individual addresses.
		 * 
		 * @return
		 */	
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> blockSizeIterator() {
			Iterator<? extends Entry<K, V>> iterator = trie.blockSizeNodeIterator(!isReverse);
			return (Iterator<Entry<K, V>>) iterator;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<Entry<K,V>> spliterator() {
			Spliterator<? extends Entry<K, V>> result = trie.nodeSpliterator(!isReverse);
			return (Spliterator<Entry<K, V>>) result;
		}
		@Override
		public int size() {
			return trie.size();
		}
		@Override
		public boolean isEmpty() {
			return trie.isEmpty();
	    }
		@SuppressWarnings("unchecked")
		@Override
		public boolean contains(Object o) {
			if (!(o instanceof Entry)) {
				return false;
			}
			Entry<K,?> entry = (Entry<K,?>) o;
			Entry<K,V> existingNode = trie.getAddedNode(entry.getKey());
			return existingNode != null && Objects.equals(existingNode.getValue(), entry.getValue());
		}
		@SuppressWarnings("unchecked")
		@Override
		public boolean remove(Object o) {
			if (!(o instanceof Entry)) {
				return false;
			}
			Entry<K,?> entry = (Entry<K,?>) o; 
			AssociativeTrieNode<K, V> existingNode = trie.getAddedNode(entry.getKey());
			if(existingNode != null && Objects.equals(existingNode.getValue(), entry.getValue())) {
				existingNode.remove();
				return true;
			}
			return false;
		}
		@Override
		public void clear() {
			trie.clear();
		}
		@Override
		public int hashCode() {
			return trie.hashCode();
		}
		@Override
		public boolean equals(Object o) {
			if(o instanceof AddressTrieMap.EntrySet) {
				EntrySet<?,?> other = (EntrySet<?,?>) o;
				return trie.equals(other.trie);
			} 
			return super.equals(o);
		}
		@Override
		public boolean removeAll(Collection<?> collection) {
			if(collection instanceof List || collection instanceof Queue || collection.size() < size()) {
				boolean result = false;
				for (Object object : collection) {
					if(remove(object)) {
						result = true;
					}
				}
				return result;
			}
			return removeIf(collection::contains);
	    }
	}
	@Override
	public AddressTrieSet<K> keySet() {
		AddressTrieSet<K> set = keySet;
		if(set == null) {
			set = new AddressTrieSet<K>(trie, bounds, isReverse);
			keySet = set;
		}
		return set;
	}
	@Override
	public AddressTrieSet<K> navigableKeySet() {
		return keySet();
	}
	@Override
	public EntrySet<K,V> entrySet() {
		EntrySet<K,V> set = entrySet;
		if(set == null) {
			set = new EntrySet<K,V>(trie, isReverse);
			entrySet = set;
		}
		return set;
	}
	@Override
	public V merge(K key, V suppliedValue,
            BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
		if(suppliedValue == null) {
			throw new NullPointerException();
		}
		AssociativeTrieNode<K, V> node = trie.remap(key, existingValue -> {
			V newValue =  (existingValue == null) ? suppliedValue : remappingFunction.apply(existingValue, suppliedValue);
			return newValue;
		});
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		AssociativeTrieNode<K, V> node = trie.remap(key, existingValue -> {
			V newValue = remappingFunction.apply(key, existingValue);
			return newValue;
		});
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V computeIfAbsent(K key, Function<? super K, ? extends V> remappingFunction) {
		AssociativeTrieNode<K, V> node = trie.remapIfAbsent(key, () -> remappingFunction.apply(key), false);
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V putIfAbsent(K key, V value) {
		return trie.remapIfAbsent(key, () -> value, true).getValue();
	}
	@Override
	public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			if(prevValue != null) {
				 V newValue = remappingFunction.apply(key, prevValue);
				 if (newValue != null) {
	                node.setValue(newValue);
	            } else {
	            	node.remove();
	            }
				return newValue;
			}
		}
		return null;
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean containsKey(Object key) {
		return trie.contains((K) key);
	}
	@Override
	public boolean containsValue(Object value) {
		Iterator<? extends AssociativeTrieNode<K, V>> iterator = trie.nodeIterator(true);
		while (iterator.hasNext()) {
			AssociativeTrieNode<K, V> node = iterator.next();
			if (value.equals(node.getValue())) {
				return true;
			}
		}
		return false;
	}
	@SuppressWarnings("unchecked")
	@Override
	public V get(Object key) {
		return trie.get((K) key);
	}
	/**
	 * Maps the given single address or prefix block subnet to the given value in the map.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * See {@link AssociativeAddressTrie}
	 */
	@Override
	public V put(K key, V value) {
		return trie.put(key, value);
	}
	@SuppressWarnings("unchecked")
	@Override
	public V remove(Object key) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		if(node != null) {
			V result = node.getValue();
			node.remove();
			return result;
		}
		return null;
	}
	private AssociativeTrieNode<K,V> getNode(K key) {
		return (AssociativeTrieNode<K, V>) trie.getAddedNode(key);
	}
	@SuppressWarnings("unchecked")
	@Override
	public V getOrDefault(Object key, V defaultValue) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		return node == null ? defaultValue : node.getValue();
	}
	@Override
	public void forEach(BiConsumer<? super K, ? super V> action) {
		Iterator<? extends AssociativeTrieNode<K,V>> iterator = trie.nodeIterator(!isReverse);
		if(iterator.hasNext()) {
			AssociativeTrieNode<K,V> next = iterator.next();
			action.accept(next.getKey(), next.getValue());
			while(iterator.hasNext()) {
				next = iterator.next();
				action.accept(next.getKey(), next.getValue());
			}
		} else if(action == null) {
			throw new NullPointerException();
		}
	}
	@Override
	public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
		Iterator<? extends AssociativeTrieNode<K,V>> iterator = trie.nodeIterator(!isReverse);
		if(iterator.hasNext()) {
			AssociativeTrieNode<K,V> next = iterator.next();
			next.setValue(function.apply(next.getKey(), next.getValue()));
			while(iterator.hasNext()) {
				next = iterator.next();
				next.setValue(function.apply(next.getKey(), next.getValue()));
			}
		} else if(function == null) {
			throw new NullPointerException();
		}
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean remove(Object key, Object value) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		if(node != null) {
			V prevValue = node.getValue();
			if(Objects.equals(value, prevValue)) {
				node.remove();
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean replace(K key, V oldValue, V newValue) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			if(Objects.equals(oldValue, prevValue)) {
				node.setValue(newValue);
				return true;
			}
		}
		return false;
	}
	@Override
	public V replace(K key, V value) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			node.setValue(value);
			return prevValue;
		}
		return null;
	}
	/**
     * Returns the number of mappings in this map.  
     * This is a constant time operation, unless the map has a restricted range, see {@link #hasRestrictedRange()},
     * in which case it is a linear time operation proportional to the number of mappings.
     * 
     * @return the number of elements in this map
     */
	@Override
	public int size() {
		return trie.size();
	}
	@Override
	public boolean isEmpty() {
		return trie.isEmpty();
    }
	@Override
	public void clear() {
    	trie.clear();
	}
	@Override
	public int hashCode() {
		return trie.hashCode();
	}
	private AddressTrieMap<K,V> toSubMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
		if(isReverse) {
			K tmp = fromKey;
			boolean tmpInc = fromInclusive;
			fromKey = toKey;
			fromInclusive = toInclusive;
			toKey = tmp;
			toInclusive = tmpInc;
		}
		AddressBounds<K> bounds = trie.bounds, newBounds;
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(fromKey, fromInclusive, toKey, toInclusive, trie.getComparator());
		} else {
			newBounds = bounds.restrict(fromKey, fromInclusive, toKey, toInclusive);
			
		}
		if(newBounds == null) {
			return this;
		}
		Range<K> newRange = new Range<K>(newBounds, isReverse);
		return new AddressTrieMap<K,V>(trie.createSubTrie(newBounds), newRange, isReverse);
	}
	@Override
	public AddressTrieMap<K,V> subMap(K fromKey, K toKey) {
		return subMap(fromKey, true, toKey, false);
	}
	
	@Override
	public AddressTrieMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
		if(fromKey == null || toKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(fromKey, fromInclusive, toKey, toInclusive);
	}
	@Override
	public AddressTrieMap<K,V> headMap(K toKey) {
		return headMap(toKey, false);
	}
	@Override
	public AddressTrieMap<K, V> headMap(K toKey, boolean inclusive) {
		if(toKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(null, true, toKey, inclusive);
	}
	@Override
	public AddressTrieMap<K,V> tailMap(K fromKey) {
		return tailMap(fromKey, true);
	}
	@Override
	public AddressTrieMap<K, V> tailMap(K fromKey, boolean inclusive) {
		if(fromKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(fromKey, inclusive, null, false);
	}
	@Override
	public Entry<K, V> firstEntry() {
		return isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
	}
	@Override
	public K firstKey() {
		return keySet().first();
	}
	@Override
	public Entry<K, V> lastEntry() {
		return isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
	}
	@Override
	public K lastKey() {
		return keySet().last();
	}
	@Override
	public Entry<K, V> lowerEntry(K key) {
		return isReverse ? trie.higherAddedNode(key) : trie.lowerAddedNode(key);
	}
	@Override
	public K lowerKey(K key) {
		return keySet().lower(key);
	}
	@Override
	public Entry<K, V> floorEntry(K key) {
		return isReverse ? trie.ceilingAddedNode(key) : trie.floorAddedNode(key);
	}
	@Override
	public K floorKey(K key) {
		return keySet().floor(key);
	}
	@Override
	public Entry<K, V> ceilingEntry(K key) {
		return isReverse ? trie.floorAddedNode(key) : trie.ceilingAddedNode(key);
	}
	@Override
	public K ceilingKey(K key) {
		return keySet().ceiling(key);
	}
	@Override
	public Entry<K, V> higherEntry(K key) {
		return isReverse ? trie.lowerAddedNode(key) : trie.higherAddedNode(key);
	}
	@Override
	public K higherKey(K key) {
		return keySet().higher(key);
	}
	@Override
	public Entry<K, V> pollFirstEntry() {
		AssociativeTrieNode<K,V> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		return null;
    	}
    	first.remove();
    	return first;
	}
	@Override
	public Entry<K, V> pollLastEntry() {
		AssociativeTrieNode<K,V> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		return null;
    	}
    	last.remove();
    	return last;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof AddressTrieMap<?,?>) {
			AddressTrieMap<?,?> other = (AddressTrieMap<?,?>) o;
			// note that isReverse is ignored, intentionally
			// two maps are equal if they have the same mappings
			return trie.equals(other.trie);
		} 
		return super.equals(o);
	}
	/**
	 * Clones the map along with the backing trie.  If the map had a restricted range, the clone does not.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public AddressTrieMap<K,V> clone() {
		try {
			AddressTrieMap<K,V> clone = (AddressTrieMap<K,V>) super.clone();
			clone.trie = trie.clone();
			// cloning a trie eliminates the bounds, we we put them back
			clone.trie.bounds = trie.bounds; //can share because bounds are immutable
			clone.keySet = null;
			clone.entrySet = null;
			clone.descending = null;
			return clone;
		} catch (CloneNotSupportedException cannotHappen) {
			return null;
		}
	}
	@Override
	public Comparator<K> comparator() {
		return isReverse ? AddressTrie.reverseComparator() : AddressTrie.comparator();
	}
	public String toTrieString() {
		return trie.toString();
	}
	/**
	 * Returns a sub-map consisting of the mappings in the map with address keys contained by the given address
	 * The sub-map will have a restricted range matching the range of the given subnet or address.
	 * <p>
	 * If the sub-map would be the same size as this map, then this map is returned.
	 * The sub-map will the same backing trie as this map.
	 * 
	 * @param addr
	 * @return
	 */
	public AddressTrieMap<K,V> subMapFromKeysContainedBy(K addr) {
		AssociativeAddressTrie<K,V> newTrie = trie.elementsContainedByToSubTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieMap<K,V>(newTrie, null, isReverse);
		}
		Range<K> newRange = new Range<K>(newTrie.bounds, isReverse);
		return new AddressTrieMap<K,V>(newTrie, newRange, isReverse);
	}
	/**
	 * Returns a sub-map consisting of the mappings in the map with address keys that contain the given address.
	 * The sub-map will have the same restricted range (if any) as this sub-map.
	 * <p>
	 * If the sub-map would be the same size as this map, then this map is returned.
	 * Otherwise, the sub-map is backed by a new trie.
	 
	 * @param addr
	 * @return
	 */
	public AddressTrieMap<K,V> subMapFromKeysContaining(K addr) {
		AssociativeAddressTrie<K,V> newTrie = trie.elementsContainingToTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieMap<K,V>(newTrie, null, isReverse);
		}
		Range<K> newRange = new Range<K>(newTrie.bounds, isReverse);
		return new AddressTrieMap<K,V>(newTrie, newRange, isReverse);
	}
	/**
	 * Returns true if a subnet or address key in the map contains the given subnet or address.
	 * 
	 * @param addr
	 * @return
	 */
	public boolean keyContains(K addr) {
		return trie.elementContainsBounds(addr);
	}
	
	/**
	 * Returns the map entry corresponding to the key with the longest prefix match with the given address.
	 * @param addr
	 * @return
	 */
	public Entry<K,V> longestPrefixMatchEntry(K addr) {
		return trie.smallestElementContainingBounds(addr);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Supplier;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringCache;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * This represents a single segment of an IP address.  For IPv4, segments are 1 byte.  For IPv6, they are two bytes.
 * 
 * IPAddressSegment objects are immutable and thus also thread-safe.
 * 
 * @author sfoley
 *
 */
public abstract class IPAddressSegment extends IPAddressDivision implements AddressSegment {
	
	private static final long serialVersionUID = 4L;
	
	// These two values define the uniqueness of a segment with respect to equality and comparison, while the prefix is ignored as these values encapsulate the range of addresses created by the prefix.
	private final int value; // the lower value of the segment
	private final int upperValue; // the upper value of a CIDR or other type of range, if not a range it is the same as value
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address with the given value.
	 * 
	 * @param value the value of the segment
	 */
	protected IPAddressSegment(int value) {
		if(value < 0) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address.
	 * 
	 * @param value the value of the segment.
	 * 		If the segmentPrefixLength is non-null, the network prefix of the value is used, and the segment represents all segment values with the same network prefix (all network or subnet segments, in other words).
	 * @param segmentPrefixLength the segment prefix bits, which can be null
	 */
	protected IPAddressSegment(int value, Integer segmentPrefixLength) {
		this(value, value, segmentPrefixLength);
	}
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address that represents a range of values.
	 * 
	 * @param segmentPrefixLength the segment prefix bits, which can be null.  If segmentPrefixLength is non-null, this segment represents a range of segment values with the given network prefix length.
	 * @param lower the lower value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the lower value becomes the smallest value with the same network prefix.
	 * @param upper the upper value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the upper value becomes the largest value with the same network prefix.
	 */
	protected IPAddressSegment(int lower, int upper, Integer segmentPrefixLength) {
		super(segmentPrefixLength);
		if(lower < 0 || upper < 0) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		segmentPrefixLength = getSegmentPrefixLength();
		if(segmentPrefixLength == null || segmentPrefixLength >= getBitCount() || !getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			this.value = lower;
			this.upperValue = upper;
		} else {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			this.value = lower & mask;
			this.upperValue = upper | getSegmentHostMask(segmentPrefixLength);
		}
	}
	
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	
	public boolean isIPv4() {
		return false;
	}
	
	public boolean isIPv6() {
		return false;
	}
	
	public abstract IPVersion getIPVersion();
	protected static Integer getSplitSegmentPrefix(int bitsPerSegment, Integer networkPrefixLength, int segmentIndex) {
		return IPAddressSection.getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, segmentIndex);
	}
	
	@Override
	protected long getDivisionNetworkMask(int bits) {
		return getSegmentNetworkMask(bits);
	}
	
	@Override
	protected long getDivisionHostMask(int bits) {
		return getSegmentHostMask(bits);
	}
	
	protected abstract int getSegmentNetworkMask(int bits);
	
	protected abstract int getSegmentHostMask(int bits);
	
	@Override
	public int getMinPrefixLengthForBlock() {
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getSegmentPrefixLength() == 0) {
			return 0;
		}
		return super.getMinPrefixLengthForBlock();
	}
	
	public static int getMaxSegmentValue(IPVersion version) {
		return version.isIPv4() ? IPv4Address.MAX_VALUE_PER_SEGMENT : IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	protected boolean isChangedByPrefix(Integer bits, boolean smallerOnly) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(smallerOnly) {
			if(isPrefixed()) {
				return hasBits && bits < getSegmentPrefixLength();
			}
		} else {
			if(isPrefixed()) {
				return !hasBits || bits != getSegmentPrefixLength().intValue();
			}
		}
		return hasBits;
	}
	protected <S extends IPAddressSegment> S toPrefixedSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		boolean hasBits = (segmentPrefixLength != null);
		if(lower != upper) {
			//note that the case where our segmentPrefix is less than the requested prefix bits has already been accounted for in isNetworkChangedByPrefix
			//so we are not handling that here
			if(!hasBits) {
				return creator.createSegment(lower, upper, null);
			}
			return creator.createSegment(lower, upper, segmentPrefixLength);
		}
		return hasBits ? creator.createSegment(lower, segmentPrefixLength) : creator.createSegment(lower);
	}
	@Override
	public boolean isPrefixBlock() {
		return (isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) || super.isPrefixBlock();
	}
	protected boolean isNetworkChangedByPrefix(Integer bits, boolean withPrefixLength) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		withPrefixLength &= hasBits;
		boolean thisHasPrefix = isPrefixed();
		if(withPrefixLength != thisHasPrefix) {
			return true;
		}
		if(!hasBits || bits != getDivisionPrefixLength()) {
			return true;
		}
		return
			//this call differs from the host side.  On the host side, we check that the network portion is 0
			//on the network side, we check that the host side is the full range, not 0.  
			//This means that any resulting network section is the same regardless of whether a prefix is used: we don't need a prefix.
			!containsPrefixBlock(bits);
	}
	
	protected boolean isNetworkChangedByPrefixNonNull(int prefixBitCount) {
		return !isPrefixed() || prefixBitCount != getDivisionPrefixLength() || !containsPrefixBlock(prefixBitCount);
	}
	
	/**
	 * used by constructors of IPAddressSection, see {@link IPAddress#getNetworkSection(int, boolean)}
	 */
	public IPAddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	
	/**
	 * used by getNetworkSection and by constructors of IPAddressSection, see {@link IPAddress#getNetworkSection(int, boolean)}
	 */
	public abstract IPAddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength);
	protected <S extends IPAddressSegment> S toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength, AddressSegmentCreator<S> creator) {
		int newLower = getSegmentValue();
		int newUpper = getUpperSegmentValue();
		boolean hasPrefLen = segmentPrefixLength != null;
		if(hasPrefLen) {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			newLower &= mask;
			newUpper |= getSegmentHostMask(segmentPrefixLength);
		}
		withPrefixLength = withPrefixLength && hasPrefLen;
		if(newLower != newUpper) {
			//note that the case where our segmentPrefix is less than the requested prefix bits has already been accounted for in isNetworkChangedByPrefix
			//so we are not handling that here
			if(!withPrefixLength) {
				return creator.createSegment(newLower, newUpper, null);
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		}
		return withPrefixLength ? creator.createSegment(newLower, segmentPrefixLength) : creator.createSegment(newLower);
	}
	
	/**
	 * used by getHostSection, see {@link IPAddress#getHostSection(int)}
	 */
	public abstract IPAddressSegment toHostSegment(Integer segmentPrefixLength);
	
	protected <S extends IPAddressSegment> S toHostSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		// We need to use Masker:
		// For example, ipv4 0-4, masking with prefix length 7, should become 0-1, not 0-0
		// So you cannot do a straight mask of 0 and 4.
		int mask = (segmentPrefixLength == null) ? 0 : getSegmentHostMask(segmentPrefixLength);
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		Masker masker = maskRange(lower, upper, mask, getMaxValue());
		int newLower = (int) masker.getMaskedLower(lower, mask);
		int newUpper = (int) masker.getMaskedUpper(upper, mask);
		if(newLower != newUpper) {
			return creator.createSegment(newLower, newUpper, null);
		}
		return creator.createSegment(newLower);
	}
	
	protected boolean isHostChangedByPrefix(Integer bits) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		//a host segment has no prefix, so if this remains unchanged it must have no prefix length
		if(isPrefixed()) {
			return true;
		}
		int mask = !hasBits ? 0 : getSegmentHostMask(bits);
		//additionally, the value must match the value for the given network prefix length
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != (value & mask) || upperValue != (upperValue & mask);
	}
	
	protected boolean isChangedBy(int newValue, int newUpperValue, Integer segmentPrefixLength) throws IncompatibleAddressException {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != newValue ||
				upperValue != newUpperValue ||
						(isPrefixed() ? !getSegmentPrefixLength().equals(segmentPrefixLength) : (segmentPrefixLength != null));
	}
	
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.maskRange(value, upperValue, maskValue, maxValue);
	}
	
	public MaskResult maskRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		Masker masker = AddressDivision.maskRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public BitwiseOrResult bitwiseOrRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		BitwiseOrer orer = AddressDivision.bitwiseOrRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new BitwiseOrResult(value, upperValue, maskValue, orer);
	}
	
	/**
	 * If this segment represents a range of values, returns a segment representing just the lowest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	public abstract IPAddressSegment getLower();
	
	/**
	 * If this segment represents a range of values, returns a segment representing just the highest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	public abstract IPAddressSegment getUpper();
	
	protected static <S extends IPAddressSegment> S getLowestOrHighest(S original, AddressSegmentCreator<S> segmentCreator, boolean lowest) {
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(!original.isMultiple() && !(isAllSubnets && original.isPrefixed())) {
			return original;
		}
		return segmentCreator.createSegment(lowest ? original.getSegmentValue() : original.getUpperSegmentValue(), 
				isAllSubnets ? null : original.getSegmentPrefixLength());
	}
	@Override
	public abstract Iterable<? extends IPAddressSegment> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSegment> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSegment> stream();
	/**
	 * Iterates through the individual prefix blocks.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator();
	/**
	 * Partitions and traverses through the individual prefix blocks of this segment for its prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator();
	/**
	 * Returns a sequential stream of the individual prefix blocks of this segment.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream();
	/**
	 * Iterates through the individual prefixes.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixIterator();
	/**
	 * Partitions and traverses through the individual prefixes of this segment for its prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixSpliterator();
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		int originalValue = seg.getSegmentValue();
		int originalUpperValue = seg.getUpperSegmentValue();
		int originalValuePrefix = originalValue >>> shiftAdjustment;
		int originalUpperValuePrefix = originalUpperValue >>> shiftAdjustment;
		Integer segPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		IntBinaryIteratorProvider<S> subIteratorProvider = (isLowest, isHighest, value, upperValue) -> {
			if(isLowest || isHighest) {
				value = isLowest ? originalValue : value << shiftAdjustment;
				upperValue = isHighest ?  originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
				return iterator(null, value, upperValue, bitCount, creator, segPrefixLength, true, false);
			}
			return iterator(null, value << shiftAdjustment, upperValue << shiftAdjustment, bitCount, creator, segPrefixLength, true, true);
		};
		return createSegmentSpliterator(
				seg,
				originalValuePrefix,
				originalUpperValuePrefix,
				iteratorProvider,
				subIteratorProvider,
				(value, upperValue) -> {
					value = (value == originalValuePrefix) ? originalValue : value << shiftAdjustment;
					upperValue = (upperValue == originalUpperValuePrefix) ? 
							originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
					return creator.createSegment(value, upperValue, segPrefLength);
				});
	}
	/**
	 * Returns a sequential stream of the individual prefixes of this segment.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixStream();
	/**
	 * Iterates through the individual prefix blocks according to the given segment prefix length.
	 * Any existing prefix length is disregarded.
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator(int prefixLength);
	
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixBlockSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		Integer segmentPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		return createSegmentSpliterator(
				seg,
				seg.getSegmentValue() >>> shiftAdjustment,
				seg.getUpperSegmentValue() >>> shiftAdjustment,
				iteratorProvider,
				(isLowest, isHighest, value, upperValue) -> iterator(
							null,
							value << shiftAdjustment,
							(upperValue << shiftAdjustment) | upperShiftMask,
							bitCount,
							creator,
							segmentPrefixLength,
							true,
							true),
				(value, upperValue) -> creator.createSegment(
						value << shiftAdjustment,
						(upperValue << shiftAdjustment) | upperShiftMask,
						segmentPrefixLength));
	}
	/**
	 * Partitions and traverses through the individual prefix blocks for the given prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator(int prefixLength);
	/**
	 * Returns a sequential stream of the individual prefix blocks for the given prefix length.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream(int prefixLength);
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BITS_PER_SEGMENT : IPv6Address.BITS_PER_SEGMENT;
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
	}
	public static int getDefaultTextualRadix(IPVersion version) {
		return version.isIPv4() ? IPv4Address.DEFAULT_TEXTUAL_RADIX : IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	
	public boolean matchesWithPrefixMask(int value, Integer segmentPrefixLength) {
		return super.matchesWithPrefixMask(value, segmentPrefixLength);
	}
	
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	
	/**
	 * @return the same value as {@link #getCount()} as an integer
	 */
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	
	/**
	 * Counts the number of prefixes in this address segment.
	 * <p>
	 * If this segment has no prefix length, this is equivalent to {@link #getValueCount()}
	 * 
	 * @return
	 */
	public int getPrefixValueCount() {
		Integer prefixLength = getSegmentPrefixLength();
		if(prefixLength == null) {
			return (int) getValueCount();
		}
		return getPrefixValueCount(this, prefixLength);
	}
	
	@Override
	public BigInteger getCount() {
		return BigInteger.valueOf(getValueCount());
	}
	
	@Override
	public BigInteger getPrefixCount(int segmentPrefixLength) {
		return BigInteger.valueOf(getPrefixValueCount(segmentPrefixLength));
	}
	
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(this, segmentPrefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= segmentPrefixLength) {
			return getValueCount();
		}
		int shiftAdjustment = bitCount - segmentPrefixLength;
		return (getUpperSegmentValue() >>> shiftAdjustment) - (getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected int highByte() {
		return highByte(getSegmentValue());
	}
	
	protected int lowByte() {
		return lowByte(getSegmentValue());
	}
	
	protected static int highByte(int value) {
		return value >> 8;
	}
	
	protected static int lowByte(int value) {
		return value & 0xff;
	}
	
	@Override
	public long getMaxValue() {
		return getMaxSegmentValue();
	}
	@Override
	public boolean isMultiple() {
		return getSegmentValue() != getUpperSegmentValue();
	}
	
	/**
	 * returns the lower value
	 */
	@Override
	public int getSegmentValue() {
		return value;
	}
	
	/**
	 * returns the upper value
	 */
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	
	/**
	 * returns the lower value as a long, although for individual segments {@link #getSegmentValue()} provides the same value as an int
	 */
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	
	/**
	 * returns the lower upper value as a long, although for individual segments {@link #getUpperSegmentValue()} provides the same value as an int
	 */
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	
	@Override
	public abstract IPAddressSegment reverseBits(boolean perByte);
	
	@Override
	public abstract IPAddressSegment reverseBytes();
	/**
	 * @deprecated use {@link #withoutPrefixLength()} and {@link #toZeroHost()}
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSegment removePrefixLength();
	/**
	 * Returns a segment with the same network bits as this segment, 
	 * but with the host bits changed to 0.
	 * <p>
	 * If there is no prefix length associated with this segment, returns an all-zero segment.
	 * <p>
	 * This is nearly equivalent to doing the mask (see {@link #maskRange(int)}) of this segment
	 * with the network mask for the given prefix length,
	 * but when applying a mask to a range of values you can have a non-sequential result.
	 * <p>
	 * With this method, if the resulting series has a range of values, 
	 * then the resulting series range boundaries will have host values of 0, 
	 * but not necessarily all the intervening values.
	 * <p>
	 * For instance, the 1-byte segment range 4-7 with prefix length 6, 
	 * when masked with 252 (the network mask) results in just the single value 4, matching the result of this method.
	 * The 1-byte segment range 4-8 with prefix length 6, 
	 * when masked with 252 results in the two non-sequential values, 4 and 8, 
	 * but the result of this method with prefix length 6 results in the range 4-8, the same as the original segment.
	 * <p>
	 * The default behaviour is that the resultant series will have the same prefix length.
	 * The resultant series will not have a prefix length if {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()} is {@link inet.ipaddr.AddressNetwork.PrefixConfiguration#ALL_PREFIXED_ADDRESSES_ARE_SUBNETS}. 
	 *
	 * @return
	 */
	public abstract IPAddressSegment toZeroHost();
	/**
	 * @deprecated use {@link #toZeroHost()} and {@link #withoutPrefixLength()}
	 * @param zeroed
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSegment removePrefixLength(boolean zeroed);
	/**
	 * Returns a segment with the same values but without a prefix length.
	 * 
	 * @return
	 */
	public abstract IPAddressSegment withoutPrefixLength();
	
	protected static <S extends IPAddressSegment> S toZeroHost(S original, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			Integer segmentPrefixLength = original.getSegmentPrefixLength();
			int mask = original.getSegmentNetworkMask(segmentPrefixLength);
			int newLower = lower & mask;
			int newUpper = upper & mask;
			boolean allPrefsSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			if(allPrefsSubnets) {
				return creator.createSegment(newLower, newUpper, null);
			}
			if(newLower == lower && newUpper == upper) {
				return original;
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		} else if(original.isZero()) {
			return original;
		}
		return creator.createSegment(0, null);
	}
	
	protected static <S extends IPAddressSegment> S removePrefix(S original, boolean zeroed, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			if(zeroed) {
				int maskBits = original.getSegmentNetworkMask(original.getSegmentPrefixLength());
				long value = original.getDivisionValue();
				long upperValue = original.getUpperDivisionValue();
				long maxValue = original.getMaxValue();
				Masker masker = maskRange(value, upperValue, maskBits, maxValue);
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(original, maskBits, "ipaddress.error.maskMismatch");
				}
				return creator.createSegment((int) masker.getMaskedLower(lower, maskBits), (int) masker.getMaskedUpper(upper, maskBits), null);
			}
			return creator.createSegment(lower, upper, null);
		}
		return original;
	}
	
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	
	public Integer getSegmentPrefixLength() {
		return getDivisionPrefixLength();
	}
	
	@Override
	public int hashCode() {
		return hash(getSegmentValue(), getUpperSegmentValue(), getBitCount());
	}
	
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	protected boolean isSameValues(AddressSegment otherSegment) {
		//note that it is the range of values that matters, the prefix bits do not
		return getSegmentValue() == otherSegment.getSegmentValue() && getUpperSegmentValue() == otherSegment.getUpperSegmentValue();
	}
	public boolean prefixEquals(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixEquals(other, prefLength);
	}
	
	@Override
	public boolean prefixEquals(AddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return isSameValues(other);
		}
		return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) == (getUpperSegmentValue() >>> shift);
	}
	
	/**
	 * Using the prefix length of this segment, or the whole segment if it has no prefix length,
	 * returns whether the prefix bit value ranges contain the same bits of the given segment.
	 * 
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixContains(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixContains(other, prefLength);
	}
	
	/**
	 * Returns whether the given prefix bit value ranges contain the same bits of the given segment.
	 * 
	 * @param other
	 * @param prefixLength
	 * @return
	 */
	public boolean prefixContains(IPAddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return contains(other);
		}
		return (other.getSegmentValue() >>> shift) >= (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet segment contains the given address segment
	 */
	protected boolean containsSeg(AddressSegment other) {
		return other.getSegmentValue() >= getSegmentValue() && other.getUpperSegmentValue() <= getUpperSegmentValue();
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet segment overlaps the given address segment
	 */
	protected boolean overlapsSeg(AddressSegment other) {
		return other.getSegmentValue() <= getUpperSegmentValue() && other.getUpperSegmentValue() >= getSegmentValue();
	}
			
	@Override
	public boolean includesZero() {
		return getSegmentValue() == 0;
	}
	
	@Override
	public boolean includesMax() {
		return getUpperSegmentValue() == getMaxSegmentValue();
	}
	
	boolean containsPrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isPrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	
	boolean containsSinglePrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isSinglePrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(IPStringCache.canonicalSegmentParams);
	}
	public String toNormalizedString(IPStringOptions options) {
		IPAddressStringWriter<IPAddressStringDivisionSeries> params =  IPAddressSection.toIPParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	
	protected static int toUnsignedStringLength(int value, int radix) {
		return AddressDivision.toUnsignedStringLength(value, radix);
	}
	
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return toUnsignedStringCased(value, radix, 0, false, appendable);
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int lowerValue) {
		if(cachedWildcardString == null && isStandardString && lowerValue == getDivisionValue() && lowerValue == getUpperDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedString == null) {
			if(isSinglePrefixBlock()) {
				if(isStandardString && rangeLower == getDivisionValue()) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
				}
			} else if(isFullRange()) {
				cachedString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue()) {
				long upper = getUpperDivisionValue();
				if(isPrefixed()) {
					upper &= getDivisionNetworkMask(getDivisionPrefixLength());
				}
				if(rangeUpper == upper) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
				}
			}
		}
	}
	
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * Provides an interface to the trie operations.  
 * Operations which take an address as an argument require that the address is an individual address or prefix block. 
 * 
 * @author scfoley
 *
 * @param <E>
 */
public interface AddressTrieOps<E extends Address> extends TreeOps<E> {
	/**
	 * Gets the node corresponding to the given address, returns null if not such element exists.
	 * <p>
	 * If added is true, returns only nodes representing added elements, otherwise returns any node, 
	 * including a prefix block that was not added.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * @see #contains(Address)
	 * @param addr
	 * @return
	 */
	TrieNode<E> getNode(E addr);
	/**
	 * Gets trie nodes representing added elements.
	 * <p>
	 * Use {@link #contains(Address)} to check for the existence of a given address in the trie,
	 * as well as {@link #getNode(Address)} to search for all nodes including those not-added but also auto-generated nodes for subnet blocks.
	 * 
	 * @param addr
	 * @return
	 */
	default TrieNode<E> getAddedNode(E addr) {
		TrieNode<E> ret = getNode(addr);
		return (ret == null || ret.isAdded()) ? ret : null;
	}
	/**
	 * Checks if a prefix block subnet or address in the trie contains the given subnet or address.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the subnet or address is contained by a trie element, false otherwise.
	 * <p>
	 * To get all the containing addresses, use {@link #elementsContaining(Address)}.
	 * 
	 * @param addr
	 * @return
	 */
	boolean elementContains(E addr);
	/**
	 * Returns whether the given address or prefix block subnet is in the trie (as an added element).
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the prefix block or address address exists already in the trie, false otherwise.
	 * <p>
	 * Use {@link #getAddedNode(Address)} to get the node for the address rather than just checking for its existence.
	 * 
	 * @param addr
	 * @return
	 */
	boolean contains(E addr);
	/**
	 * Removes the given single address or prefix block subnet from the trie.
	 * <p>
	 * Removing an element will not remove contained elements (nodes for contained blocks and addresses).
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the prefix block or address was removed, false if not already in the trie.
	 * <p>
	 * You can also remove by calling {@link #getAddedNode(Address)} to get the node and then calling {@link BinaryTreeNode#remove()} on the node.
	 * <p>
	 * When an address is removed, the corresponding node may remain in the trie if it remains a subnet block for two sub-nodes.
	 * If the corresponding node can be removed from the trie, it will be.
	 * 
	 * @see #removeElementsContainedBy(Address)
	 * @param addr
	 * @return
	 */
	boolean remove(E addr);
	/**
	 * Removes any single address or prefix block subnet from the trie that is contained in the given individual address or prefix block subnet.
	 * <p>
	 * Goes further than {@link #remove(Address)}, not requiring a match to an inserted node, and also removing all the sub-nodes of any removed node or sub-node.
	 * <p>
	 * For example, after inserting 1.2.3.0 and 1.2.3.1, passing 1.2.3.0/31 to {@link #removeElementsContainedBy(Address)} will remove them both,
	 * while {@link #remove(Address)} will remove nothing.  
	 * After inserting 1.2.3.0/31, then #remove(Address) will remove 1.2.3.0/31, but will leave 1.2.3.0 and 1.2.3.1 in the trie.
	 * <p>
	 * It cannot partially delete a node, such as deleting a single address from a prefix block represented by a node.  
	 * It can only delete the whole node if the whole address or block represented by that node is contained in the given address or block.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns the root node of the subtrie that was removed from the trie, or null if nothing was removed.
	 * 
	 * @param addr
	 * @return
	 */
	TrieNode<E> removeElementsContainedBy(E addr);
	/**
	 * Checks if a part of this trie is contained by the given prefix block subnet or individual address.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns the root node of the contained subtrie, or null if no subtrie is contained.
	 * The node returned need not be an "added" node, see {@link TrieNode#isAdded()} for more details on added nodes.
	 * The returned subtrie is backed by this trie, so changes in this trie are reflected in those nodes and vice-versa.
	 * 
	 * @param addr
	 * @return
	 */
	TrieNode<E> elementsContainedBy(E addr);
				
	/**
	 * Finds the added subnets and/or addresses in the trie that contain the given individual address or prefix block subnet.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns a list of the nodes for prefix block subnets and addresses from the trie that contain the address or block.
	 * The list consists only of added nodes, see {@link TrieNode#isAdded()} for more details on added nodes.
	 * The list is constructed as a trie in which each parent node has only one sub-node.
	 * <p>
	 * Use {@link #elementContains(Address)} to check for the existence of a containing address.
	 * 
	 * @param addr
	 * @return
	 */
	TrieNode<E> elementsContaining(E addr);
	
	/**
	 * Finds the containing subnet or address in the trie with the smallest subnet size,
	 * which is equivalent to finding the subnet or address with the longest matching prefix.
	 * Returns the node corresponding to that subnet.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns null if no added subnet or address contains the given argument.
	 * <p>
	 * Use {@link #elementContains(Address)} to check for the existence of a containing address.<br>
	 * To get all the containing addresses, use {@link #elementsContaining(Address)}.<br>
	 * Use {@link #longestPrefixMatch(Address)} to get the address corresponding to the result of this method.<br>
	 * 
	 * @param addr
	 * @return
	 */
	TrieNode<E> longestPrefixMatchNode(E addr);
	
	/**
	 * Of all the added subnets or address whose prefix matches the given address, returns the one with the longest prefix.
	 * This is equivalent to finding the containing subnet or address with the smallest subnet size.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns null if no added subnet or address contains the given argument.
	 * <p>
	 * Use {@link #elementContains(Address)} to check for the existence of a containing address.<br>
	 * To get all the containing addresses (subnets with matching prefix), use {@link #elementsContaining(Address)}.<br>
	 * To get the node corresponding to the result of this method, use {@link #longestPrefixMatchNode(Address)}<br>
	 *
	 * @param addr
	 * @return
	 */
	E longestPrefixMatch(E addr);
	/**
	 * Finds the containing subnet or address in the trie with the largest subnet size,
	 * which is equivalent to finding the subnet or address with the shortest matching prefix.
	 * Returns the node corresponding to that subnet.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns null if no added subnet or address contains the given argument.
	 * <p>
	 * Use {@link #elementContains(Address)} to check for the existence of a containing address.<br>
	 * To get all the containing addresses, use {@link #elementsContaining(Address)}.<br>
	 * Use {@link #shortestPrefixMatch(Address)} to get the address corresponding to the result of this method.<br>
	 * 
	 * @param addr
	 * @return
	 */
	TrieNode<E> shortestPrefixMatchNode(E addr);
	
	/**
	 * Of all the added subnets or address whose prefix matches the given address, returns the one with the shortest prefix.
	 * This is equivalent to finding the containing subnet or address with the largest subnet size.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns null if no added subnet or address contains the given argument.
	 * <p>
	 * Use {@link #elementContains(Address)} to check for the existence of a containing address.<br>
	 * To get all the containing addresses (subnets with matching prefix), use {@link #elementsContaining(Address)}.<br>
	 * To get the node corresponding to the result of this method, use {@link #shortestPrefixMatchNode(Address)}<br>
	 *
	 * @param addr
	 * @return
	 */
	E shortestPrefixMatch(E addr);
	@Override
	Iterator<? extends TrieNode<E>> nodeIterator(boolean forward);
	@Override
	Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward);
	@Override
	Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder);
	@Override
	<C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder);
	@Override
	Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder);
	@Override
	Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder);
	
	@Override
	Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward);
	
	@Override
	Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward);
	/**
	 * Returns the node with the first (lowest valued) key, whether the node is added or not
	 * 
	 * @return
	 */
	TrieNode<E> firstNode();
	/**
	 * Returns the node with the last (highest valued) key, whether the node is added or not
	 * 
	 * @return
	 */
	TrieNode<E> lastNode();
	
	/**
	 * Returns the added node with the first (lowest valued) key, 
	 * or null if there are no added entries in this trie or subtrie
	 * @return
	 */
	TrieNode<E> firstAddedNode();
	/**
	 * Returns the added node with the last (highest valued) key, 
	 * or null if there are no added elements in this trie or subtrie
	 * @return
	 */
	TrieNode<E> lastAddedNode();
	/**
	 * Returns the added node whose address is the highest address less than or equal to the given address.
	 * @param addr
	 * @return
	 */
	TrieNode<E> floorAddedNode(E addr);
	/**
	 * Returns the added node whose address is the highest address strictly less than the given address.
	 * @param addr
	 * @return
	 */
	TrieNode<E> lowerAddedNode(E addr);
	/**
	 * Returns the added node whose address is the lowest address greater than or equal to the given address.
	 * @param addr
	 * @return
	 */
	TrieNode<E> ceilingAddedNode(E addr);
	/**
	 * Returns the added node whose address is the lowest address strictly greater than the given address.
	 * @param addr
	 * @return
	 */
	TrieNode<E> higherAddedNode(E addr);
	/**
	 * Returns the highest added address less than or equal to the given address.
	 * 
	 * @param addr
	 * @return
	 */
	E floor(E addr);
	/**
	 * Returns the highest added address strictly less than the given address.
	 * 
	 * @param addr
	 * @return
	 */
	E lower(E addr);
	/**
	 * Returns the lowest added address greater than or equal to the given address.
	 * 
	 * @param addr
	 * @return
	 */
	E ceiling(E addr);
	/**
	 * Returns the lowest added address strictly greater than the given address.
	 * 
	 * @param addr
	 * @return
	 */
	E higher(E addr);
	/**
	 * Provides an interface to the trie add operations.<p>
	 * Operations which take an address as an argument require that the address is an individual address or prefix block. 
	 * 
	 * 
	 * @author scfoley
	 *
	 * @param <E>
	 */
	public static interface AddressTrieAddOps<E extends Address> extends AddressTrieOps<E> {
		/**
		 * Adds the given single address or prefix block subnet to the trie.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * Given a subnet s of type E and a trie of type AddressTrie&lt;E&gt;, such as {@link inet.ipaddr.ipv4.IPv4Address} and {@link inet.ipaddr.ipv4.IPv4AddressTrie},
		 * you can convert and add the spanning prefix blocks with <code>Partition.partitionWithSpanningBlocks(s).predicateForEach(trie::add)</code>,
		 * or you can convert and add using a single max block size with <code>Partition.partitionWithSingleBlockSize(s).predicateForEach(trie::add)</code>.
		 * <p>
		 * Returns true if the prefix block or address was inserted, false if already in the trie.
		 * 
		 * @param addr
		 * @return
		 */
		boolean add(E addr);
		
		/**
		 * Adds the given single address or prefix block subnet to the trie, if not already there.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link #add(Address)} for more details.
		 * <p>
		 * Returns the node for the added address, whether it was already in the trie or not.
		 * <p>
		 * If you wish to know whether the node was already there when adding, use {@link #add(Address)}, or before adding you can use {@link #getAddedNode(Address)}
		 * 
		 * @param addr
		 * @return
		 */
		TrieNode<E> addNode(E addr);
	
		/**
		 * Adds nodes matching the given sub-root node and all of its sub-nodes to the trie, if not already there.
		 * <p>
		 * For each added in the given node that does not exist in the trie, a copy of each node will be made that matches the trie type (associative or not),
		 * and the copy will be inserted into the trie.
		 * <p>
		 * The node type need not match the node type of the trie, although the address type/version E must match.
		 * You can add associative nodes to tries with this method but associated values will all be null.
		 * If you want to preserve the values, use {@link AssociativeAddressTriePutOps#putTrie(AssociativeTrieNode)} instead.
		 * <p>
		 * When adding one trie to another, this method is more efficient than adding each node of the first trie individually.
		 * When using this method, searching for the location to add sub-nodes starts from the inserted parent node.
		 * <p>
		 * Returns the node corresponding to the given sub-root node, whether it was already in the trie or not.
		 * <p>
		 * 
		 * @param trie
		 * @return
		 */
		TrieNode<E> addTrie(TrieNode<E> trie);
	}
	/**
	 * Provides an interface to the associative trie operations.<p>
	 * Operations which take an address as an argument require that the address is an individual address or prefix block.
	 * 
	 * 
	 * @author scfoley
	 *
	 * @param <K>
	 * @param <V>
	 */
	public static interface AssociativeAddressTrieOps<K extends Address, V> extends AddressTrieOps<K> {
		/**
		 * Gets the specified value for the specified key in this mapped trie or subtrie.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * <p>
		 * Returns the value for the given key.
		 * Returns null if the contains no mapping for that key or if the mapped value is null.
		 * 
		 * @param addr
		 * @return
		 */
		V get(K addr);
	}
	/**
	 * Provides an interface to the associative trie put operations.<p>
	 * Operations which take an address as an argument require that the address is an individual address or prefix block.
	 * 
	 * 
	 * @author scfoley
	 *
	 * @param <K>
	 * @param <V>
	 */
	public static interface AssociativeAddressTriePutOps<K extends Address, V> extends AssociativeAddressTrieOps<K, V> {
		/**
		 * Associates the specified value with the specified key in this map.
		 * <p>
	     * Unlike {@link #putNew(Address, Object)}, {@link #put(Address, Object)} can provide the value to which to key was previously mapped.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * <p>
		 * If this map previously contained a mapping for a key, 
		 * the old value is replaced by the specified value, and the old value is returned.
	     * If this map did not previously contain a mapping for the key, null is returned.
		 * 
		 * @param addr
		 * @return
		 */
		V put(K addr, V value);
		
		/**
		 * Associates the specified value with the specified key in this map.
		 * <p>
	     * Unlike {@link #put(Address, Object)}, {@link #put(Address, Object)} can distinguish between
	     * cases where the call results in a new entry, and cases where the call matched a previous entry that was mapped to null.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * <p>
		 * If this map previously contained a mapping for a key, 
		 * the old value is replaced by the specified value, and false is returned.
	     * If this map did not previously contain a mapping for the key, true is returned.
	     * 
		 * @param addr
		 * @return
		 */
		boolean putNew(K addr, V value);
		
		
		/**
		 * Associates the specified value with the specified key in this map.
		 * <p>
	     * Unlike {@link #put(Address, Object)}, {@link #put(Address, Object)} can distinguish between
	     * cases where the call results in a new entry, and cases where the call matched a previous entry that was mapped to null.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * <p>
		 * Returns the node for the added address, whether it was already in the tree or not.
		 * <p>
		 * If you wish to know whether the node was already there when adding, use {@link #putNew(Address, Object)}, or before adding you can use {@link #getAddedNode(Address)}
	     * 
		 * @param addr
		 * @return
		 */
		AssociativeTrieNode<K,V> putNode(K addr, V value);
		/**
		 * Remaps node values in the trie.
		 * <p>
		 * This will lookup the node corresponding to the given key.
		 * It will call the remapping function with the key as the first argument, regardless of whether the node is found or not.
		 * <p>
		 * If the node is not found, the value argument will be null.  
		 * If the node is found, the value argument will be the node's value, which can also be null.  
		 * <p>
		 * If the remapping function returns null, then the matched node will be removed, if any.
		 * If it returns a non-null value, then it will either set the existing node to have that value,
		 * or if there was no matched node, it will create a new node with that value.
		 * <p>
		 * The method will return the node involved, which is either the matched node, or the newly created node,
		 * or null if there was no matched node nor newly created node.
		 * <p>
		 * If the remapping function modifies the trie during its computation,
		 * and the returned value specifies changes to be made,
		 * then the trie will not be changed and ConcurrentModificationException will be thrown instead.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * 
		 * @param addr
		 * @param remapper
		 * @return
		 */
		AssociativeTrieNode<K, V> remap(K addr, Function<? super V, ? extends V> remapper);
		/**
		 * Remaps node values in the trie, but only for nodes that do not exist or are mapped to null.
		 * <p>
		 * This will look up the node corresponding to the given key.
		 * If the node is not found or mapped to null, this will call the remapping function.
		 * <p>
		 * If the remapping function returns a non-null value, then it will either set the existing node to have that value,
		 * or if there was no matched node, it will create a new node with that value.
		 * If the remapping function returns null, then it will do the same if insertNull is true, otherwise it will do nothing.
		 * <p>
		 * The method will return the node involved, which is either the matched node, or the newly created node,
		 * or null if there was no matched node nor newly created node.
		 * <p>
		 * If the remapping function modifies the trie during its computation,
		 * and the returned value specifies changes to be made,
		 * then the trie will not be changed and ConcurrentModificationException will be thrown instead.
		 * <p>
		 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
		 * <p>
		 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
		 * See {@link AddressTrieAddOps#add(Address)} for more details.
		 * 
		 * @param addr
		 * @param remapper
		 * @param insertNull whether null values returned from remapper should be inserted into the map, or whether null values indicate no remapping
		 * @return
		 */
		AssociativeTrieNode<K, V> remapIfAbsent(K addr, Supplier<? extends V> remapper, boolean insertNull);
		/**
		 * Adds nodes matching the given sub-root node and all of its sub-nodes to the trie, if not already there.
		 * <p>
		 * For each added in the given node that does not exist in the trie, a copy of each node will be made that matches the trie type (associative or not),
		 * the copy including the associated value, and the copy will be inserted into the trie.
		 * <p>
		 * The node type need not match the node type of the trie, although the address type/version E must match.
		 * So this means you can add non-associative nodes with this method,
		 * in which case, the new nodes will be associative but will be mapped to null.
		 * <p>
		 * When adding one trie to another, this method is more efficient than adding each node of the first trie individually.
		 * When using this method, searching for the location to add sub-nodes starts from the inserted parent node.
		 * <p>
		 * Returns the node corresponding to the given sub-root node, whether it was already in the trie or not.
		 * <p>
		 * 
		 * @param trie
		 * @return
		 */
		AssociativeTrieNode<K, V> putTrie(AssociativeTrieNode<K, V> trie);
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NavigableSet;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Spliterator;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.AddressBounds;
import inet.ipaddr.format.util.BinaryTreeNode.KeyIterator;
/**
 * Wraps a {@link inet.ipaddr.format.util.AddressTrie} to view it as a Java Collections Framework set, 
 * implementing the {@link java.util.Set}, {@link java.util.SortedSet} and {@link java.util.NavigableSet} interfaces.
 * <p>
 * Like {@link java.util.TreeSet}, this set is backed by a binary tree and implements the same interfaces that {@link java.util.TreeSet} does.  
 * But there are some significant differences between the two binary tree implementations.
 * See {@link inet.ipaddr.format.util.AddressTrieMap} for a description of some of the differences.
 * {@link java.util.TreeMap} is backed by a {@link java.util.TreeSet} and 
 * {@link inet.ipaddr.format.util.AddressTrieMap} is backed by an {@link inet.ipaddr.format.util.AddressTrie} just like {@link inet.ipaddr.format.util.AddressTrie},
 * so all of the same implementation comparisons apply equally between the map implementations and the set implementations.
 * <p>
 * With the trie set, only addresses that are either individual address or prefix block subnets of the same type and version can be added to the trie,
 * see {@link inet.ipaddr.format.util.AddressTrie.AddressComparator} for a comparator for the ordering.
 * <p>
 * Should you wish to store, in a collection, address instances that are not individual address or prefix block subnets,
 * you can use {@link java.util.TreeSet} or any other Java collections framework set to store addresses of any type,
 * or addresses of different versions or types in the same set,
 * since all address items in this library are comparable with a natural ordering.  
 * There are additional orderings provided by this library as well, see {@link inet.ipaddr.AddressComparator}.
 * 
 * @author scfoley
 *
 * @param <E> the address type
 */
public class AddressTrieSet<E extends Address> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable {
	private static final long serialVersionUID = 1L;
	private AddressTrie<E> trie; // the backing trie
	private final boolean isReverse;
	private final Range<E> bounds;
	private AddressTrieSet<E> descending; //cached
	public AddressTrieSet(AddressTrie<E> trie) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.set == null) {
			trie.set = this;
		}
	}
	public AddressTrieSet(AddressTrie<E> trie, Collection<? extends E> collection) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.set == null) {
			trie.set = this;
		}
        addAll(collection);
    }
	AddressTrieSet(AddressTrie<E> trie, Range<E> bounds, boolean isReverse) {
		this.trie = trie;
		this.bounds = bounds;
		this.isReverse = isReverse;
		if(trie.set == null && !isReverse && bounds == null) {
			trie.set = this;
		}
	}
	public static class Range<E extends Address> implements Serializable {
		private static final long serialVersionUID = 1L;
		final AddressBounds<E> wrapped;
		Range<E> reversed;
		final boolean isReverse;
		Range(AddressBounds<E> wrapped) {
			this(wrapped, false);
		}
		Range(AddressBounds<E> wrapped, boolean isReverse) {
			if(wrapped == null) {
				throw new NullPointerException();
			}
			this.wrapped = wrapped;
			this.isReverse = isReverse;
		}
		Range<E> reverse() {
			Range<E> result = reversed;
			if(result == null) {
				result = new Range<E>(wrapped, !isReverse);
				reversed = result;
				result.reversed = this;
			}
			return result;
		}
		public boolean isInBounds(E addr) {
			return isWithinLowerBound(addr) && isWithinUpperBound(addr);
		}
		public E getLowerBound() {
			return isReverse ? wrapped.getUpperBound() : wrapped.getLowerBound();
		}
		public E getUpperBound() {
			return isReverse ? wrapped.getLowerBound() : wrapped.getUpperBound();
		}
		public boolean lowerIsInclusive() {
			return isReverse ? wrapped.upperIsInclusive() : wrapped.lowerIsInclusive();
		}
		public boolean upperIsInclusive() {
			return isReverse ? wrapped.lowerIsInclusive() : wrapped.upperIsInclusive();
		}
		public boolean isLowerBounded() {
			return getLowerBound() != null;
		}
		public boolean isUpperBounded() {
			return getUpperBound() != null;
		}
		public boolean isBelowLowerBound(E addr) {
			return isReverse ? wrapped.isAboveUpperBound(addr) : wrapped.isBelowLowerBound(addr);
		}
		public boolean isAboveUpperBound(E addr) {
			return isReverse ? wrapped.isBelowLowerBound(addr) : wrapped.isAboveUpperBound(addr);
		}
		public boolean isWithinLowerBound(E addr) {
			return !isBelowLowerBound(addr);					
		}
		public boolean isWithinUpperBound(E addr) {
			return !isAboveUpperBound(addr);
		}
		@Override
		public String toString() {
			Function<? super E, String> stringer = Address::toCanonicalString;
			return AddressBounds.toString(
					getLowerBound(), lowerIsInclusive(), 
					getUpperBound(), upperIsInclusive(), stringer, " -> ", stringer);
		}
	}
	private boolean isBounded() {
		return bounds != null;
	}
	@Override
	public AddressTrieSet<E> descendingSet() {
		AddressTrieSet<E> desc = descending;
		if(desc == null) {
			Range<E> reverseBounds = isBounded() ?  bounds.reverse() : null;
			desc = new AddressTrieSet<E>(trie, reverseBounds, !isReverse);
			descending = desc;
			desc.descending = this;
		}
		return desc;
	}
	/**
	 * Returns a trie representing this set.
	 * <p>
	 * If this set has a restricted range, {@link #hasRestrictedRange()}, this generates a new trie for the set with only the nodes pertaining to the subset.
	 * Otherwise this returns the backing trie for this set.
	 * <p>
	 * When a new trie is generated, the original backing trie for this set remains the same, it is not changed to the new trie.
	 * <p>
	 * The returned trie will always have the same natural trie ordering,
	 * even if this set has the reverse ordering.
	 * 
	 */
	public AddressTrie<E> asTrie() {
		if(isBounded()) {
			return trie.clone();
		}
		if(!isReverse) {
			trie.set = this;// in case we constructed the set first, we put a reference back to us
		}
		return trie;
	}
	/**
	 * Returns whether this set is the result of a call to {@link #headSet(Address)}, {@link #tailSet(Address)},
	 * {@link #subSet(Address, Address)} or any of the other six methods with the same names.
	 * 
	 * @return
	 */
	public boolean hasRestrictedRange() {
		return isBounded();
	}
	/**
	 * Returns the range if this set has a restricted range, see {@link #hasRestrictedRange()}.  Otherwise returns null.
	 * 
	 * @return
	 */
	public Range<E> getRange() {
		return bounds;
	}
	/**
     * Returns the number of elements in this set.  
     * This is a constant time operation, unless the set has a restricted range, see {@link #hasRestrictedRange()},
     * in which case it is a linear time operation proportional to the number of elements.
     * 
     * @return the number of elements in this set
     */
	@Override
	public int size() {
		return trie.size();
	}
	@Override
	public boolean isEmpty() {
		return trie.isEmpty();
    }
	@SuppressWarnings("unchecked")
	@Override
	public boolean contains(Object o) {
		return trie.contains((E) o);
	}
	/**
	 * Adds the given single address or prefix block subnet to this set.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * See {@link AddressTrie}
	 */
	@Override
	public boolean add(E e) {
		return trie.add(e);
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean remove(Object o) {
		return trie.remove((E) o);
	}
	@Override
	public void clear() {
		trie.clear();
	}
	@Override
	public int hashCode() {
		return trie.hashCode();
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof AddressTrieSet<?>) {
			AddressTrieSet<?> other = (AddressTrieSet<?>) o;
			// note that isReverse is ignored, intentionally
			// two sets are equal if they have the same elements
			return trie.equals(other.trie);
		} 
		return super.equals(o);
	}
	/**
	 * Clones the set along with the backing trie.  If the set had a restricted range, the clone does not.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public AddressTrieSet<E> clone() {
		try {
			AddressTrieSet<E> clone = (AddressTrieSet<E>) super.clone();
			clone.trie = trie.clone();
			// cloned tries have no bounds, so we need to put the bounds back, 
			// even though there are no longer trie elements outside the bounds,
			// they still need to be part of this set
			clone.trie.bounds = trie.bounds; 
			clone.descending = null;
			return clone;
		} catch (CloneNotSupportedException cannotHappen) {
			return null;
		}
	}
	@Override
	public boolean removeAll(Collection<?> collection) {
		if(collection instanceof List || collection instanceof Queue || collection.size() < size()) {
			boolean result = false;
			for (Object object : collection) {
				if(remove(object)) {
					result = true;
				}
			}
			return result;
		}
		return removeIf(collection::contains);
    }
	@Override
	public Iterator<E> iterator() {
		return isReverse ? trie.descendingIterator() : trie.iterator();
	}
	@Override
	public Iterator<E> descendingIterator() {
		return isReverse ? trie.iterator() : trie.descendingIterator();
	}
	/**
	 * Returns an iterator that visits containing subnet blocks before their contained addresses and subnet blocks.
	 */
	public Iterator<E> containingFirstIterator() {
		return new KeyIterator<E>(trie.containingFirstIterator(!isReverse));
	}
	/**
	 * Returns an iterator that visits contained addresses and subnet blocks before their containing subnet blocks.
	 */
	public Iterator<E> containedFirstIterator() {
		return new KeyIterator<E>(trie.containedFirstIterator(!isReverse));
	}
	@Override
	public Spliterator<E> spliterator() {
		return isReverse ? trie.descendingSpliterator() : trie.spliterator();
    }
	@Override
	public Comparator<E> comparator() {
		return isReverse ? AddressTrie.reverseComparator() : AddressTrie.comparator();
	}
	/**
	 * Iterates from largest prefix blocks to smallest to individual addresses.
	 * Blocks of equal size are iterated in set order.
	 * 
	 * @return
	 */
	public Iterator<E> blockSizeIterator() {
		return new KeyIterator<E>(trie.blockSizeNodeIterator(!isReverse));
	}
	private AddressTrieSet<E> toSubSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		if(isReverse) {
			E tmp = fromElement;
			boolean tmpInc = fromInclusive;
			fromElement = toElement;
			fromInclusive = toInclusive;
			toElement = tmp;
			toInclusive = tmpInc;
		}
		Range<E> range = bounds;
		AddressBounds<E> bounds, newBounds;
		if(range != null) {
			bounds = range.wrapped;
		} else {
			bounds = null;
		}
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(fromElement, fromInclusive, toElement,  toInclusive, trie.getComparator());
		} else {
			newBounds = bounds.restrict(fromElement, fromInclusive, toElement, toInclusive);
		}
		if(newBounds == null) {
			return this;
		}
		Range<E> newRange = new Range<E>(newBounds, isReverse);
		return new AddressTrieSet<E>(trie.createSubTrie(newBounds), newRange, isReverse);
	}
	@Override
	public AddressTrieSet<E> subSet(E fromElement, E toElement) {
		return subSet(fromElement, true, toElement, false);
    }
	@Override
	public AddressTrieSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		if(fromElement == null || toElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(fromElement, fromInclusive, toElement, toInclusive);
	}
	@Override
	public AddressTrieSet<E> headSet(E toElement) {
		return headSet(toElement, false);
    }
	@Override
	public AddressTrieSet<E> headSet(E toElement, boolean inclusive) {
		if(toElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(null, true, toElement, inclusive);
	}
	@Override
	public AddressTrieSet<E> tailSet(E fromElement) {
		return tailSet(fromElement, true);
    }
	@Override
	public AddressTrieSet<E> tailSet(E fromElement, boolean inclusive) {
		if(fromElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(fromElement, inclusive, null, false);
	}
	@Override
	public E first() {
		BinaryTreeNode<E> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		throw new NoSuchElementException();
    	}
    	return first.getKey();
    }
    @Override
	public E last() {
    	BinaryTreeNode<E> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		throw new NoSuchElementException();
    	}
    	return last.getKey();
    }
	@Override
	public E lower(E e) {
		return isReverse ? trie.higher(e) : trie.lower(e);
	}
	@Override
	public E floor(E e) {
		return isReverse ? trie.ceiling(e) : trie.floor(e);
	}
	@Override
	public E ceiling(E e) {
		return isReverse ? trie.floor(e) : trie.ceiling(e);
	}
	@Override
	public E higher(E e) {
		return isReverse ? trie.lower(e) : trie.higher(e);
	}
	@Override
	public E pollFirst() {
		BinaryTreeNode<E> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		return null;
    	}
    	first.remove();
    	return first.getKey();
	}
	@Override
	public E pollLast() {
		BinaryTreeNode<E> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		return null;
    	}
    	last.remove();
    	return last.getKey();
	}
	public String toTrieString() {
		return trie.toString();
	}
	/**
	 * Returns a subset consisting of those addresses in the set contained by the given address.
	 * The subset will have a restricted range matching the range of the given subnet or address.
	 * <p>
	 * If the subset would be the same size as this set, then this set is returned.
	 * The subset will the same backing trie as this set.
	 * 
	 * @param addr
	 * @return
	 */
	public AddressTrieSet<E> elementsContainedBy(E addr) {
		AddressTrie<E> newTrie = trie.elementsContainedByToSubTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieSet<E>(newTrie, null, isReverse);
		}
		Range<E> newRange = new Range<E>(newTrie.bounds, isReverse);
		return new AddressTrieSet<E>(newTrie, newRange, isReverse);
	}
	/**
	 * Returns a subset consisting of those addresses in the set that contain the given address.
	 * The subset will have the same restricted range (if any) as this set.
	 * <p>
	 * If the subset would be the same size as this set, then this set is returned.
	 * Otherwise, the subset is backed by a new trie.
	 * 
	 * @param addr
	 * @return
	 */
	public AddressTrieSet<E> elementsContaining(E addr) {
		AddressTrie<E> newTrie = trie.elementsContainingToTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieSet<E>(newTrie, null, isReverse);
		}
		Range<E> newRange = new Range<E>(newTrie.bounds, isReverse);
		return new AddressTrieSet<E>(newTrie, newRange, isReverse);
	}
	/**
	 * Returns true if a subnet or address in the set contains the given subnet or address.
	 * 
	 * @param addr
	 * @return
	 */
	public boolean elementContains(E addr) {
		return trie.elementContainsBounds(addr);
	}
	
	/**
	 * Returns the element with the longest prefix match with the given address.
	 * @param addr
	 * @return
	 */
	public E longestPrefixMatch(E addr) {
		return trie.longestPrefixMatchBounds(addr);
	}
}
/*
 * Copyright 2018-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.validate;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionLengthProvider;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionValueProvider;
import inet.ipaddr.ipv6.IPv6Address;
public class ParsedAddressGrouping {
	
	/**
	 * Returns the index of the segment containing the last byte within the network prefix
	 * When networkPrefixLength is zero (so there are no segments containing bytes within the network prefix), returns -1
	 * 
	 * @param networkPrefixLength
	 * @param byteLength
	 * @return
	 */
	public static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return (networkPrefixLength - 1) >> 4;//note this is intentionally a signed shift and not >>> so that networkPrefixLength of 0 returns -1
			}
			return (networkPrefixLength - 1) / bitsPerSegment;
		}
		return (networkPrefixLength - 1) >> 3;
	}
	
	/**
	 * Returns the index of the segment containing the first byte outside the network prefix.
	 * When networkPrefixLength is null, or it matches or exceeds the bit length, returns the segment count.
	 * 
	 * @param networkPrefixLength
	 * @param byteLength
	 * @return
	 */
	public static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return networkPrefixLength >> 4;
			}
			return networkPrefixLength / bitsPerSegment;
		}
		return networkPrefixLength >> 3;
	}
	/**
	 * Returns the total number of bits for the given segment count, with each segment having the given number of bits.
	 * The number of bytes must correspond to the number of bits.
	 * 
	 * @param segmentCount
	 * @param bytesPerSegment
	 * @param bitsPerSegment
	 * @return
	 */
	public static int getTotalBits(int segmentCount, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment != 1) {
			if(bytesPerSegment == 2) {
				return segmentCount << 4;
			}
			return segmentCount * bitsPerSegment;
		}
		return segmentCount << 3;
	}
	
	/**
	 * Across an address prefixes are:
	 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
	 * or IPv4: ...(null).(1 to 8).(0)...
	 */
	public static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		if(prefixLength != null) {
			return getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
		}
		return null;
	}
	public static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		int decrement = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return getDivisionPrefixLength(bitsPerSegment, prefixLength - decrement);
	}
	
	/**
	 * Across an address prefixes are:
	 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
	 * or IPv4: ...(null).(1 to 8).(0)...
	 */
	public static Integer getDivisionPrefixLength(int divisionBits, int divisionPrefixedBits) {
		if(divisionPrefixedBits <= 0) {
			return cache(0); //none of the bits in this segment matter
		} else if(divisionPrefixedBits <= divisionBits) {
			return cache(divisionPrefixedBits);//some of the bits in this segment matter
		}
		return null; //all the bits in this segment matter
	}
	
	/**
	 * Translates a non-null segment prefix length into an address prefix length.  
	 * When calling this for the first segment with a non-null prefix length, this gives the overall prefix length.
	 * <p>
	 * Across an address prefixes are:
	 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
	 * or IPv4: ...(null).(1 to 8).(0)...
	 */
	public static Integer getNetworkPrefixLength(int bitsPerSegment, int segmentPrefixLength, int segmentIndex) {
		int increment = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return cache(increment + segmentPrefixLength);
	}
	
	public static boolean isPrefixSubnet(
			DivisionValueProvider lowerValueProvider,
			DivisionValueProvider lowerExtendedValueProvider,
			DivisionValueProvider upperValueProvider,
			DivisionValueProvider upperExtendedValueProvider,
			DivisionLengthProvider bitLengthProvider,
			int divisionCount,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		}
		int totalBitLength = 0;
		topLoop:
		for(int i = 0; i < divisionCount; i++) {
			int divBitLength = bitLengthProvider.getLength(i);
			Integer divisionPrefLength = ParsedAddressGrouping.getDivisionPrefixLength(divBitLength, networkPrefixLength - totalBitLength);
			if(divBitLength == 0) {
				continue;
			}
			if(divisionPrefLength == null) {
				totalBitLength += divBitLength;
				continue;
			}
			int divisionPrefixLength = divisionPrefLength;
			int extendedPrefixLength, extendedDivBitLength;
			boolean isExtended, hasExtendedPrefixLength;
			boolean hasPrefLen = divisionPrefixLength != divBitLength;
			if(hasPrefLen) {
				// for values larger than 64 bits, the "extended" values are the upper (aka most significant, leftmost) bits
				if(isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
					if(hasExtendedPrefixLength = (divisionPrefixLength < extendedDivBitLength)) {
						extendedPrefixLength = divisionPrefixLength;
						divisionPrefixLength = 0;
					} else {
						isExtended = false;
						extendedPrefixLength = extendedDivBitLength;
						divisionPrefixLength -= extendedDivBitLength;
					}
				} else {
					extendedPrefixLength = extendedDivBitLength = 0;
					hasExtendedPrefixLength = false;
				}
			} else {
				extendedPrefixLength = extendedDivBitLength = 0;
				hasExtendedPrefixLength = isExtended = false;// we may be extended, but we set to false because we do nothing when no prefix
			}
			while(true) {
				if(isExtended) {
					long extendedLower = lowerExtendedValueProvider.getValue(i);
					if(extendedPrefixLength == 0) {
						if(extendedLower != 0) {
							return false;
						}
						long extendedUpper = upperExtendedValueProvider.getValue(i);
						if(fullRangeOnly) {
							long maxVal = ~0L >>> (Long.SIZE - extendedDivBitLength);
							if(extendedUpper != maxVal) {
								return false;
							}
						} else {
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes > 0) {
								if(upperOnes < Long.SIZE && (extendedUpper >>> upperOnes) != 0) {
									return false;
								}
								fullRangeOnly = true;
							} else if(extendedUpper != 0) {
								return false;
							}
						}
					} else if(hasExtendedPrefixLength) {
						int divHostBits = extendedDivBitLength - extendedPrefixLength; // < 64, when 64 handled by block above
						if(fullRangeOnly) {
							long hostMask = ~(~0L << divHostBits);
							if((hostMask & extendedLower) != 0) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							if((hostMask & extendedUpper) != hostMask) {
								return false;
							}
						} else {
							int lowerZeros = Long.numberOfTrailingZeros(extendedLower);
							if(lowerZeros < divHostBits) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes < divHostBits) {
								int upperZeros = Long.numberOfTrailingZeros(extendedUpper >>> upperOnes);
								if(upperOnes + upperZeros < divHostBits) {
									return false;
								}
								fullRangeOnly = upperOnes > 0;
							} else {
								fullRangeOnly = true;
							}
						}
					}
				}
				if(divisionPrefixLength == 0) {
					long lower = lowerValueProvider.getValue(i);
					if(lower != 0) {
						return false;
					}
					long upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {	
						long maxVal = ~0L >>> (Long.SIZE - divBitLength);
						if(upper != maxVal) {
							return false;
						}
					} else {
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if(upperOnes < Long.SIZE && (upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(hasPrefLen){
					long lower = lowerValueProvider.getValue(i);
					int divHostBits = divBitLength - divisionPrefixLength; // < 64, when 64 handled by block above
					if(fullRangeOnly) {
						long hostMask = ~(~0L << divHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Long.numberOfTrailingZeros(lower);
						if(lowerZeros < divHostBits) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes < divHostBits) {
							int upperZeros = Long.numberOfTrailingZeros(upper >>> upperOnes);
							if(upperOnes + upperZeros < divHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				if(++i == divisionCount) {
					break topLoop;
				}
				divBitLength = bitLengthProvider.getLength(i);
				if(hasExtendedPrefixLength = isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
				} else {
					extendedDivBitLength = 0;
				}
				extendedPrefixLength = divisionPrefixLength = 0;
			} // end while
		}
		return true;
	}
	
	// For explicit prefix config this always returns false.  
	// For all prefix subnets config this always returns true if the prefix length does not extend beyond the address end.
	public static boolean isPrefixSubnet(
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		} else {
			int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
			if(networkPrefixLength >= totalBitCount) {
				return false;
			}
		}
		if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int prefixedSegment = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int i = prefixedSegment;
		if(i < segmentCount) {
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			do {
				//we want to see if there is a sequence of zeros followed by a sequence of full-range bits from the prefix onwards
				//once we start seeing full range bits, the remained of the section must be full range
				//for instance x marks the start of zeros and y marks the start of full range:
				//segment 1 segment 2 ...
				//upper: 10101010  10100111 11111111 11111111
				//lower: 00111010  00100000 00000000 00000000
				//                    x y
				//upper: 10101010  10100000 00000000 00111111
				//lower: 00111010  00100000 10000000 00000000
				//                           x         y
				//
				//the bit marked x in each set of 4 segment of 8 bits is a sequence of zeros, followed by full range bits starting at bit y
				int lower = lowerValueProvider.getValue(i);
				if(segmentPrefixLength == 0) {
					if(lower != 0) {
						return false;
					}
					int upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {
						if(upper != segmentMaxValue) {
							return false;
						}
					} else {
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if((upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(segmentPrefixLength < bitsPerSegment) {
					int segHostBits = bitsPerSegment - segmentPrefixLength;
					if(fullRangeOnly) {
						int hostMask = ~(~0 << segHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Integer.numberOfTrailingZeros(lower);
						if(lowerZeros < segHostBits) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes < segHostBits) {
							int upperZeros = Integer.numberOfTrailingZeros((upper | (~0 << bitsPerSegment)) >>> upperOnes);
							if(upperOnes + upperZeros < segHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				segmentPrefixLength = 0;
			} while(++i < segmentCount);
		}
		return true;
	}
	
	// this is used to cache:
	// - ports
	// - prefix lengths and bit lengths
	// - segment mask values
	// so it needs to be large enough to accommodate all of those, but we only populate the bit lengths to start
	private static final Integer cache[] = new Integer[Short.MAX_VALUE]; static {
		for(int i = 0; i <= IPv6Address.BIT_COUNT; i++) {
			cache[i] = i;
		}
	}
     
	public static Integer cache(int i) {
		if(i >= 0 && i < cache.length) {
			Integer result = cache[i];
			if(result == null) {
				result = cache[i] = i;
			}
			return result;
		}
		return i;
	}
}
/*
 * Copyright 2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.IPAddress;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressAssociativeTrie;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressAssociativeTrie;
/**
 * Combines an IPv4 with an IPv6 associative trie to map both IPv4 and IPv6 addresses and prefix blocks.
 *   
 * For a tree that is either IPv4 or IPv6, one or the other, you can just use #{@link AssociativeAddressTrie}.
 * 
 * Another alternative to this data structure is to use a single IPv6 trie, while mapping IPv4 addresses to IPv6 with the default IPv4-mapped address mapping, or some other mapping.
 * 
 * @author scfoley
 *
 */
public class DualIPv4v6AssociativeTries<V> extends BaseDualIPv4v6Tries<IPv4AddressAssociativeTrie<V>, IPv6AddressAssociativeTrie<V>> {
	
	private static final long serialVersionUID = 1L;
	private IPv6AddressAssociativeTrie<V> ipv6Trie;
	private IPv4AddressAssociativeTrie<V> ipv4Trie;
	
	public DualIPv4v6AssociativeTries() {
		this(new IPv4AddressAssociativeTrie<V>(), new IPv6AddressAssociativeTrie<V>());
	}
	
	public DualIPv4v6AssociativeTries(IPv4AddressAssociativeTrie<V> ipv4Trie, IPv6AddressAssociativeTrie<V> ipv6Trie) {
		super(ipv4Trie, ipv6Trie);
		this.ipv4Trie = ipv4Trie;
		this.ipv6Trie = ipv6Trie;
	}
	
	@Override
	public DualIPv4v6AssociativeTries<V> clone() {
		DualIPv4v6AssociativeTries<V> result = (DualIPv4v6AssociativeTries<V>) super.clone();
		result.ipv4Trie = ipv4Trie.clone();
		result.ipv6Trie = ipv6Trie.clone();
		result.assignTrackers(result.ipv4Trie, result.ipv6Trie);
		return result;
	}
	
	@Override
	public IPv4AddressAssociativeTrie<V> getIPv4Trie() { 
		return ipv4Trie;
	}
	
	@Override
	public IPv6AddressAssociativeTrie<V> getIPv6Trie() {
		return ipv6Trie;
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> elementsContaining(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContaining, getIPv6Trie()::elementsContaining);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> elementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContainedBy, getIPv6Trie()::elementsContainedBy);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> removeElementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::removeElementsContainedBy, getIPv6Trie()::removeElementsContainedBy);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> getAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::getAddedNode, getIPv6Trie()::getAddedNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> longestPrefixMatchNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatchNode, getIPv6Trie()::longestPrefixMatchNode);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> addNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::addNode, getIPv6Trie()::addNode);
	}
		
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> addTrie(TrieNode<? extends IPAddress> trie) {
		return unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> floorAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::floorAddedNode, getIPv6Trie()::floorAddedNode);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> lowerAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::lowerAddedNode, getIPv6Trie()::lowerAddedNode);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> ceilingAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::ceilingAddedNode, getIPv6Trie()::ceilingAddedNode);
	}
	
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> higherAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::higherAddedNode, getIPv6Trie()::higherAddedNode);
	}
	
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> nodeIterator(boolean forward) {
		return combineNodeIterators(forward, getIPv4Trie().nodeIterator(forward), getIPv6Trie().nodeIterator(forward));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return combineNodeIterators(forwardSubNodeOrder, getIPv4Trie().containingFirstIterator(forwardSubNodeOrder), getIPv6Trie().containingFirstIterator(forwardSubNodeOrder));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return combineNodeIterators(forwardSubNodeOrder, getIPv4Trie().containedFirstIterator(forwardSubNodeOrder), getIPv6Trie().containedFirstIterator(forwardSubNodeOrder));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return combineBlockSizeNodeIterators(lowerSubNodeFirst, getIPv4Trie().blockSizeNodeIterator(lowerSubNodeFirst), getIPv6Trie().blockSizeNodeIterator(lowerSubNodeFirst));
	}
	@Override
	public Spliterator<AssociativeTrieNode<? extends IPAddress, V>> nodeSpliterator(boolean forward) {
		return combineNodeSpliterators(forward, getIPv4Trie().nodeSpliterator(forward), getIPv6Trie().nodeSpliterator(forward));
	}
	public AssociativeTrieNode<? extends IPAddress, V> addTrie(AssociativeTrieNode<? extends IPAddress, V> trie) {
		return DualIPv4v6Tries.unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	public V get(IPAddress addr) {
		return DualIPv4v6Tries.addressFuncOp(addr, getIPv4Trie()::get, getIPv6Trie()::get);
	}
	public V put(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValValBiFuncOp(addr, value, getIPv4Trie()::put, getIPv6Trie()::put);
	}
	public boolean putNew(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValBiFuncOp(addr, value, getIPv4Trie()::putNew, getIPv6Trie()::putNew);
	}
	public AssociativeTrieNode<? extends IPAddress, V> putNode(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValBiFuncOp(addr, value, getIPv4Trie()::putNode, getIPv6Trie()::putNode);
	}
	public AssociativeTrieNode<? extends IPAddress, V> putTrie(AssociativeTrieNode<? extends IPAddress, V> trie) {
		return DualIPv4v6Tries.unaryOp(trie, getIPv4Trie()::putTrie, getIPv6Trie()::putTrie);
	}
	public AssociativeTrieNode<? extends IPAddress, V> remap(IPAddress addr, Function<? super V, ? extends V> remapper) {
		return addressFuncOp(addr, remapper, getIPv4Trie()::remap, getIPv6Trie()::remap);
	}
	public AssociativeTrieNode<? extends IPAddress, V> remapIfAbsent(IPAddress addr, Supplier<? extends V> remapper, boolean insertNull) {
		return addressFuncBoolOp(addr, remapper, insertNull, getIPv4Trie()::remapIfAbsent, getIPv6Trie()::remapIfAbsent);
	}
	static <T, V, F> T addressFuncOp(
			IPAddress addr, 
			F remapper, 
			BiFunction<IPv4Address, F, T> ipv4Op, 
			BiFunction<IPv6Address, F, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), remapper);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), remapper);
		} 
		return null;
	}
	
	static <T, V, F> T addressFuncBoolOp(
			IPAddress addr, 
			F remapper, 
			boolean insertNull,
			TriBoolFunction<IPv4Address, F, T> ipv4Op, 
			TriBoolFunction<IPv6Address, F, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), remapper, insertNull);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), remapper, insertNull);
		} 
		return null;
	}
	
	@FunctionalInterface
	public interface TriBoolFunction<T, U, R> {
	    /**
	     * Applies this function to the given arguments.
	     *
	     * @param t the first function argument
	     * @param u the second function argument
	     * @param b the third function argument
	     * @return the function result
	     */
	    R apply(T t, U u, boolean b);
	}
}
/*
 * Copyright 2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Spliterator;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import inet.ipaddr.Address;
import inet.ipaddr.IPAddress;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AddressTrieOps.AddressTrieAddOps;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * Contains a pair of IPv4 and IPv6 tries for a data structure that can have fast look-up and containment checks of both IPv4 and IPv6 addresses.
 *   
 * For a tree that is either IPv4 or IPv6, you can just use #{@link AddressTrie}.
 * 
 * @author scfoley
 *
 */
public abstract class BaseDualIPv4v6Tries<T4 extends AddressTrie<IPv4Address>, T6 extends AddressTrie<IPv6Address>> implements Iterable<IPAddress>, Serializable, Cloneable {
	
	private static final long serialVersionUID = 1L;
	
	/**
	 * returns the contained IPv4 trie
	 * @return
	 */
	public abstract T4 getIPv4Trie();
	
	/**
	 * returns the contained IPv6 trie
	 * @return
	 */
	public abstract T6 getIPv6Trie();
	
	private ChangeTracker ipv4Tracker, ipv6Tracker;
	
	BaseDualIPv4v6Tries(AddressTrie<IPv4Address> ipv4Trie, AddressTrie<IPv6Address> ipv6Trie) {
		assignTrackers(ipv4Trie, ipv6Trie);
	}
	
	void assignTrackers(AddressTrie<IPv4Address> ipv4Trie, AddressTrie<IPv6Address> ipv6Trie) {
		this.ipv4Tracker = ipv4Trie.absoluteRoot().changeTracker;
		this.ipv6Tracker = ipv6Trie.absoluteRoot().changeTracker;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public BaseDualIPv4v6Tries<T4, T6> clone() {
		try {
			return (BaseDualIPv4v6Tries<T4, T6>) super.clone();
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	
	@Override
	public boolean equals(Object other) {
		if(other instanceof BaseDualIPv4v6Tries) {
			BaseDualIPv4v6Tries<?, ?> o = (BaseDualIPv4v6Tries<?, ?>) other;
			return getIPv4Trie().equals(o.getIPv4Trie()) && getIPv6Trie().equals(o.getIPv6Trie());
		}
		return false;
	}
	
	@Override
	public String toString() {
		return AddressTrie.toString(true, getIPv4Trie(), getIPv6Trie());
	}
	static boolean addressPredicateOp(IPAddress addr, Predicate<IPv4Address> ipv4Op, Predicate<IPv6Address> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.test(addr.toIPv4());
		} else if(addr.isIPv6()) {
			return ipv6Op.test(addr.toIPv6());
		} 
		return false;
	}
	static <T> T addressFuncOp(IPAddress addr, Function<IPv4Address, T> ipv4Op, Function<IPv6Address, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4());
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6());
		} 
		return null;
	}
	
	static <V> V addressValValBiFuncOp(IPAddress addr, V value, BiFunction<IPv4Address, V, V> ipv4Op, BiFunction<IPv6Address, V, V> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), value);
		} 
		return null;
	}
	
	static <V, R> R addressValBiFuncOp(IPAddress addr, V value, BiFunction<IPv4Address, V, R> ipv4Op, BiFunction<IPv6Address, V, R> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), value);
		} 
		return null;
	}
	
	static <V> boolean addressValBiPredicateOp(IPAddress addr, V value, BiPredicate<IPv4Address, V> ipv4Op, BiPredicate<IPv6Address, V> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.test(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.test(addr.toIPv6(), value);
		} 
		return false;
	}
	
	@SuppressWarnings("unchecked")
	static <T extends TrieNode<? extends IPAddress>, 
		R extends TrieNode<? extends IPAddress>,
		R1 extends TrieNode<IPv4Address>, 
		R2 extends TrieNode<IPv6Address>> R unaryOp(T trie, UnaryOperator<R1> ipv4Op, UnaryOperator<R2> ipv6Op) {
		IPAddress addr = trie.getKey();
		if(addr.isIPv4()) {
			return (R) ipv4Op.apply((R1) trie);
		} else if(addr.isIPv6()) {
			return (R) ipv6Op.apply((R2) trie);
		} 
		return null;
	}
	/**
	 * Returns the number of elements in the tries.  
	 * Only added nodes are counted.
	 * When zero is returned, {@link #isEmpty()} returns true.
	 * 
	 * @return
	 */
	public int size() {
		return getIPv4Trie().size() + getIPv6Trie().size();
	}
	/**
	 * Returns true if there are no added nodes within the two tries
	 */
	public boolean isEmpty() {
		return getIPv4Trie().isEmpty() && getIPv6Trie().isEmpty();
	}
	/**
	 * Adds the given single address or prefix block subnet to one of the two tries.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * Given a subnet s of type E and a trie of type AddressTrie&lt;E&gt;, such as {@link inet.ipaddr.ipv4.IPv4Address} and {@link inet.ipaddr.ipv4.IPv4AddressTrie},
	 * you can convert and add the spanning prefix blocks with <code>Partition.partitionWithSpanningBlocks(s).predicateForEach(trie::add)</code>,
	 * or you can convert and add using a single max block size with <code>Partition.partitionWithSingleBlockSize(s).predicateForEach(trie::add)</code>.
	 * <p>
	 * Returns true if the prefix block or address was inserted, false if already in one of the two tries.
	 * 
	 * @param addr
	 * @return
	 */
	public boolean add(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::add, getIPv6Trie()::add);
	}
	/**
	 * Returns whether the given address or prefix block subnet is in one of the two tries (as an added element).
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the prefix block or address address exists already in one the two tries, false otherwise.
	 * <p>
	 * Use {@link #getAddedNode(IPAddress)} to get the node for the address rather than just checking for its existence.
	 * 
	 * @param addr
	 * @return
	 */
	public boolean contains(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::contains, getIPv6Trie()::contains);
	}
	/**
	 * Removes the given single address or prefix block subnet from the tries.
	 * <p>
	 * Removing an element will not remove contained elements (nodes for contained blocks and addresses).
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException. 
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the prefix block or address was removed, false if not already in one of the two tries.
	 * <p>
	 * You can also remove by calling {@link #getAddedNode(IPAddress)} to get the node and then calling {@link BinaryTreeNode#remove()} on the node.
	 * <p>
	 * When an address is removed, the corresponding node may remain in the trie if it remains a subnet block for two sub-nodes.
	 * If the corresponding node can be removed from the trie, it will be.
	 * 
	 * @see #removeElementsContainedBy(IPAddress)
	 * @param addr
	 * @return
	 */
	public boolean remove(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::remove, getIPv6Trie()::remove);
	}
	/**
	 * Checks if a prefix block subnet or address in ones of the two tries contains the given subnet or address.
	 * <p>
	 * If the given address is not a single address nor prefix block, then this method throws IllegalArgumentException.
	 * <p>
	 * If not a single address nor prefix block, the {@link Partition} class can be used to convert the address before calling this method.  
	 * See {@link AddressTrieAddOps#add(Address)} for more details.
	 * <p>
	 * Returns true if the subnet or address is contained by a trie element, false otherwise.
	 * <p>
	 * To get all the containing addresses, use {@link #elementsContaining(IPAddress)}.
	 * 
	 * @param addr
	 * @return
	 */
	public boolean elementContains(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::elementContains, getIPv6Trie()::elementContains);
	}
	public TrieNode<? extends IPAddress> elementsContaining(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContaining, getIPv6Trie()::elementsContaining);
	}
	public TrieNode<? extends IPAddress> elementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContainedBy, getIPv6Trie()::elementsContainedBy);
	}
	public TrieNode<? extends IPAddress> removeElementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::removeElementsContainedBy, getIPv6Trie()::removeElementsContainedBy);
	}
	public TrieNode<? extends IPAddress> getAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::getAddedNode, getIPv6Trie()::getAddedNode);
	}
	public TrieNode<? extends IPAddress> longestPrefixMatchNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatchNode, getIPv6Trie()::longestPrefixMatchNode);
	}
	public IPAddress longestPrefixMatch(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatch, getIPv6Trie()::longestPrefixMatch);
	}
	public TrieNode<? extends IPAddress> addNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::addNode, getIPv6Trie()::addNode);
	}
	public TrieNode<? extends IPAddress> addTrie(TrieNode<? extends IPAddress> trie) {
		return unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	public TrieNode<? extends IPAddress> floorAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::floorAddedNode, getIPv6Trie()::floorAddedNode);
	}
	public TrieNode<? extends IPAddress> lowerAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::lowerAddedNode, getIPv6Trie()::lowerAddedNode);
	}
	public TrieNode<? extends IPAddress> ceilingAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::ceilingAddedNode, getIPv6Trie()::ceilingAddedNode);
	}
	public TrieNode<? extends IPAddress> higherAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::higherAddedNode, getIPv6Trie()::higherAddedNode);
	}
	public IPAddress floor(IPAddress addr) {
		return AddressTrie.getNodeKey(floorAddedNode(addr));
	}
	public IPAddress lower(IPAddress addr) {
		return AddressTrie.getNodeKey(lowerAddedNode(addr));
	}
	public IPAddress ceiling(IPAddress addr) {
		return AddressTrie.getNodeKey(ceilingAddedNode(addr));
	}
	public IPAddress higher(IPAddress addr) {
		return AddressTrie.getNodeKey(higherAddedNode(addr));
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPAddress> iterator() {
		Iterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().iterator(), ipv6Iterator = getIPv6Trie().iterator();
		return new DualIterator<IPAddress>((Iterator<IPAddress>) ipv4Iterator, (Iterator<IPAddress>) ipv6Iterator, true);
	}
	@SuppressWarnings("unchecked")
	public Iterator<IPAddress> descendingIterator() {
		Iterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().descendingIterator(), ipv6Iterator = getIPv6Trie().descendingIterator();
		return new DualIterator<IPAddress>((Iterator<IPAddress>) ipv4Iterator, (Iterator<IPAddress>) ipv6Iterator, false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPAddress> spliterator() {
		Spliterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().spliterator(), ipv6Iterator = getIPv6Trie().spliterator();
		return new DualSpliterator<IPAddress>((Spliterator<IPAddress>) ipv4Iterator, (Spliterator<IPAddress>) ipv6Iterator);
	}
	@SuppressWarnings("unchecked")
	public Spliterator<IPAddress> descendingSpliterator() {
		Spliterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().descendingSpliterator(), ipv6Iterator = getIPv6Trie().descendingSpliterator();
		return new DualSpliterator<IPAddress>((Spliterator<IPAddress>) ipv6Iterator, (Spliterator<IPAddress>) ipv4Iterator);
	}
	
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Iterator<T> combineNodeIterators(
			boolean forward,
			Iterator<? extends T> ipv4It, 
			Iterator<? extends T> ipv6It) {
		Iterator<T> ipv4I = (Iterator<T>) ipv4It;
		Iterator<T> ipv6I = (Iterator<T>) ipv6It;
		return new DualIterator<T>(ipv4I, ipv6I, forward);
	}
	
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Iterator<T> combineBlockSizeNodeIterators(
			boolean lowerSubNodeFirst,
			Iterator<? extends T> ipv4It, 
			Iterator<? extends T> ipv6It) {
		Iterator<T> ipv4I = (Iterator<T>) ipv4It;
		Iterator<T> ipv6I = (Iterator<T>) ipv6It;
		return new DualBlockSizeIterator<T>(lowerSubNodeFirst, ipv4I, ipv6I);
	}
	
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> nodeIterator(boolean forward);
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> containingFirstIterator(boolean forwardSubNodeOrder);
	
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> containedFirstIterator(boolean forwardSubNodeOrder);
	
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> blockSizeNodeIterator(boolean lowerSubNodeFirst);
	
	public abstract Spliterator<? extends TrieNode<? extends IPAddress>> nodeSpliterator(boolean forward);
	
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Spliterator<T> combineNodeSpliterators(
			boolean forward,
			Spliterator<? extends T> ipv4It, 
			Spliterator<? extends T> ipv6It) {
		Spliterator<T> ipv4I = (Spliterator<T>) ipv4It;
		Spliterator<T> ipv6I = (Spliterator<T>) ipv6It;
		if(forward) {
			return new DualSpliterator<T>(ipv4I, ipv6I);
		} 
		return new DualSpliterator<T>(ipv6I, ipv4I);
	}
	
	static class BlockSizeComp<E extends Address> implements Comparator<E> {
		private final boolean reverseBlocksEqualSize;
	
		BlockSizeComp(boolean reverseBlocksEqualSize) {
			this.reverseBlocksEqualSize = reverseBlocksEqualSize;
		}
	
		@Override
		public int compare(E addr1, E addr2) {
			if(addr1 == addr2) {
				return 0;
			}
			if(addr1.isPrefixed()) {
				if(addr2.isPrefixed()) {
					int val = (addr2.getBitCount() - addr2.getPrefixLength())
							- (addr1.getBitCount() - addr1.getPrefixLength());
					if(val == 0) {
						int compVal = compareLowValues(addr1, addr2);
						return reverseBlocksEqualSize ? -compVal : compVal;
					}
					return val;
				}
				return -1;
			}
			if(addr2.isPrefixed()) {
				return 1;
			}
			int compVal = compareLowValues(addr1, addr2);
			return reverseBlocksEqualSize ? -compVal : compVal;
		}
	};
	
	static int compareLowValues(Address one, Address two) {
		return Address.ADDRESS_LOW_VALUE_COMPARATOR.compare(one, two);
	}
	
	static final Comparator<?> BLOCK_SIZE_COMP = new BlockSizeComp<>(false), REVERSE_BLOCK_SIZE_COMP = new BlockSizeComp<>(true);
	class BaseDualIterator {
		Change ipv4CurrentChange, ipv6CurrentChange;
		
		BaseDualIterator() {
			if(ipv4Tracker != null) {
				ipv4CurrentChange = ipv4Tracker.getCurrent();
			}
			if(ipv6Tracker != null) {
				ipv6CurrentChange = ipv6Tracker.getCurrent();
			}
		}
		
		void changedSince() {
			if(ipv4Tracker != null) {
				ipv4Tracker.changedSince(ipv4CurrentChange);
			}
			if(ipv6Tracker != null) {
				ipv6Tracker.changedSince(ipv6CurrentChange);
			}
		}
	}
	class DualBlockSizeIterator<T extends TrieNode<? extends IPAddress>> extends BaseDualIterator implements Iterator<T> {
		T ipv4Item, ipv6Item; 
		Iterator<T> ipv4Iterator, ipv6Iterator;
		T lastItem;
		Comparator<IPAddress> comp;
		@SuppressWarnings("unchecked")
		DualBlockSizeIterator(boolean lowerSubNodeFirst, Iterator<T> ipv4Iterator, Iterator<T> ipv6Iterator) {
			boolean reverseBlocksEqualSize = !lowerSubNodeFirst;
			comp = (Comparator<IPAddress>) (reverseBlocksEqualSize ? REVERSE_BLOCK_SIZE_COMP : BLOCK_SIZE_COMP);
			this.ipv4Iterator = ipv4Iterator;
			this.ipv6Iterator = ipv6Iterator;
		}
		
		@Override
		public boolean hasNext() {
			return ipv4Item != null || ipv6Item != null || ipv4Iterator.hasNext() || ipv6Iterator.hasNext();
		}
		@Override
		public T next() {
			if(hasNext()) {
				changedSince();
			} else {
				throw new NoSuchElementException();
			}
			// replace whatever was returned previously
			if(ipv4Item == null && ipv4Iterator.hasNext()) {
				ipv4Item = ipv4Iterator.next();
			} 
			if(ipv6Item == null && ipv6Iterator.hasNext()) {
				ipv6Item = ipv6Iterator.next();
			}
			
			T result;
			
			// now return the lowest of the two
			if(ipv4Item == null) {
				result = lastItem = ipv6Item;
				ipv6Item = null;
			} else if(ipv6Item == null) {
				result = lastItem = ipv4Item;
				ipv4Item = null;
			} else {
				int cmp = comp.compare(ipv4Item.getKey(), ipv6Item.getKey());
				if(cmp < 0) {
					result = lastItem = ipv4Item;
					ipv4Item = null;
				} else {
					result = lastItem = ipv6Item;
					ipv6Item = null;
				}
			}
			return result;
		}
		
		@Override
		public void remove() {
			if(lastItem == null) {
				throw new IllegalStateException();
			}
			changedSince();
			if(lastItem.getKey().isIPv4()) {
				ipv4Iterator.remove();
				ipv4CurrentChange = ipv4Tracker.getCurrent();
			} else {
				ipv6Iterator.remove();
				ipv6CurrentChange = ipv6Tracker.getCurrent();
			}
			lastItem = null;
	    }
	}
	
	class DualIterator<T> extends BaseDualIterator implements Iterator<T> {
		private Iterator<T> current; // always points to the previously-used iterator, so that "remove" works as intended, and any caching functionality as well
		private Iterator<T> first, last;
		private boolean firstIsIPv4;
		
		DualIterator(Iterator<T> ipv4Iterator, Iterator<T> ipv6Iterator, boolean forward) {
			if(forward) {
				this.first = ipv4Iterator;
				this.last = ipv6Iterator;
			} else {
				this.first = ipv6Iterator;
				this.last = ipv4Iterator;
			}
			current = first;
			firstIsIPv4 = forward;
		}
		
		@Override
		public boolean hasNext() {
			if(current == last) {
				return last.hasNext();
			}
			return current.hasNext() || last.hasNext();
		}
		
		@Override
		public T next() {
			if(current != last && !first.hasNext()) {
				current = last;
			}
			
			// note that the next element is always pre-prepared for 
			// all iterator subtypes of AbstractNodeIterator
			// so that means we know we can trust the result of hasNext
			// even when the trie has been changed.
			if(current.hasNext()) {
				//TODO you really only need to check the non-current here, since current.next() checks the current, but is this optimization worth the bother? I suppose
				changedSince();
			}
			return current.next();
		}
		
		@Override
		public void remove() {
			changedSince();
			
			current.remove();
	        
	        if(current == first ? firstIsIPv4 : !firstIsIPv4) {
	        	if(ipv4Tracker != null) {
    				ipv4CurrentChange = ipv4Tracker.getCurrent();
    			}
	        } else if(ipv6Tracker != null) {
    			ipv6CurrentChange = ipv6Tracker.getCurrent();
	        }
	    }
	}
	
	class DualSpliterator<T> extends BaseDualIterator implements Spliterator<T> {
		// before the first split we use first and second,
		// after that we use current
		Spliterator<T> first, second, current;
		DualSpliterator(Spliterator<T> first, Spliterator<T> second) {
			this.first = first;
			this.second = second;
		}
		
		@Override
		public boolean tryAdvance(Consumer<? super T> action) {
			changedSince();
			if(current == null) {
				if(first.tryAdvance(action)) {
					return true;
				}
				return second.tryAdvance(action);
			}
			return current.tryAdvance(action);
		}
	
		@Override
		public Spliterator<T> trySplit() {
			changedSince();
			if(current == null) {
				current = second;
				return first;
			}
			return current.trySplit();
		}
	
		@Override
		public void forEachRemaining(Consumer<? super T> action) {
			changedSince();
			if(current == null) {
				current = second;
				first.forEachRemaining(action);
				second.forEachRemaining(action);
			} else {
				current.forEachRemaining(action);
			}
	    }
		
		@Override
		public long estimateSize() {
			if(current == null) {
				return first.estimateSize() + second.estimateSize();
			}
			return current.estimateSize();
		}
	
		@Override
		public int characteristics() {
			if(current == null) {
				return first.characteristics() & second.characteristics();
			}
			return current.characteristics();
		}
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * An IPv4 address trie in which each node can be associated with a value.
 * 
 * See {@link AssociativeAddressTrie} for more details.
 * 
 * @author scfoley
 * 
 * @param <V> the type of the associated values
 *
 */
public class IPv4AddressAssociativeTrie<V> extends AssociativeAddressTrie<IPv4Address, V> {
	private static final long serialVersionUID = 1L;
	private static final IPv4Address INIT_ROOT = IPv4AddressTrie.INIT_ROOT;
	public IPv4AddressAssociativeTrie() {
		super(new IPv4AssociativeTrieNode<V>());
	}
	protected IPv4AddressAssociativeTrie(AddressBounds<IPv4Address> bounds) {
		super(new IPv4AssociativeTrieNode<V>(), bounds);
	}
	protected IPv4AddressAssociativeTrie(IPv4AssociativeTrieNode<V> root, AddressBounds<IPv4Address> bounds) {
		super(root, bounds);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getRoot() {
		return (IPv4AssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected IPv4AssociativeTrieNode<V> absoluteRoot() {
		return (IPv4AssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected IPv4AddressAssociativeTrie<V> createNew(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected IPv4AddressAssociativeTrie<V> createSubTrie(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class IPv4AssociativeTrieNode<V> extends AssociativeTrieNode<IPv4Address, V> {
		private static final long serialVersionUID = 1L;
		protected IPv4AssociativeTrieNode(IPv4Address addr) {
			super(addr);
		}
		public IPv4AssociativeTrieNode() { // root node
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv4Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv4AssociativeTrieNode<V> getUpperSubNode() {
			return (IPv4AssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> getLowerSubNode() {
			return (IPv4AssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> getParent() {
			return (IPv4AssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected IPv4AssociativeTrieNode<V> createNewImpl(IPv4Address addr) {
			return new IPv4AssociativeTrieNode<V>(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> removeElementsContainedBy(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> elementsContainedBy(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> elementsContaining(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		
		@Override
		public IPv4AssociativeTrieNode<V> longestPrefixMatchNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> getAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> getNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv4AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv4AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv4AssociativeTrieNode<V> previousAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.previousAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> nextAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.nextAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> nextNode() {
			return (IPv4AssociativeTrieNode<V>) super.nextNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> previousNode() {
			return (IPv4AssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lowerAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> floorAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> higherAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> ceilingAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> firstNode() {
			return (IPv4AssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lastNode() {
			return (IPv4AssociativeTrieNode<V>) super.lastNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> firstAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lastAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.lastAddedNode();
		}
		
		@Override
		protected IPv4AddressAssociativeTrie<V> createNewTree() {
			return new IPv4AddressAssociativeTrie<V>();
		}
		
		@Override
		public IPv4AddressAssociativeTrie<V> asNewTrie() {
			return (IPv4AddressAssociativeTrie<V>) super.asNewTrie();
		}
		@Override
		public IPv4AssociativeTrieNode<V> cloneTree() {
			return (IPv4AssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public IPv4AssociativeTrieNode<V> clone() {
			return (IPv4AssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv4AddressAssociativeTrie.IPv4AssociativeTrieNode && super.equals(o);
		}
		@Override
		protected TrieKeyData getTrieKeyCache(IPv4Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv4AssociativeTrieNode<V> removeElementsContainedBy(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> elementsContainedBy(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> elementsContaining(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> longestPrefixMatchNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> addNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public IPv4AssociativeTrieNode<V> addTrie(TrieNode<IPv4Address> trie) {
		return (IPv4AssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv4AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv4AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv4AssociativeTrieNode<V> lowerAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> floorAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> higherAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> ceilingAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> firstNode() {
		return (IPv4AssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> lastNode() {
		return (IPv4AssociativeTrieNode<V>) super.lastNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> firstAddedNode() {
		return (IPv4AssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> lastAddedNode() {
		return (IPv4AssociativeTrieNode<V>) super.lastAddedNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> putNode(IPv4Address addr, V value) {
		return (IPv4AssociativeTrieNode<V>) super.putNode(addr, value);
	}
	@Override
	public IPv4AssociativeTrieNode<V> putTrie(AssociativeTrieNode<IPv4Address, V> trie) {
		return (IPv4AssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public IPv4AssociativeTrieNode<V> remap(IPv4Address addr, Function<? super V, ? extends V> remapper) {
		return (IPv4AssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public IPv4AssociativeTrieNode<V> remapIfAbsent(IPv4Address addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (IPv4AssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv4AddressAssociativeTrie && super.equals(o);
	}
	@Override
	public IPv4AddressAssociativeTrie<V> clone() {
		return (IPv4AddressAssociativeTrie<V>) super.clone();
	}
	@Override
	public AssociativeAddedTree<IPv4Address, V> constructAddedNodesTree() {
		IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<IPv4Address, V>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
/*
 * Copyright 2020-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.mac;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * A MAC address trie in which each node can be associated with a value.
 * 
 * See {@link AssociativeAddressTrie} for more details.
 * 
 * @author scfoley
 * 
 * @param <V> the type of the associated values
 *
 */
public class MACAddressAssociativeTrie<V> extends AssociativeAddressTrie<MACAddress, V> {
	private static final long serialVersionUID = 1L;
	private static final MACAddress INIT_ROOT = MACAddressTrie.INIT_ROOT;
	private static final MACAddress INIT_ROOT_EXTENDED = MACAddressTrie.INIT_ROOT_EXTENDED;
	public MACAddressAssociativeTrie() {
		super(new MACAssociativeTrieNode<V>());
	}
	protected MACAddressAssociativeTrie(AddressBounds<MACAddress> bounds) {
		super(new MACAssociativeTrieNode<V>(), bounds);
	}
	protected MACAddressAssociativeTrie(MACAssociativeTrieNode<V> root, AddressBounds<MACAddress> bounds) {
		super(root, bounds);
	}
	// if the very first address inserted into the trie is 64-bit, the trie is 64 bit
	@Override
	protected void adjustRoot(MACAddress addr) {
		if(isEmpty() && addr.getSegmentCount() == MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			absoluteRoot().setExtendedRootKey();
		}
	}
	@Override
	public MACAssociativeTrieNode<V> getRoot() {
		return (MACAssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected MACAssociativeTrieNode<V> absoluteRoot() {
		return (MACAssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected MACAddressAssociativeTrie<V> createNew(AddressBounds<MACAddress> bounds) {
		return new MACAddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected MACAddressAssociativeTrie<V> createSubTrie(AddressBounds<MACAddress> bounds) {
		return new MACAddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class MACAssociativeTrieNode<V> extends AssociativeTrieNode<MACAddress, V> {
		private static final long serialVersionUID = 1L;
		protected MACAssociativeTrieNode(MACAddress addr) {
			super(addr);
		}
		public MACAssociativeTrieNode() { // root node
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<MACAddress> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		void setExtendedRootKey() {
			setKey(INIT_ROOT_EXTENDED);
		}
		@Override
		public MACAssociativeTrieNode<V> getUpperSubNode() {
			return (MACAssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public MACAssociativeTrieNode<V> getLowerSubNode() {
			return (MACAssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public MACAssociativeTrieNode<V> getParent() {
			return (MACAssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected MACAssociativeTrieNode<V> createNewImpl(MACAddress addr) {
			return new MACAssociativeTrieNode<V>(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> removeElementsContainedBy(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> elementsContainedBy(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> elementsContaining(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> longestPrefixMatchNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> getAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> getNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACAssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<MACAssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACAssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<MACAssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public MACAssociativeTrieNode<V> previousAddedNode() {
			return (MACAssociativeTrieNode<V>) super.previousAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> nextAddedNode() {
			return (MACAssociativeTrieNode<V>) super.nextAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> nextNode() {
			return (MACAssociativeTrieNode<V>) super.nextNode();
		}
		@Override
		public MACAssociativeTrieNode<V> previousNode() {
			return (MACAssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lowerAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> floorAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> higherAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> ceilingAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> firstNode() {
			return (MACAssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lastNode() {
			return (MACAssociativeTrieNode<V>) super.lastNode();
		}
		@Override
		public MACAssociativeTrieNode<V> firstAddedNode() {
			return (MACAssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lastAddedNode() {
			return (MACAssociativeTrieNode<V>) super.lastAddedNode();
		}
		
		@Override
		protected MACAddressAssociativeTrie<V> createNewTree() {
			return new MACAddressAssociativeTrie<V>();
		}
		@Override
		public MACAddressAssociativeTrie<V> asNewTrie() {
			return (MACAddressAssociativeTrie<V>) super.asNewTrie();
		}
		
		@Override
		public MACAssociativeTrieNode<V> cloneTree() {
			return (MACAssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public MACAssociativeTrieNode<V> clone() {
			return (MACAssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof MACAddressAssociativeTrie.MACAssociativeTrieNode && super.equals(o);
		}
	}
	@Override
	public MACAssociativeTrieNode<V> removeElementsContainedBy(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> elementsContainedBy(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> elementsContaining(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> longestPrefixMatchNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> getAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> getNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> addNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public MACAssociativeTrieNode<V> addTrie(TrieNode<MACAddress> trie) {
		return (MACAssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACAssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<MACAssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACAssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<MACAssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public MACAssociativeTrieNode<V> lowerAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> floorAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> higherAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> ceilingAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> firstNode() {
		return (MACAssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public MACAssociativeTrieNode<V> lastNode() {
		return (MACAssociativeTrieNode<V>) super.lastNode();
	}
	@Override
	public MACAssociativeTrieNode<V> firstAddedNode() {
		return (MACAssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public MACAssociativeTrieNode<V> lastAddedNode() {
		return (MACAssociativeTrieNode<V>) super.lastAddedNode();
	}
	@Override
	public MACAssociativeTrieNode<V> putNode(MACAddress addr, V value) {
		return (MACAssociativeTrieNode<V>) super.putNode(addr, value);
	}
	@Override
	public MACAssociativeTrieNode<V> putTrie(AssociativeTrieNode<MACAddress, V> trie) {
		return (MACAssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public MACAssociativeTrieNode<V> remap(MACAddress addr, Function<? super V, ? extends V> remapper) {
		return (MACAssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public MACAssociativeTrieNode<V> remapIfAbsent(MACAddress addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (MACAssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof MACAddressAssociativeTrie && super.equals(o);
	}
	@Override
	public MACAddressAssociativeTrie<V> clone() {
		return (MACAddressAssociativeTrie<V>) super.clone();
	}
	@Override
	public AssociativeAddedTree<MACAddress, V> constructAddedNodesTree() {
		MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>> trie = new MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<MACAddress, V>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>> trie = new MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
/*
 * Copyright 2020-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.mac;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.MACAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * A MAC address trie.
 * 
 * See {@link AddressTrie}  for more details.
 * 
 * @author scfoley
 *
 */
public class MACAddressTrie extends AddressTrie<MACAddress> {
	private static final long serialVersionUID = 1L;
	static final MACAddress INIT_ROOT = new MACAddressString("*:*:*:*:*:*").getAddress();
	static final MACAddress INIT_ROOT_EXTENDED = new MACAddressString("*:*:*:*:*:*:*:*").getAddress();
	public MACAddressTrie() {
		super(new MACTrieNode());
	}
	protected MACAddressTrie(AddressBounds<MACAddress> bounds) {
		super(new MACTrieNode(), bounds);
	}
	protected MACAddressTrie(MACTrieNode root, AddressBounds<MACAddress> bounds) {
		super(root, bounds);
	}
	// if the very first address inserted into the trie is 64-bit, the trie is 64 bit
	@Override
	protected void adjustRoot(MACAddress addr) {
		if(isEmpty() && addr.getSegmentCount() == MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			absoluteRoot().setExtendedRootKey();
		}
	}
	@Override
	protected MACTrieNode absoluteRoot() {
		return (MACTrieNode) super.absoluteRoot();
	}
	@Override
	protected MACAddressTrie createNew(AddressBounds<MACAddress> bounds) {
		return new MACAddressTrie(bounds);
	}
	@Override
	protected MACAddressTrie createSubTrie(AddressBounds<MACAddress> bounds) {
		return new MACAddressTrie(absoluteRoot(), bounds);
	}
	@Override
	public MACTrieNode getRoot() {
		return (MACTrieNode) super.getRoot();
	}
	public static class MACTrieNode extends TrieNode<MACAddress> {
		private static final long serialVersionUID = 1L;
		protected MACTrieNode(MACAddress addr) {
			super(addr);
		}
		public MACTrieNode() { // root node
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<MACAddress> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		void setExtendedRootKey() {
			setKey(INIT_ROOT_EXTENDED);
		}
		@Override
		public MACTrieNode getUpperSubNode() {
			return (MACTrieNode) super.getUpperSubNode();
		}
		@Override
		public MACTrieNode getLowerSubNode() {
			return (MACTrieNode) super.getLowerSubNode();
		}
		@Override
		public MACTrieNode getParent() {
			return (MACTrieNode) super.getParent();
		}
		@Override
		protected MACTrieNode createNewImpl(MACAddress addr) {
			return new MACTrieNode(addr);
		}
		@Override
		public MACTrieNode removeElementsContainedBy(MACAddress addr) {
			return (MACTrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public MACTrieNode elementsContainedBy(MACAddress addr) {
			return (MACTrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public MACTrieNode elementsContaining(MACAddress addr) {
			return (MACTrieNode) super.elementsContaining(addr);
		}
		@Override
		public MACTrieNode longestPrefixMatchNode(MACAddress addr) {
			return (MACTrieNode) super.longestPrefixMatchNode(addr);
		}
		@Override
		public MACTrieNode getAddedNode(MACAddress addr) {
			return (MACTrieNode) super.getAddedNode(addr);
		}
		@Override
		public MACTrieNode getNode(MACAddress addr) {
			return (MACTrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> nodeIterator(boolean forward) {
			return (Iterator<MACTrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> allNodeIterator(boolean forward) {
			return (Iterator<MACTrieNode>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACTrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACTrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACTrieNode, MACAddress, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<MACTrieNode, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACTrieNode, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<MACTrieNode, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACTrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<MACTrieNode>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACTrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<MACTrieNode>) super.allNodeSpliterator(forward);
		}
		@Override
		public MACTrieNode previousAddedNode() {
			return (MACTrieNode) super.previousAddedNode();
		}
		@Override
		public MACTrieNode nextAddedNode() {
			return (MACTrieNode) super.nextAddedNode();
		}
		@Override
		public MACTrieNode nextNode() {
			return (MACTrieNode) super.nextNode();
		}
		@Override
		public MACTrieNode previousNode() {
			return (MACTrieNode) super.previousNode();
		}
		@Override
		public MACTrieNode lowerAddedNode(MACAddress addr) {
			return (MACTrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public MACTrieNode floorAddedNode(MACAddress addr) {
			return (MACTrieNode) super.floorAddedNode(addr);
		}
		@Override
		public MACTrieNode higherAddedNode(MACAddress addr) {
			return (MACTrieNode) super.higherAddedNode(addr);
		}
		@Override
		public MACTrieNode ceilingAddedNode(MACAddress addr) {
			return (MACTrieNode) super.ceilingAddedNode(addr);
		}
		@Override
		public MACTrieNode firstNode() {
			return (MACTrieNode) super.firstNode();
		}
		@Override
		public MACTrieNode lastNode() {
			return (MACTrieNode) super.lastNode();
		}
		@Override
		public MACTrieNode firstAddedNode() {
			return (MACTrieNode) super.firstAddedNode();
		}
		@Override
		public MACTrieNode lastAddedNode() {
			return (MACTrieNode) super.lastAddedNode();
		}
		
		@Override
		protected MACAddressTrie createNewTree() {
			return new MACAddressTrie();
		}
		
		@Override
		public MACAddressTrie asNewTrie() {
			return (MACAddressTrie) super.asNewTrie();
		}
		@Override
		public MACTrieNode cloneTree() {
			return (MACTrieNode) super.cloneTree();
		}
		@Override
		public MACTrieNode clone() {
			return (MACTrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof MACTrieNode && super.equals(o);
		}
	}
	@Override
	public MACTrieNode removeElementsContainedBy(MACAddress addr) {
		return (MACTrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public MACTrieNode elementsContainedBy(MACAddress addr) {
		return (MACTrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public MACTrieNode elementsContaining(MACAddress addr) {
		return (MACTrieNode) super.elementsContaining(addr);
	}
	@Override
	public MACTrieNode longestPrefixMatchNode(MACAddress addr) {
		return (MACTrieNode) super.longestPrefixMatchNode(addr);
	}
	@Override
	public MACTrieNode getAddedNode(MACAddress addr) {
		return (MACTrieNode) super.getAddedNode(addr);
	}
	@Override
	public MACTrieNode getNode(MACAddress addr) {
		return (MACTrieNode) super.getNode(addr);
	}
	@Override
	public MACTrieNode addNode(MACAddress addr) {
		return (MACTrieNode) super.addNode(addr);
	}
	@Override
	public MACTrieNode addTrie(TrieNode<MACAddress> trie) {
		return (MACTrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> nodeIterator(boolean forward) {
		return (Iterator<MACTrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> allNodeIterator(boolean forward) {
		return (Iterator<MACTrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACTrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACTrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACTrieNode, MACAddress, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<MACTrieNode, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACTrieNode, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<MACTrieNode, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACTrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<MACTrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACTrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<MACTrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public MACTrieNode lowerAddedNode(MACAddress addr) {
		return (MACTrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public MACTrieNode floorAddedNode(MACAddress addr) {
		return (MACTrieNode) super.floorAddedNode(addr);
	}
	@Override
	public MACTrieNode higherAddedNode(MACAddress addr) {
		return (MACTrieNode) super.higherAddedNode(addr);
	}
	@Override
	public MACTrieNode ceilingAddedNode(MACAddress addr) {
		return (MACTrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public MACTrieNode firstNode() {
		return (MACTrieNode) super.firstNode();
	}
	@Override
	public MACTrieNode lastNode() {
		return (MACTrieNode) super.lastNode();
	}
	@Override
	public MACTrieNode firstAddedNode() {
		return (MACTrieNode) super.firstAddedNode();
	}
	@Override
	public MACTrieNode lastAddedNode() {
		return (MACTrieNode) super.lastAddedNode();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof MACAddressTrie && super.equals(o);
	}
	@Override
	public MACAddressTrie clone() {
		return (MACAddressTrie) super.clone();
	}
	@Override
	public AddedTree<MACAddress> constructAddedNodesTree() {
		MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>> trie = new MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>>();
		contructAddedTree(trie);
		return new AddedTree<MACAddress>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>> trie = new MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
/**
 * An IPv4 address trie.
 * 
 * See {@link AddressTrie} for more details.
 * 
 * @author scfoley
 *
 */
public class IPv4AddressTrie extends AddressTrie<IPv4Address> {
	private static final long serialVersionUID = 1L;
	
	static final IPv4Address INIT_ROOT = new IPAddressString("0.0.0.0/0").getAddress().toIPv4();
	public IPv4AddressTrie() {
		super(new IPv4TrieNode());
	}
	
	protected IPv4AddressTrie(AddressBounds<IPv4Address> bounds) {
		super(new IPv4TrieNode(), bounds);
	}
	
	protected IPv4AddressTrie(IPv4TrieNode root, AddressBounds<IPv4Address> bounds) {
		super(root, bounds);
	}
	
	@Override
	protected IPv4TrieNode absoluteRoot() {
		return (IPv4TrieNode) super.absoluteRoot();
	}
	
	@Override
	protected IPv4AddressTrie createNew(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressTrie(bounds);
	}
	
	@Override
	protected IPv4AddressTrie createSubTrie(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressTrie(absoluteRoot(), bounds);
	}
	
	@Override
	public IPv4TrieNode getRoot() {
		return (IPv4TrieNode) super.getRoot();
	}
	
	public static class IPv4TrieNode extends TrieNode<IPv4Address> {
		private static final long serialVersionUID = 1L;
		protected IPv4TrieNode(IPv4Address addr) {
			super(addr);
		}
		public IPv4TrieNode() {
			super(INIT_ROOT);
		} // root node
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv4Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
	
		@Override
		public IPv4TrieNode getUpperSubNode() {
			return (IPv4TrieNode) super.getUpperSubNode();
		}
	
		@Override
		public IPv4TrieNode getLowerSubNode() {
			return (IPv4TrieNode) super.getLowerSubNode();
		}
		
		@Override
		public IPv4TrieNode getParent() {
			return (IPv4TrieNode) super.getParent();
		}
		
		@Override
		protected IPv4TrieNode createNewImpl(IPv4Address addr) {
			return new IPv4TrieNode(addr);
		}
		
		@Override
		public IPv4TrieNode removeElementsContainedBy(IPv4Address addr) {
			return (IPv4TrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv4TrieNode elementsContainedBy(IPv4Address addr) {
			return (IPv4TrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public IPv4TrieNode elementsContaining(IPv4Address addr) {
			return (IPv4TrieNode) super.elementsContaining(addr);
		}
		
		@Override
		public IPv4TrieNode longestPrefixMatchNode(IPv4Address addr) {
			return (IPv4TrieNode) super.longestPrefixMatchNode(addr);
		}
		
		@Override
		public IPv4TrieNode getAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.getAddedNode(addr);
		}
		@Override
		public IPv4TrieNode getNode(IPv4Address addr) {
			return (IPv4TrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> nodeIterator(boolean forward) {
			return (Iterator<IPv4TrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> allNodeIterator(boolean forward) {
			return (Iterator<IPv4TrieNode>) super.allNodeIterator(forward);
		}
	
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4TrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv4TrieNode>) super.nodeSpliterator(forward);
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4TrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv4TrieNode>) super.allNodeSpliterator(forward);
		}
		
		@Override
		public IPv4TrieNode previousAddedNode() {
			return (IPv4TrieNode) super.previousAddedNode();
		}
		
		@Override
		public IPv4TrieNode nextAddedNode() {
			return (IPv4TrieNode) super.nextAddedNode();
		}
		
		@Override
		public IPv4TrieNode nextNode() {
			return (IPv4TrieNode) super.nextNode();
		}
		
		@Override
		public IPv4TrieNode previousNode() {
			return (IPv4TrieNode) super.previousNode();
		}
		
		@Override
		public IPv4TrieNode lowerAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public IPv4TrieNode floorAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.floorAddedNode(addr);
		}
		@Override
		public IPv4TrieNode higherAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.higherAddedNode(addr);
		}
		@Override
		public IPv4TrieNode ceilingAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.ceilingAddedNode(addr);
		}
		
		@Override
		public IPv4TrieNode firstNode() {
			return (IPv4TrieNode) super.firstNode();
		}
		@Override
		public IPv4TrieNode lastNode() {
			return (IPv4TrieNode) super.lastNode();
		}
		
		@Override
		protected IPv4AddressTrie createNewTree() {
			return new IPv4AddressTrie();
		}
		@Override
		public IPv4AddressTrie asNewTrie() {
			return (IPv4AddressTrie) super.asNewTrie();
		}
		@Override
		public IPv4TrieNode cloneTree() {
			return (IPv4TrieNode) super.cloneTree();
		}
		@Override
		public IPv4TrieNode clone() {
			return (IPv4TrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv4TrieNode && super.equals(o);
		}
		static class IPv4TrieKeyData extends TrieKeyData {
			int uint32Val, mask32Val, nextBitMask32Val;
			@Override
			public boolean is32Bits() {
				return true;
			}
			@Override
			public int getUint32Val() {
				return uint32Val;
			}
			@Override
			public int getMask32Val() {
				return mask32Val;
			}
			@Override
			public int getNextBitMask32Val() {
				return nextBitMask32Val;
			}
		}
		@Override
		protected TrieKeyData getTrieKeyCache(IPv4Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv4TrieNode removeElementsContainedBy(IPv4Address addr) {
		return (IPv4TrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv4TrieNode elementsContainedBy(IPv4Address addr) {
		return (IPv4TrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public IPv4TrieNode elementsContaining(IPv4Address addr) {
		return (IPv4TrieNode) super.elementsContaining(addr);
	}
	
	@Override
	public IPv4TrieNode longestPrefixMatchNode(IPv4Address addr) {
		return (IPv4TrieNode) super.longestPrefixMatchNode(addr);
	}
	
	@Override
	public IPv4TrieNode getAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.getAddedNode(addr);
	}
	@Override
	public IPv4TrieNode getNode(IPv4Address addr) {
		return (IPv4TrieNode) super.getNode(addr);
	}
	
	@Override
	public IPv4TrieNode addNode(IPv4Address addr) {
		return (IPv4TrieNode) super.addNode(addr);
	}
	
	@Override
	public IPv4TrieNode addTrie(TrieNode<IPv4Address> trie) {
		return (IPv4TrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> nodeIterator(boolean forward) {
		return (Iterator<IPv4TrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> allNodeIterator(boolean forward) {
		return (Iterator<IPv4TrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4TrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv4TrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4TrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv4TrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv4TrieNode lowerAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public IPv4TrieNode floorAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.floorAddedNode(addr);
	}
	@Override
	public IPv4TrieNode higherAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.higherAddedNode(addr);
	}
	@Override
	public IPv4TrieNode ceilingAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv4TrieNode firstNode() {
		return (IPv4TrieNode) super.firstNode();
	}
	@Override
	public IPv4TrieNode lastNode() {
		return (IPv4TrieNode) super.lastNode();
	}
	@Override
	public IPv4AddressTrie clone() {
		return (IPv4AddressTrie) super.clone();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv4AddressTrie && super.equals(o);
	}
	@Override
	public AddedTree<IPv4Address> constructAddedNodesTree() {
		IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>>();
		contructAddedTree(trie);
		return new AddedTree<IPv4Address>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}