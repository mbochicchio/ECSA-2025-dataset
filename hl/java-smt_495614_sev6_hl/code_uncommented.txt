package org.sosy_lab.java_smt.solvers.opensmt.api;
public class VectorPTRef extends java.util.AbstractList<PTRef> implements java.util.RandomAccess {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected VectorPTRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(VectorPTRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(VectorPTRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_VectorPTRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public VectorPTRef(PTRef[] initialElements) {
    this();
    reserve(initialElements.length);
    for (PTRef element : initialElements) {
      add(element);
    }
  }
  public VectorPTRef(Iterable<PTRef> initialElements) {
    this();
    for (PTRef element : initialElements) {
      add(element);
    }
  }
  public PTRef get(int index) {
    return doGet(index);
  }
  public PTRef set(int index, PTRef e) {
    return doSet(index, e);
  }
  public boolean add(PTRef e) {
    modCount++;
    doAdd(e);
    return true;
  }
  public void add(int index, PTRef e) {
    modCount++;
    doAdd(index, e);
  }
  public PTRef remove(int index) {
    modCount++;
    return doRemove(index);
  }
  protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    doRemoveRange(fromIndex, toIndex);
  }
  public int size() {
    return doSize();
  }
  public VectorPTRef() {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_0(), true);
  }
  public VectorPTRef(VectorPTRef other) {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_1(VectorPTRef.getCPtr(other), other), true);
  }
  public long capacity() {
    return OsmtNativeJNI.VectorPTRef_capacity(swigCPtr, this);
  }
  public void reserve(long n) {
    OsmtNativeJNI.VectorPTRef_reserve(swigCPtr, this, n);
  }
  public boolean isEmpty() {
    return OsmtNativeJNI.VectorPTRef_isEmpty(swigCPtr, this);
  }
  public void clear() {
    OsmtNativeJNI.VectorPTRef_clear(swigCPtr, this);
  }
  public VectorPTRef(int count, PTRef value) {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_2(count, PTRef.getCPtr(value), value), true);
  }
  private int doSize() {
    return OsmtNativeJNI.VectorPTRef_doSize(swigCPtr, this);
  }
  private void doAdd(PTRef x) {
    OsmtNativeJNI.VectorPTRef_doAdd__SWIG_0(swigCPtr, this, PTRef.getCPtr(x), x);
  }
  private void doAdd(int index, PTRef x) {
    OsmtNativeJNI.VectorPTRef_doAdd__SWIG_1(swigCPtr, this, index, PTRef.getCPtr(x), x);
  }
  private PTRef doRemove(int index) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doRemove(swigCPtr, this, index), true);
  }
  private PTRef doGet(int index) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doGet(swigCPtr, this, index), false);
  }
  private PTRef doSet(int index, PTRef val) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doSet(swigCPtr, this, index, PTRef.getCPtr(val), val), true);
  }
  private void doRemoveRange(int fromIndex, int toIndex) {
    OsmtNativeJNI.VectorPTRef_doRemoveRange(swigCPtr, this, fromIndex, toIndex);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class OsmtNativeJNI {
  public final static native long new_VectorInt__SWIG_0();
  public final static native long new_VectorInt__SWIG_1(long jarg1, VectorInt jarg1_);
  public final static native long VectorInt_capacity(long jarg1, VectorInt jarg1_);
  public final static native void VectorInt_reserve(long jarg1, VectorInt jarg1_, long jarg2);
  public final static native boolean VectorInt_isEmpty(long jarg1, VectorInt jarg1_);
  public final static native void VectorInt_clear(long jarg1, VectorInt jarg1_);
  public final static native long new_VectorInt__SWIG_2(int jarg1, int jarg2);
  public final static native int VectorInt_doSize(long jarg1, VectorInt jarg1_);
  public final static native void VectorInt_doAdd__SWIG_0(long jarg1, VectorInt jarg1_, int jarg2);
  public final static native void VectorInt_doAdd__SWIG_1(long jarg1, VectorInt jarg1_, int jarg2, int jarg3);
  public final static native int VectorInt_doRemove(long jarg1, VectorInt jarg1_, int jarg2);
  public final static native int VectorInt_doGet(long jarg1, VectorInt jarg1_, int jarg2);
  public final static native int VectorInt_doSet(long jarg1, VectorInt jarg1_, int jarg2, int jarg3);
  public final static native void VectorInt_doRemoveRange(long jarg1, VectorInt jarg1_, int jarg2, int jarg3);
  public final static native void delete_VectorInt(long jarg1);
  public final static native long new_VectorPTRef__SWIG_0();
  public final static native long new_VectorPTRef__SWIG_1(long jarg1, VectorPTRef jarg1_);
  public final static native long VectorPTRef_capacity(long jarg1, VectorPTRef jarg1_);
  public final static native void VectorPTRef_reserve(long jarg1, VectorPTRef jarg1_, long jarg2);
  public final static native boolean VectorPTRef_isEmpty(long jarg1, VectorPTRef jarg1_);
  public final static native void VectorPTRef_clear(long jarg1, VectorPTRef jarg1_);
  public final static native long new_VectorPTRef__SWIG_2(int jarg1, long jarg2, PTRef jarg2_);
  public final static native int VectorPTRef_doSize(long jarg1, VectorPTRef jarg1_);
  public final static native void VectorPTRef_doAdd__SWIG_0(long jarg1, VectorPTRef jarg1_, long jarg2, PTRef jarg2_);
  public final static native void VectorPTRef_doAdd__SWIG_1(long jarg1, VectorPTRef jarg1_, int jarg2, long jarg3, PTRef jarg3_);
  public final static native long VectorPTRef_doRemove(long jarg1, VectorPTRef jarg1_, int jarg2);
  public final static native long VectorPTRef_doGet(long jarg1, VectorPTRef jarg1_, int jarg2);
  public final static native long VectorPTRef_doSet(long jarg1, VectorPTRef jarg1_, int jarg2, long jarg3, PTRef jarg3_);
  public final static native void VectorPTRef_doRemoveRange(long jarg1, VectorPTRef jarg1_, int jarg2, int jarg3);
  public final static native void delete_VectorPTRef(long jarg1);
  public final static native long new_VectorSRef__SWIG_0();
  public final static native long new_VectorSRef__SWIG_1(long jarg1, VectorSRef jarg1_);
  public final static native long VectorSRef_capacity(long jarg1, VectorSRef jarg1_);
  public final static native void VectorSRef_reserve(long jarg1, VectorSRef jarg1_, long jarg2);
  public final static native boolean VectorSRef_isEmpty(long jarg1, VectorSRef jarg1_);
  public final static native void VectorSRef_clear(long jarg1, VectorSRef jarg1_);
  public final static native long new_VectorSRef__SWIG_2(int jarg1, long jarg2, SRef jarg2_);
  public final static native int VectorSRef_doSize(long jarg1, VectorSRef jarg1_);
  public final static native void VectorSRef_doAdd__SWIG_0(long jarg1, VectorSRef jarg1_, long jarg2, SRef jarg2_);
  public final static native void VectorSRef_doAdd__SWIG_1(long jarg1, VectorSRef jarg1_, int jarg2, long jarg3, SRef jarg3_);
  public final static native long VectorSRef_doRemove(long jarg1, VectorSRef jarg1_, int jarg2);
  public final static native long VectorSRef_doGet(long jarg1, VectorSRef jarg1_, int jarg2);
  public final static native long VectorSRef_doSet(long jarg1, VectorSRef jarg1_, int jarg2, long jarg3, SRef jarg3_);
  public final static native void VectorSRef_doRemoveRange(long jarg1, VectorSRef jarg1_, int jarg2, int jarg3);
  public final static native void delete_VectorSRef(long jarg1);
  public final static native long new_VectorSymRef__SWIG_0();
  public final static native long new_VectorSymRef__SWIG_1(long jarg1, VectorSymRef jarg1_);
  public final static native long VectorSymRef_capacity(long jarg1, VectorSymRef jarg1_);
  public final static native void VectorSymRef_reserve(long jarg1, VectorSymRef jarg1_, long jarg2);
  public final static native boolean VectorSymRef_isEmpty(long jarg1, VectorSymRef jarg1_);
  public final static native void VectorSymRef_clear(long jarg1, VectorSymRef jarg1_);
  public final static native long new_VectorSymRef__SWIG_2(int jarg1, long jarg2, SymRef jarg2_);
  public final static native int VectorSymRef_doSize(long jarg1, VectorSymRef jarg1_);
  public final static native void VectorSymRef_doAdd__SWIG_0(long jarg1, VectorSymRef jarg1_, long jarg2, SymRef jarg2_);
  public final static native void VectorSymRef_doAdd__SWIG_1(long jarg1, VectorSymRef jarg1_, int jarg2, long jarg3, SymRef jarg3_);
  public final static native long VectorSymRef_doRemove(long jarg1, VectorSymRef jarg1_, int jarg2);
  public final static native long VectorSymRef_doGet(long jarg1, VectorSymRef jarg1_, int jarg2);
  public final static native long VectorSymRef_doSet(long jarg1, VectorSymRef jarg1_, int jarg2, long jarg3, SymRef jarg3_);
  public final static native void VectorSymRef_doRemoveRange(long jarg1, VectorSymRef jarg1_, int jarg2, int jarg3);
  public final static native void delete_VectorSymRef(long jarg1);
  public final static native long new_VectorVectorInt__SWIG_0();
  public final static native long new_VectorVectorInt__SWIG_1(long jarg1, VectorVectorInt jarg1_);
  public final static native long VectorVectorInt_capacity(long jarg1, VectorVectorInt jarg1_);
  public final static native void VectorVectorInt_reserve(long jarg1, VectorVectorInt jarg1_, long jarg2);
  public final static native boolean VectorVectorInt_isEmpty(long jarg1, VectorVectorInt jarg1_);
  public final static native void VectorVectorInt_clear(long jarg1, VectorVectorInt jarg1_);
  public final static native long new_VectorVectorInt__SWIG_2(int jarg1, long jarg2, VectorInt jarg2_);
  public final static native int VectorVectorInt_doSize(long jarg1, VectorVectorInt jarg1_);
  public final static native void VectorVectorInt_doAdd__SWIG_0(long jarg1, VectorVectorInt jarg1_, long jarg2, VectorInt jarg2_);
  public final static native void VectorVectorInt_doAdd__SWIG_1(long jarg1, VectorVectorInt jarg1_, int jarg2, long jarg3, VectorInt jarg3_);
  public final static native long VectorVectorInt_doRemove(long jarg1, VectorVectorInt jarg1_, int jarg2);
  public final static native long VectorVectorInt_doGet(long jarg1, VectorVectorInt jarg1_, int jarg2);
  public final static native long VectorVectorInt_doSet(long jarg1, VectorVectorInt jarg1_, int jarg2, long jarg3, VectorInt jarg3_);
  public final static native void VectorVectorInt_doRemoveRange(long jarg1, VectorVectorInt jarg1_, int jarg2, int jarg3);
  public final static native void delete_VectorVectorInt(long jarg1);
  public final static native void PTRef_x_set(long jarg1, PTRef jarg1_, long jarg2);
  public final static native long PTRef_x_get(long jarg1, PTRef jarg1_);
  public final static native long PTRef_Undef_get();
  public final static native void delete_PTRef(long jarg1);
  public final static native void SSymRef_x_set(long jarg1, SSymRef jarg1_, long jarg2);
  public final static native long SSymRef_x_get(long jarg1, SSymRef jarg1_);
  public final static native void delete_SSymRef(long jarg1);
  public final static native boolean SortSymbol_isInternal(long jarg1, SortSymbol jarg1_);
  public final static native long SortSymbol_getArity(long jarg1, SortSymbol jarg1_);
  public final static native String SortSymbol_getName(long jarg1, SortSymbol jarg1_);
  public final static native void delete_SortSymbol(long jarg1);
  public final static native void SRef_x_set(long jarg1, SRef jarg1_, long jarg2);
  public final static native long SRef_x_get(long jarg1, SRef jarg1_);
  public final static native void delete_SRef(long jarg1);
  public final static native long Sort_getSymRef(long jarg1, Sort jarg1_);
  public final static native long Sort_getSize(long jarg1, Sort jarg1_);
  public final static native long Sort_getArgs(long jarg1, Sort jarg1_);
  public final static native void delete_Sort(long jarg1);
  public final static native int Symbol_size(long jarg1, Symbol jarg1_);
  public final static native long Symbol_rsort(long jarg1, Symbol jarg1_);
  public final static native boolean Symbol_isInterpreted(long jarg1, Symbol jarg1_);
  public final static native long Symbol_getArgTypes(long jarg1, Symbol jarg1_);
  public final static native void delete_Symbol(long jarg1);
  public final static native void SymRef_x_set(long jarg1, SymRef jarg1_, long jarg2);
  public final static native long SymRef_x_get(long jarg1, SymRef jarg1_);
  public final static native void delete_SymRef(long jarg1);
  public final static native void delete_InterpolationContext(long jarg1);
  public final static native long InterpolationContext_getSingleInterpolant(long jarg1, InterpolationContext jarg1_, long jarg2, VectorInt jarg2_);
  public final static native long InterpolationContext_getPathInterpolants(long jarg1, InterpolationContext jarg1_, long jarg2, VectorVectorInt jarg2_);
  public final static native int getLogicFromString(long jarg1);
  public final static native long LogicFactory_getInstance(int jarg1);
  public final static native long LogicFactory_getLAInstance(int jarg1);
  public final static native long LogicFactory_getLRAInstance();
  public final static native long LogicFactory_getLIAInstance();
  public final static native String LogicFactory_getVersion();
  public final static native void delete_LogicFactory(long jarg1);
  public final static native long new_SMTOption__SWIG_0(int jarg1);
  public final static native long new_SMTOption__SWIG_1(double jarg1);
  public final static native long new_SMTOption__SWIG_2(String jarg1);
  public final static native boolean SMTOption_isEmpty(long jarg1, SMTOption jarg1_);
  public final static native String SMTOption_toString(long jarg1, SMTOption jarg1_);
  public final static native long new_SMTOption__SWIG_3(boolean jarg1);
  public final static native void delete_SMTOption(long jarg1);
  public final static native void SMTConfig_o_produce_unsat_cores_set(String jarg1);
  public final static native String SMTConfig_o_produce_unsat_cores_get();
  public final static native void SMTConfig_o_minimal_unsat_cores_set(String jarg1);
  public final static native String SMTConfig_o_minimal_unsat_cores_get();
  public final static native void SMTConfig_o_print_cores_full_set(String jarg1);
  public final static native String SMTConfig_o_print_cores_full_get();
  public final static native long new_SMTConfig__SWIG_0();
  public final static native void delete_SMTConfig(long jarg1);
  public final static native long new_SMTConfig__SWIG_1(long jarg1, SMTConfig jarg1_);
  public final static native void SMTConfig_setProduceProofs(long jarg1, SMTConfig jarg1_);
  public final static native boolean SMTConfig_produce_unsat_cores(long jarg1, SMTConfig jarg1_);
  public final static native boolean SMTConfig_minimal_unsat_cores(long jarg1, SMTConfig jarg1_);
  public final static native boolean SMTConfig_print_cores_full(long jarg1, SMTConfig jarg1_);
  public final static native boolean SMTConfig_produce_proof(long jarg1, SMTConfig jarg1_);
  public final static native void SMTConfig_setOption(long jarg1, SMTConfig jarg1_, String jarg2, long jarg3, SMTOption jarg3_);
  public final static native String TemplateFunction_getName(long jarg1, TemplateFunction jarg1_);
  public final static native long TemplateFunction_getRetSort(long jarg1, TemplateFunction jarg1_);
  public final static native long TemplateFunction_getBody(long jarg1, TemplateFunction jarg1_);
  public final static native long new_TemplateFunction(String jarg1, long jarg2, VectorPTRef jarg2_, long jarg3, SRef jarg3_, long jarg4, PTRef jarg4_);
  public final static native long TemplateFunction_getArgs(long jarg1, TemplateFunction jarg1_);
  public final static native void delete_TemplateFunction(long jarg1);
  public final static native int Pterm_size(long jarg1, Pterm jarg1_);
  public final static native long Pterm_symb(long jarg1, Pterm jarg1_);
  public final static native long Pterm_at(long jarg1, Pterm jarg1_, int jarg2);
  public final static native void delete_Pterm(long jarg1);
  public final static native long Model_evaluate(long jarg1, Model jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Model_getDefinition(long jarg1, Model jarg1_, long jarg2, SymRef jarg2_);
  public final static native void delete_Model(long jarg1);
  public final static native char sstat_getValue(long jarg1, sstat jarg1_);
  public final static native long sstat_True();
  public final static native long sstat_False();
  public final static native long sstat_Undef();
  public final static native long sstat_Error();
  public final static native void delete_sstat(long jarg1);
  public final static native long new_MainSolver__SWIG_0(long jarg1, Logic jarg1_, long jarg2, SMTConfig jarg2_, String jarg3);
  public final static native void delete_MainSolver(long jarg1);
  public final static native long new_MainSolver__SWIG_1(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getConfig(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getLogic(long jarg1, MainSolver jarg1_);
  public final static native void MainSolver_push(long jarg1, MainSolver jarg1_);
  public final static native boolean MainSolver_pop(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getAssertionLevel(long jarg1, MainSolver jarg1_);
  public final static native void MainSolver_insertFormula(long jarg1, MainSolver jarg1_, long jarg2, PTRef jarg2_);
  public final static native long MainSolver_getInsertedFormulasCount(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_check(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_solve(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getStatus(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getModel(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getInterpolationContext(long jarg1, MainSolver jarg1_);
  public final static native void MainSolver_stop(long jarg1, MainSolver jarg1_);
  public final static native long MainSolver_getUnsatCore(long jarg1, MainSolver jarg1_);
  public final static native long new_Logic__SWIG_0(int jarg1);
  public final static native void delete_Logic(long jarg1);
  public final static native long new_Logic__SWIG_1(long jarg1, Logic jarg1_);
  public final static native long Logic_getSortDefinition(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_);
  public final static native long Logic_getSortSymbol(long jarg1, Logic jarg1_, long jarg2, SSymRef jarg2_);
  public final static native long Logic_getSortRef(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native String Logic_printSort(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_);
  public final static native long Logic_declareUninterpretedSort(long jarg1, Logic jarg1_, String jarg2);
  public final static native boolean Logic_isArraySort(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_);
  public final static native long Logic_getArraySort(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_, long jarg3, SRef jarg3_);
  public final static native boolean Logic_isArrayStore(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isArraySelect(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Logic_getSym(long jarg1, Logic jarg1_, long jarg2, SymRef jarg2_);
  public final static native long Logic_getSymRef(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native String Logic_getSymName(long jarg1, Logic jarg1_, long jarg2, SymRef jarg2_);
  public final static native long Logic_getPterm(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Logic_mkAnd__SWIG_0(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_mkOr__SWIG_0(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_mkXor(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_mkImpl__SWIG_0(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_mkNot(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Logic_mkIte(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_, long jarg4, PTRef jarg4_);
  public final static native long Logic_mkEq__SWIG_0(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_mkVar__SWIG_0(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_, String jarg3, boolean jarg4);
  public final static native long Logic_mkVar__SWIG_1(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_, String jarg3);
  public final static native long Logic_mkConst(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_, String jarg3);
  public final static native long Logic_mkBoolVar(long jarg1, Logic jarg1_, String jarg2);
  public final static native String Logic_dumpWithLets(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Logic_parseFormula(long jarg1, Logic jarg1_, String jarg2);
  public final static native long Logic_getSort_bool(long jarg1, Logic jarg1_);
  public final static native long Logic_getTerm_true(long jarg1, Logic jarg1_);
  public final static native long Logic_getTerm_false(long jarg1, Logic jarg1_);
  public final static native boolean Logic_isEquality(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isDisequality(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isIte(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isConstant(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isVar(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isUF(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isAnd(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isOr(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isNot(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isXor(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isImplies(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isTrue(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isFalse(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean Logic_isIff(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native String Logic_protectName(long jarg1, Logic jarg1_, long jarg2, SymRef jarg2_);
  public final static native String Logic_pp(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long Logic_mkStore(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_, long jarg4, PTRef jarg4_);
  public final static native long Logic_mkSelect(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_getDefaultValue(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_);
  public final static native long Logic_mkUninterpFun(long jarg1, Logic jarg1_, long jarg2, SymRef jarg2_, long jarg3, VectorPTRef jarg3_);
  public final static native long Logic_mkAnd__SWIG_1(long jarg1, Logic jarg1_, long jarg2, VectorPTRef jarg2_);
  public final static native long Logic_mkOr__SWIG_1(long jarg1, Logic jarg1_, long jarg2, VectorPTRef jarg2_);
  public final static native long Logic_mkImpl__SWIG_1(long jarg1, Logic jarg1_, long jarg2, VectorPTRef jarg2_);
  public final static native long Logic_mkEq__SWIG_1(long jarg1, Logic jarg1_, long jarg2, VectorPTRef jarg2_);
  public final static native long Logic_mkDistinct__SWIG_0(long jarg1, Logic jarg1_, long jarg2, VectorPTRef jarg2_);
  public final static native long Logic_mkDistinct__SWIG_1(long jarg1, Logic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long Logic_declareFun(long jarg1, Logic jarg1_, String jarg2, long jarg3, SRef jarg3_, long jarg4, VectorSRef jarg4_);
  public final static native long Logic_instantiateFunctionTemplate(long jarg1, Logic jarg1_, long jarg2, TemplateFunction jarg2_, long jarg3, VectorPTRef jarg3_);
  public final static native boolean Logic_isSortBool(long jarg1, Logic jarg1_, long jarg2, SRef jarg2_);
  public final static native long Logic_insertTerm(long jarg1, Logic jarg1_, long jarg2, SymRef jarg2_, long jarg3, VectorPTRef jarg3_);
  public final static native void delete_ArithLogic(long jarg1);
  public final static native long new_ArithLogic(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getSort_real(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getSort_int(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_mkConst(long jarg1, ArithLogic jarg1_, long jarg2, SRef jarg2_, String jarg3);
  public final static native long ArithLogic_mkIntVar(long jarg1, ArithLogic jarg1_, String jarg2);
  public final static native long ArithLogic_mkRealVar(long jarg1, ArithLogic jarg1_, String jarg2);
  public final static native boolean ArithLogic_isNumConst(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isIntConst(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isRealConst(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isSortInt(long jarg1, ArithLogic jarg1_, long jarg2, SRef jarg2_);
  public final static native boolean ArithLogic_isSortReal(long jarg1, ArithLogic jarg1_, long jarg2, SRef jarg2_);
  public final static native boolean ArithLogic_isPlus(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isNeg(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isTimes(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isLeq(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isLt(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isGeq(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isGt(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long ArithLogic_getTerm_IntZero(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getTerm_RealZero(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getTerm_IntOne(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getTerm_RealOne(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getTerm_IntMinusOne(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_getTerm_RealMinusOne(long jarg1, ArithLogic jarg1_);
  public final static native long ArithLogic_mkNeg(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long ArithLogic_mkMinus(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkPlus(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkTimes(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkIntDiv(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkRealDiv(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkMod(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkLeq(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkGeq(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkLt(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkGt(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_, long jarg3, PTRef jarg3_);
  public final static native long ArithLogic_mkIntConst(long jarg1, ArithLogic jarg1_, String jarg2);
  public final static native long ArithLogic_mkRealConst(long jarg1, ArithLogic jarg1_, String jarg2);
  public final static native String ArithLogic_getNumConst(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isMinus(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isDiv(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native boolean ArithLogic_isMod(long jarg1, ArithLogic jarg1_, long jarg2, PTRef jarg2_);
  public final static native long ArithLogic_SWIGUpcast(long jarg1);
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Evaluator;
import org.sosy_lab.java_smt.api.FormulaManager;
import org.sosy_lab.java_smt.api.Model;
import org.sosy_lab.java_smt.api.Model.ValueAssignment;
import org.sosy_lab.java_smt.api.SolverContext.ProverOptions;
import org.sosy_lab.java_smt.api.SolverException;
import org.sosy_lab.java_smt.basicimpl.AbstractProverWithAllSat;
import org.sosy_lab.java_smt.basicimpl.ShutdownHook;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtSolverContext.OpenSMTOptions;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.MainSolver;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTConfig;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTOption;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
import org.sosy_lab.java_smt.solvers.opensmt.api.sstat;
public abstract class OpenSmtAbstractProver<T> extends AbstractProverWithAllSat<T> {
  protected final OpenSmtFormulaCreator creator;
  protected final MainSolver osmtSolver;
  protected final SMTConfig osmtConfig;
  private boolean changedSinceLastSatQuery = false;
  protected OpenSmtAbstractProver(
      OpenSmtFormulaCreator pFormulaCreator,
      FormulaManager pMgr,
      ShutdownNotifier pShutdownNotifier,
      SMTConfig pConfig,
      Set<ProverOptions> pOptions) {
    super(pOptions, pMgr.getBooleanFormulaManager(), pShutdownNotifier);
    creator = pFormulaCreator;
    osmtConfig = pConfig;
    osmtSolver = new MainSolver(creator.getEnv(), pConfig, "JavaSmt");
  }
  protected static SMTConfig getConfigInstance(
      Set<ProverOptions> pOptions, OpenSMTOptions pSolverOptions, boolean interpolation) {
    SMTConfig config = new SMTConfig();
    config.setOption(":random-seed", new SMTOption(pSolverOptions.randomSeed));
    config.setOption(
        ":produce-models",
        new SMTOption(
            pOptions.contains(ProverOptions.GENERATE_MODELS)
                || pOptions.contains(ProverOptions.GENERATE_ALL_SAT)));
    SMTOption optUnsatCore = new SMTOption(pOptions.contains(ProverOptions.GENERATE_UNSAT_CORE));
    config.setOption(":produce-unsat-cores", optUnsatCore);
    config.setOption(":print-cores-full", optUnsatCore);
    config.setOption(":produce-interpolants", new SMTOption(interpolation));
    if (interpolation) {
      config.setOption(":interpolation-bool-algorithm", new SMTOption(pSolverOptions.algBool));
      config.setOption(":interpolation-euf-algorithm", new SMTOption(pSolverOptions.algUf));
      config.setOption(":interpolation-lra-algorithm", new SMTOption(pSolverOptions.algLra));
    }
    return config;
  }
  final MainSolver getOsmtSolver() {
    return osmtSolver;
  }
  @Override
  protected void pushImpl() {
    setChanged();
    osmtSolver.push();
  }
  @Override
  protected void popImpl() {
    setChanged();
    osmtSolver.pop();
  }
  @Nullable
  protected abstract T addConstraintImpl(PTRef f) throws InterruptedException;
  @Override
  @Nullable
  protected T addConstraintImpl(BooleanFormula pF) throws InterruptedException {
    setChanged();
    PTRef f = creator.extractInfo(pF);
    return addConstraintImpl(f);
  }
  @SuppressWarnings("resource")
  @Override
  public Model getModel() {
    Preconditions.checkState(!closed);
    checkGenerateModels();
    Model model =
        new OpenSmtModel(
            this, creator, Collections2.transform(getAssertedFormulas(), creator::extractInfo));
    return registerEvaluator(model);
  }
  @Override
  public Evaluator getEvaluator() {
    Preconditions.checkState(!closed);
    checkGenerateModels();
    return getEvaluatorWithoutChecks();
  }
  @SuppressWarnings("resource")
  @Override
  protected Evaluator getEvaluatorWithoutChecks() {
    return registerEvaluator(new OpenSmtEvaluator(this, creator));
  }
  protected void setChanged() {
    if (!changedSinceLastSatQuery) {
      changedSinceLastSatQuery = true;
      closeAllEvaluators();
    }
  }
  @Override
  public ImmutableList<ValueAssignment> getModelAssignments() throws SolverException {
    Preconditions.checkState(!closed);
    Preconditions.checkState(!changedSinceLastSatQuery);
    return super.getModelAssignments();
  }
  private String getReasonFromSolverFeatures() {
    Logic osmtLogic = creator.getEnv();
    Map<String, PTRef> userDeclarations = new HashMap<>();
    for (PTRef asserted : Collections2.transform(getAssertedFormulas(), creator::extractInfo)) {
      userDeclarations.putAll(creator.extractVariablesAndUFs(asserted, true));
    }
    boolean usesUFs = false;
    boolean usesIntegers = false;
    boolean usesReals = false;
    boolean usesArrays = false;
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      if (sym.size() > 1) {
        usesUFs = true;
      }
      SRef sort = sym.rsort();
      if (osmtLogic.isArraySort(sort)) {
        usesArrays = true;
      }
      if (sort.equals(creator.getIntegerType())) {
        usesIntegers = true;
      }
      if (sort.equals(creator.getRationalType())) {
        usesReals = true;
      }
    }
    return getReasonFromSolverFeatures(usesUFs, usesIntegers, usesReals, usesArrays);
  }
  protected String getReasonFromSolverFeatures(
      boolean usesUFs, boolean usesIntegers, boolean usesReals, boolean usesArrays) {
    if (usesIntegers && usesReals) {
      return "OpenSMT does not support mixed integer-real arithmetics.";
    }
    List<String> errors = new ArrayList<>();
    if (usesUFs && !creator.getLogic().doesLogicSupportUFs()) {
      errors.add("uninterpreted function");
    }
    if (usesIntegers && !creator.getLogic().doesLogicSupportIntegers()) {
      errors.add("integer");
    }
    if (usesReals && !creator.getLogic().doesLogicSupportReals()) {
      errors.add("real");
    }
    if (usesArrays && !creator.getLogic().doesLogicSupportArrays()) {
      errors.add("array");
    }
    if (errors.isEmpty()) {
      return "Unknown reason.";
    } else {
      return String.format(
          "Assertions use features %s that are not supported " + "by the specified logic %s.",
          errors, creator.getLogic());
    }
  }
  @Override
  @SuppressWarnings("try") 
  public boolean isUnsat() throws InterruptedException, SolverException {
    Preconditions.checkState(!closed);
    closeAllEvaluators();
    changedSinceLastSatQuery = false;
    sstat result;
    try (ShutdownHook listener = new ShutdownHook(shutdownNotifier, osmtSolver::stop)) {
      shutdownNotifier.shutdownIfNecessary();
      try {
        result = osmtSolver.check();
      } catch (Exception e) {
        if (e.getMessage().isEmpty()) {
          String reason = String.format(" Most likely reason: %s", getReasonFromSolverFeatures());
          throw new SolverException(
              String.format(
                  "OpenSMT crashed while checking satisfiability. Most likely reason: %s", reason));
        } else {
          throw new SolverException("OpenSMT crashed while checking satisfiability.", e);
        }
      }
      shutdownNotifier.shutdownIfNecessary();
    }
    if (result.equals(sstat.Error())) {
      throw new SolverException("OpenSMT crashed while checking satisfiability.");
    } else if (result.equals(sstat.Undef())) {
      throw new InterruptedException();
    } else {
      return result.equals(sstat.False());
    }
  }
  @Override
  public List<BooleanFormula> getUnsatCore() {
    Preconditions.checkState(!closed);
    checkGenerateUnsatCores();
    Preconditions.checkState(!changedSinceLastSatQuery);
    return Lists.transform(osmtSolver.getUnsatCore(), creator::encapsulateBoolean);
  }
  @Override
  public boolean isUnsatWithAssumptions(Collection<BooleanFormula> pAssumptions)
      throws SolverException, InterruptedException {
    throw new UnsupportedOperationException("OpenSMT does not support solving with assumptions.");
  }
  @Override
  public Optional<List<BooleanFormula>> unsatCoreOverAssumptions(
      Collection<BooleanFormula> pAssumptions) throws SolverException, InterruptedException {
    throw new UnsupportedOperationException("OpenSMT does not support solving with assumptions.");
  }
  @Override
  public void close() {
    if (!closed) {
      osmtSolver.delete();
    }
    super.close();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import org.sosy_lab.java_smt.basicimpl.AbstractEvaluator;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Model;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
public class OpenSmtEvaluator extends AbstractEvaluator<PTRef, SRef, Logic> {
  private final Model osmtModel;
  OpenSmtEvaluator(OpenSmtAbstractProver<?> pProver, OpenSmtFormulaCreator pCreator) {
    super(pProver, pCreator);
    osmtModel = pProver.getOsmtSolver().getModel();
  }
  @Override
  public PTRef evalImpl(PTRef f) {
    Preconditions.checkState(!isClosed());
    return osmtModel.evaluate(f);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.errorprone.annotations.Immutable;
import java.util.Objects;
import org.sosy_lab.java_smt.api.ArrayFormula;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
@Immutable
public class OpenSmtFormula implements Formula {
  @SuppressWarnings("Immutable")
  private final Logic osmtLogic;
  @SuppressWarnings("Immutable")
  private final PTRef osmtTerm;
  OpenSmtFormula(Logic logic, PTRef term) {
    osmtLogic = logic;
    osmtTerm = term;
  }
  @Override
  public final String toString() {
    return osmtLogic.pp(osmtTerm);
  }
  @Override
  public final boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof OpenSmtFormula)) {
      return false;
    }
    OpenSmtFormula that = (OpenSmtFormula) o;
    return this.osmtLogic.equals(that.osmtLogic) && this.osmtTerm.equals(that.osmtTerm);
  }
  @Override
  public final int hashCode() {
    return Objects.hash(osmtLogic, osmtTerm);
  }
  final PTRef getOsmtTerm() {
    return osmtTerm;
  }
  @Immutable
  @SuppressWarnings("ClassTypeParameterName")
  static final class OpenSmtArrayFormula<TI extends Formula, TE extends Formula>
      extends OpenSmtFormula implements ArrayFormula<TI, TE> {
    private final FormulaType<TI> indexType;
    private final FormulaType<TE> elementType;
    OpenSmtArrayFormula(
        Logic pLogic, PTRef pTerm, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
      super(pLogic, pTerm);
      indexType = pIndexType;
      elementType = pElementType;
    }
    public FormulaType<TI> getIndexType() {
      return indexType;
    }
    public FormulaType<TE> getElementType() {
      return elementType;
    }
  }
  @Immutable
  static final class OpenSmtIntegerFormula extends OpenSmtFormula implements IntegerFormula {
    OpenSmtIntegerFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
  @Immutable
  static final class OpenSmtRationalFormula extends OpenSmtFormula implements RationalFormula {
    OpenSmtRationalFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
  @Immutable
  static final class OpenSmtBooleanFormula extends OpenSmtFormula implements BooleanFormula {
    OpenSmtBooleanFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class PTRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected PTRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(PTRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(PTRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_PTRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof PTRef) {
      PTRef that = (PTRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.PTRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.PTRef_x_get(swigCPtr, this);
  }
  public static PTRef getUndef() {
    long cPtr = OsmtNativeJNI.PTRef_Undef_get();
    return (cPtr == 0) ? null : new PTRef(cPtr, false);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SymRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SymRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SymRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SymRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SymRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof SymRef) {
      SymRef that = (SymRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.SymRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.SymRef_x_get(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Logic {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Logic(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Logic obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Logic obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Logic(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public Logic(Logic_t type) {
    this(OsmtNativeJNI.new_Logic__SWIG_0(type.swigValue()), true);
  }
  public Logic(Logic arg0) {
    this(OsmtNativeJNI.new_Logic__SWIG_1(Logic.swigRelease(arg0), arg0), true);
  }
  public Sort getSortDefinition(SRef s) {
    return new Sort(OsmtNativeJNI.Logic_getSortDefinition(swigCPtr, this, SRef.getCPtr(s), s), false);
  }
  public SortSymbol getSortSymbol(SSymRef ss) {
    return new SortSymbol(OsmtNativeJNI.Logic_getSortSymbol(swigCPtr, this, SSymRef.getCPtr(ss), ss), false);
  }
  public SRef getSortRef(PTRef tr) {
    return new SRef(OsmtNativeJNI.Logic_getSortRef(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public String printSort(SRef s) {
    return OsmtNativeJNI.Logic_printSort(swigCPtr, this, SRef.getCPtr(s), s);
  }
  public SRef declareUninterpretedSort(String arg0) {
    return new SRef(OsmtNativeJNI.Logic_declareUninterpretedSort(swigCPtr, this, arg0), true);
  }
  public boolean isArraySort(SRef sref) {
    return OsmtNativeJNI.Logic_isArraySort(swigCPtr, this, SRef.getCPtr(sref), sref);
  }
  public SRef getArraySort(SRef domain, SRef codomain) {
    return new SRef(OsmtNativeJNI.Logic_getArraySort(swigCPtr, this, SRef.getCPtr(domain), domain, SRef.getCPtr(codomain), codomain), true);
  }
  public boolean isArrayStore(PTRef arg0) {
    return OsmtNativeJNI.Logic_isArrayStore(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public boolean isArraySelect(PTRef arg0) {
    return OsmtNativeJNI.Logic_isArraySelect(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public Symbol getSym(SymRef s) {
    return new Symbol(OsmtNativeJNI.Logic_getSym(swigCPtr, this, SymRef.getCPtr(s), s), false);
  }
  public SymRef getSymRef(PTRef tr) {
    return new SymRef(OsmtNativeJNI.Logic_getSymRef(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public String getSymName(SymRef s) {
    return OsmtNativeJNI.Logic_getSymName(swigCPtr, this, SymRef.getCPtr(s), s);
  }
  public Pterm getPterm(PTRef tr) {
    return new Pterm(OsmtNativeJNI.Logic_getPterm(swigCPtr, this, PTRef.getCPtr(tr), tr), false);
  }
  public PTRef mkAnd(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkAnd__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkOr(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkOr__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkXor(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkXor(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkImpl(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkImpl__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkNot(PTRef arg0) {
    return new PTRef(OsmtNativeJNI.Logic_mkNot(swigCPtr, this, PTRef.getCPtr(arg0), arg0), true);
  }
  public PTRef mkIte(PTRef c, PTRef t, PTRef e) {
    return new PTRef(OsmtNativeJNI.Logic_mkIte(swigCPtr, this, PTRef.getCPtr(c), c, PTRef.getCPtr(t), t, PTRef.getCPtr(e), e), true);
  }
  public PTRef mkEq(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkEq__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkVar(SRef arg0, String arg1, boolean isInterpreted) {
    return new PTRef(OsmtNativeJNI.Logic_mkVar__SWIG_0(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1, isInterpreted), true);
  }
  public PTRef mkVar(SRef arg0, String arg1) {
    return new PTRef(OsmtNativeJNI.Logic_mkVar__SWIG_1(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1), true);
  }
  public PTRef mkConst(SRef arg0, String arg1) {
    return new PTRef(OsmtNativeJNI.Logic_mkConst(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1), true);
  }
  public PTRef mkBoolVar(String name) {
    return new PTRef(OsmtNativeJNI.Logic_mkBoolVar(swigCPtr, this, name), true);
  }
  public String dumpWithLets(PTRef formula) {
    return OsmtNativeJNI.Logic_dumpWithLets(swigCPtr, this, PTRef.getCPtr(formula), formula);
  }
  public PTRef parseFormula(String input) {
    return new PTRef(OsmtNativeJNI.Logic_parseFormula(swigCPtr, this, input), true);
  }
  public SRef getSort_bool() {
    return new SRef(OsmtNativeJNI.Logic_getSort_bool(swigCPtr, this), true);
  }
  public PTRef getTerm_true() {
    return new PTRef(OsmtNativeJNI.Logic_getTerm_true(swigCPtr, this), true);
  }
  public PTRef getTerm_false() {
    return new PTRef(OsmtNativeJNI.Logic_getTerm_false(swigCPtr, this), true);
  }
  public boolean isEquality(PTRef tr) {
    return OsmtNativeJNI.Logic_isEquality(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isDisequality(PTRef tr) {
    return OsmtNativeJNI.Logic_isDisequality(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIte(PTRef tr) {
    return OsmtNativeJNI.Logic_isIte(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isConstant(PTRef tr) {
    return OsmtNativeJNI.Logic_isConstant(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isVar(PTRef tr) {
    return OsmtNativeJNI.Logic_isVar(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isUF(PTRef arg0) {
    return OsmtNativeJNI.Logic_isUF(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public boolean isAnd(PTRef tr) {
    return OsmtNativeJNI.Logic_isAnd(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isOr(PTRef tr) {
    return OsmtNativeJNI.Logic_isOr(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isNot(PTRef tr) {
    return OsmtNativeJNI.Logic_isNot(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isXor(PTRef tr) {
    return OsmtNativeJNI.Logic_isXor(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isImplies(PTRef tr) {
    return OsmtNativeJNI.Logic_isImplies(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isTrue(PTRef tr) {
    return OsmtNativeJNI.Logic_isTrue(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isFalse(PTRef tr) {
    return OsmtNativeJNI.Logic_isFalse(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIff(PTRef tr) {
    return OsmtNativeJNI.Logic_isIff(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public String protectName(SymRef sr) {
    return OsmtNativeJNI.Logic_protectName(swigCPtr, this, SymRef.getCPtr(sr), sr);
  }
  public String pp(PTRef tr) {
    return OsmtNativeJNI.Logic_pp(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public PTRef mkStore(PTRef array, PTRef index, PTRef value) {
    return new PTRef(OsmtNativeJNI.Logic_mkStore(swigCPtr, this, PTRef.getCPtr(array), array, PTRef.getCPtr(index), index, PTRef.getCPtr(value), value), true);
  }
  public PTRef mkSelect(PTRef array, PTRef index) {
    return new PTRef(OsmtNativeJNI.Logic_mkSelect(swigCPtr, this, PTRef.getCPtr(array), array, PTRef.getCPtr(index), index), true);
  }
  public PTRef getDefaultValue(SRef sref) {
    return new PTRef(OsmtNativeJNI.Logic_getDefaultValue(swigCPtr, this, SRef.getCPtr(sref), sref), true);
  }
  public PTRef mkUninterpFun(SymRef f, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkUninterpFun(swigCPtr, this, SymRef.getCPtr(f), f, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkAnd(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkAnd__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkOr(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkOr__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkImpl(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkImpl__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkEq(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkEq__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkDistinct(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkDistinct__SWIG_0(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkDistinct(PTRef a, PTRef b) {
    return new PTRef(OsmtNativeJNI.Logic_mkDistinct__SWIG_1(swigCPtr, this, PTRef.getCPtr(a), a, PTRef.getCPtr(b), b), true);
  }
  public SymRef declareFun(String fname, SRef rsort, VectorSRef args) {
    return new SymRef(OsmtNativeJNI.Logic_declareFun(swigCPtr, this, fname, SRef.getCPtr(rsort), rsort, VectorSRef.getCPtr(args), args), true);
  }
  public PTRef instantiateFunctionTemplate(TemplateFunction tmplt, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_instantiateFunctionTemplate(swigCPtr, this, TemplateFunction.getCPtr(tmplt), tmplt, VectorPTRef.getCPtr(args), args), true);
  }
  public boolean isSortBool(SRef sort) {
    return OsmtNativeJNI.Logic_isSortBool(swigCPtr, this, SRef.getCPtr(sort), sort);
  }
  public PTRef insertTerm(SymRef sym, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_insertTerm(swigCPtr, this, SymRef.getCPtr(sym), sym, VectorPTRef.getCPtr(args), args), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Sort {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Sort(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Sort obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Sort obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Sort(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public SSymRef getSymRef() {
    return new SSymRef(OsmtNativeJNI.Sort_getSymRef(swigCPtr, this), true);
  }
  public long getSize() {
    return OsmtNativeJNI.Sort_getSize(swigCPtr, this);
  }
  public VectorSRef getArgs() {
    return new VectorSRef(OsmtNativeJNI.Sort_getArgs(swigCPtr, this), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SortSymbol {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SortSymbol(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SortSymbol obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SortSymbol obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SortSymbol(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean isInternal() {
    return OsmtNativeJNI.SortSymbol_isInternal(swigCPtr, this);
  }
  public long getArity() {
    return OsmtNativeJNI.SortSymbol_getArity(swigCPtr, this);
  }
  public String getName() {
    return OsmtNativeJNI.SortSymbol_getName(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof SRef) {
      SRef that = (SRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.SRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.SRef_x_get(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class TemplateFunction {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected TemplateFunction(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(TemplateFunction obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(TemplateFunction obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_TemplateFunction(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public String getName() {
    return OsmtNativeJNI.TemplateFunction_getName(swigCPtr, this);
  }
  public SRef getRetSort() {
    return new SRef(OsmtNativeJNI.TemplateFunction_getRetSort(swigCPtr, this), true);
  }
  public PTRef getBody() {
    return new PTRef(OsmtNativeJNI.TemplateFunction_getBody(swigCPtr, this), true);
  }
  public TemplateFunction(String name, VectorPTRef args_, SRef ret_sort, PTRef tr_body) {
    this(OsmtNativeJNI.new_TemplateFunction(name, VectorPTRef.getCPtr(args_), args_, SRef.getCPtr(ret_sort), ret_sort, PTRef.getCPtr(tr_body), tr_body), true);
  }
  public VectorPTRef getArgs() {
    return new VectorPTRef(OsmtNativeJNI.TemplateFunction_getArgs(swigCPtr, this), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Symbol {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Symbol(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Symbol obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Symbol obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Symbol(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public int size() {
    return OsmtNativeJNI.Symbol_size(swigCPtr, this);
  }
  public SRef rsort() {
    return new SRef(OsmtNativeJNI.Symbol_rsort(swigCPtr, this), true);
  }
  public boolean isInterpreted() {
    return OsmtNativeJNI.Symbol_isInterpreted(swigCPtr, this);
  }
  public VectorSRef getArgTypes() {
    return new VectorSRef(OsmtNativeJNI.Symbol_getArgTypes(swigCPtr, this), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class ArithLogic extends Logic {
  private transient long swigCPtr;
  protected ArithLogic(long cPtr, boolean cMemoryOwn) {
    super(OsmtNativeJNI.ArithLogic_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }
  protected static long getCPtr(ArithLogic obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(ArithLogic obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_ArithLogic(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }
  public ArithLogic(ArithLogic arg0) {
    this(OsmtNativeJNI.new_ArithLogic(ArithLogic.swigRelease(arg0), arg0), true);
  }
  public SRef getSort_real() {
    return new SRef(OsmtNativeJNI.ArithLogic_getSort_real(swigCPtr, this), true);
  }
  public SRef getSort_int() {
    return new SRef(OsmtNativeJNI.ArithLogic_getSort_int(swigCPtr, this), true);
  }
  public PTRef mkConst(SRef s, String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkConst(swigCPtr, this, SRef.getCPtr(s), s, name), true);
  }
  public PTRef mkIntVar(String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntVar(swigCPtr, this, name), true);
  }
  public PTRef mkRealVar(String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealVar(swigCPtr, this, name), true);
  }
  public boolean isNumConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isNumConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIntConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isIntConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isRealConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isRealConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isSortInt(SRef sr) {
    return OsmtNativeJNI.ArithLogic_isSortInt(swigCPtr, this, SRef.getCPtr(sr), sr);
  }
  public boolean isSortReal(SRef sr) {
    return OsmtNativeJNI.ArithLogic_isSortReal(swigCPtr, this, SRef.getCPtr(sr), sr);
  }
  public boolean isPlus(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isPlus(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isNeg(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isNeg(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isTimes(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isTimes(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isLeq(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isLeq(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isLt(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isLt(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isGeq(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isGeq(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isGt(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isGt(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public PTRef getTerm_IntZero() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntZero(swigCPtr, this), true);
  }
  public PTRef getTerm_RealZero() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealZero(swigCPtr, this), true);
  }
  public PTRef getTerm_IntOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntOne(swigCPtr, this), true);
  }
  public PTRef getTerm_RealOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealOne(swigCPtr, this), true);
  }
  public PTRef getTerm_IntMinusOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntMinusOne(swigCPtr, this), true);
  }
  public PTRef getTerm_RealMinusOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealMinusOne(swigCPtr, this), true);
  }
  public PTRef mkNeg(PTRef tr) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkNeg(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public PTRef mkMinus(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkMinus(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkPlus(PTRef p1, PTRef p2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkPlus(swigCPtr, this, PTRef.getCPtr(p1), p1, PTRef.getCPtr(p2), p2), true);
  }
  public PTRef mkTimes(PTRef p1, PTRef p2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkTimes(swigCPtr, this, PTRef.getCPtr(p1), p1, PTRef.getCPtr(p2), p2), true);
  }
  public PTRef mkIntDiv(PTRef nom, PTRef den) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntDiv(swigCPtr, this, PTRef.getCPtr(nom), nom, PTRef.getCPtr(den), den), true);
  }
  public PTRef mkRealDiv(PTRef nom, PTRef den) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealDiv(swigCPtr, this, PTRef.getCPtr(nom), nom, PTRef.getCPtr(den), den), true);
  }
  public PTRef mkMod(PTRef first, PTRef second) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkMod(swigCPtr, this, PTRef.getCPtr(first), first, PTRef.getCPtr(second), second), true);
  }
  public PTRef mkLeq(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkLeq(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkGeq(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkGeq(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkLt(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkLt(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkGt(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkGt(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkIntConst(String c) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntConst(swigCPtr, this, c), true);
  }
  public PTRef mkRealConst(String c) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealConst(swigCPtr, this, c), true);
  }
  public String getNumConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_getNumConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isMinus(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isMinus(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isDiv(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isDiv(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isMod(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isMod(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class MainSolver {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected MainSolver(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(MainSolver obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(MainSolver obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_MainSolver(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public MainSolver(Logic logic, SMTConfig conf, String name) {
    this(OsmtNativeJNI.new_MainSolver__SWIG_0(Logic.getCPtr(logic), logic, SMTConfig.getCPtr(conf), conf, name), true);
  }
  public MainSolver(MainSolver arg0) {
    this(OsmtNativeJNI.new_MainSolver__SWIG_1(MainSolver.swigRelease(arg0), arg0), true);
  }
  public SMTConfig getConfig() {
    return new SMTConfig(OsmtNativeJNI.MainSolver_getConfig(swigCPtr, this), false);
  }
  public Logic getLogic() {
    return new Logic(OsmtNativeJNI.MainSolver_getLogic(swigCPtr, this), false);
  }
  public void push() {
    OsmtNativeJNI.MainSolver_push(swigCPtr, this);
  }
  public boolean pop() {
    return OsmtNativeJNI.MainSolver_pop(swigCPtr, this);
  }
  public long getAssertionLevel() {
    return OsmtNativeJNI.MainSolver_getAssertionLevel(swigCPtr, this);
  }
  public void insertFormula(PTRef fla) {
    OsmtNativeJNI.MainSolver_insertFormula(swigCPtr, this, PTRef.getCPtr(fla), fla);
  }
  public long getInsertedFormulasCount() {
    return OsmtNativeJNI.MainSolver_getInsertedFormulasCount(swigCPtr, this);
  }
  public sstat check() {
    return new sstat(OsmtNativeJNI.MainSolver_check(swigCPtr, this), true);
  }
  public sstat solve() {
    return new sstat(OsmtNativeJNI.MainSolver_solve(swigCPtr, this), true);
  }
  public sstat getStatus() {
    return new sstat(OsmtNativeJNI.MainSolver_getStatus(swigCPtr, this), true);
  }
  public Model getModel() {
    long cPtr = OsmtNativeJNI.MainSolver_getModel(swigCPtr, this);
    return (cPtr == 0) ? null : new Model(cPtr, true);
  }
  public InterpolationContext getInterpolationContext() {
    long cPtr = OsmtNativeJNI.MainSolver_getInterpolationContext(swigCPtr, this);
    return (cPtr == 0) ? null : new InterpolationContext(cPtr, true);
  }
  public void stop() {
    OsmtNativeJNI.MainSolver_stop(swigCPtr, this);
  }
  public VectorPTRef getUnsatCore() {
    return new VectorPTRef(OsmtNativeJNI.MainSolver_getUnsatCore(swigCPtr, this), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Pterm {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Pterm(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Pterm obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Pterm obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Pterm(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public int size() {
    return OsmtNativeJNI.Pterm_size(swigCPtr, this);
  }
  public SymRef symb() {
    return new SymRef(OsmtNativeJNI.Pterm_symb(swigCPtr, this), true);
  }
  public PTRef at(int i) {
    return new PTRef(OsmtNativeJNI.Pterm_at(swigCPtr, this, i), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import static com.google.common.truth.Truth.assertThat;
import org.junit.AssumptionViolatedException;
import org.junit.BeforeClass;
import org.junit.Test;
import org.sosy_lab.common.NativeLibraries;
import org.sosy_lab.java_smt.solvers.opensmt.api.ArithLogic;
import org.sosy_lab.java_smt.solvers.opensmt.api.InterpolationContext;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.LogicFactory;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic_t;
import org.sosy_lab.java_smt.solvers.opensmt.api.MainSolver;
import org.sosy_lab.java_smt.solvers.opensmt.api.Model;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTConfig;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTOption;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.TemplateFunction;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorInt;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorSRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.sstat;
public class OpenSmtNativeAPITest {
  @BeforeClass
  public static void load() {
    try {
      NativeLibraries.loadLibrary("opensmtj");
    } catch (UnsatisfiedLinkError e) {
      throw new AssumptionViolatedException("OpenSMT is not available", e);
    }
  }
  private VectorPTRef variables(Logic logic, PTRef term) {
    if (logic.isVar(term)) {
      VectorPTRef vars = new VectorPTRef();
      vars.add(term);
      return vars;
    } else {
      VectorPTRef vars = new VectorPTRef();
      for (int i = 0; i < logic.getPterm(term).size(); i++) {
        PTRef sub = logic.getPterm(term).at(i);
        vars.addAll(variables(logic, sub));
      }
      return vars;
    }
  }
  private boolean verifyInterpolant(Logic logic, PTRef partA, PTRef partB, PTRef interpol) {
    SMTConfig config = new SMTConfig();
    MainSolver solver = new MainSolver(logic, config, "opensmt-verifier");
    solver.push();
    solver.insertFormula(logic.mkNot(logic.mkImpl(partA, interpol)));
    if (!solver.check().equals(sstat.False())) {
      return false;
    }
    solver.pop();
    solver.push();
    solver.insertFormula(logic.mkNot(logic.mkImpl(interpol, logic.mkNot(partB))));
    if (!solver.check().equals(sstat.False())) {
      return false;
    }
    solver.pop();
    VectorPTRef varsPartA = variables(logic, partA);
    VectorPTRef varsPartB = variables(logic, partB);
    VectorPTRef varsInterpol = variables(logic, interpol);
    return varsPartA.containsAll(varsInterpol) && varsPartB.containsAll(varsInterpol);
  }
  @Test
  public void testSolverFactory() {
    Logic logic = LogicFactory.getInstance(Logic_t.QF_UF);
    PTRef varA = logic.mkBoolVar("a");
    PTRef varB = logic.mkBoolVar("b");
    PTRef f = logic.mkEq(varA, varB);
    SMTConfig config = new SMTConfig();
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.True());
    Model model = mainSolver.getModel();
    PTRef valA = model.evaluate(varA);
    PTRef valB = model.evaluate(varB);
    assertThat(valA).isEqualTo(valB);
  }
  @Test
  public void testBooleanLogic() {
    Logic logic = LogicFactory.getInstance(Logic_t.QF_BOOL);
    PTRef varA = logic.mkBoolVar("a");
    PTRef notA = logic.mkNot(varA);
    PTRef f = logic.mkAnd(varA, notA);
    SMTConfig config = new SMTConfig();
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.False());
  }
  @Test
  public void testUninterpretedFunctionLogic() {
    Logic logic = LogicFactory.getInstance(Logic_t.QF_UF);
    SRef mySort = logic.declareUninterpretedSort("U");
    PTRef varA = logic.mkVar(mySort, "a");
    PTRef varB = logic.mkVar(mySort, "b");
    PTRef f0 = logic.mkEq(varA, varB);
    VectorSRef sigF = new VectorSRef();
    sigF.add(mySort);
    SymRef funF = logic.declareFun("f", mySort, sigF);
    VectorPTRef argFa = new VectorPTRef();
    argFa.add(varA);
    PTRef appFa = logic.mkUninterpFun(funF, argFa);
    VectorPTRef argFb = new VectorPTRef();
    argFb.add(varB);
    PTRef appFb = logic.mkUninterpFun(funF, argFb);
    VectorPTRef dist = new VectorPTRef();
    dist.add(appFa);
    dist.add(appFb);
    PTRef f1 = logic.mkDistinct(dist);
    SMTConfig config = new SMTConfig();
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f0);
    mainSolver.push();
    mainSolver.insertFormula(f1);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.False());
  }
  @Test
  public void testUninterpretedFunctionInterpol() {
    Logic logic = LogicFactory.getInstance(Logic_t.QF_UF);
    SRef mysort = logic.declareUninterpretedSort("U");
    PTRef varA = logic.mkVar(mysort, "a");
    PTRef varB = logic.mkVar(mysort, "b");
    PTRef varC = logic.mkVar(mysort, "c");
    PTRef f0 = logic.mkAnd(logic.mkEq(varA, varB), logic.mkEq(varB, varC));
    VectorPTRef dist = new VectorPTRef();
    dist.add(varA);
    dist.add(varC);
    PTRef f1 = logic.mkDistinct(dist);
    SMTConfig config = new SMTConfig();
    config.setOption(":produce-interpolants", new SMTOption(true));
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f0);
    mainSolver.push();
    mainSolver.insertFormula(f1);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.False());
    InterpolationContext context = mainSolver.getInterpolationContext();
    VectorInt mask = new VectorInt();
    mask.add(0);
    PTRef interpol = context.getSingleInterpolant(mask);
    assertThat(verifyInterpolant(logic, f0, f1, interpol)).isTrue();
  }
  @Test
  public void testLinearIntegerLogic() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_LIA);
    PTRef varA = logic.mkIntVar("a");
    PTRef varC = logic.mkIntVar("c");
    PTRef const0 = logic.mkIntConst("0");
    PTRef const3 = logic.mkIntConst("3");
    PTRef f0 = logic.mkLt(logic.mkPlus(varA, const3), varC);
    PTRef f1 = logic.mkGeq(varC, const0);
    SMTConfig config = new SMTConfig();
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f0);
    mainSolver.push();
    mainSolver.insertFormula(f1);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.True());
  }
  @Test
  public void testLinearIntegerInterpol() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_LIA);
    PTRef varA = logic.mkIntVar("a");
    PTRef varB = logic.mkIntVar("b");
    PTRef varC = logic.mkIntVar("c");
    PTRef f0 = logic.mkAnd(logic.mkGt(varA, varB), logic.mkGt(varB, varC));
    PTRef f1 = logic.mkGt(varC, varA);
    SMTConfig config = new SMTConfig();
    config.setOption(":produce-interpolants", new SMTOption(true));
    MainSolver solver = new MainSolver(logic, config, "opensmt-test");
    solver.push();
    solver.insertFormula(f0);
    solver.push();
    solver.insertFormula(f1);
    sstat r = solver.check();
    assertThat(r).isEqualTo(sstat.False());
    InterpolationContext context = solver.getInterpolationContext();
    VectorInt mask = new VectorInt();
    mask.add(0);
    PTRef interpol = context.getSingleInterpolant(mask);
    assertThat(verifyInterpolant(logic, f0, f1, interpol)).isTrue();
    config.setOption(":interpolation-lra-algorithm", new SMTOption(5));
    PTRef interpolDweak = context.getSingleInterpolant(mask);
    assertThat(verifyInterpolant(logic, f0, f1, interpolDweak)).isTrue();
  }
  @Test
  public void testIntegerArray() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_ALIA);
    SRef sortIntArray = logic.getArraySort(logic.getSort_int(), logic.getSort_int());
    PTRef varA = logic.mkVar(sortIntArray, "a");
    PTRef varI = logic.mkIntVar("i");
    PTRef varJ = logic.mkIntVar("j");
    PTRef varE = logic.mkIntVar("e");
    PTRef eq0 = logic.mkEq(varE, logic.mkSelect(logic.mkStore(varA, varI, varE), varI));
    PTRef eq1 = logic.mkEq(varA, logic.mkStore(varA, varI, logic.mkSelect(varA, varI)));
    PTRef eq2 =
        logic.mkImpl(
            logic.mkDistinct(varI, varJ),
            logic.mkEq(
                logic.mkSelect(logic.mkStore(varA, varI, varE), varJ), logic.mkSelect(varA, varJ)));
    VectorPTRef neg =
        new VectorPTRef(new PTRef[] {logic.mkNot(eq0), logic.mkNot(eq1), logic.mkNot(eq2)});
    PTRef f = logic.mkOr(neg);
    SMTConfig config = new SMTConfig();
    MainSolver solver = new MainSolver(logic, config, "opensmt-test");
    solver.push();
    solver.insertFormula(f);
    sstat r = solver.check();
    assertThat(r).isEqualTo(sstat.False());
  }
  @Test
  public void testFormulaIntrospection() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_LIA);
    PTRef varA = logic.mkIntVar("a");
    PTRef varB = logic.mkIntVar("b");
    PTRef varC = logic.mkIntVar("c");
    PTRef f = logic.mkLt(logic.mkPlus(varA, varB), logic.mkNeg(varC));
    VectorPTRef vars = variables(logic, f);
    assertThat(vars.size() == 3).isTrue();
  }
  @Test
  public void testFunctionTemplates() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_LIA);
    PTRef negateA = logic.mkIntVar("negateA");
    PTRef negateBody = logic.mkTimes(logic.getTerm_IntMinusOne(), negateA);
    VectorPTRef negateArgs = new VectorPTRef();
    negateArgs.add(negateA);
    TemplateFunction negateF =
        new TemplateFunction("negate", negateArgs, logic.getSort_int(), negateBody);
    PTRef varA = logic.mkIntVar("a");
    VectorPTRef arg0 = new VectorPTRef();
    arg0.add(varA);
    PTRef app0 = logic.instantiateFunctionTemplate(negateF, arg0);
    VectorPTRef arg1 = new VectorPTRef();
    arg1.add(app0);
    PTRef app1 = logic.instantiateFunctionTemplate(negateF, arg1);
    PTRef f = logic.mkNot(logic.mkEq(app1, varA));
    SMTConfig config = new SMTConfig();
    MainSolver solver = new MainSolver(logic, config, "opensmt-test");
    solver.push();
    solver.insertFormula(f);
    sstat r = solver.check();
    assertThat(r).isEqualTo(sstat.False());
  }
  @Test
  public void testAbort() {
    ArithLogic logic = LogicFactory.getLAInstance(Logic_t.QF_LIA);
    PTRef varA = logic.mkIntVar("a");
    PTRef varC = logic.mkIntVar("c");
    PTRef const0 = logic.mkIntConst("0");
    PTRef const3 = logic.mkIntConst("3");
    PTRef f0 = logic.mkLt(logic.mkPlus(varA, const3), varC);
    PTRef f1 = logic.mkGeq(varC, const0);
    SMTConfig config = new SMTConfig();
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.push();
    mainSolver.insertFormula(f0);
    mainSolver.push();
    mainSolver.insertFormula(f1);
    mainSolver.stop();
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.Undef());
  }
  @Test
  public void testUnsatCore() {
    Logic logic = LogicFactory.getInstance(Logic_t.QF_UF);
    PTRef b1 = logic.mkBoolVar("b1");
    PTRef b2 = logic.mkBoolVar("b2");
    PTRef nb1 = logic.mkNot(b1);
    SMTConfig config = new SMTConfig();
    config.setOption(":produce-unsat-cores", new SMTOption(true));
    config.setOption(":print-cores-full", new SMTOption(true));
    MainSolver mainSolver = new MainSolver(logic, config, "opensmt-test");
    mainSolver.insertFormula(b1);
    mainSolver.insertFormula(b2);
    mainSolver.insertFormula(nb1);
    sstat r = mainSolver.check();
    assertThat(r).isEqualTo(sstat.False());
    VectorPTRef core = mainSolver.getUnsatCore();
    assertThat(core).containsExactly(b1, nb1);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class LogicFactory {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected LogicFactory(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(LogicFactory obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(LogicFactory obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_LogicFactory(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public static Logic getInstance(Logic_t arg0) {
    long cPtr = OsmtNativeJNI.LogicFactory_getInstance(arg0.swigValue());
    return (cPtr == 0) ? null : new Logic(cPtr, true);
  }
  public static ArithLogic getLAInstance(Logic_t arg0) {
    long cPtr = OsmtNativeJNI.LogicFactory_getLAInstance(arg0.swigValue());
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static ArithLogic getLRAInstance() {
    long cPtr = OsmtNativeJNI.LogicFactory_getLRAInstance();
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static ArithLogic getLIAInstance() {
    long cPtr = OsmtNativeJNI.LogicFactory_getLIAInstance();
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static String getVersion() {
    return OsmtNativeJNI.LogicFactory_getVersion();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class VectorSRef extends java.util.AbstractList<SRef> implements java.util.RandomAccess {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected VectorSRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(VectorSRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(VectorSRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_VectorSRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public VectorSRef(SRef[] initialElements) {
    this();
    reserve(initialElements.length);
    for (SRef element : initialElements) {
      add(element);
    }
  }
  public VectorSRef(Iterable<SRef> initialElements) {
    this();
    for (SRef element : initialElements) {
      add(element);
    }
  }
  public SRef get(int index) {
    return doGet(index);
  }
  public SRef set(int index, SRef e) {
    return doSet(index, e);
  }
  public boolean add(SRef e) {
    modCount++;
    doAdd(e);
    return true;
  }
  public void add(int index, SRef e) {
    modCount++;
    doAdd(index, e);
  }
  public SRef remove(int index) {
    modCount++;
    return doRemove(index);
  }
  protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    doRemoveRange(fromIndex, toIndex);
  }
  public int size() {
    return doSize();
  }
  public VectorSRef() {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_0(), true);
  }
  public VectorSRef(VectorSRef other) {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_1(VectorSRef.getCPtr(other), other), true);
  }
  public long capacity() {
    return OsmtNativeJNI.VectorSRef_capacity(swigCPtr, this);
  }
  public void reserve(long n) {
    OsmtNativeJNI.VectorSRef_reserve(swigCPtr, this, n);
  }
  public boolean isEmpty() {
    return OsmtNativeJNI.VectorSRef_isEmpty(swigCPtr, this);
  }
  public void clear() {
    OsmtNativeJNI.VectorSRef_clear(swigCPtr, this);
  }
  public VectorSRef(int count, SRef value) {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_2(count, SRef.getCPtr(value), value), true);
  }
  private int doSize() {
    return OsmtNativeJNI.VectorSRef_doSize(swigCPtr, this);
  }
  private void doAdd(SRef x) {
    OsmtNativeJNI.VectorSRef_doAdd__SWIG_0(swigCPtr, this, SRef.getCPtr(x), x);
  }
  private void doAdd(int index, SRef x) {
    OsmtNativeJNI.VectorSRef_doAdd__SWIG_1(swigCPtr, this, index, SRef.getCPtr(x), x);
  }
  private SRef doRemove(int index) {
    return new SRef(OsmtNativeJNI.VectorSRef_doRemove(swigCPtr, this, index), true);
  }
  private SRef doGet(int index) {
    return new SRef(OsmtNativeJNI.VectorSRef_doGet(swigCPtr, this, index), false);
  }
  private SRef doSet(int index, SRef val) {
    return new SRef(OsmtNativeJNI.VectorSRef_doSet(swigCPtr, this, index, SRef.getCPtr(val), val), true);
  }
  private void doRemoveRange(int fromIndex, int toIndex) {
    OsmtNativeJNI.VectorSRef_doRemoveRange(swigCPtr, this, fromIndex, toIndex);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.collect.ImmutableList;
import java.math.BigInteger;
import java.util.List;
import org.sosy_lab.common.rationals.Rational;
import org.sosy_lab.java_smt.api.ArrayFormula;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.FormulaType.ArrayFormulaType;
import org.sosy_lab.java_smt.api.FunctionDeclarationKind;
import org.sosy_lab.java_smt.api.visitors.FormulaVisitor;
import org.sosy_lab.java_smt.basicimpl.FormulaCreator;
import org.sosy_lab.java_smt.basicimpl.FunctionDeclarationImpl;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtArrayFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtBooleanFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtIntegerFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtRationalFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.ArithLogic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.LogicFactory;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic_t;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Pterm;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorSRef;
public final class OpenSmtFormulaCreator extends FormulaCreator<PTRef, SRef, Logic, SymRef> {
  private final Logics logicToUse;
  private OpenSmtFormulaCreator(Logics logicType, Logic logic) {
    super(
        logic,
        logic.getSort_bool(),
        (logic instanceof ArithLogic) ? ((ArithLogic) logic).getSort_int() : null,
        (logic instanceof ArithLogic) ? ((ArithLogic) logic).getSort_real() : null,
        null,
        null);
    logicToUse = logicType;
  }
  public static OpenSmtFormulaCreator create(Logics logicType) {
    return new OpenSmtFormulaCreator(logicType, createLogic(logicType));
  }
  private static Logic createLogic(Logics logicType) {
    switch (logicType) {
      case CORE:
        return LogicFactory.getInstance(Logic_t.QF_BOOL);
      case QF_AX:
        return LogicFactory.getInstance(Logic_t.QF_AX);
      case QF_UF:
        return LogicFactory.getInstance(Logic_t.QF_UF);
      case QF_IDL:
        return LogicFactory.getLAInstance(Logic_t.QF_IDL);
      case QF_RDL:
        return LogicFactory.getLAInstance(Logic_t.QF_RDL);
      case QF_LIA:
        return LogicFactory.getLAInstance(Logic_t.QF_LIA);
      case QF_LRA:
        return LogicFactory.getLAInstance(Logic_t.QF_LRA);
      case QF_ALIA:
        return LogicFactory.getLAInstance(Logic_t.QF_ALIA);
      case QF_ALRA:
        return LogicFactory.getLAInstance(Logic_t.QF_ALRA);
      case QF_UFLIA:
        return LogicFactory.getLAInstance(Logic_t.QF_UFLIA);
      case QF_UFLRA:
        return LogicFactory.getLAInstance(Logic_t.QF_UFLRA);
      case QF_AUFLIA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLIA);
      case QF_AUFLRA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLRA);
      case QF_AUFLIRA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLIRA);
      default:
        throw new AssertionError("no logic available");
    }
  }
  Logics getLogic() {
    return logicToUse;
  }
  @Override
  public PTRef extractInfo(Formula pT) {
    OpenSmtFormula formula = (OpenSmtFormula) pT;
    return formula.getOsmtTerm();
  }
  @Override
  public PTRef callFunctionImpl(SymRef declaration, List<PTRef> args) {
    return getEnv().insertTerm(declaration, new VectorPTRef(args));
  }
  @Override
  public SymRef declareUFImpl(String pName, SRef pReturnType, List<SRef> pArgTypes) {
    return getEnv().declareFun(pName, pReturnType, new VectorSRef(pArgTypes));
  }
  @Override
  public SRef getArrayType(SRef indexType, SRef elementType) {
    return getEnv().getArraySort(indexType, elementType);
  }
  @Override
  public SRef getBitvectorType(int bitwidth) {
    throw new UnsupportedOperationException("OpenSMT does not support bitvectors.");
  }
  @Override
  public SymRef getBooleanVarDeclarationImpl(PTRef pPTRef) {
    return getEnv().getSymRef(pPTRef);
  }
  @Override
  public SRef getFloatingPointType(FormulaType.FloatingPointType type) {
    throw new UnsupportedOperationException("OpenSMT does not support floating point operations.");
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TD extends Formula, TR extends Formula> FormulaType<TD> getArrayFormulaIndexType(
      ArrayFormula<TD, TR> pArray) {
    OpenSmtArrayFormula<TD, TR> array = (OpenSmtArrayFormula<TD, TR>) pArray;
    return array.getIndexType();
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TD extends Formula, TR extends Formula> FormulaType<TR> getArrayFormulaElementType(
      ArrayFormula<TD, TR> pArray) {
    OpenSmtArrayFormula<TD, TR> array = (OpenSmtArrayFormula<TD, TR>) pArray;
    return array.getElementType();
  }
  @SuppressWarnings("unchecked")
  @Override
  public <T extends Formula> FormulaType<T> getFormulaType(T pFormula) {
    if (pFormula instanceof ArrayFormula<?, ?>) {
      FormulaType<T> arrayIndexType = getArrayFormulaIndexType((ArrayFormula<T, T>) pFormula);
      FormulaType<T> arrayElementType = getArrayFormulaElementType((ArrayFormula<T, T>) pFormula);
      return (FormulaType<T>) FormulaType.getArrayType(arrayIndexType, arrayElementType);
    }
    return super.getFormulaType(pFormula);
  }
  @Override
  public FormulaType<?> getFormulaType(PTRef pFormula) {
    SRef sort = getEnv().getSortRef(pFormula);
    return getFormulaTypeFromTermType(sort);
  }
  private FormulaType<?> getFormulaTypeFromTermType(SRef sort) {
    Logic logic = getEnv();
    if (logic.isSortBool(sort)) {
      return FormulaType.BooleanType;
    }
    if (logic.isArraySort(sort)) {
      VectorSRef args = getEnv().getSortDefinition(sort).getArgs();
      FormulaType<?> indexType = getFormulaTypeFromTermType(args.get(0));
      FormulaType<?> elementType = getFormulaTypeFromTermType(args.get(1));
      return FormulaType.getArrayType(indexType, elementType);
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isSortInt(sort)) {
      return FormulaType.IntegerType;
    }
    if (alogic.isSortReal(sort)) {
      return FormulaType.RationalType;
    }
    throw new AssertionError(String.format("Encountered unhandled Type '%s'.", sort));
  }
  @SuppressWarnings("unchecked")
  @Override
  public <T extends Formula> T encapsulate(FormulaType<T> pType, PTRef pTerm) {
    assert pType.equals(getFormulaType(pTerm))
            || (pType.equals(FormulaType.RationalType)
                && getFormulaType(pTerm).equals(FormulaType.IntegerType))
        : String.format(
            "Cannot encapsulate formula %s of Type %s as %s", pTerm, getFormulaType(pTerm), pType);
    if (pType.isBooleanType()) {
      return (T) new OpenSmtBooleanFormula(getEnv(), pTerm);
    }
    if (pType.isIntegerType()) {
      return (T) new OpenSmtIntegerFormula(getEnv(), pTerm);
    }
    if (pType.isRationalType()) {
      return (T) new OpenSmtRationalFormula(getEnv(), pTerm);
    }
    if (pType.isArrayType()) {
      ArrayFormulaType<?, ?> arrFt = (ArrayFormulaType<?, ?>) pType;
      return (T)
          new OpenSmtArrayFormula<>(getEnv(), pTerm, arrFt.getIndexType(), arrFt.getElementType());
    }
    throw new IllegalArgumentException("Cannot create formulas of Type " + pType + " in OpenSMT");
  }
  public Formula encapsulate(PTRef pTerm) {
    return encapsulate(getFormulaType(pTerm), pTerm);
  }
  @Override
  public BooleanFormula encapsulateBoolean(PTRef pTerm) {
    assert getFormulaType(pTerm).isBooleanType()
        : String.format(
            "%s is not boolean, but %s (%s)",
            pTerm, getEnv().getSortRef(pTerm), getFormulaType(pTerm));
    return new OpenSmtBooleanFormula(getEnv(), pTerm);
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TI extends Formula, TE extends Formula> ArrayFormula<TI, TE> encapsulateArray(
      PTRef pTerm, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
    assert getFormulaType(pTerm).equals(FormulaType.getArrayType(pIndexType, pElementType))
        : String.format(
            "%s is no array, but %s (%s)",
            pTerm, getEnv().getSortRef(pTerm), getFormulaType(pTerm));
    return new OpenSmtArrayFormula<>(getEnv(), pTerm, pIndexType, pElementType);
  }
  @Override
  public PTRef makeVariable(SRef type, String varName) {
    return getEnv().mkVar(type, varName);
  }
  @SuppressWarnings("unused")
  private FunctionDeclarationKind getDeclarationKind(PTRef f) {
    Logic logic = getEnv();
    if (logic.isAnd(f)) {
      return FunctionDeclarationKind.AND;
    } else if (logic.isIff(f)) {
      return FunctionDeclarationKind.IFF;
    } else if (logic.isImplies(f)) {
      return FunctionDeclarationKind.IMPLIES;
    } else if (logic.isIte(f)) {
      return FunctionDeclarationKind.ITE;
    } else if (logic.isNot(f)) {
      return FunctionDeclarationKind.NOT;
    } else if (logic.isOr(f)) {
      return FunctionDeclarationKind.OR;
    } else if (logic.isArraySelect(f)) {
      return FunctionDeclarationKind.SELECT;
    } else if (logic.isArrayStore(f)) {
      return FunctionDeclarationKind.STORE;
    } else if (logic.isUF(f)) {
      return FunctionDeclarationKind.UF;
    } else if (logic.isXor(f)) {
      return FunctionDeclarationKind.XOR;
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isPlus(f)) {
      return FunctionDeclarationKind.ADD;
    } else if (alogic.isDisequality(f)) {
      return FunctionDeclarationKind.DISTINCT;
    } else if (alogic.isDiv(f)) {
      return FunctionDeclarationKind.DIV;
    } else if (alogic.isEquality(f)) {
      return FunctionDeclarationKind.EQ;
    } else if (alogic.isGeq(f)) {
      return FunctionDeclarationKind.GT;
    } else if (alogic.isGt(f)) {
      return FunctionDeclarationKind.GTE;
    } else if (alogic.isLt(f)) {
      return FunctionDeclarationKind.LT;
    } else if (alogic.isLeq(f)) {
      return FunctionDeclarationKind.LTE;
    } else if (alogic.isMod(f)) {
      return FunctionDeclarationKind.MODULO;
    } else if (alogic.isTimes(f)) {
      return FunctionDeclarationKind.MUL;
    } else if (alogic.isMinus(f)) {
      return FunctionDeclarationKind.SUB;
    } else if (alogic.isNeg(f)) {
      return FunctionDeclarationKind.UMINUS;
    }
    throw new UnsupportedOperationException("Encountered unsupported declaration kind");
  }
  @Override
  public Object convertValue(PTRef value) {
    Logic logic = getEnv();
    if (logic.isTrue(value)) {
      return Boolean.TRUE;
    }
    if (logic.isFalse(value)) {
      return Boolean.FALSE;
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isIntConst(value)) {
      return new BigInteger(alogic.getNumConst(value));
    }
    if (alogic.isRealConst(value)) {
      Rational ratValue = Rational.ofString(alogic.getNumConst(value));
      return ratValue.isIntegral() ? ratValue.getNum() : ratValue;
    }
    throw new UnsupportedOperationException("Term `" + logic.pp(value) + "` is not a value");
  }
  @Override
  public <R> R visit(FormulaVisitor<R> visitor, Formula formula, PTRef f) {
    Logic logic = getEnv();
    if (logic.isConstant(f)) {
      return visitor.visitConstant(formula, convertValue(f));
    }
    if (logic.isVar(f)) {
      String varName = logic.getSymName(logic.getSymRef(f));
      return visitor.visitFreeVariable(formula, dequote(varName));
    }
    String varName = logic.getSymName(logic.getSymRef(f));
    ImmutableList.Builder<Formula> argTerms = ImmutableList.builder();
    ImmutableList.Builder<FormulaType<?>> argTypes = ImmutableList.builder();
    Pterm pterm = logic.getPterm(f);
    for (int i = 0; i < pterm.size(); i++) {
      PTRef sub = pterm.at(i);
      argTerms.add(encapsulate(sub));
      argTypes.add(getFormulaType(sub));
    }
    return visitor.visitFunction(
        formula,
        argTerms.build(),
        FunctionDeclarationImpl.of(
            varName,
            getDeclarationKind(f),
            argTypes.build(),
            getFormulaType(f),
            logic.getSymRef(f)));
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SSymRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SSymRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SSymRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SSymRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SSymRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof SSymRef) {
      SSymRef that = (SSymRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.SSymRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.SSymRef_x_get(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigInteger;
import java.util.List;
import org.sosy_lab.java_smt.api.NumeralFormula;
import org.sosy_lab.java_smt.basicimpl.AbstractNumeralFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.ArithLogic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
@SuppressWarnings("ClassTypeParameterName")
abstract class OpenSmtNumeralFormulaManager<
        ParamFormulaType extends NumeralFormula, ResultFormulaType extends NumeralFormula>
    extends AbstractNumeralFormulaManager<
        PTRef, SRef, Logic, ParamFormulaType, ResultFormulaType, SymRef> {
  protected final ArithLogic osmtLogic;
  OpenSmtNumeralFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
    osmtLogic = (ArithLogic) pCreator.getEnv();
  }
  protected abstract SRef getNumeralType();
  @Override
  protected boolean isNumeral(PTRef pVal) {
    return osmtLogic.isNumConst(pVal);
  }
  @Override
  protected PTRef makeNumberImpl(long i) {
    return makeNumberImpl(Long.toString(i));
  }
  @Override
  protected PTRef makeNumberImpl(BigInteger pI) {
    return makeNumberImpl(pI.toString());
  }
  @Override
  protected PTRef makeNumberImpl(String pI) {
    SRef type = getNumeralType();
    return osmtLogic.mkConst(type, pI);
  }
  @Override
  protected PTRef makeVariableImpl(String varName) {
    SRef type = getNumeralType();
    try {
      return getFormulaCreator().makeVariable(type, varName);
    } catch (RuntimeException e) {
      throw new IllegalArgumentException(e.getMessage());
    }
  }
  @Override
  protected PTRef multiply(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkTimes(pParam1, pParam2);
  }
  @Override
  protected PTRef modulo(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkMod(pParam1, pParam2);
  }
  @Override
  protected PTRef negate(PTRef pParam1) {
    return osmtLogic.mkNeg(pParam1);
  }
  @Override
  protected PTRef add(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkPlus(pParam1, pParam2);
  }
  @Override
  protected PTRef subtract(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkMinus(pParam1, pParam2);
  }
  @Override
  protected PTRef equal(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkEq(pParam1, pParam2);
  }
  @Override
  protected PTRef greaterThan(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkGt(pParam1, pParam2);
  }
  @Override
  protected PTRef greaterOrEquals(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkGeq(pParam1, pParam2);
  }
  @Override
  protected PTRef lessThan(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkLt(pParam1, pParam2);
  }
  @Override
  protected PTRef lessOrEquals(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkLeq(pParam1, pParam2);
  }
  @Override
  protected PTRef distinctImpl(List<PTRef> pParam) {
    return osmtLogic.mkDistinct(new VectorPTRef(pParam));
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigDecimal;
import org.sosy_lab.java_smt.api.NumeralFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
import org.sosy_lab.java_smt.api.RationalFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
public class OpenSmtRationalFormulaManager
    extends OpenSmtNumeralFormulaManager<NumeralFormula, RationalFormula>
    implements RationalFormulaManager {
  OpenSmtRationalFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
  }
  @Override
  protected SRef getNumeralType() {
    return getFormulaCreator().getRationalType();
  }
  @Override
  protected PTRef makeNumberImpl(double pNumber) {
    return makeNumberImpl(Double.toString(pNumber));
  }
  @Override
  protected PTRef makeNumberImpl(BigDecimal pNumber) {
    return makeNumberImpl(pNumber.toPlainString());
  }
  @Override
  public PTRef divide(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkRealDiv(pParam1, pParam2);
  }
  @Override
  protected PTRef floor(PTRef pNumber) {
    throw new UnsupportedOperationException("OpenSMT does not support floor operation");
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.basicimpl.AbstractArrayFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
@SuppressWarnings("MethodTypeParameterName")
public class OpenSmtArrayFormulaManager
    extends AbstractArrayFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final Logic logic;
  public OpenSmtArrayFormulaManager(OpenSmtFormulaCreator pFormulaCreator) {
    super(pFormulaCreator);
    logic = pFormulaCreator.getEnv();
  }
  @Override
  protected PTRef select(PTRef pArray, PTRef pIndex) {
    return logic.mkSelect(pArray, pIndex);
  }
  @Override
  protected PTRef store(PTRef pArray, PTRef pIndex, PTRef pValue) {
    return logic.mkStore(pArray, pIndex, pValue);
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TI extends Formula, TE extends Formula> PTRef internalMakeArray(
      String pName, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
    final SRef osmtArrayType = toSolverType(FormulaType.getArrayType(pIndexType, pElementType));
    return getFormulaCreator().makeVariable(osmtArrayType, pName);
  }
  @Override
  protected <TI extends Formula, TE extends Formula> PTRef internalMakeArray(
      FormulaType<TI> pIndexType, FormulaType<TE> pElementType, PTRef defaultElement) {
    throw new UnsupportedOperationException();
  }
  @Override
  protected PTRef equivalence(PTRef pArray1, PTRef pArray2) {
    return logic.mkEq(pArray1, pArray2);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sosy_lab.java_smt.basicimpl.AbstractModel;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Model;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
import org.sosy_lab.java_smt.solvers.opensmt.api.TemplateFunction;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
public class OpenSmtModel extends AbstractModel<PTRef, SRef, Logic> {
  private final Logic osmtLogic;
  private final Model osmtModel;
  private final ImmutableList<ValueAssignment> model;
  OpenSmtModel(
      OpenSmtAbstractProver<?> pProver,
      OpenSmtFormulaCreator pCreator,
      Collection<PTRef> pAssertedTerms) {
    super(pProver, pCreator);
    osmtLogic = pCreator.getEnv();
    osmtModel = pProver.getOsmtSolver().getModel();
    Map<String, PTRef> userDeclarations = new HashMap<>();
    for (PTRef asserted : pAssertedTerms) {
      userDeclarations.putAll(creator.extractVariablesAndUFs(asserted, true));
    }
    ImmutableList.Builder<ValueAssignment> builder = ImmutableList.builder();
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      int numArgs = sym.size() - 1;
      SRef sort = sym.rsort();
      if (osmtLogic.isArraySort(sort)) {
        throw new UnsupportedOperationException(
            "OpenSMT does not support model generation when arrays are used");
      }
      if (numArgs == 0) {
        PTRef key = osmtLogic.mkVar(sort, osmtLogic.getSymName(ref));
        PTRef value = osmtModel.evaluate(key);
        builder.add(
            new ValueAssignment(
                pCreator.encapsulate(key),
                pCreator.encapsulate(value),
                pCreator.encapsulateBoolean(osmtLogic.mkEq(key, value)),
                osmtLogic.getSymName(ref),
                pCreator.convertValue(value),
                new ArrayList<>()));
      } else {
        TemplateFunction tf = osmtModel.getDefinition(ref);
        for (List<PTRef> path : unfold(numArgs, tf.getBody())) {
          List<PTRef> args = path.subList(0, numArgs);
          PTRef key = osmtLogic.insertTerm(ref, new VectorPTRef(args));
          PTRef value = path.get(numArgs);
          builder.add(
              new ValueAssignment(
                  pCreator.encapsulate(key),
                  pCreator.encapsulate(value),
                  pCreator.encapsulateBoolean(osmtLogic.mkEq(key, value)),
                  osmtLogic.getSymName(ref),
                  pCreator.convertValue(value),
                  Lists.transform(args, pCreator::convertValue)));
        }
      }
    }
    model = builder.build();
  }
  @Override
  public PTRef evalImpl(PTRef f) {
    Preconditions.checkState(!isClosed());
    Map<String, PTRef> userDeclarations = creator.extractVariablesAndUFs(f, true);
    for (PTRef term : userDeclarations.values()) {
      SRef sort = osmtLogic.getSortRef(term);
      if (osmtLogic.isArraySort(sort)) {
        throw new UnsupportedOperationException(
            "OpenSMT does not support model generation when arrays are used");
      }
    }
    return osmtModel.evaluate(f);
  }
  private List<List<PTRef>> unfold(int numArgs, PTRef body) {
    List<List<PTRef>> unwrapped = new ArrayList<>();
    if (osmtLogic.isIte(body)) {
      PTRef sub0 = osmtLogic.getPterm(body).at(0);
      PTRef sub1 = osmtLogic.getPterm(body).at(1);
      PTRef sub2 = osmtLogic.getPterm(body).at(2);
      PTRef sub00 = osmtLogic.getPterm(sub0).at(0);
      PTRef sub01 = osmtLogic.getPterm(sub0).at(1);
      PTRef value = osmtLogic.isVar(sub00) ? sub01 : sub00;
      for (List<PTRef> nested : unfold(numArgs - 1, sub1)) {
        List<PTRef> prefixed = new ArrayList<>();
        prefixed.add(value);
        prefixed.addAll(nested);
        unwrapped.add(prefixed);
      }
      unwrapped.addAll(unfold(numArgs, sub2));
    }
    if (numArgs == 0) {
      List<PTRef> value = new ArrayList<>();
      value.add(body);
      unwrapped.add(value);
    }
    return unwrapped;
  }
  @Override
  public ImmutableList<ValueAssignment> asList() {
    return model;
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import java.util.Map;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.basicimpl.AbstractFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
class OpenSmtFormulaManager extends AbstractFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final OpenSmtFormulaCreator creator;
  private final Logic osmtLogic;
  OpenSmtFormulaManager(
      OpenSmtFormulaCreator pFormulaCreator,
      OpenSmtUFManager pFfmgr,
      OpenSmtBooleanFormulaManager pBfmgr,
      OpenSmtIntegerFormulaManager pIfmgr,
      OpenSmtRationalFormulaManager pRfmgr,
      OpenSmtArrayFormulaManager pAfmgr) {
    super(
        pFormulaCreator,
        pFfmgr,
        pBfmgr,
        pIfmgr,
        pRfmgr,
        null,
        null,
        null,
        pAfmgr,
        null,
        null,
        null);
    creator = pFormulaCreator;
    osmtLogic = pFormulaCreator.getEnv();
  }
  @Override
  public PTRef parseImpl(String pS) throws IllegalArgumentException {
    return osmtLogic.parseFormula(pS);
  }
  @Override
  public String dumpFormulaImpl(PTRef f) {
    assert getFormulaCreator().getFormulaType(f) == FormulaType.BooleanType
        : "Only BooleanFormulas may be dumped";
    StringBuilder out = new StringBuilder();
    Map<String, PTRef> userDeclarations = creator.extractVariablesAndUFs(f, true);
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      out.append("(declare-fun ")
          .append(osmtLogic.protectName(ref))
          .append(" (")
          .append(Joiner.on(' ').join(Lists.transform(sym.getArgTypes(), osmtLogic::printSort)))
          .append(") ")
          .append(osmtLogic.printSort(sym.rsort()))
          .append(")\n");
    }
    out.append("(assert ").append(osmtLogic.dumpWithLets(f)).append(')');
    return out.toString();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.util.Collection;
import org.sosy_lab.java_smt.basicimpl.AbstractBooleanFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
public class OpenSmtBooleanFormulaManager
    extends AbstractBooleanFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final Logic logic;
  private final PTRef openSmtTrue;
  private final PTRef openSmtFalse;
  OpenSmtBooleanFormulaManager(OpenSmtFormulaCreator pCreator) {
    super(pCreator);
    logic = pCreator.getEnv();
    openSmtTrue = logic.getTerm_true();
    openSmtFalse = logic.getTerm_false();
  }
  @Override
  protected PTRef and(PTRef pParam1, PTRef pParam2) {
    return logic.mkAnd(pParam1, pParam2);
  }
  @Override
  protected PTRef andImpl(Collection<PTRef> pParams) {
    return logic.mkAnd(new VectorPTRef(pParams));
  }
  @Override
  protected PTRef equivalence(PTRef bits1, PTRef bits2) {
    return logic.mkEq(bits1, bits2);
  }
  @Override
  protected PTRef ifThenElse(PTRef pCond, PTRef pF1, PTRef pF2) {
    if (isTrue(pCond)) {
      return pF1;
    } else if (isFalse(pCond)) {
      return pF2;
    } else if (pF1.equals(pF2)) {
      return pF1;
    } else if (isTrue(pF1) && isFalse(pF2)) {
      return pCond;
    } else if (isFalse(pF1) && isTrue(pF2)) {
      return not(pCond);
    }
    return logic.mkIte(pCond, pF1, pF2);
  }
  @Override
  protected boolean isFalse(PTRef bits) {
    return logic.isFalse(bits);
  }
  @Override
  protected boolean isTrue(PTRef bits) {
    return logic.isTrue(bits);
  }
  @Override
  protected PTRef makeBooleanImpl(boolean value) {
    return value ? openSmtTrue : openSmtFalse;
  }
  @Override
  protected PTRef makeVariableImpl(String pVar) {
    return logic.mkBoolVar(pVar);
  }
  @Override
  protected PTRef not(PTRef pParam1) {
    return logic.mkNot(pParam1);
  }
  @Override
  protected PTRef or(PTRef pParam1, PTRef pParam2) {
    return logic.mkOr(pParam1, pParam2);
  }
  @Override
  protected PTRef orImpl(Collection<PTRef> pParams) {
    return logic.mkOr(new VectorPTRef(pParams));
  }
  @Override
  protected PTRef xor(PTRef pParam1, PTRef pParam2) {
    return logic.mkXor(pParam1, pParam2);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import org.sosy_lab.java_smt.basicimpl.AbstractUFManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
class OpenSmtUFManager extends AbstractUFManager<PTRef, SymRef, SRef, Logic> {
  OpenSmtUFManager(OpenSmtFormulaCreator pCreator) {
    super(pCreator);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigDecimal;
import java.math.BigInteger;
import org.sosy_lab.java_smt.api.IntegerFormulaManager;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
class OpenSmtIntegerFormulaManager
    extends OpenSmtNumeralFormulaManager<IntegerFormula, IntegerFormula>
    implements IntegerFormulaManager {
  OpenSmtIntegerFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
  }
  @Override
  protected SRef getNumeralType() {
    return getFormulaCreator().getIntegerType();
  }
  @Override
  protected PTRef makeNumberImpl(double pNumber) {
    return makeNumberImpl((long) pNumber);
  }
  @Override
  protected PTRef makeNumberImpl(BigDecimal pNumber) {
    return decimalAsInteger(pNumber);
  }
  @Override
  protected PTRef divide(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkIntDiv(pParam1, pParam2);
  }
  @Override
  protected PTRef modularCongruence(PTRef pNumber1, PTRef pNumber2, long pModulo) {
    return modularCongruence(pNumber1, pNumber2, BigInteger.valueOf(pModulo));
  }
  @Override
  protected PTRef modularCongruence(PTRef pNumber1, PTRef pNumber2, BigInteger pModulo) {
    if (BigInteger.ZERO.compareTo(pModulo) < 0) {
      PTRef n = makeNumberImpl(pModulo);
      PTRef x = subtract(pNumber1, pNumber2);
      return osmtLogic.mkEq(x, osmtLogic.mkTimes(n, osmtLogic.mkIntDiv(x, n)));
    }
    return osmtLogic.getTerm_true();
  }
}