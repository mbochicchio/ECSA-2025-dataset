package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.IPAddressPartStringSubCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection.IPv4AddressSectionStringCollection;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection.IPv4StringBuilder;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
public class IPv4AddressSection extends IPAddressSection implements Iterable<IPv4AddressSection> {
	private static final long serialVersionUID = 4L;
	private static final long MAX_VALUES[] = new long[] {0, IPv4Address.MAX_VALUE_PER_SEGMENT, 0xffff, 0xffffff, 0xffffffffL};
	static class IPv4StringCache extends IPStringCache {
		static final IPStringOptions fullParams;
		static final IPStringOptions normalizedWildcardParams;
		static final IPStringOptions sqlWildcardParams;
		static final IPStringOptions inetAtonOctalParams;
		static final IPStringOptions inetAtonHexParams;
		static final IPStringOptions canonicalParams;
		static final IPStringOptions reverseDNSParams;
		static final IPStringOptions segmentedBinaryParams;
		static {
			WildcardOptions allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL);
			WildcardOptions allSQLWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL, new Wildcards(IPAddress.SEGMENT_SQL_WILDCARD_STR, IPAddress.SEGMENT_SQL_SINGLE_WILDCARD_STR));
			WildcardOptions wildcardsRangeOnlyNetworkOnly = new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPAddress.RANGE_SEPARATOR_STR));
			fullParams = new IPv4StringOptions.Builder().setExpandedSegments(true).setWildcardOptions(wildcardsRangeOnlyNetworkOnly).toOptions();
			normalizedWildcardParams = new IPv4StringOptions.Builder().setWildcardOptions(allWildcards).toOptions();
			sqlWildcardParams = new IPv4StringOptions.Builder().setWildcardOptions(allSQLWildcards).toOptions();
			inetAtonOctalParams = new IPv4StringOptions.Builder().setRadix(IPv4Address.inet_aton_radix.OCTAL.getRadix()).setSegmentStrPrefix(IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix()).toOptions();
			inetAtonHexParams = new IPv4StringOptions.Builder().setRadix(IPv4Address.inet_aton_radix.HEX.getRadix()).setSegmentStrPrefix(IPv4Address.inet_aton_radix.HEX.getSegmentStrPrefix()).toOptions();
			canonicalParams = new IPv4StringOptions.Builder().toOptions();
			reverseDNSParams = new IPv4StringOptions.Builder().setWildcardOptions(allWildcards).setReverse(true).setAddressSuffix(IPv4Address.REVERSE_DNS_SUFFIX).toOptions();
			segmentedBinaryParams = new IPStringOptions.Builder(2).setSeparator(IPv4Address.SEGMENT_SEPARATOR).setSegmentStrPrefix(IPAddress.BINARY_STR_PREFIX).toOptions();
		}
		public String octalString;
		public String hexString;
	}
	static class IPv4AddressCache extends SectionCache<IPv4Address> {}
	transient IPv4StringCache stringCache;
	private transient SectionCache<IPv4AddressSection> sectionCache;
	private transient Integer cachedLowerVal, cachedUpperVal;
	public IPv4AddressSection(IPv4AddressSegment segment) {
		this(new IPv4AddressSegment[] {segment}, false);
	}
	public IPv4AddressSection(IPv4AddressSegment segments[]) throws AddressValueException {
		this(segments, true);
	}
	public IPv4AddressSection(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, true, networkPrefixLength, false);
	}
	protected IPv4AddressSection(IPv4AddressSegment[] segments, boolean cloneSegments, Integer networkPrefixLength, boolean singleOnly) throws AddressValueException {
		this(segments, cloneSegments, networkPrefixLength == null );
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segments.length << 3;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv4Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segments.length > 0) {
				if(cachedPrefixLength != NO_PREFIX_LENGTH && cachedPrefixLength < networkPrefixLength) {
					networkPrefixLength = cachedPrefixLength;
				}
				IPv4AddressNetwork network = getNetwork();
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(), 
						!singleOnly && isPrefixSubnetSegs(segments, networkPrefixLength, network, false) ? IPv4AddressSegment::toNetworkSegment : IPv4AddressSegment::toPrefixedSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} 
	}
	protected IPv4AddressSection(IPv4AddressSegment segments[], boolean cloneSegments) throws AddressValueException {
		this(segments, cloneSegments, true);
	}
	IPv4AddressSection(IPv4AddressSegment segments[], boolean cloneSegments, boolean normalizeSegments) throws AddressValueException {
		super(segments, cloneSegments, true);
		if(normalizeSegments && isPrefixed()) {
			normalizePrefixBoundary(getNetworkPrefixLength(), getSegmentsInternal(), IPv4Address.BITS_PER_SEGMENT, IPv4Address.BYTES_PER_SEGMENT, IPv4AddressSegment::toPrefixNormalizedSeg);
		}
		if(segments.length > IPv4Address.SEGMENT_COUNT) {
			throw new AddressValueException(segments.length);
		}
	}
	public IPv4AddressSection(SegmentValueProvider valueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount, networkPrefixLength);
	}
	public IPv4AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv4AddressSegment[segmentCount], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		createSegments(
				segs,
				lowerValueProvider,
				upperValueProvider,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength > IPv4Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(),
						IPv4AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
	}
	public IPv4AddressSection(SegmentValueProvider valueProvider, int segmentCount) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount);
	}
	public IPv4AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount) {
		this(lowerValueProvider, upperValueProvider, segmentCount, null);
	}
	protected IPv4AddressSection(byte bytes[], int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, networkPrefixLength, cloneBytes, singleOnly);
	}
	protected IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		super(new IPv4AddressSegment[segmentCount >= 0 ? segmentCount : Math.max(0, byteEndIndex - byteStartIndex)], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		toSegments(
			segs,
			bytes,
			byteStartIndex,
			byteEndIndex,
			getBytesPerSegment(),
			getBitsPerSegment(),
			network,
			networkPrefixLength);
		boolean byteLengthIsExact = bytes.length == segs.length;
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segs.length << 3;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv4Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segs.length > 0) {
				PrefixConfiguration prefConf = network.getPrefixConfiguration();
				if(prefConf.zeroHostsAreSubnets()) {
					if(isPrefixSubnetSegs(segs, networkPrefixLength, network, false) && !singleOnly) {
						setPrefixedSegments(
								network,
								networkPrefixLength,
								segs,
								getBitsPerSegment(),
								getBytesPerSegment(),
								network.getAddressCreator(),
								IPv4AddressSegment::toNetworkSegment);
					} else if(byteLengthIsExact && networkPrefixLength >= getBitCount()) {
						setBytes(cloneBytes ? bytes.clone() : bytes);
					}
				} else if(byteLengthIsExact && (prefConf.prefixedSubnetsAreExplicit() || networkPrefixLength >= getBitCount())) {
					setBytes(cloneBytes ? bytes.clone() : bytes);
				}
			} else if(byteLengthIsExact) {
				setBytes(bytes); 
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
			if(byteLengthIsExact) {
				setBytes(cloneBytes ? bytes.clone() : bytes);
			}
		}
	}
	protected IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, segmentCount, prefix, true, false);
	}
	public IPv4AddressSection(byte bytes[], Integer prefix) throws AddressValueException {
		this(bytes, bytes.length, prefix, true, false);
	}
	public IPv4AddressSection(byte bytes[]) throws AddressValueException {
		this(bytes, bytes.length, null, true, false);
	}
	public IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
	}
	public IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, null, true, false);
	}
	public IPv4AddressSection(int value, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv4AddressSegment[IPv4Address.SEGMENT_COUNT], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		createSegments(
				segs,
				0,
				value,
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength > IPv4Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(),
						IPv4AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
	}
	public IPv4AddressSection(int value) {
		this(value, null);
	}
	@Override
	public IPv4AddressSegment[] getSegments() {
		return (IPv4AddressSegment[]) getDivisionsInternal().clone();
	}
	@Override
	public IPv4AddressSection getSection() {
		return this;
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection(index, getSegmentCount());
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection(index, endIndex, this, getAddressCreator());
	}
	@Override
	protected void setInetAddress(InetAddress addr) {
		super.setInetAddress(addr);
	}
	void cache(IPv4Address thisAddr, IPv4Address lower, IPv4Address upper) {
		if((lower != null || upper != null) && getSingleLowestOrHighestSection(this) == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv4AddressCache cache = thisAddr.addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = thisAddr.addressCache;
					boolean create = (cache == null);
					if(create) {
						thisAddr.addressCache = cache = new IPv4AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	void cache(IPv4AddressSection lower, IPv4AddressSection upper) {
		SectionCache<IPv4AddressSection> cache = sectionCache;
		if((lower != null || upper != null) && 
				(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null))) {
			synchronized(this) {
				cache = sectionCache;
				boolean create = (cache == null);
				if(create) {
					sectionCache = cache = new SectionCache<IPv4AddressSection>();
					cache.lower = lower;
					cache.upper = upper;
				} else {
					if(cache.lower == null) {
						cache.lower = lower;
					}
					if(cache.upper == null) {
						cache.upper = upper;
					}
				}
			}
		}
	}
	private IPv4AddressSection getLowestOrHighestSection(boolean lowest, boolean excludeZeroHost) {
		IPv4AddressSection result = getSingleLowestOrHighestSection(this);
		if(result == null) {
			SectionCache<IPv4AddressSection> cache = sectionCache;
			if(cache == null || (lowest ? (excludeZeroHost ? ((result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull) : (result = cache.lower) == null) : (result = cache.upper) == null)) {
				synchronized(this) {
					cache = sectionCache;
					boolean create = (cache == null);
					if(create) {
						sectionCache = cache = new SectionCache<IPv4AddressSection>();
					} else {
						if(lowest) {
							if(excludeZeroHost) {
								create = (result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull;
							} else {
								create = (result = cache.lower) == null;
							}
						} else {
							create = (result = cache.upper) == null;
						}
					}
					if(create) {
						result = createLowestOrHighestSection(
								this,
								getAddressCreator(), 
								this::segmentsNonZeroHostIterator,
								i -> lowest ? getSegment(i).getLower() : getSegment(i).getUpper(),
								lowest,
								excludeZeroHost);
						if(result == null) {
							cache.lowerNonZeroHostIsNull = true;
						} else if(lowest) {
							if(excludeZeroHost) {
								 cache.lowerNonZeroHost = result;
							} else {
								cache.lower = result;
							}
						} else {
							cache.upper = result;
						}
					}
				}
			}
		} else if(excludeZeroHost && includesZeroHost()) {
			return null;
		}
		return result;
	}
	IPv4Address getLowestOrHighest(IPv4Address addr, boolean lowest, boolean excludeZeroHost) {
		IPv4AddressSection sectionResult = getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == this) {
			return addr;
		} else if(sectionResult == null) {
			return null;
		}
		IPv4Address result = null;
		IPv4AddressCache cache = addr.addressCache;
		if(cache == null || 
				(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addr.addressCache;
				boolean create = (cache == null);
				if(create) {
					cache = addr.addressCache = new IPv4AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getAddressCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	@Override
	public IPv4AddressSection getLowerNonZeroHost() {
		return getLowestOrHighestSection(true, true);
	}
	@Override
	public IPv4AddressSection getLower() {
		return getLowestOrHighestSection(true, false);
	}
	@Override
	public IPv4AddressSection getUpper() {
		return getLowestOrHighestSection(false, false);
	}
	public int intValue() {
		return getIntValue(true);
	}
	public int upperIntValue() {
		return getIntValue(false);
	}
	public long longValue() {
		return intValue() & 0xffffffffL;
	}
	public long upperLongValue() {
		return upperIntValue() & 0xffffffffL;
	}
	private int calcValue(boolean lower) {
		int segCount = getSegmentCount();
		int result = 0;
		if(segCount != 0) {
			IPv4AddressSegment first = getSegment(0);
			result = lower ? first.getSegmentValue() : first.getUpperSegmentValue();
			if(segCount != 1) {
				int bitsPerSegment = getBitsPerSegment();
				for(int i = 1; i < segCount; i++) {
					IPv4AddressSegment seg = getSegment(i);
					result = (result << bitsPerSegment) | 
							(lower ? seg.getSegmentValue() : seg.getUpperSegmentValue());
				}
			}
		}
		return result;
	}
	private int getIntValue(boolean lower) {
		int result = 0;
		if(lower || !isMultiple()) {
			Integer cachedInt = this.cachedLowerVal;
			if(cachedInt == null) {
				result = calcValue(true);
				this.cachedLowerVal = result;
			} else {
				result = cachedInt;
			}
		} else {
			Integer cachedInt = this.cachedUpperVal;
			if(cachedInt == null) {
				result = calcValue(false);
				this.cachedUpperVal = result;
			} else {
				result = cachedInt;
			}
		}
		return result;
	}
	@Override
	public IPv4AddressSection reverseBits(boolean perByte) {
		return reverseBits(perByte, this, getAddressCreator(), i -> getSegment(i).reverseBits(perByte), true);
	}
	@Override
	public IPv4AddressSection reverseBytes() {
		return reverseSegments();
	}
	@Override
	public IPv4AddressSection reverseBytesPerSegment() {
		if(!isPrefixed()) {
			return this;
		}
		return withoutPrefixLength();
	}
	@Override
	public IPv4AddressSection reverseSegments() {
		if(getSegmentCount() <= 1) {
			if(isPrefixed()) {
				return withoutPrefixLength();
			}
			return this;
		}
		return reverseSegments(this, getAddressCreator(), (i) -> getSegment(i).withoutPrefixLength(), true);
	}
	@Override
	protected IPv4AddressSegment[] getSegmentsInternal() {
		return (IPv4AddressSegment[])  super.getDivisionsInternal();
	}
	@Override
	public Iterable<IPv4AddressSection> getIterable() {
		return this;
	}
	private Iterator<IPv4AddressSection> iterator(Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		IPv4AddressSection original;
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		} else {
			original = this;
		}
		return iterator(
				useOriginal,
				original,
				getAddressCreator(),
				useOriginal ? null : segmentsIterator(excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4AddressSection> spliterator(boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		IteratorProvider<IPv4AddressSection, IPv4AddressSection> iteratorProvider;
		ToLongFunction<IPv4AddressSection> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			longSizer = section -> longCount(section, segmentCount) - section.longZeroHostCount(prefixLength, segmentCount);
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator(segs -> isZeroHost(segs, prefixLength));
		} else {
			longSizer = section -> longCount(section, segmentCount);
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator();
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				null,
				null,
				longSizer);
	}
	Iterator<IPv4Address> iterator(IPv4Address original,
			AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator,
			Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		if(useOriginal && excludeFunc != null && excludeFunc.test(original.getSection().getSegmentsInternal())) {
			original = null;
		}
		return iterator(
				useOriginal,
				original, 
				creator, 
				useOriginal ? null : 
					segmentsIterator(
							getSegmentCount(),
							creator,
							isMultiple() ? null : () -> getLower().getSegmentsInternal(),
							index -> getSegment(index).iterator(!isAllSubnets),
							excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4Address> spliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = original;
		}
		IteratorProvider<IPv4Address, IPv4Address> iteratorProvider;
		ToLongFunction<IPv4Address> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			longSizer = addr -> longCount(addr.getSection(), segmentCount) - addr.getSection().longZeroHostCount(prefixLength, segmentCount);
			iteratorProvider = (isLowest, isHighest, addr) -> addr.getSection().iterator(addr, addr.getAddressCreator(), s -> isZeroHost(s, prefixLength));
		} else {
			longSizer = addr -> longCount(addr.getSection(), segmentCount);
			iteratorProvider = (isLowest, isHighest, addr) -> addr.iterator();
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				null,
				null,
				longSizer);
	}
	@Override
	public Iterator<IPv4AddressSection> nonZeroHostIterator() {
		return iterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv4AddressSection> iterator() {
		return iterator(null);
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> spliterator() {
		return spliterator(false);
	}
	@Override
	public Stream<IPv4AddressSection> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSection> prefixIterator() {
		return prefixIterator(false);
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator() {
		return prefixSpliterator(false);
	}
	@Override
	public Stream<IPv4AddressSection> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSection> prefixBlockIterator() {
		return prefixIterator(true);
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> prefixBlockSpliterator() {
		return prefixSpliterator(true);
	}
	@Override
	public Stream<IPv4AddressSection> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	private Iterator<IPv4AddressSection> prefixIterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean useOriginal = isBlockIterator ? isSinglePrefixBlock() : longPrefixCount(prefLength) == 1;
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
								segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				prefLength);
	}
	private AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(false);
		}
		return prefixSpliterator(isBlockIterator, prefLength);
	}
	private AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator(boolean isBlockIterator, int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		IPv4AddressCreator creator = getAddressCreator();
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, section) -> section.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, section) -> section.prefixIterator() : 
							((isLowest, isHighest, section) -> (isLowest || isHighest) ? section.prefixIterator() : section.prefixBlockIterator())), 
				null,
				null,
				section -> longPrefixCount(section, prefixLength));
	}
	@Override
	public Iterator<IPv4AddressSection> blockIterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return iterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean useOriginal = !isMultiple(segmentCount);
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
							getSegmentCount(),
							creator,
							null, 
							index -> getSegment(index).iterator(!isAllSubnets),
							null, 
							segmentCount - 1, 
							segmentCount, 
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> blockSpliterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv4AddressSection forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.blockIterator(segmentCount), 
				null,
				null,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv4AddressSection> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AddressSection> sequentialBlockIterator() {
		return (Iterator<IPv4AddressSection>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4AddressSection>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4AddressSection> sequentialBlockStream() {
		return (Stream<IPv4AddressSection>) super.sequentialBlockStream();
	}
	private Iterator<IPv4AddressSegment[]> segmentsIterator(Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return segmentsIterator(
				getSegmentCount(),
				getSegmentCreator(),
				isMultiple() ? null : () -> getLower().getSegments(),
				index -> getSegment(index).iterator(!isAllSubnets),
				excludeFunc);
	}
	private Predicate<IPv4AddressSegment[]> excludeNonZeroHosts() {
		if(isPrefixed()) {
			int prefLength = getNetworkPrefixLength();
			return segments -> isZeroHost(segments, prefLength);
		}
		return null;
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return segmentsIterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return segmentsIterator(null);
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4AddressSection, IPv4AddressSegment[]> segmentsSpliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.segmentsIterator(),
				null,
				null,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator(IPv4Address address, IPv4AddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = address.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = address;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.segmentsIterator(),
				null,
				null,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	Iterator<IPv4Address> prefixIterator(
			IPv4Address original,
			AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator(original, creator, null);
		}
		return prefixIterator(original, creator, isBlockIterator, prefLength);
	}
	AddressComponentSpliterator<IPv4Address> prefixSpliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(original, creator, false);
		}
		return prefixSpliterator(original, creator, isBlockIterator, prefLength);
	}
	AddressComponentSpliterator<IPv4Address> prefixSpliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean isBlockIterator,
			int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(original, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				original.setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, addr) -> addr.prefixBlockIterator() : 
							(!isSequential() ? (isLowest, isHighest, addr) -> addr.prefixIterator() : 
							((isLowest, isHighest, addr) -> (isLowest || isHighest) ? addr.prefixIterator() : addr.prefixBlockIterator())),
				null,
				null,
				addr -> longPrefixCount(addr.getSection(), prefixLength));
	}
	Iterator<IPv4Address> prefixIterator(IPv4Address original, AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator, boolean isBlockIterator, int prefLength) {
		if(prefLength > getBitCount() || prefLength < 0) {
			throw new PrefixLenException(original, prefLength);
		}
		boolean useOriginal = isBlockIterator ? containsSinglePrefixBlock(prefLength) : longPrefixCount(prefLength) == 1;
		if(useOriginal) {
			original = original.setPrefixLength(prefLength, false);
		}
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator, 
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null,
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				cacheBits(prefLength));
	}
	Iterator<IPv4Address> blockIterator(IPv4Address original, AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount > getSegmentCount()) {
			return iterator(original, creator, null);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple(segmentCount);
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator,
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(!isAllSubnets),
							null,
							networkSegIndex,
							hostSegIndex,
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4Address> blockSpliterator(IPv4Address original, IPv4AddressCreator creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator(original, creator, false);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = original;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.blockIterator(segmentCount), 
				null,
				null,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	protected boolean isZeroHost(IPv4AddressSegment segments[], int prefixLength) {
		return super.isZeroHost(segments, prefixLength);
	}
	private static long getMaxValue(int segmentCount) {
		return MAX_VALUES[segmentCount];
	}
	@Override
	public IPv4AddressSection incrementBoundary(long increment) {
		if(increment <= 0) {
			if(increment == 0) {
				return this;
			}
			return getLower().increment(increment);
		}
		return getUpper().increment(increment);
	}
	@Override
	public IPv4AddressSection increment(long increment) {
		if(increment == 0 && !isMultiple()) {
			return this;
		}
		checkOverflow(increment, this::longValue, this::upperLongValue, () -> getCount().longValue(), this::isSequential, () -> getMaxValue(getSegmentCount()));
		return increment(
				this,
				increment,
				getAddressCreator(),
				() -> getCount().longValue(),
				this::longValue,
				this::upperLongValue,
				this::getLower,
				this::getUpper,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength());
	}
	public long getIPv4Count(boolean excludeZeroHosts) {
		return excludeZeroHosts && includesZeroHost() ? 
				longZeroHostCount(getNetworkPrefixLength(), getSegmentCount()) : 
					longCount(getSegmentCount());
	}
	@Override
	protected BigInteger getCountImpl(int segCount) {
		if(!isMultiple()) {
			return BigInteger.ONE;
		}
		return BigInteger.valueOf(longCount(this, segCount));
	}
	@Override
	protected BigInteger getZeroHostCountImpl(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				return BigInteger.valueOf(longZeroHostCount(prefixLength, segCount));
			} else {
				return BigInteger.ONE;
			}
		}
		return BigInteger.ZERO;
	}
	public long getIPv4PrefixCount(int prefixLength) {
		checkSubnet(this, prefixLength);
		return longPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return BigInteger.valueOf(getIPv4PrefixCount(prefixLength));
	}
	public long getIPv4PrefixCount() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getIPv4Count(false);
		}
		return getIPv4PrefixCount(prefixLength);
	}
	@Override
	protected BigInteger getPrefixCountImpl() {
		return BigInteger.valueOf(getIPv4PrefixCount());
	}
	private IPv4AddressCreator getSegmentCreator() {
		return getIPv4SegmentCreator();
	}
	private IPv4AddressCreator getAddressCreator() {
		return getIPv4SegmentCreator();
	}
	private IPv4AddressCreator getIPv4SegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return (IPv4AddressSegment) super.getDivision(index);
	}
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return (IPv4AddressSegment) super.getSegment(index);
	}
	public void getSegments(Collection<? super IPv4AddressSegment> segs) {
		getSegments(0, getSegmentCount(), segs);
	}
	public void getSegments(int start, int end, Collection<? super IPv4AddressSegment> segs) {
		for(int i = start; i < end; i++) {
			segs.add(getSegment(i));
		}
	}
	@Override
	public int getBitsPerSegment() {
		return IPv4Address.BITS_PER_SEGMENT;
	}
	@Override
	public int getBytesPerSegment() {
		return IPv4Address.BYTES_PER_SEGMENT;
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() << 3;
	}
	@Override
	public int getByteCount() {
		return getSegmentCount();
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int segmentCount = getSegmentCount();
		byte bytes[] = new byte[segmentCount];
		for(int i = 0; i < segmentCount; i++) {
			IPv4AddressSegment seg = getSegment(i);
			int val = low ? seg.getSegmentValue() : seg.getUpperSegmentValue();
			bytes[i] = (byte) val;
		}
		return bytes;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV4;
	}
	@Override
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		return other instanceof IPv4AddressSection && mask instanceof IPv4AddressSection && super.matchesWithMask(other, mask);
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPv4AddressSection && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		return o == this || (o instanceof IPv4AddressSection && ((IPv4AddressSection) o).isSameGrouping(this));
	}
	@Override
	public boolean overlaps(AddressSection other) {
		return other instanceof IPv4AddressSection && overlaps(this, other);
	}
	@Override
	public boolean contains(AddressSection other) {
		return other instanceof IPv4AddressSection && super.contains(other);
	}
	@Override
	protected boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength) {
		if(other instanceof IPv4AddressSection) {
			IPv4AddressSection remaining[] = ((IPv4AddressSection) other).subtract(this);
			if(remaining != null) {
				for(int i = 0; i < remaining.length; i++) {
					if(!remaining[i].isZeroHost(otherPrefixLength)) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}
	static BigInteger enumerate(IPv4AddressSection addr, AddressSection other) {
		Long result = enumerateSmall(addr, other);
		if(result != null) {
			return BigInteger.valueOf(result);
		}
		return null;
	}
	public Long enumerateIPv4(IPv4AddressSection other){
		checkSegmentCount(other);
		return enumerateSmall(this, other);
	}
	static Long enumerateIPv4(IPv4AddressSection addr, AddressSection other) {
		 return enumerateSmall(addr, other);
	}
	@Override
	public BigInteger enumerate(AddressSection other) {
		if(other instanceof IPv4AddressSection) {
			checkSegmentCount(other);
			Long result = enumerateSmall(this, other);
			if(result != null) {
				return BigInteger.valueOf(result);
			}
		}
		return null;
	}
	@Override
	public boolean prefixEquals(AddressSection other) {
		return other == this || (other instanceof IPv4AddressSection && prefixEquals(this, other, 0));
	}
	@Override
	public boolean prefixContains(IPAddressSection other) {
		return other == this || (other instanceof IPv4AddressSection && prefixContains(this, other, 0));
	}
	public IPv4AddressSection append(IPv4AddressSection other) {
		int count = getSegmentCount();
		return replace(count, count, other, 0, other.getSegmentCount());
	}
	public IPv4AddressSection insert(int index, IPv4AddressSection other) {
		return replace(index, index, other, 0, other.getSegmentCount());
	}
	public IPv4AddressSection replace(int index, IPv4AddressSection other) {
		return replace(index, index + other.getSegmentCount(), other, 0, other.getSegmentCount());
	}
	public IPv4AddressSection appendToNetwork(IPv4AddressSection other) {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null) {
			return append(other);
		}
		IPv4AddressSection thizz = this;
		int bitsPerSegment = getBitsPerSegment();
		int adjustment = prefixLength % bitsPerSegment;
		if(adjustment != 0) {
			prefixLength += bitsPerSegment - adjustment;
			thizz = setPrefixLength(prefixLength, false);
		}
		int index = prefixLength >>> 3;
		if(other.isPrefixed() && other.getPrefixLength() == 0) {
			return insert(index, other);
		}
		return thizz.replace(index, index, other, 0, other.getSegmentCount(), true);
	}
	public IPv4AddressSection replace(int startIndex, int endIndex, IPv4AddressSection replacement, int replacementStartIndex, int replacementEndIndex) {
		return replace(startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, false);
	}
	private IPv4AddressSection replace(int startIndex, int endIndex, IPv4AddressSection replacement, int replacementStartIndex, int replacementEndIndex, boolean appendNetwork) {
		int segmentCount = getSegmentCount();
		int replacedCount = endIndex - startIndex;
		int replacementCount = replacementEndIndex - replacementStartIndex;
		if(replacedCount < 0 || replacementCount < 0 || startIndex < 0 || replacementStartIndex < 0 || replacementEndIndex > replacement.getSegmentCount() || endIndex > segmentCount) {
			throw new IndexOutOfBoundsException();
		}
		IPv4AddressSection thizz = this;
		if(segmentCount + replacementCount - replacedCount > IPv4Address.SEGMENT_COUNT) {
			throw new AddressValueException(this, replacement, segmentCount + replacementCount - replacedCount);
		} else if(replacementCount == 0 && replacedCount == 0) {
			return this;
		} else if(segmentCount == replacedCount) {
			return replacement;
		} else if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(appendNetwork) {
				thizz = withoutPrefixLength();
				int replacementEndBits = replacementEndIndex << 3;
				if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
					replacement = replacement.setPrefixLength(replacementEndBits, false);
				}
			}
		} else {
			Integer prefixLength = getPrefixLength();
			if(appendNetwork) {
				int additionalSegs = segmentCount - endIndex;
				if(additionalSegs > 0) {
					thizz = getSection(0, startIndex).withoutPrefixLength();
					replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
					replacementEndIndex += additionalSegs;
					endIndex = startIndex;
				} else {
					thizz = withoutPrefixLength();
					int replacementEndBits = replacementEndIndex << 3;
					if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
						replacement = replacement.setPrefixLength(replacementEndBits, false);
					}
				}
			} else if(prefixLength != null && !appendNetwork && prefixLength <= startIndex << 3) {
				replacement = replacement.setPrefixLength(0, false);
			} else if(endIndex < segmentCount) {
				int replacementEndBits = replacementEndIndex << 3;
				if(replacement.isPrefixed() && replacement.getNetworkPrefixLength() <= replacementEndBits) {
					int thisNextIndexBits = endIndex << 3;
					if(prefixLength == null || prefixLength > thisNextIndexBits) {
						if(replacedCount > 0 || replacement.getPrefixLength() == 0) {
							thizz = setPrefixLength(thisNextIndexBits, false);
						} else {
							int additionalSegs = segmentCount - endIndex;
							thizz = getSection(0, startIndex);
							replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
							replacementEndIndex += additionalSegs;
						}
					}
				}
			}
		}
		return replace(thizz, startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, getAddressCreator(), appendNetwork, false);
	}
	public IPv4AddressSection intersect(IPv4AddressSection other) throws SizeMismatchException {
		return intersect(this, other, getAddressCreator(), this::getSegment, other::getSegment);
	}
	public IPv4AddressSection[] subtract(IPv4AddressSection other) throws SizeMismatchException {
		return subtract(this, other, getAddressCreator(), this::getSegment, (section, prefix) -> section.setPrefixLength(prefix, false, true));
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return Address.defaultIpv4Network();
	}
	@Override
	public IPv4AddressSection adjustPrefixBySegment(boolean nextSegment) {
		return adjustPrefixBySegment(nextSegment, true);
	}
	@Override
	public IPv4AddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return (IPv4AddressSection) super.adjustPrefixBySegment(nextSegment, zeroed);
	}
	@Override
	public IPv4AddressSection adjustPrefixLength(int adjustment) {
		return adjustPrefixLength(adjustment, true);
	}
	@Override
	public IPv4AddressSection adjustPrefixLength(int adjustment, boolean zeroed) {
		return (IPv4AddressSection) adjustPrefixLength(this, adjustment, zeroed, getAddressCreator(), (section, i) -> section.getSegment(i));
	}
	@Deprecated
	@Override
	public IPv4AddressSection applyPrefixLength(int networkPrefixLength) {
		return setPrefixLength(networkPrefixLength, true, true, true);
	}
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength) {
		return setPrefixLength(networkPrefixLength, true, false, true);
	}
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros) {
		return setPrefixLength(networkPrefixLength, withZeros, false, true);
	}
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean zeroHostIsBlock) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, zeroHostIsBlock);
	}
	private IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean noShrink, boolean zeroHostIsBlock) {
		return setPrefixLength(
				this,
				getAddressCreator(),
				networkPrefixLength,
				withZeros,
				noShrink,
				!zeroHostIsBlock,
				(section, i) -> section.getSegment(i));
	}
	@Override
	@Deprecated
	public IPv4AddressSection removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv4AddressSection withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv4AddressSection removePrefixLength(boolean zeroed) {
		return removePrefixLength(this, zeroed, getAddressCreator(), IPv4AddressSection::getSegment);
	}
	@Override
	public IPv4AddressSection toZeroHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address networkMask = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				networkMask = networkMask.getLower();
			}
			return networkMask.getSection(0, getSegmentCount());
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return createZeroHost(false);
	}
	IPv4AddressSection createZeroHost(boolean boundariesOnly) {
		int prefixLength = getNetworkPrefixLength();
		IPv4AddressNetwork network = getNetwork();
		IPv4Address mask = network.getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				network.getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : cacheBits(prefixLength),
				getAddressCreator(),
				!boundariesOnly,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv4AddressSection toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		IPv4Address mask = getNetwork().getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv4AddressSection toZeroNetwork() {
		if(!isPrefixed()) {
			IPv4Address hostMask = getNetwork().getHostMask(getBitCount());
			return hostMask.getSection(0, getSegmentCount());
		}
		return createZeroNetwork();
	}
	IPv4AddressSection createZeroNetwork() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getSubnetSegments(
				this,
				prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv4AddressSection toMaxHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix.getSection(0, getSegmentCount());
			}
			return resultNoPrefix.setPrefixLength(0).getSection(0, getSegmentCount());
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper(); 
		}
		return createMaxHost();
	}
	public IPv4AddressSection createMaxHost() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv4AddressSection toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	public IPv4AddressSection mask(IPv4AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getSubnetSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				false);
	}
	public IPv4AddressSection mask(IPv4AddressSection mask) throws IncompatibleAddressException, SizeMismatchException {
		return mask(mask, false);
	}
	public IPv4AddressSection maskNetwork(IPv4AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv4AddressSection hostMask = getNetwork().getHostMaskSection(networkPrefixLength);
		return getSubnetSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true, 
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = hostMask.getSegment(i).getSegmentValue();
					return val1 | val2;
				},
				false);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	public IPv4AddressSection bitwiseOr(IPv4AddressSection mask) throws IncompatibleAddressException {
		return bitwiseOr(mask, false);
	}
	public IPv4AddressSection bitwiseOr(IPv4AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getOredSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	public IPv4AddressSection bitwiseOrNetwork(IPv4AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv4AddressSection networkMask = getNetwork().getNetworkMaskSection(networkPrefixLength);
		return getOredSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true,
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = networkMask.getSegment(i).getSegmentValue();
					return val1 & val2;
				}
		);
	}
	@Override
	public IPv4AddressSection getHostMask() {
		return (IPv4AddressSection) super.getHostMask();
	}
	@Override
	public IPv4AddressSection getNetworkMask() {
		return (IPv4AddressSection) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		if(isPrefixed()) {
			return getNetworkSection(getNetworkPrefixLength());
		}
		return getNetworkSection(getBitCount());
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getNetworkSection(networkPrefixLength, true);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getNetworkSection(this, networkPrefixLength, withPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, withPrefixLength));
	}
	@Override
	public IPv4AddressSection getHostSection() {
		if(isPrefixed()) {
			return getHostSection(getNetworkPrefixLength());
		}
		return getHostSection(0);
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		int hostSegmentCount = getHostSegmentCount(networkPrefixLength);
		return getHostSection(this, networkPrefixLength, hostSegmentCount, getAddressCreator(), (prefix, i) -> getSegment(i).toHostSegment(prefix));
	}
	@Override
	public IPv4AddressSection toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4AddressSection toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return toPrefixBlock(this, networkPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, true));
	}
	@Override
	public IPv4AddressSection assignPrefixForSingleBlock() {
		return (IPv4AddressSection) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv4AddressSection assignMinPrefixForBlock() {
		return (IPv4AddressSection) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4AddressSection coverWithPrefixBlock() {
		return (IPv4AddressSection) coverWithPrefixBlock(this, getLower(), getUpper());
	}
	public IPv4AddressSection coverWithPrefixBlock(IPv4AddressSection other) throws AddressConversionException {
		checkSegmentCount(other);
		return coverWithPrefixBlock(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return IPAddressSection.coverWithPrefixBlock(first, other, getLower, getUpper, comparator);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries orig,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		return IPAddressSection.coverWithPrefixBlock(orig, lower, upper);
	}
	@Override
	public IPv4AddressSection[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4AddressSection[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4AddressSection> list = (ArrayList<IPv4AddressSection>) spanWithBlocks(true);
		return list.toArray(new IPv4AddressSection[list.size()]);
	}
	public IPv4AddressSection[] spanWithPrefixBlocks(IPv4AddressSection other) {
		return getSpanningPrefixBlocks(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4AddressSection::assignPrefixForSingleBlock,
				IPv4AddressSection::withoutPrefixLength,
				getAddressCreator()::createSectionArray);
	}
	@Deprecated
	public IPv4AddressSection[] spanWithRangedSegments(IPv4AddressSection other) {
		return spanWithSequentialBlocks(other);
	}
	@Override
	public IPv4AddressSection[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4AddressSection[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4AddressSection> list = (ArrayList<IPv4AddressSection>) spanWithBlocks(false);
		return list.toArray(new IPv4AddressSection[list.size()]);
	}
	public IPv4AddressSection[] spanWithSequentialBlocks(IPv4AddressSection other) {
		return getSpanningSequentialBlocks(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4AddressSection::withoutPrefixLength,
				getAddressCreator());
	}
	@Deprecated
	public IPv4AddressSection[] mergePrefixBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		return mergeToPrefixBlocks(sections);
	}
	public IPv4AddressSection[] mergeToPrefixBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv4AddressSection converted[] = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4AddressSection[blocks.size()]);
	}
	private IPv4AddressSection[] getCloned(IPv4AddressSection... sections) {
		IPv4AddressSection converted[] = new IPv4AddressSection[sections.length + 1];
		System.arraycopy(sections, 0, converted, 1, sections.length);
		converted[0] = this;
		return converted;
	}
	private void checkSectionsMergeable(IPv4AddressSection sections[]) {
		for(int i = 0; i < sections.length; i++) {
			IPv4AddressSection section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.getSegmentCount() != getSegmentCount()) {
				throw new SizeMismatchException(this, section);
			}
		}
	}
	public IPv4AddressSection[] mergeToSequentialBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv4AddressSection converted[] = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator()::createSequentialBlockSection);
		return blocks.toArray(new IPv4AddressSection[blocks.size()]);
	}
	@Override
	protected boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					stringCache = new IPv4StringCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	protected IPv4StringCache getStringCache() {
		return stringCache;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			stringCache.canonicalString = result = toNormalizedString(IPv4StringCache.canonicalParams);
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			stringCache.fullString = result = toNormalizedString(IPv4StringCache.fullParams);
		}
		return result;
	}
	@Override
	public String toCompressedString() {
		return toCanonicalString();
	}
	@Override
	public String toNormalizedString() {
		return toCanonicalString();
	}
	@Override
	protected void cacheNormalizedString(String str) {
		if(hasNoStringCache() || stringCache.canonicalString == null) {
			stringCache.canonicalString = str;
		}
	}
	@Override
	public String toCompressedWildcardString() {
		return toNormalizedWildcardString();
	}
	@Override
	public String toSubnetString() {
		return toNormalizedWildcardString();
	}
	@Override
	public String toPrefixLengthString() {
		return toCanonicalString();
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		String result;
		if(radix == IPv4Address.inet_aton_radix.OCTAL) {
			if(hasNoStringCache() || (result = stringCache.octalString) == null) {
				stringCache.octalString = result = toNormalizedString(IPv4StringCache.inetAtonOctalParams);
			}
		} else if(radix == IPv4Address.inet_aton_radix.HEX) {
			if(hasNoStringCache() || (result = stringCache.hexString) == null) {
				stringCache.hexString = result = toNormalizedString(IPv4StringCache.inetAtonHexParams);
			}
		} else {
			result = toCanonicalString();
		}
		return result;
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		if(joinedCount <= 0) {
			return toInetAtonString(radix);
		}
		IPStringOptions stringParams;
		if(radix == IPv4Address.inet_aton_radix.OCTAL) {
			stringParams = IPv4StringCache.inetAtonOctalParams;
		} else if(radix == IPv4Address.inet_aton_radix.HEX) {
			stringParams = IPv4StringCache.inetAtonHexParams;
		} else {
			stringParams = IPv4StringCache.canonicalParams;
		}
		return toNormalizedString(stringParams, joinedCount);
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			stringCache.normalizedWildcardString = result = toNormalizedString(IPv4StringCache.normalizedWildcardParams);
		}
		return result;
	}
	@Override
	public String toCanonicalWildcardString() {
		return toNormalizedWildcardString();
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			stringCache.sqlWildcardString = result = toNormalizedString(IPv4StringCache.sqlWildcardParams);
		}
		return result;
	}
	@Override
	public String toReverseDNSLookupString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.reverseDNSString) == null) {
			stringCache.reverseDNSString = result = toNormalizedString(IPv4StringCache.reverseDNSParams);
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			stringCache.segmentedBinaryString = result = toNormalizedString(IPv4StringCache.segmentedBinaryParams);
		}
		return result;
	}
	public String toNormalizedString(IPStringOptions stringParams, int joinCount) throws IncompatibleAddressException {
		if(joinCount <= 0) {
			return toNormalizedString(stringParams);
		}
		int thisCount = getSegmentCount();
		if(thisCount <= 1) {
			return toNormalizedString(stringParams);
		}
		IPAddressStringDivisionSeries equivalentPart = toJoinedSegments(joinCount);
		return toNormalizedString(stringParams, equivalentPart);
	}
	public IPAddressDivisionGrouping toJoinedSegments(int joinCount) {
		int thisCount = getSegmentCount();
		if(joinCount <= 0 || thisCount <=1) {
			return this;
		}
		int totalCount;
		if(joinCount >= thisCount) {
			joinCount = thisCount - 1;
			totalCount = 1;
		} else {
			totalCount = thisCount - joinCount;
		}
		int notJoinedCount = totalCount - 1;
		IPAddressDivision segs[] = new IPAddressDivision[totalCount];
		int i = 0;
		for(; i < notJoinedCount; i++) {
			segs[i] = getDivision(i);
		}
		IPv4JoinedSegments joinedSegment = joinSegments(joinCount);
		segs[notJoinedCount] = joinedSegment;
		IPAddressDivisionGrouping equivalentPart = new IPAddressDivisionGrouping(segs, getNetwork());
		return equivalentPart;
	}
	private IPv4JoinedSegments joinSegments(int joinCount) {
		long lower = 0, upper = 0;
		int networkPrefixLength = 0;
		Integer prefix = null;
		int firstSegIndex = 0;
		IPv4AddressSegment firstRange = null;
		int firstJoinedIndex = getSegmentCount() - 1 - joinCount;
		for(int j = 0; j <= joinCount; j++) {
			IPv4AddressSegment thisSeg = getSegment(firstJoinedIndex + j);
			if(firstRange != null) {
				if(!thisSeg.isFullRange()) {
					throw new IncompatibleAddressException(firstRange, firstSegIndex, thisSeg, firstJoinedIndex + j, "ipaddress.error.segmentMismatch");
				}
			} else if(thisSeg.isMultiple()) {
				firstSegIndex = firstJoinedIndex + j;
				firstRange = thisSeg;
			}
			lower = lower << getBitsPerSegment() | thisSeg.getSegmentValue();
			upper = upper << getBitsPerSegment() | thisSeg.getUpperSegmentValue();
			if(prefix == null) {
				Integer thisSegPrefix = thisSeg.getSegmentPrefixLength();
				if(thisSegPrefix != null) {
					prefix = cacheBits(networkPrefixLength + thisSegPrefix);
				} else {
					networkPrefixLength += thisSeg.getBitCount();
				}
			}
		}
		IPv4JoinedSegments joinedSegment = new IPv4JoinedSegments(joinCount, lower, upper, prefix);
		return joinedSegment;
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.DATABASE_SEARCH_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4SectionStringCollection collection = new IPv4SectionStringCollection();
		IPAddressStringDivisionSeries parts[] = getParts(opts);
		for(IPAddressStringDivisionSeries part : parts) {
			IPv4StringBuilder builder = new IPv4StringBuilder(part, opts, new IPv4AddressSectionStringCollection(part));
			IPv4AddressSectionStringCollection subCollection = builder.getVariations();
			collection.add(subCollection);
		}
		return collection;
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		if(!options.includesAny(IPv4StringBuilderOptions.ALL_JOINS)) {
			return super.getParts(options);
		}
		ArrayList<IPAddressStringDivisionSeries> parts = new ArrayList<>(IPv4Address.SEGMENT_COUNT);
		if(options.includes(IPStringBuilderOptions.BASIC)) {
			parts.add(this);
		}
		boolean joined[] = new boolean[IPv4Address.SEGMENT_COUNT];
		int segmentCount = getSegmentCount();
		joined[Math.max(3, segmentCount - 1)] = options.includes(IPv4StringBuilderOptions.JOIN_ALL);
		joined[Math.max(2, Math.min(2, segmentCount - 1))] |= options.includes(IPv4StringBuilderOptions.JOIN_TWO);
		joined[Math.max(1, Math.min(1, segmentCount - 1))] |= options.includes(IPv4StringBuilderOptions.JOIN_ONE);
		for(int i = 1; i < joined.length; i++) {
			if(joined[i]) {
				parts.add(toJoinedSegments(i));
			}
		}
		return parts.toArray(new IPAddressStringDivisionSeries[parts.size()]);
	}
	static class EmbeddedIPv4AddressSection extends IPv4AddressSection {
		private static final long serialVersionUID = 4L;
		private final IPAddressSection encompassingSection;
		EmbeddedIPv4AddressSection(IPAddressSection encompassingSection, IPv4AddressSegment subSegments[]) {
			super(subSegments, false);
			this.encompassingSection = encompassingSection;
		}
		@Override
		public boolean isPrefixBlock() {
			return encompassingSection.isPrefixBlock();
		}
	}
	static class IPv4SectionStringCollection extends IPAddressPartStringCollection {
		@Override
		protected void add(IPAddressPartStringSubCollection<?, ?, ? extends IPAddressPartConfiguredString<?, ?>> collection) {
			super.add(collection);
		}
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
	}
	public static class IPv4StringBuilderOptions extends IPStringBuilderOptions {
		public static final int JOIN_ALL = 0x2;
		public static final int JOIN_TWO = 0x4;
		public static final int JOIN_ONE = 0x8;
		public static final int ALL_JOINS = JOIN_ALL | JOIN_TWO | JOIN_ONE;
		public static final int IPV6_CONVERSIONS = 0x10000;
		public static final int OCTAL = 0x100;
		public static final int HEX = 0x200;
		public final IPv6StringBuilderOptions ipv6ConverterOptions;
		public final IPv6AddressConverter converter;
		public static final IPv4StringBuilderOptions STANDARD_OPTS = new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS);
		public static final IPv4StringBuilderOptions DATABASE_SEARCH_OPTS = new IPv4StringBuilderOptions();
		public static final IPv4StringBuilderOptions ALL_OPTS = new IPv4StringBuilderOptions(
				IPStringBuilderOptions.BASIC | 
					IPv4StringBuilderOptions.JOIN_ALL | 
					IPv4StringBuilderOptions.JOIN_TWO | 
					IPv4StringBuilderOptions.JOIN_ONE |
					IPv4StringBuilderOptions.HEX |
					IPv4StringBuilderOptions.OCTAL |
					IPv4StringBuilderOptions.IPV6_CONVERSIONS |
					IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS,
				null,
				new IPv6StringBuilderOptions(
						IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.MIXED |
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL |
							IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
		public IPv4StringBuilderOptions() {
			this.ipv6ConverterOptions = null;
			this.converter = null;
		}
		public IPv4StringBuilderOptions(int options) {
			this(options, null, null);
		}
		public IPv4StringBuilderOptions(int options, IPv6AddressConverter ipv6AddressConverter, IPv6StringBuilderOptions ipv6ConverterOptions) {
			super(options | (ipv6ConverterOptions == null ? 0 : IPV6_CONVERSIONS));
			if(includes(IPV6_CONVERSIONS)) {
				if(ipv6ConverterOptions == null) {
					ipv6ConverterOptions = new IPv6StringBuilderOptions(
							IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL | 
							IPv6StringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS | 
							IPv6StringBuilderOptions.MIXED);
				}
				if(ipv6AddressConverter == null) {
					ipv6AddressConverter = IPAddress.DEFAULT_ADDRESS_CONVERTER;
				}
			}
			this.ipv6ConverterOptions = ipv6ConverterOptions;
			this.converter = ipv6AddressConverter;
		}
		public static IPv4StringBuilderOptions from(IPStringBuilderOptions opts) {
			if(opts instanceof IPv4StringBuilderOptions) {
				return (IPv4StringBuilderOptions) opts;
			}
			return new IPv4StringBuilderOptions(opts.options & ~(ALL_JOINS | IPV6_CONVERSIONS | OCTAL | HEX));
		}
	}
	public static class IPv4StringOptions extends IPStringOptions {
		protected IPv4StringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				String suffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, ' ', label, suffix, reverse, splitDigits, uppercase);
		}
		public static class Builder extends IPStringOptions.Builder {
			public Builder() {
				this(IPv4Address.DEFAULT_TEXTUAL_RADIX, IPv4Address.SEGMENT_SEPARATOR);
			}
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			@Override
			public IPv4StringOptions toOptions() {
				return new IPv4StringOptions(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	private static class IPv4StringParams extends IPAddressStringParams<IPAddressStringDivisionSeries> {
		IPv4StringParams(int radix) {
			super(radix, IPv4Address.SEGMENT_SEPARATOR, false);
		}
		@Override
		public IPv4StringParams clone() {
			return (IPv4StringParams) super.clone();
		}
	}
	static class IPv4StringCollection extends IPAddressPartStringCollection {
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
		static class IPv4AddressSectionStringCollection extends IPAddressPartStringSubCollection<IPAddressStringDivisionSeries, IPv4StringParams, IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>> {
			IPv4AddressSectionStringCollection(IPAddressStringDivisionSeries addr) {
				super(addr);
			}
			@Override
			public Iterator<IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>> iterator() {
				return new IPAddressConfigurableStringIterator() {
					@Override
					public IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams> next() {
						return new IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>(part, iterator.next()); 
					}
				};
			}
		}
		static class IPv4StringBuilder
			extends AddressPartStringBuilder<IPAddressStringDivisionSeries, IPv4StringParams, IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>, IPv4AddressSectionStringCollection, IPv4StringBuilderOptions> {
			private IPv4StringBuilder(IPAddressStringDivisionSeries address, IPv4StringBuilderOptions options, IPv4AddressSectionStringCollection collection) {
				super(address, options, collection);
			}
			public static boolean isDecimalSameAsOctal(IPAddressStringDivisionSeries part) {
				int count = part.getDivisionCount();
				for(int i = 0; i < count; i++) {
					AddressStringDivision seg = part.getDivision(i);
					if(!seg.isBoundedBy(8)) {
						return false;
					}
				}
				return true;	
			}
			@Override
			public void addAllVariations() {
				ArrayList<IPv4StringParams> allParams = new ArrayList<IPv4StringParams>();
				ArrayList<Integer> radices = new ArrayList<Integer>();
				radices.add(cacheBits(IPv4Address.DEFAULT_TEXTUAL_RADIX));
				if(options.includes(IPv4StringBuilderOptions.HEX)) {
					radices.add(cacheBits(16));
				}
				boolean hasDecimalOctalDups = false;
				if(options.includes(IPv4StringBuilderOptions.OCTAL)) {
					radices.add(cacheBits(8));
					hasDecimalOctalDups = options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS) && IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix().equals("0") && isDecimalSameAsOctal(addressSection);
				}
				for(int radix : radices) {
					ArrayList<IPv4StringParams> radixParams = new ArrayList<>();
					IPv4StringParams stringParams = new IPv4StringParams(radix);
					radixParams.add(stringParams);
					switch(radix) {
						case 8:
							stringParams.setSegmentStrPrefix(IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix());
							break;
						case 16:
							stringParams.setSegmentStrPrefix(IPv4Address.inet_aton_radix.HEX.getSegmentStrPrefix());
							break;
					}
					if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS)) {
						int expandables[] = getExpandableSegments(radix);
						int count = addressSection.getDivisionCount();
						for(int i = 0; i < count; i++) {
							int expansionLength = expandables[i];
							int len = radixParams.size();
							while(expansionLength > 0) {
								for(int j = 0; j < len; j++) {
									IPv4StringParams clone = radixParams.get(j);
									if(hasDecimalOctalDups && radix == 10) {
										boolean isDup = true;
										for(int k = 0; k < count; k++) {
											if(k != i) {
												int length = clone.getExpandedSegmentLength(k);
												if(length == 0) {
													isDup = false;
													break;
												}
											}
										}
										if(isDup) {
											continue;
										}
									}
									clone = clone.clone();
									clone.expandSegment(i, expansionLength, addressSection.getDivisionCount());
									radixParams.add(clone);
								}
								if(!options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS)) {
									break;
								}
								expansionLength--;
							}
						}
					} else if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS)) {
						boolean allExpandable = isExpandable(radix);
						if(allExpandable) {
							IPv4StringParams expandParams = new IPv4StringParams(IPv4Address.DEFAULT_TEXTUAL_RADIX);
							expandParams.expandSegments(true);
							radixParams.add(expandParams);
						}
					}
					allParams.addAll(radixParams);
				}
				for(int i=0; i<allParams.size(); i++) {
					IPv4StringParams param = allParams.get(i);
					addStringParam(param);
				}
			}
			@Override
			protected void addStringParam(IPv4StringParams stringParams) {
				super.addStringParam(stringParams);
			}
		} 
	} 
}
package inet.ipaddr.format;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.Arrays;
import java.util.Iterator;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.ToLongFunction;
import inet.ipaddr.AddressComponent;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.HostIdentifierException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.string.AddressStringDivision;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
import inet.ipaddr.format.string.IPAddressStringDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressDivisionWriter;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressSegmentParams;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
public abstract class AddressDivisionGroupingBase implements AddressDivisionSeries {
	private static final long serialVersionUID = 1L;
	protected static final Integer NO_PREFIX_LENGTH = -1;
	static final BigInteger ALL_ONES = BigInteger.ZERO.not();
	protected static BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);
	static ResourceBundle bundle;
	static {
		String propertyFileName = "IPAddressResources";
		String name = HostIdentifierException.class.getPackage().getName() + '.' + propertyFileName;
		try {
			bundle = ResourceBundle.getBundle(name);
		} catch (MissingResourceException e) {
			System.err.println("bundle " + name + " is missing");
		}
	}
	protected static class ValueCache {
		public byte[] lowerBytes, upperBytes;
		public BigInteger value, upperValue;
		public InetAddress inetAddress;
	}
	protected transient ValueCache valueCache;
	private final AddressDivisionBase divisions[];
	protected Integer cachedPrefixLength; 
	private transient Boolean isMultiple;
	private transient BigInteger cachedCount;
	private transient BigInteger cachedPrefixCount;
	protected transient int hashCode;
	public AddressDivisionGroupingBase(AddressDivisionBase divisions[]) {
		this(divisions, true);
	}
	public AddressDivisionGroupingBase(AddressDivisionBase divisions[], boolean checkDivisions) {
		this.divisions = divisions;
		if(checkDivisions) {
			for(int i = 0; i < divisions.length; i++) {
				if(divisions[i] == null) {
					throw new NullPointerException(getMessage("ipaddress.error.null.segment"));
				}
			}
		}
	}
	protected static String getMessage(String key) {
		if(bundle != null) {
			try {
				return bundle.getString(key);
			} catch (MissingResourceException e1) {}
		}
		return key;
	}
	@Override
	public AddressDivisionBase getDivision(int index) {
		return getDivisionsInternal()[index];
	}
	protected void initCachedValues(Integer cachedNetworkPrefixLength, BigInteger cachedCount) {
		this.cachedPrefixLength = cachedNetworkPrefixLength == null ? NO_PREFIX_LENGTH : cachedNetworkPrefixLength;
		this.cachedCount = cachedCount;
	}
	@Override
	public int getDivisionCount() {
		return getDivisionsInternal().length;
	}
	@Override
	public byte[] getBytes() {
		return getBytesInternal().clone();
	}
	protected byte[] getBytesInternal() {
		byte cached[];
		if(hasNoValueCache() || (cached = valueCache.lowerBytes) == null) {
			valueCache.lowerBytes = cached = getBytesImpl(true);
		}
		return cached;
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getBytesCopy(bytes, index, getBytesInternal());
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getBytes(bytes, 0);
	}
	private static byte[] getBytesCopy(byte[] bytes, int startIndex, byte[] cached) {
		int byteCount = cached.length;
		if(bytes == null || bytes.length < byteCount + startIndex) {
			if(startIndex > 0) {
				byte bytes2[] = new byte[byteCount + startIndex];
				if(bytes != null) {
					System.arraycopy(bytes, 0, bytes2, 0, Math.min(startIndex, bytes.length));
				}
				System.arraycopy(cached, 0, bytes2, startIndex, byteCount);
				return bytes2;
			}
			return cached.clone();
		}
		System.arraycopy(cached, 0, bytes, startIndex, byteCount);
		return bytes;
	}
	@Override
	public byte[] getUpperBytes() {
		return getUpperBytesInternal().clone();
	}
	protected byte[] getUpperBytesInternal() {
		byte cached[];
		if(hasNoValueCache()) {
			ValueCache cache = valueCache;
			cache.upperBytes = cached = getBytesImpl(false);
			if(!isMultiple()) {
				cache.lowerBytes = cached;
			}
		} else {
			ValueCache cache = valueCache;
			if((cached = cache.upperBytes) == null) {
				if(!isMultiple()) {
					if((cached = cache.lowerBytes) != null) {
						cache.upperBytes = cached;
					} else {
						cache.lowerBytes = cache.upperBytes = cached = getBytesImpl(false);
					}
				} else {
					cache.upperBytes = cached = getBytesImpl(false);
				}
			}
		}
		return cached;
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getBytesCopy(bytes, index, getUpperBytesInternal());
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getBytes(bytes, 0);
	}
	protected abstract byte[] getBytesImpl(boolean low);
	protected void setBytes(byte bytes[]) {
		if(valueCache == null) {
			valueCache = new ValueCache();
		}
		valueCache.lowerBytes = bytes;
	}
	protected void setUpperBytes(byte bytes[]) {
		if(valueCache == null) {
			valueCache = new ValueCache();
		}
		valueCache.upperBytes = bytes;
	}
	@Override
	public BigInteger getValue() {
		BigInteger cached;
		if(hasNoValueCache() || (cached = valueCache.value) == null) {
			valueCache.value = cached = new BigInteger(1, getBytesInternal());
		}
		return cached;
	}
	@Override
	public BigInteger getUpperValue() {
		BigInteger cached;
		if(hasNoValueCache()) {
			ValueCache cache = valueCache;
			cache.upperValue = cached = new BigInteger(1, getUpperBytesInternal());
			if(!isMultiple()) {
				cache.value = cached;
			}
		} else {
			ValueCache cache = valueCache;
			if((cached = cache.upperValue) == null) {
				if(!isMultiple()) {
					if((cached = cache.value) != null) {
						cache.upperValue = cached;
					} else {
						cache.value = cache.upperValue = cached = new BigInteger(1, getUpperBytesInternal());
					}
				} else {
					cache.upperValue = cached = new BigInteger(1, getUpperBytesInternal());
				}
			}
		}
		return cached;
	}
	protected boolean hasNoValueCache() {
		if(valueCache == null) {
			synchronized(this) {
				if(valueCache == null) {
					valueCache = new ValueCache();
					return true;
				}
			}
		}
		return false;
	}
	protected void setInetAddress(InetAddress addr) {
		if(valueCache == null) {
			valueCache = new ValueCache();
		}
		valueCache.inetAddress = addr;
	}
	@Override
	public boolean isPrefixed() {
		return getPrefixLength() != null;
	}
	@Override
	public Integer getPrefixLength() {
		return cachedPrefixLength;
	}
	protected static Integer calculatePrefix(IPAddressDivisionSeries series) {
		int count = series.getDivisionCount();
		if(count > 0) {
			if(series.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && !series.getDivision(count - 1).isPrefixed()) {
				return null;
			}
			int result = 0;
			for(int i = 0; i < count; i++) { 
				IPAddressGenericDivision div = series.getDivision(i);
				Integer prefix = div.getDivisionPrefixLength();
				if(prefix != null) {
					result += prefix;
					return ParsedAddressGrouping.cache(result);
				} else {
					result += div.getBitCount();
				}
			}
		}
		return null;
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		int count = getDivisionCount();
		int totalPrefix = getBitCount();
		for(int i = count - 1; i >= 0 ; i--) {
			AddressDivisionBase div = getDivision(i);
			int segBitCount = div.getBitCount();
			int segPrefix = div.getMinPrefixLengthForBlock();
			if(segPrefix == segBitCount) {
				break;
			} else {
				totalPrefix -= segBitCount;
				if(segPrefix != 0) {
					totalPrefix += segPrefix;
					break;
				}
			}
		}
		return totalPrefix;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		int totalPrefix;
		if(!isMultiple()) {
			totalPrefix = getBitCount();
		} else {
			int count = getDivisionCount();
			totalPrefix = 0;
			for(int i = 0; i < count; i++) {
				AddressDivisionBase div = getDivision(i);
				Integer divPrefix = div.getPrefixLengthForSingleBlock();
				if(divPrefix == null) {
					return null;
				}
				totalPrefix += divPrefix;
				if(divPrefix < div.getBitCount()) {
					for(i++; i < count; i++) {
						AddressDivisionBase laterDiv = getDivision(i);
						if(!laterDiv.isFullRange()) {
							return null;
						}
					}
				}
			}
		}
		return cacheBits(totalPrefix);
	}
	protected static Integer getPrefixLengthForSingleBlock(IPAddressDivisionSeries series) {
		int totalPrefix;
		if(!series.isMultiple()) {
			totalPrefix = series.getBitCount();
		} else {
			int count = series.getDivisionCount();
			totalPrefix = 0;
			boolean isAutoSubnets = series.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			for(int i = 0; i < count; i++) {
				IPAddressGenericDivision div = series.getDivision(i);
				Integer divPrefix = div.getPrefixLengthForSingleBlock();
				if(divPrefix == null) {
					return null;
				}
				totalPrefix += divPrefix;
				if(isAutoSubnets && div.isPrefixed()) {
					return cacheBits(totalPrefix);
				}
				if(divPrefix < div.getBitCount()) {
					for(i++; i < count; i++) {
						IPAddressGenericDivision laterDiv = series.getDivision(i);
						if(!laterDiv.isFullRange()) {
							return null;
						}
						if(isAutoSubnets && laterDiv.isPrefixed()) {
							return cacheBits(totalPrefix);
						}
					}
				}
			}
		}
		return cacheBits(totalPrefix);
	}
	protected static Integer cacheBits(int i) {
		return ParsedAddressGrouping.cache(i);
	}
	@Override
	public BigInteger getCount() {
		BigInteger cached = cachedCount;
		if(cached == null) {
			cachedCount = cached = getCountImpl();
		}
		return cached;
	}
	protected BigInteger getCountImpl() {
		return AddressDivisionSeries.super.getCount();
	}
	@Override
	public BigInteger getPrefixCount() {
		BigInteger cached = cachedPrefixCount;
		if(cached == null) {
			Integer prefixLength = getPrefixLength();
			if(prefixLength == null || prefixLength >= getBitCount()) {
				cachedPrefixCount = cached = getCount();
			} else {
				cachedPrefixCount = cached = getPrefixCountImpl();
			}
		}
		return cached;
	}
	protected BigInteger getPrefixCountImpl() {
		return AddressDivisionSeries.super.getPrefixCount();
	}
	@Override
	public boolean isMultiple() {
		Boolean result = isMultiple;
		if(result == null) {
			for(int i = getDivisionCount() - 1; i >= 0; i--) {
				AddressDivisionBase seg = getDivision(i);
				if(seg.isMultiple()) {
					return isMultiple = Boolean.TRUE;
				}
			}
			return isMultiple = Boolean.FALSE;
		}
		return result;
	}
	@Override
	public boolean isSequential() {
		return !isMultiple() || AddressDivisionSeries.super.isSequential();
	}
	protected static int adjustHashCode(int currentHash, long lowerValue, long upperValue) {
		return AddressDivisionBase.adjustHashCode(currentHash, lowerValue, upperValue);
	}
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			int count = getDivisionCount();
			for(int i = 0; i < count; i++) {
				AddressDivisionBase combo = getDivision(i);
				BigInteger lower = combo.getValue(), upper = combo.getUpperValue();
				int longBits = Long.SIZE;
				do {
					long low = lower.longValue();
					long up = upper.longValue();
					lower = lower.shiftRight(longBits);
					upper = upper.shiftRight(longBits);
					res = adjustHashCode(res, low, up);
				} while(upper.signum() != 0);
			}
			hashCode = res;
		}
		return res;
	}
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		int count = getDivisionCount();
		if(count != other.getDivisionCount()) {
			return false;
		} else for(int i = 0; i < count; i++) {
			AddressDivisionBase one = getDivision(i);
			AddressDivisionBase two = other.getDivision(i);
			if(!one.equals(two)) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionGroupingBase) {
			AddressDivisionGroupingBase other = (AddressDivisionGroupingBase) o;
			return other.isSameGrouping(this);
		}
		return false;
	}
	protected AddressDivisionBase[] getDivisionsInternal() {
		return divisions;
	}
	@Override
	public String toString() {
		return Arrays.asList(getDivisionsInternal()).toString();
	}
	@Override
	public String[] getDivisionStrings() {
		String result[] = new String[getDivisionCount()];
		Arrays.setAll(result, i -> getDivision(i).getWildcardString());
		return result;
	}
	@Override
	public boolean isZero() {
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			if(!getDivision(i).isZero()) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean includesZero() {
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			if(!getDivision(i).includesZero()) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean isMax() {
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			if(!getDivision(i).isMax()) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean includesMax() {
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			if(!getDivision(i).includesMax()) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean isFullRange() {
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			AddressDivisionBase div = getDivision(i);
			if(!div.isFullRange()) {
				return false;
			}
		}
		return true;
	}
	protected static void checkSubnet(AddressDivisionSeries series, int prefixLength) throws PrefixLenException {
		if(prefixLength < 0 || prefixLength > series.getBitCount()) {
			throw new PrefixLenException(series, prefixLength);
		}
	}
	@Override
	public boolean isSinglePrefixBlock() {
		return isPrefixed() && containsSinglePrefixBlock(getPrefixLength());
	}
	@Override
	public boolean isPrefixBlock() { 
		return isPrefixed() && containsPrefixBlock(getPrefixLength());
	}
	protected static boolean containsPrefixBlock(IPAddressDivisionSeries series, int prefixLength) {
		checkSubnet(series, prefixLength);
		boolean isAllSubnets = series.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(isAllSubnets && series.isPrefixed() && series.getNetworkPrefixLength() <= prefixLength) {
			return true;
		}
		int prevBitCount = 0;
		int divCount = series.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressGenericDivision div = series.getDivision(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength < totalBitCount) {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!div.containsPrefixBlock(divPrefixLen)) {
					return false;
				}
				if(isAllSubnets && div.isPrefixed()) {
					return true;
				}
				for(++i; i < divCount; i++) {
					div = series.getDivision(i);
					if(!div.isFullRange()) {
						return false;
					}
					if(isAllSubnets && div.isPrefixed()) {
						return true;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	protected static boolean containsSinglePrefixBlock(IPAddressDivisionSeries series, int prefixLength) {
		checkSubnet(series, prefixLength);
		boolean isAllSubnets = series.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(isAllSubnets && series.isPrefixed() && series.getNetworkPrefixLength() < prefixLength) {
			return false;
		}
		int prevBitCount = 0;
		int divCount = series.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressGenericDivision div = series.getDivision(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(div.isMultiple()) {
					return false;
				}
			} else  {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!div.containsSinglePrefixBlock(divPrefixLen)) {
					return false;
				}
				if(isAllSubnets && div.isPrefixed()) {
					return true;
				}
				for(++i; i < divCount; i++) {
					div = series.getDivision(i);
					if(!div.isFullRange()) {
						return false;
					}
					if(isAllSubnets && div.isPrefixed()) {
						return true;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@FunctionalInterface
	protected static interface IteratorProvider<S, T> {
		Iterator<T> apply(boolean isLowestRange, boolean isHighestRange, S iteratedAddressItem);
	}
	protected static class AddressItemRangeSpliterator<S extends AddressComponentRange, T>
		extends AddressItemSpliteratorBase<S, T> implements SplitterSink<S, T> {
		private S forIteration;
		private Iterator<T> iterator;
		private S split1, split2; 
		protected final IteratorProvider<S, T> iteratorProvider;
		private boolean isLowest;
		private final boolean isHighest;
		private Function<S, BigInteger> sizer; 
		private Predicate<S> downSizer;
		private final ToLongFunction<S> longSizer; 
		private long longSize;
		private BigInteger bigSize;
		final Predicate<SplitterSink<S, T>> splitter;
		protected AddressItemRangeSpliterator(
				S forIteration,
				Predicate<SplitterSink<S, T>> splitter,
				IteratorProvider<S, T> iteratorProvider,
				Function<S, BigInteger> sizer ,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer ) {
			this(forIteration, splitter, iteratorProvider, true, true, sizer, downSizer, longSizer);
			updateSizers();
		}
		protected AddressItemRangeSpliterator(
				S forIteration,
				Predicate<SplitterSink<S, T>> splitter,
				IteratorProvider<S, T> iteratorProvider,
				boolean isLowest,
				boolean isHighest,
				Function<S, BigInteger> sizer ,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer ) {
			this.forIteration = forIteration;
			this.iteratorProvider = iteratorProvider;
			this.isLowest = isLowest;
			this.isHighest = isHighest;
			this.longSizer = longSizer;
			this.sizer = sizer;
			this.downSizer = downSizer;
			this.splitter = splitter;
			updateSizers();
		}
		void updateSizers() {
			if(sizer != null) { 
				isBig = downSizer == null || !downSizer.test(forIteration);
				if(!isBig) {
					sizer = null;
					downSizer = null;
				}
			} else {
				isBig = false;
			}
			longSize = -1;
			bigSize = null;
		}
		private long originalLongSize() {
			long size = longSize;
			if(size < 0) {
				longSize = size = longSizer.applyAsLong(forIteration);
			}
			return size;
		}
		private long currentLongSize() {
			return originalLongSize() - iteratedCountL;
		}
		@Override
		public long estimateSize() {
			if(isBig) {
				if(currentBigSize().compareTo(LONG_MAX) <= 0) {
					return currentBigSize().longValue();
				}
				return Long.MAX_VALUE;
			}
			return currentLongSize();
		}
		private BigInteger originalBigSize() {
			BigInteger size = bigSize;
			if(bigSize == null) {
				bigSize = size = sizer.apply(forIteration);
			}
			return size;
		}
		private BigInteger currentBigSize() {
			return originalBigSize().subtract(iteratedCountB);
		}
		@Override
		public BigInteger getSize() {
			if(isBig) {
				return currentBigSize().subtract(BigInteger.valueOf(iteratedCountI));
			}
			return BigInteger.valueOf(currentLongSize());
		}
		@Override
		public S getAddressItem() {
			return forIteration;
		}
		@Override
		public int characteristics() {
			if(isBig) {
				return CONCURRENT | NONNULL | SORTED | ORDERED | DISTINCT;
			}
			return super.characteristics();
		}
		private Iterator<T> provideIterator() {
			if(iterator == null) {
				iterator = iteratorProvider.apply(isLowest, isHighest, forIteration);
			}
			return iterator;
		}
		@Override
		public boolean tryAdvance(Consumer<? super T> action) {
			if(inForEach) {
				return false;
			}
			if(isBig ? iteratedCountB.signum() <= 0 || iteratedCountB.compareTo(originalBigSize()) < 0 : iteratedCountL < originalLongSize()) {
				return tryAdvance(provideIterator(), action);
			}
			return false;
		}
		@Override
		public void forEachRemaining(Consumer<? super T> action) {
			if(inForEach) {
				return;
			}
			inForEach = true;
			try {
				if(isBig) {
					forEachRemaining(provideIterator(), action, originalBigSize());
				} else {
					forEachRemaining(provideIterator(), action, originalLongSize());
				}
				return;
			} finally {
				inForEach = false;
			}
		}
		protected boolean canSplit() {
			if(inForEach) {
				return false;
			}
			return isBig ? iteratedCountB.compareTo(originalBigSize().shiftRight(1)) < 0 :
					iteratedCountL < (originalLongSize() >> 1);
		}
		protected boolean split() {
			return splitter.test(this);
		}
		protected AddressItemRangeSpliterator<S, T> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new AddressItemRangeSpliterator<S, T>(split, splitter, iteratorProvider, isLowest, false, sizer, downSizer, longSizer);
		}
		@Override
		public AddressItemRangeSpliterator<S, T> trySplit() {
			if(!canSplit() || !split()) {
				return null;
			}
			boolean hasIterated = isBig ? iteratedCountB.signum() > 0 : iteratedCountL > 0;
			BigInteger splitSizeBig = null;
			long splitSize = -1;
			if(hasIterated) {
				if(isBig) {
					splitSizeBig = sizer.apply(split1);
					if(iteratedCountB.compareTo(splitSizeBig) >= 0) {
						return null;
					}
				} else {
					splitSize = longSizer.applyAsLong(split1);
					if(iteratedCountL >= splitSize) {
						return null;
					}
				}
			}
			AddressItemRangeSpliterator<S, T> splitOff = createSpliterator(split1, isLowest, sizer, downSizer, longSizer);
			if(hasIterated) {
				if(isBig) {
					if(splitOff.isBig) {
						splitOff.iteratedCountB = iteratedCountB;
					} else {
						splitOff.iteratedCountL = iteratedCountB.longValue();
					}
					iteratedCountB = BigInteger.ZERO;
				} else {
					splitOff.iteratedCountL = iteratedCountL;
					iteratedCountL = 0;
				}
				splitOff.iterator = iterator;
				iterator = null;
				splitOff.bigSize = splitSizeBig;
				splitOff.longSize = splitSize;
			}
			forIteration = split2;
			isLowest = false;
			updateSizers();
			return splitOff;
		}
		@Override
		public void setSplitValues(S left, S right) {
			split1 = left;
			split2 = right;
		}
	}
	protected static interface SplitterSink<S, T> {
		void setSplitValues(S left, S right);
		S getAddressItem();
	};
	protected static <S extends AddressComponentRange,T> AddressComponentRangeSpliterator<S, T> createItemSpliterator(
			S forIteration,
			Predicate<SplitterSink<S, T>> splitter,
			IteratorProvider<S, T> iteratorProvider,
			Function<S, BigInteger> sizer ,
			Predicate<S> downSizer,
			ToLongFunction<S> longSizer ) {
		return new AddressItemRangeSpliterator<S, T>(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
	}
	protected static <T extends AddressComponent> AddressComponentSpliterator<T> createSeriesSpliterator(
			T forIteration,
			Predicate<SplitterSink<T,T>> splitter,
			IteratorProvider<T, T> iteratorProvider,
			Function<T, BigInteger> sizer ,
			Predicate<T> downSizer,
			ToLongFunction<T> longSizer ) {
		return new AddressSeriesSpliterator<T>(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
	}
	protected static class AddressStringParams<T extends AddressStringDivisionSeries> implements AddressDivisionWriter, AddressSegmentParams, Cloneable {
		public static final Wildcards DEFAULT_WILDCARDS = new Wildcards();
		private Wildcards wildcards = DEFAULT_WILDCARDS;
		protected boolean expandSegments; 
		private String segmentStrPrefix = ""; 
		private int radix;
		protected Character separator;
		private boolean uppercase; 
		private boolean reverse;
		private boolean splitDigits;
		private String addressLabel = "";
		private char zoneSeparator;
		public AddressStringParams(int radix, Character separator, boolean uppercase) {
			this(radix, separator, uppercase, (char) 0);
		}
		public AddressStringParams(int radix, Character separator, boolean uppercase, char zoneSeparator) {
			if(radix < AddressDivisionBase.MIN_RADIX || radix > AddressDivisionBase.MAX_RADIX) {
				throw new IllegalArgumentException();
			}
			this.radix = radix;
			this.separator = separator;
			this.uppercase = uppercase;
			this.zoneSeparator  = zoneSeparator;
		}
		public void setZoneSeparator(char zoneSeparator) {
			this.zoneSeparator = zoneSeparator;
		}
		public String getAddressLabel() {
			return addressLabel;
		}
		public void setAddressLabel(String str) {
			this.addressLabel = str;
		}
		public Character getSeparator() {
			return separator;
		}
		public void setSeparator(Character separator) {
			this.separator = separator;
		}
		@Override
		public Wildcards getWildcards() {
			return wildcards;
		}
		public void setWildcards(Wildcards wc) {
			wildcards = wc;
		}
		@Override
		public boolean preferWildcards() {
			return true;
		}
		@Override
		public int getLeadingZeros(int segmentIndex) {
			if(expandSegments) {
				return -1;
			}
			return 0;
		}
		@Override
		public String getSegmentStrPrefix() {
			return segmentStrPrefix;
		}
		public void setSegmentStrPrefix(String segmentStrPrefix) {
			if(segmentStrPrefix == null) {
				throw new NullPointerException();
			}
			this.segmentStrPrefix = segmentStrPrefix;
		}
		@Override
		public int getRadix() {
			return radix;
		}
		public void setRadix(int radix) {
			this.radix = radix;
		}
		public void setUppercase(boolean uppercase) {
			this.uppercase = uppercase;
		}
		@Override
		public boolean isUppercase() {
			return uppercase;
		}
		public void setSplitDigits(boolean split) {
			this.splitDigits = split;
		}
		@Override
		public boolean isSplitDigits() {
			return splitDigits;
		}
		@Override
		public Character getSplitDigitSeparator() {
			return separator;
		}
		@Override
		public boolean isReverseSplitDigits() {
			return reverse;
		}
		public void setReverse(boolean rev) {
			this.reverse = rev;
		}
		public boolean isReverse() {
			return reverse;
		}
		public void expandSegments(boolean expand) {
			expandSegments = expand;
		}
		public StringBuilder appendLabel(StringBuilder builder) {
			String str = getAddressLabel();
			if(str != null && str.length() > 0) {
				builder.append(str);
			}
			return builder;
		}
		public int getAddressLabelLength() {
			String str = getAddressLabel();
			if(str != null) {
				return str.length();
			}
			return 0;
		}
		public int getSegmentsStringLength(T part) {
			int count = 0;
			if(part.getDivisionCount() != 0) {
				int divCount = part.getDivisionCount();
				for(int i = 0; i < divCount; i++) {
					count += appendSegment(i, null, part);
				}
				Character separator = getSeparator();
				if(separator != null) {
					count += divCount - 1;
				}
			}
			return count;
		}
		public StringBuilder appendSegments(StringBuilder builder, T part) {
			int count = part.getDivisionCount();
			if(count != 0) {
				boolean reverse = isReverse();
				int i = 0;
				Character separator = getSeparator();
				while(true) {
					int segIndex = reverse ? (count - i - 1) : i;
					appendSegment(segIndex, builder, part);
					if(++i == count) {
						break;
					}
					if(separator != null) {
						builder.append(separator);
					}
				}
			}
			return builder;
		}
		public int appendSingleDivision(AddressStringDivision seg, StringBuilder builder) {
			if(builder == null) {
				return getAddressLabelLength() + seg.getStandardString(0, this, null);
			}
			appendLabel(builder);
			seg.getStandardString(0, this, builder);
			return 0;
		}
		protected int appendSegment(int segmentIndex, StringBuilder builder, T part) {
			AddressStringDivision seg = part.getDivision(segmentIndex);
			return seg.getStandardString(segmentIndex, this, builder);
		}
		public int getZoneLength(CharSequence zone) {
			if(zone != null && zone.length() > 0) {
				return zone.length() + 1; 
			}
			return 0;
		}
		public int getStringLength(T addr, CharSequence zone) {
			int result = getStringLength(addr);
			if(zone != null) {
				result += getZoneLength(zone);
			}
			return result;
		}
		public int getStringLength(T addr) {
			return getAddressLabelLength() + getSegmentsStringLength(addr);
		}
		public StringBuilder appendZone(StringBuilder builder, CharSequence zone) {
			if(zone != null && zone.length() > 0) {
				builder.append(zoneSeparator).append(zone);
			}
			return builder;
		}
		public StringBuilder append(StringBuilder builder, T addr, CharSequence zone) {
			return appendZone(appendSegments(appendLabel(builder), addr), zone);
		}
		public StringBuilder append(StringBuilder builder, T addr) {
			return append(builder, addr, null);
		}
		@Override
		public int getDivisionStringLength(AddressStringDivision seg) {
			return appendSingleDivision(seg, null);
		}
		@Override
		public StringBuilder appendDivision(StringBuilder builder, AddressStringDivision seg) {
			appendSingleDivision(seg, builder);
			return builder;
		}
		public String toString(T addr, CharSequence zone) {	
			int length = getStringLength(addr, zone);
			StringBuilder builder = new StringBuilder(length);
			append(builder, addr, zone);
			checkLengths(length, builder);
			return builder.toString();
		}
		public String toString(T addr) {	
			return toString(addr, null);
		}
		public static void checkLengths(int length, StringBuilder builder) {
		}
		public static AddressStringParams<AddressStringDivisionSeries> toParams(StringOptions opts) {
			@SuppressWarnings("unchecked")
			AddressStringParams<AddressStringDivisionSeries> result = (AddressStringParams<AddressStringDivisionSeries>) getCachedParams(opts);
			if(result == null) {
				result = new AddressStringParams<AddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
				result.expandSegments(opts.expandSegments);
				result.setWildcards(opts.wildcards);
				result.setSegmentStrPrefix(opts.segmentStrPrefix);
				result.setAddressLabel(opts.addrLabel);
				result.setReverse(opts.reverse);
				result.setSplitDigits(opts.splitDigits);
				setCachedParams(opts, result);
			}
			return result;
		}
		@Override
		public AddressStringParams<T> clone() {
			try {
				@SuppressWarnings("unchecked")
				AddressStringParams<T> parms = (AddressStringParams<T>) super.clone();
				return parms;
			} catch(CloneNotSupportedException e) {
				 return null;
			}
		}
	}
	protected static class IPAddressStringParams<T extends IPAddressStringDivisionSeries> extends AddressStringParams<T> implements IPAddressStringWriter<T> {
		public static final WildcardOption DEFAULT_WILDCARD_OPTION = WildcardOption.NETWORK_ONLY;
		protected static final int EXTRA_SPACE = 16;
		private WildcardOption wildcardOption = DEFAULT_WILDCARD_OPTION;
		private int expandSegment[]; 
		private String addressSuffix = "";
		public IPAddressStringParams(int radix, Character separator, boolean uppercase) {
			this(radix, separator, uppercase, (char) 0);
		}
		public IPAddressStringParams(int radix, Character separator, boolean uppercase, char zoneSeparator) {
			super(radix, separator, uppercase, zoneSeparator);
		}
		public String getAddressSuffix() {
			return addressSuffix;
		}
		public void setAddressSuffix(String suffix) {
			this.addressSuffix = suffix;
		}
		@Override
		public boolean preferWildcards() {
			return wildcardOption == WildcardOption.ALL;
		}
		public void setWildcardOption(WildcardOption option) {
			wildcardOption = option;
		}
		public int getExpandedSegmentLength(int segmentIndex) {
			if(expandSegment == null || expandSegment.length <= segmentIndex) {
				return 0;
			}
			return expandSegment[segmentIndex];
		}
		public void expandSegment(int index, int expansionLength, int segmentCount) {
			if(expandSegment == null) {
				expandSegment = new int[segmentCount];
			}
			expandSegment[index] = expansionLength;
		}
		@Override
		public char getTrailingSegmentSeparator() {
			return separator;
		}
		public StringBuilder appendSuffix(StringBuilder builder) {
			String suffix = getAddressSuffix();
			if(suffix != null) {
				builder.append(suffix);
			}
			return builder;
		}
		public int getAddressSuffixLength() {
			String suffix = getAddressSuffix();
			if(suffix != null) {
				return suffix.length();
			}
			return 0;
		}
		@Override
		public int getLeadingZeros(int segmentIndex) {
			if(expandSegments) {
				return -1;
			} else if(expandSegment != null && expandSegment.length > segmentIndex) {
				return expandSegment[segmentIndex];
			}
			return 0;
		}
		@Override
		public IPAddressStringParams<T> clone() {
			IPAddressStringParams<T> parms = (IPAddressStringParams<T>) super.clone();
			if(expandSegment != null) {
				parms.expandSegment = expandSegment.clone();
			}
			return parms;
		}
		@Override
		public int getTrailingSeparatorCount(T addr) {
			int count = addr.getDivisionCount();
			if(count > 0) {
				return count - 1;
			}
			return 0;
		}
		public static int getPrefixIndicatorStringLength(IPAddressStringDivisionSeries addr) {
			if(addr.isPrefixed()) {
				int value = addr.getPrefixLength();
				if(value < 10) {
					return 2;
				} else if(value < 100) {
					return 3;
				}
				return 4;
			}
			return 0;
		}
		@Override
		public int getStringLength(T addr) {
			int count = getSegmentsStringLength(addr);
			if(!isReverse() && !preferWildcards()) {
				count += getPrefixIndicatorStringLength(addr);
			}
			return count + getAddressSuffixLength() + getAddressLabelLength();
		}
		public void appendPrefixIndicator(StringBuilder builder, IPAddressStringDivisionSeries addr) {
			if(addr.isPrefixed()) {
				builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(addr.getPrefixLength());
			}
		}
		@Override
		public StringBuilder append(StringBuilder builder, T addr, CharSequence zone) {
			appendSuffix(appendZone(appendSegments(appendLabel(builder), addr), zone));
			if(!isReverse() && !preferWildcards()) {
				appendPrefixIndicator(builder, addr);
			}
			return builder;
		}
		@Override
		protected int appendSegment(int segmentIndex, StringBuilder builder, T part) {
			IPAddressStringDivision seg = part.getDivision(segmentIndex);
			PrefixConfiguration config = part.getNetwork().getPrefixConfiguration();
			Integer prefix; 
			if(config.prefixedSubnetsAreExplicit() || preferWildcards() 
					|| (prefix = seg.getDivisionPrefixLength()) == null  || prefix >= seg.getBitCount()
					|| (config.zeroHostsAreSubnets() && !part.isPrefixBlock())
					|| isSplitDigits()) {
				return seg.getStandardString(segmentIndex, this, builder);
			}
			if(seg.isSinglePrefixBlock()) {
				return seg.getLowerStandardString(segmentIndex, this, builder);
			}
			return seg.getPrefixAdjustedRangeString(segmentIndex, this, builder);
		}
	}
	protected static class StringOptionsBase {
		AddressDivisionWriter cachedParams; 	
	}
	protected static AddressDivisionWriter getCachedParams(StringOptionsBase opts) {
		return opts.cachedParams;
	}
	protected static void setCachedParams(StringOptionsBase opts, AddressDivisionWriter cachedParams) {
		opts.cachedParams = cachedParams;
	}
	protected static AddressStringParams<IPAddressStringDivisionSeries> toIPParams(IPStringOptions opts) {
		return AddressDivisionBase.toParams(opts);
	}
}
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4AddressCache;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection;
import inet.ipaddr.ipv4.IPv4AddressTrie.IPv4TrieNode.IPv4TrieKeyData;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public class IPv4Address extends IPAddress implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = '.';
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int SEGMENT_COUNT = 4;
	public static final int BYTE_COUNT = 4;
	public static final int BIT_COUNT = 32;
	public static final int DEFAULT_TEXTUAL_RADIX = 10;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE = 0xffffffff;
	public static final String REVERSE_DNS_SUFFIX = ".in-addr.arpa";
	transient IPv4AddressCache addressCache;
	private transient IPv4TrieKeyData cachedTrieKeyData;
	public IPv4Address(IPv4AddressSegment[] segments) throws AddressValueException {
		this(segments, null);
	}
	public IPv4Address(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(segments, networkPrefixLength));
		if(getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", getSegmentCount());
		}
	}
	public IPv4Address(IPv4AddressSection section) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", section.getSegmentCount());
		}
	}
	public IPv4Address(int address) {
		this(address, null);
	}
	public IPv4Address(int address, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSectionInternal(address, networkPrefixLength));
	}
	public IPv4Address(Inet4Address inet4Address, Integer networkPrefixLength) {
		this(inet4Address, inet4Address.getAddress(), networkPrefixLength);
	}
	public IPv4Address(Inet4Address inet4Address) {
		this(inet4Address, inet4Address.getAddress(), null);
	}
	private IPv4Address(Inet4Address inet4Address, byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, 0, bytes.length, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
		getSection().setInetAddress(inet4Address);
	}
	public IPv4Address(byte[] bytes) throws AddressValueException {
		this(bytes, null);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null);
	}
	public IPv4Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null);
	}
	public IPv4Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv4Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Override
	public IPv4AddressSection getSection() {
		return (IPv4AddressSection) super.getSection();
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv4AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv6Address ipv6Addr = getConverted(options);
		if(ipv6Addr != null) {
			IPAddressStringDivisionSeries ipv6Parts[] = ipv6Addr.getParts(options.ipv6ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv6Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv6Parts,  0, parts, tmp.length, ipv6Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	@Override
	public IPv4Address toIPv4() {
		return this;
	}
	@Override
	public boolean isIPv4Convertible() {
		return true;
	}
	public IPv6Address getIPv6Address(IPv6AddressSegment segs[]) {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		return creator.createAddress(IPv6AddressSection.createSection(creator, segs, this)); 
	}
	public IPv6Address getIPv4MappedAddress() {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = zero;
		segs[5] = creator.createSegment(IPv6Address.MAX_VALUE_PER_SEGMENT);
		return getIPv6Address(segs);
	}
	@Override
	public boolean isIPv6Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv6Convertible(this);
	}
	@Override
	public IPv6Address toIPv6() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv6(this);
	}
	public IPv4Address toBroadcastAddress() {
		return toMaxHost();
	}
	public IPv4Address toNetworkAddress() {
		return toZeroHost();
	}
	void cache(IPv4Address lower, IPv4Address upper) {
		getSection().cache(this, lower, upper);
	}
	@Override
	public IPv4Address getLowerNonZeroHost() {
		return getSection().getLowestOrHighest(this, true, true);
	}
	@Override
	public IPv4Address getLower() {
		return getSection().getLowestOrHighest(this, true, false);
	}
	@Override
	public IPv4Address getUpper() {
		return getSection().getLowestOrHighest(this, false, false);
	}
	public int intValue() {
		return getSection().intValue();
	}
	public int upperIntValue() {
		return getSection().upperIntValue();
	}
	public long longValue() {
		return getSection().longValue();
	}
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	IPv4TrieKeyData getTrieKeyCache() {
		IPv4TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv4TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			keyData.uint32Val = intValue();
			if(prefLen != null) {
				int bits = prefLen;
				keyData.nextBitMask32Val = 0x80000000 >>> bits;
				keyData.mask32Val = getNetwork().getNetworkMask(bits, false).intValue();
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv4Address replace(int startIndex, int endIndex, IPv4Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv4Address replace(int startIndex, IPv4AddressSection replacement) {
		int replacementCount = Math.min(IPv4Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv4Address reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	@Override
	public IPv4Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv4Address reverseBytesPerSegment() {
		return this;
	}
	@Override
	public IPv4Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	private IPv4Address checkIdentity(IPv4AddressSection newSection) {
		IPv4AddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv4Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv4Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	public IPv4Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override
	@Deprecated
	public IPv4Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		return getSection().iterator(this, getAddressCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> spliterator() {
		return getSection().spliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> nonZeroHostIterator() {
		Predicate<IPv4AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = s -> getSection().isZeroHost(s, prefLength);
		}
		return getSection().iterator(this, getAddressCreator(), excludeFunc);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public Stream<IPv4Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4Address> sequentialBlockIterator() {
		return (Iterator<IPv4Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4Address> sequentialBlockStream() {
		return (Stream<IPv4Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public IPv4Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv4Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	public Long enumerateIPv4(IPv4Address other){
		return IPv4AddressSection.enumerateIPv4(getSection(), other.getSection());
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv4Address) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv4()) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	IPv4AddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return defaultIpv4Network();
	}
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	@Override
	protected IPv4Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv4Address converted = arg.toIPv4();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv4Address intersect(IPAddress other) throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection section = thisSection.intersect(convertArg(other).getSection());
		if(section == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result = creator.createAddress(section); 
		return result;
	}
	@Override
	public IPv4Address[] subtract(IPAddress other)  throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result[] = new IPv4Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = creator.createAddress(sections[i]); 
		}
		return result;
	}
	@Override
	public IPv4Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv4Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv4Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv4Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv4Address toMaxHost() {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv4Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv4Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv4Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv4Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address getHostMask() {
		return (IPv4Address) super.getHostMask();
	}
	@Override
	public IPv4Address getNetworkMask() {
		return (IPv4Address) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv4AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv4Address assignPrefixForSingleBlock() {
		return (IPv4Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv4Address assignMinPrefixForBlock() {
		return (IPv4Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return (IPv4Address) IPv4AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv4Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv4AddressSection.coverWithPrefixBlock(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(true);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::assignPrefixForSingleBlock,
				IPv4Address::withoutPrefixLength,
				getAddressCreator()::createAddressArray);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4Address[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(false);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::withoutPrefixLength,
				getAddressCreator());
	}
	@Override
	public IPv4AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv4Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]);
		}
		converted[0] = this;
		return converted;
	}
	@Override
	public IPv4Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator());
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getAddressCreator()::createSequentialBlockAddress;
	}
	@Override
	public Inet4Address toUpperInetAddress() {
		return (Inet4Address) super.toUpperInetAddress();
	}
	@Override
	public Inet4Address toInetAddress() {
		return (Inet4Address) super.toInetAddress();
	}
	@Override
	@Deprecated
	public IPv4AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv4AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		IPv4Address thiz = withoutPrefixLength();
		return new IPv4AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv4AddressSegment seg0 = getSegment(0);
			if(seg0.matches(239)) {
				return true;
			}
			IPv4AddressSegment seg1 = getSegment(1), seg2 = getSegment(2);
			return 
					(seg0.matches(224) && seg1.isZero() && seg2.isZero())
					|| (seg0.matches(232) && !(seg1.isZero() && seg2.isZero()));
		}
		return isLinkLocal() || isPrivate() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		if(isMulticast()) {
			return getSegment(0).matches(224) && getSegment(1).isZero() && getSegment(2).isZero() &&  getSegment(3).matches(252);
		}
		return getSegment(0).matches(169) && getSegment(1).matches(254);
	}
	public boolean isPrivate() {
		IPv4AddressSegment seg0 = getSegment(0);
		IPv4AddressSegment seg1 = getSegment(1);
		return seg0.matches(10)
			|| (seg0.matches(172) && seg1.matchesWithPrefixMask(16, 4))
			|| (seg0.matches(192) && seg1.matches(168));
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xe0, 4);
	}
	@Override
	public boolean isLoopback() {
		return getSegment(0).matches(127);
	}
	public interface IPv4AddressConverter {
		IPv4Address toIPv4(IPAddress address);
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getIPv6Network()).getParentBuilder().toParams();
	}
	public static String toNormalizedString(IPv4AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, null);
	}
	public static enum inet_aton_radix {
		OCTAL, HEX, DECIMAL;
		int getRadix() {
			if(this == OCTAL) {
				return 8;
			} else if(this == HEX) {
				return 16;
			}
			return 10;
		}
		String getSegmentStrPrefix() {
			if(this == OCTAL) {
				return "0";
			} else if(this == HEX) {
				return "0x";
			}
			return null;
		}
		@Override
		public String toString() {
			if(this == OCTAL) {
				return "octal";
			} else if(this == HEX) {
				return "hexadecimal";
			}
			return "decimal";
		}
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		return getSection().toInetAtonString(radix);
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		return getSection().toInetAtonString(radix, joinedCount);
	}
	@Override
	public String toSegmentedBinaryString() {
		return getSection().toSegmentedBinaryString();
	}
	@Override
	public String toUNCHostName() {
		return super.toCanonicalString();
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	private IPv6Address getConverted(IPv4StringBuilderOptions opts) {
		if(opts.includes(IPv4StringBuilderOptions.IPV6_CONVERSIONS)) {
			IPv6AddressConverter converter = opts.converter;
			return converter.toIPv6(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4StringCollection coll = new IPv4StringCollection();
		IPAddressPartStringCollection sectionColl = getSection().toStringCollection(opts);
		coll.addAll(sectionColl);
		IPv6Address ipv6Addr = getConverted(opts);
		if(ipv6Addr != null) {
			IPAddressPartStringCollection ipv6StringCollection = ipv6Addr.toStringCollection(opts.ipv6ConverterOptions);
			coll.addAll(ipv6StringCollection);
		}
		return coll;
	}
}
package inet.ipaddr;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSeqRange.IPAddressSeqRangeSplitterSink;
import inet.ipaddr.format.AddressComponentRange;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.util.sql.MySQLTranslator;
import inet.ipaddr.format.util.sql.SQLStringMatcher;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public abstract class IPAddressSection extends IPAddressDivisionGrouping implements IPAddressSegmentSeries, AddressSection {
	private static final long serialVersionUID = 4L;
	private static final IPAddressStringDivisionSeries EMPTY_PARTS[] = new IPAddressStringDivisionSeries[0];
	protected static class PrefixCache {
		private Integer networkMaskPrefixLen; 
		private Integer hostMaskPrefixLen; 
		private Integer cachedMinPrefix; 
		private Integer cachedEquivalentPrefix; 
		private Boolean cachedIsSinglePrefixBlock; 
	}
	private transient PrefixCache prefixCache;
	private transient BigInteger cachedNonzeroHostCount;
	protected IPAddressSection(IPAddressSegment segments[], boolean cloneSegments, boolean checkSegs) {
		super(cloneSegments ? segments.clone() : segments, false);
		if(checkSegs) {
			IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
			Integer previousSegmentPrefix = null;
			int bitsPerSegment = getBitsPerSegment();
			for(int i = 0; i < segments.length; i++) {
				IPAddressSegment segment = segments[i];
				if(!network.isCompatible(segment.getNetwork())) {
					throw new NetworkMismatchException(segment);
				}
				Integer segPrefix = segment.getSegmentPrefixLength();
				if(previousSegmentPrefix == null) {
					if(segPrefix != null) {
						cachedPrefixLength = cacheBits(getNetworkPrefixLength(bitsPerSegment, segPrefix, i));
					}
				} else if(segPrefix == null || segPrefix != 0) {
					throw new InconsistentPrefixException(segments[i - 1], segment, segPrefix);
				}
				previousSegmentPrefix = segPrefix;
			}
			if(previousSegmentPrefix == null) {
				cachedPrefixLength = NO_PREFIX_LENGTH;
			}
		}
	}
	protected void checkSegments(IPv6AddressSegment segs[]) {
		IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
		for(IPAddressSegment seg : segs) {
			if(!network.isCompatible(seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
		}
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	protected void initCachedValues(
			Integer prefixLen,
			boolean network,
			Integer cachedNetworkPrefix,
			Integer cachedMinPrefix,
			Integer cachedEquivalentPrefix,
			BigInteger cachedCount,
			RangeList zeroSegments,
			RangeList zeroRanges) {
		if(prefixCache == null) {
			prefixCache = new PrefixCache();
		}
		if(network) {
			setNetworkMaskPrefix(prefixLen);
		} else {
			setHostMaskPrefix(prefixLen);
		}
		super.initCachedValues(cachedNetworkPrefix, cachedCount);
		prefixCache.cachedMinPrefix = cachedMinPrefix;
		prefixCache.cachedIsSinglePrefixBlock = Objects.equals(cachedEquivalentPrefix, cachedNetworkPrefix);
		prefixCache.cachedEquivalentPrefix = cachedEquivalentPrefix;
	}
	@Override
	public boolean isSinglePrefixBlock() {
		if(!hasNoPrefixCache() && prefixCache.cachedIsSinglePrefixBlock != null) {
			return prefixCache.cachedIsSinglePrefixBlock;
		}
		boolean result = super.isSinglePrefixBlock();
		prefixCache.cachedIsSinglePrefixBlock = result;
		if(result) {
			prefixCache.cachedEquivalentPrefix = getNetworkPrefixLength();
		}
		return result;
	}
	protected static RangeList getNoZerosRange() {
		return IPAddressDivisionGrouping.getNoZerosRange();
	}
	protected static RangeList getSingleRange(int index, int len) {
		return IPAddressDivisionGrouping.getSingleRange(index, len);
	}
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return AddressDivisionGrouping.isCompatibleNetworks(one, two);
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() * getBitsPerSegment();
	}
	@Override
	public int getByteCount() {
		return getSegmentCount() * getBytesPerSegment();
	}
	@Override
	protected byte[] getBytesInternal() {
		return super.getBytesInternal();
	}
	public static int bitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	public static int bytesPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	protected long longCount(int segCount) {
		if(isMultiple()) {
			return longCount(this, segCount);
		}
		return 1L;
	}
	protected long longPrefixCount(int prefixLength) {
		if(isMultiple()) {
			return longPrefixCount(this, prefixLength);
		}
		return 1;
	}
	protected long longZeroHostCount(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				int bitsPerSegment = getBitsPerSegment();
				int prefixedSegment = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
				long zeroHostCount = getLongCount(i -> {
					if(i == prefixedSegment) {
						IPAddressSegment seg = getSegment(i);
						int shift = seg.getBitCount() - getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
						int count = ((seg.getUpperSegmentValue() >>> shift) - (seg.getSegmentValue() >>> shift)) + 1;
						return count;
					}
					return getSegment(i).getValueCount();
				}, prefixedSegment + 1);
				return zeroHostCount;
			} else {
				return 1L;
			}
		}
		return 0L;
	}
	protected abstract BigInteger getZeroHostCountImpl(int prefixLength, int segCount);
	@Override
	public BigInteger getNonZeroHostCount() {
		if(isPrefixed() && getNetworkPrefixLength() < getBitCount()) {
			BigInteger cached = cachedNonzeroHostCount;
			if(cached == null) {
				cachedNonzeroHostCount = cached = getCount().subtract(getZeroHostCountImpl(getNetworkPrefixLength(), getSegmentCount()));
			}
			return cached;
		}
		return getCount();
	}
	protected abstract BigInteger getCountImpl(int segCount);
	@Override
	public BigInteger getCountImpl() {
		return getCountImpl(getSegmentCount());
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		int segCount = getSegmentCount();
		if(segmentCount > segCount) {
			segmentCount = segCount;
		}
		return getCountImpl(segmentCount);
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	protected static boolean isPrefixSubnetSegs(IPAddressSegment sectionSegments[], Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, boolean fullRangeOnly) {
		int segmentCount = sectionSegments.length;
		if(segmentCount == 0) {
			return false;
		}
		IPAddressSegment seg = sectionSegments[0];
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> sectionSegments[segmentIndex].getSegmentValue(),
				segmentIndex -> sectionSegments[segmentIndex].getUpperSegmentValue(),
				segmentCount,
				seg.getByteCount(),
				seg.getBitCount(),
				seg.getMaxSegmentValue(),
				networkPrefixLength,
				network.getPrefixConfiguration(),
				fullRangeOnly);
	}
	protected boolean isNetworkSection(int networkPrefixLength, boolean withPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex + 1 < segmentCount) {
			return false; 
		}
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);
		return !getSegment(segmentCount - 1).isNetworkChangedByPrefix(cacheBits(segPrefLength), withPrefixLength);
	}
	protected boolean isHostSection(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		if(networkPrefixLength >= getBitsPerSegment()) {
			return false;
		}
		return !getSegment(0).isHostChangedByPrefix(cacheBits(networkPrefixLength));
	}
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	private Integer checkForPrefixMask(boolean network) {
		int count = getSegmentCount();
		if(count == 0) {
			return null;
		}
		int front, back;
		int maxval = getSegment(0).getMaxSegmentValue();
		if(network) {
			front = maxval;
			back = 0;
		} else {
			back = maxval;
			front = 0;
		}
		int prefixLen = 0;
		for(int i=0; i < count; i++) {
			IPAddressSegment seg = getSegment(i);
			int value = seg.getSegmentValue();
			if(value != front) {
				Integer segmentPrefixLen = seg.getBlockMaskPrefixLength(network);
				if(segmentPrefixLen == null) {
					return null;
				}
				prefixLen += segmentPrefixLen;
				for(i++; i < count; i++) {
					value = getSegment(i).getSegmentValue();
					if(value != back) {
						return null;
					}
				}
			} else {
				prefixLen += seg.getBitCount();
			}
		}
		return cacheBits(prefixLen);
	}
	public Integer getBlockMaskPrefixLength(boolean network) {
		Integer prefixLen;
		if(network) {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.networkMaskPrefixLen) == null) {
				prefixLen = setNetworkMaskPrefix(checkForPrefixMask(network));
			}
		} else {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.hostMaskPrefixLen) == null) {
				prefixLen = setHostMaskPrefix(checkForPrefixMask(network));
			}
		}
		if(prefixLen < 0) {
			return null;
		}
		return prefixLen;
	}
	private Integer setHostMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.hostMaskPrefixLen = prefixLen;
			prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH; 
		}
		return prefixLen;
	}
	private Integer setNetworkMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.networkMaskPrefixLen = prefixLen;
			prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH; 
		}
		return prefixLen;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R getNetworkSection(
					R original,
					int networkPrefixLength,
					boolean withPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSection(networkPrefixLength, withPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int networkSegmentCount = original.getNetworkSegmentCount(networkPrefixLength);
		S result[] = creator.createSegmentArray(networkSegmentCount);
		for(int i = 0; i < networkSegmentCount; i++) {
			Integer prefix = getSegmentPrefixLength(bitsPerSegment, cacheBits(networkPrefixLength), i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	protected int getNetworkSegmentCount(int networkPrefixLength) {
		return getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment()) + 1;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> 
			R getHostSection(
					R original,
					int networkPrefixLength,
					int hostSegmentCount,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isHostSection(networkPrefixLength)) {
			return original;
		}
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(hostSegmentCount);
		if(hostSegmentCount > 0) {
			int bitsPerSegment = original.getBitsPerSegment();
			for(int i = hostSegmentCount - 1, j = segmentCount - 1; i >= 0; i--, j--) {
				Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, j);
				result[i] = segProducer.apply(prefix, j);
			}
		}
		return creator.createSectionInternal(result);
	}
	protected int getHostSegmentCount(int networkPrefixLength) {
		return getSegmentCount() - getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
	}
	protected static Integer cacheBits(int i) {
		return AddressDivisionGrouping.cacheBits(i);
	}
	@FunctionalInterface
	public interface SegFunction<R, S> {
	    S apply(R addrItem, int value);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R setPrefixLength(
			R original,
			IPAddressCreator<?, R, ?, S, ?> creator,
			int networkPrefixLength,
			boolean withZeros,
			boolean noShrink,
			boolean singleOnly,
			SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		Integer existingPrefixLength = original.getNetworkPrefixLength();
		if(existingPrefixLength != null) {
			if(networkPrefixLength == existingPrefixLength.intValue()) {
				return original;
			} else if(noShrink && networkPrefixLength > existingPrefixLength.intValue()) {
				checkSubnet(original, networkPrefixLength);
				return original;
			}
		}
		checkSubnet(original, networkPrefixLength);
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		int maskBits;
		IntUnaryOperator segmentMaskProducer = null;
		if(network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(existingPrefixLength != null) {
				if(networkPrefixLength > existingPrefixLength.intValue()) {
					if(withZeros) {
						maskBits = existingPrefixLength;
					} else {
						maskBits = networkPrefixLength;
					}
				} else { 
					maskBits = networkPrefixLength;
				} 
			} else {
				maskBits = networkPrefixLength;
			}
		} else {
			if(existingPrefixLength != null) {
				if(withZeros) {
					R leftMask, rightMask;
					if(networkPrefixLength > existingPrefixLength.intValue()) {
						leftMask = network.getNetworkMaskSection(existingPrefixLength);
						rightMask = network.getHostMaskSection(networkPrefixLength);
					} else {
						leftMask = network.getNetworkMaskSection(networkPrefixLength);
						rightMask = network.getHostMaskSection(existingPrefixLength);
					}
					segmentMaskProducer = i -> {
						int val1 = segProducer.apply(leftMask, i).getSegmentValue();
						int val2 = segProducer.apply(rightMask, i).getSegmentValue();
						return val1 | val2;
					};
				}
			}
			maskBits = original.getBitCount();
		}
		if(segmentMaskProducer == null) {
			R mask = network.getNetworkMaskSection(maskBits);
			segmentMaskProducer = i -> segProducer.apply(mask, i).getSegmentValue();
		}
		return getSubnetSegments(
				original,
				cacheBits(networkPrefixLength),
				creator,
				true,
				i -> segProducer.apply(original, i),
				segmentMaskProducer,
				singleOnly);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getSubnetSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer,
			boolean singleOnly) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && !singleOnly;
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			int maskValue = segmentMaskProducer.applyAsInt(i);
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
					maskValue |= hostMask;
				}
				Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getMaskedLower(value, maskValue);
				upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
			} else {
				value &= maskValue;
				upperValue &= maskValue;
			}
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
							maskValue |= hostMask;
						}
						Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getMaskedLower(value, maskValue);
						upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
					} else {
						value &= maskValue;
						upperValue &= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength, singleOnly);
			}
		}
		return original;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getOredSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			int maskValue = segmentMaskProducer.applyAsInt(i);
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
					maskValue &= networkMask;
				}
				BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getOredLower(value, maskValue);
				upperValue = (int) masker.getOredUpper(upperValue, maskValue);
			} else {
				value |= maskValue;
				upperValue |= maskValue;
			}
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
							maskValue &= networkMask;
						}
						BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getOredLower(value, maskValue);
						upperValue = (int) masker.getOredUpper(upperValue, maskValue);
					} else {
						value |= maskValue;
						upperValue |= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength);
			}
		}
		return original;
	}
	protected static void checkSubnet(AddressDivisionSeries series, int prefixLength) throws PrefixLenException {
		AddressDivisionGrouping.checkSubnet(series, prefixLength);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, int segmentPrefixedBits) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, segmentPrefixedBits);
	}
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R createLowestOrHighestSection(
			R section,
			IPAddressCreator<?, R, ?, S, ?> creator,
			Supplier<Iterator<S[]>> nonZeroHostIteratorSupplier,
			IntFunction<S> segProducer,
			boolean lowest,
			boolean excludeZeroHost) {
		boolean create = true;
		R result = null;
		S[] segs = null;
		if(lowest && excludeZeroHost && section.includesZeroHost()) {
			Iterator<S[]> it = nonZeroHostIteratorSupplier.get();
			if(!it.hasNext()) {
				create = false;
			} else {
				segs = it.next();
			}
		} else {
			segs = createSingle(section, creator, segProducer);
		}
		if(create) {
			Integer prefLength;
			result = section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() || (prefLength = section.getNetworkPrefixLength()) == null ? 
				creator.createSectionInternal(segs) :
				creator.createPrefixedSectionInternal(segs, prefLength, true);
		}
		return result;
	}
	@Override
	public int getSegmentCount() {
		return getDivisionCount();
	}
	@Override
	public IPAddressSegment getSegment(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public IPAddressSegment getDivision(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(isAllSubnets && isPrefixed() && getNetworkPrefixLength() <= prefixLength) {
			return true;
		}
		int divCount = getDivisionCount();
		int bitsPerSegment = getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = getDivision(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(segmentPrefixLength)) {
				return false;
			}
			if(isAllSubnets && div.isPrefixed()) {
				return true;
			}
			for(++i; i < divCount; i++) {
				div = getDivision(i);
				if(!div.isFullRange()) {
					return false;
				}
				if(isAllSubnets && div.isPrefixed()) {
					return true;
				}
			}
		}
		return true;
	}
	static boolean containsPrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int divCount = lower.getDivisionCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, lower.getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), segmentPrefixLength)) {
				return false;
			}
			for(++i; i < divCount; i++) {
				div = lower.getSegment(i);
				upperDiv = upper.getSegment(i);
				if(!div.includesZero() || !upperDiv.includesMax()) {
					return false;
				}
			}
		}
		return true;
	}
	static boolean containsSinglePrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int prevBitCount = 0;
		int divCount = lower.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(!div.isSameValues(upperDiv)) {
					return false;
				}
			} else  {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!div.containsSinglePrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = lower.getSegment(i);
					upperDiv = upper.getSegment(i);
					if(!div.includesZero() || !upperDiv.includesMax()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public boolean contains(AddressSection other) {
		int count = getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		boolean prefixIsSubnet = isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		int endIndex = prefixIsSubnet ? 
				getNetworkSegmentIndex(getNetworkPrefixLength(), getBytesPerSegment(), getBitsPerSegment()) :
					count - 1;
		for(int i = endIndex; i >= 0; i--) {
			IPAddressSegment seg = getSegment(i);
			if(!seg.contains(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	public boolean containsNonZeroHosts(IPAddressSection other) {
		if(!other.isPrefixed()) {
			return contains(other);
		}
		int otherPrefixLength = other.getNetworkPrefixLength();
		if(otherPrefixLength  == other.getBitCount()) {
			return contains(other);
		}
		return containsNonZeroHostsImpl(other, otherPrefixLength);
	}
	protected abstract boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength);
	public abstract boolean prefixContains(IPAddressSection other);
	@Override
	public boolean isFullRange() {
		int divCount = getDivisionCount();
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = 0; i < divCount; i++) {
				IPAddressSegment div = getSegment(i);
				if(!div.isFullRange()) {
					return false;
				}
				Integer prefix = div.getSegmentPrefixLength();
				if(prefix != null) {
					break;
				}
			}
		} else return super.isFullRange();
		return true;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R intersect(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			IntFunction<S> otherSegProducer) {
		first.checkSegmentCount(other);
		Integer pref = first.getNetworkPrefixLength();
		Integer otherPref = other.getNetworkPrefixLength();
		if(pref != null) {
			if(otherPref != null) {
				if(otherPref > pref) {
					pref = otherPref;
				}
			} else {
				pref = null;
			}
		}
		if(other.contains(first)) {
			if(Objects.equals(pref, first.getNetworkPrefixLength())) {
				return first;
			}
		} else if(!first.isMultiple()) {
			return null;
		}
		if(first.contains(other)) {
			if(Objects.equals(pref, other.getNetworkPrefixLength())) {
				return other;
			}
		} else if(!other.isMultiple()) {
			return null;
		}
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				return null;
			}
		}
		S segs[] = addrCreator.createSegmentArray(segCount);
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			S otherSeg = otherSegProducer.apply(i);
			Integer segPref = getSegmentPrefixLength(seg.getBitCount(), pref, i);
			if(seg.contains(otherSeg)) {
				if(!otherSeg.isChangedByPrefix(segPref, false)) {
					segs[i] = otherSeg;
					continue;
				}
			}
			if(otherSeg.contains(seg)) {
				if(!seg.isChangedByPrefix(segPref, false)) {
					segs[i] = seg;
					continue;
				}
			}
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			int newLower = Math.max(lower, otherLower);
			int newHigher = Math.min(higher, otherHigher);
			segs[i] = addrCreator.createSegment(newLower, newHigher, segPref);
		}
		R result = addrCreator.createSection(segs);
		return result;
	}
	@FunctionalInterface
	public interface TriFunction<R, S> {
	    S apply(R addrItem, R addrItem2, R addrItem3);
	}
	static <R extends IPAddressSegmentSeries, OperatorResult> OperatorResult applyOperatorToLowerUpper(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			Function<R, R> prefixRemover,
			TriFunction<R, OperatorResult> operatorFunctor) {
		R lower, upper;
		boolean isFirst, isOther;
		isFirst = isOther = true;
		if(first.equals(other)) {
			if(prefixRemover != null && first.isPrefixed()) {
				if(other.isPrefixed()) {
					lower = prefixRemover.apply(first);
					isOther = isFirst = false;
				} else {
					lower = other;
					isFirst = false;
				}
			} else {
				isOther = false;
				lower = first;
			}
			upper = getUpper.apply(lower);
			lower = getLower.apply(lower);
		} else {
			R firstLower = getLower.apply(first);
			R otherLower = getLower.apply(other);
			R firstUpper = getUpper.apply(first);
			R otherUpper = getUpper.apply(other);
			if(comparator.compare(firstLower, otherLower) > 0) {
				lower = otherLower;
				isFirst = false;
			} else {
				lower = firstLower;
				isOther = false;
			}
			if(comparator.compare(firstUpper, otherUpper) < 0) {
				upper = otherUpper;
				isFirst = false;
			} else {
				upper = firstUpper;
				isOther = false;
			}
			if(prefixRemover != null) {
				lower = prefixRemover.apply(lower);
				upper = prefixRemover.apply(upper);
			}
		}
		return operatorFunctor.apply(isFirst ? first : (isOther ? other : null), lower, upper);
	}
	@SuppressWarnings("unchecked")
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return (T)
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, null, 
						IPAddressSection::coverWithPrefixBlock);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries original,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		int segCount = lower.getSegmentCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int currentSegment = 0, previousSegmentBits = 0;
		for(; currentSegment < segCount; currentSegment++) {
			IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
			IPAddressSegment upperSeg = upper.getSegment(currentSegment);
			int lowerValue = lowerSeg.getSegmentValue();
			int upperValue = upperSeg.getSegmentValue();
			int differing = lowerValue ^ upperValue;
			if(differing != 0) {
				int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
				int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
				return (original != null ? original : lower).toPrefixBlock(differingBitPrefixLen);
			}
			previousSegmentBits += bitsPerSegment;
		}
		return (original != null ? original : lower).toPrefixBlock(lower.getBitCount());
	}
	private static <R extends IPAddressSection> R[] checkSequentialBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		if(first.contains(other)) {
			return IPAddress.checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return IPAddress.checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	private static <R extends IPAddressSection> R checkPrefixBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixAdder) {
		if(first.contains(other)) {
			return IPAddress.checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return IPAddress.checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	protected static <R extends IPAddressSection> R[] getSpanningPrefixBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixAdder,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		first.checkSegmentCount(other);
		R result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			R resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, lower, upper) -> IPAddressSection.splitIntoPrefixBlocks(lower, upper));
		R resultArray[] = blocks.toArray(arrayProducer.apply(blocks.size()));
		return resultArray;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R[] getSpanningSequentialBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixRemover,
			IPAddressCreator<?, R, ?, S, ?> creator) {
		R[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createSectionArray);
		if(result != null) {
			return result;
		}
		TriFunction<R, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, creator::createSequentialBlockSection);
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createSectionArray(blocks.size()));
	}
	@FunctionalInterface
	public interface SeriesCreator {
		IPAddressSegmentSeries apply(IPAddressSegmentSeries segmentSeries, int index, int lowerVal, int upperVal);
	}
	static List<IPAddressSegmentSeries> splitIntoSequentialBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper,
			SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>(IPv6Address.SEGMENT_COUNT);
		int segCount = lower.getSegmentCount();
		if(segCount == 0) {
			blocks.add(lower);
			return blocks;
		}
		int previousSegmentBits = 0, currentSegment = 0;
		int bitsPerSegment = lower.getBitsPerSegment();
		int segSegment;
		int lowerValue, upperValue;
		SeriesStack stack = null;
		Deque<IPAddressSegmentSeries> toAdd = null;
		while(true) {
			do {
				segSegment = currentSegment;
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment++);
				lowerValue = lowerSeg.getSegmentValue();
				upperValue = upperSeg.getSegmentValue();
				previousSegmentBits += bitsPerSegment;
			} while(lowerValue == upperValue && currentSegment < segCount);
			if(lowerValue == upperValue) {
				blocks.add(lower);
			} else {	
				boolean lowerIsLowest = lower.includesZeroHost(previousSegmentBits);
				boolean higherIsHighest = upper.includesMaxHost(previousSegmentBits);
				if(lowerIsLowest) {
					if(higherIsHighest) {
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, upperValue);
						blocks.add(series);
					} else {
						IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);
						IPAddressSegmentSeries middleUpper = topLower.increment(-1);
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, middleUpper.getSegment(segSegment).getSegmentValue());
						blocks.add(series);
						lower = topLower;
						continue;
					}
				} else if(higherIsHighest) {
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);
					IPAddressSegmentSeries topLower = bottomUpper.increment(1);
					IPAddressSegmentSeries series = seriesCreator.apply(topLower, segSegment, topLower.getSegment(segSegment).getSegmentValue(), upperValue);
					if(toAdd == null) {
						toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
					}
					toAdd.addFirst(series);
					upper = bottomUpper;
					continue;
				} else {	
					IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);
					IPAddressSegmentSeries middleUpper = topLower.increment(-1);
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);
					IPAddressSegmentSeries middleLower = bottomUpper.increment(1);
					if(middleLower.compareTo(middleUpper) <= 0) {
						IPAddressSegmentSeries series = seriesCreator.apply(middleLower, segSegment, middleLower.getSegment(segSegment).getSegmentValue(), middleUpper.getSegment(segSegment).getSegmentValue());
						if(toAdd == null) {
							toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
						}
						toAdd.addFirst(series);
					}
					if(stack == null) {
						stack = new SeriesStack(IPv6Address.SEGMENT_COUNT);
					}
					stack.push(topLower, upper, previousSegmentBits, currentSegment); 
					upper = bottomUpper;
					continue;
				}
			}
			if(toAdd != null) {
				while(true) {
					IPAddressSegmentSeries saved = toAdd.pollFirst();
					if(saved == null) {
						break;
					}
					blocks.add(saved);
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	static class SeriesStack {
		int stackSize;
		int top; 
		int capacity;
		IPAddressSegmentSeries seriesPairs[]; 
		int indexPairs[]; 
		IPAddressSegmentSeries lower, upper; 
		int previousSegmentBits, currentSegment; 
		SeriesStack(int initialCapacity) {
			this.capacity = 2 * initialCapacity;
		}
		void push(IPAddressSegmentSeries lower, IPAddressSegmentSeries upper, int previousSegmentBits, int currentSegment) {
			int top = this.top;
			if(top >= stackSize) {
				resize();
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			seriesPairs[top] = lower;
			indexPairs[top++] = previousSegmentBits;
			seriesPairs[top] = upper;
			indexPairs[top++] = currentSegment;
			this.top = top;
		}
		boolean pop() {
			if(top <= 0) {
				return false;
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			int top = this.top;
			currentSegment = indexPairs[--top];
			upper = seriesPairs[top];
			previousSegmentBits = indexPairs[--top];
			lower = seriesPairs[top];
			this.top = top;
			return true;
		}
		void resize() {
			int size = stackSize;
			if(size == 0) {
				size = capacity;
			} else {
				size <<= 1; 
			}
			IPAddressSegmentSeries newSeriesPairs[] = new IPAddressSegmentSeries[size];
			int newIndexPairs[] = new int[size];
			if(top > 0) {
				System.arraycopy(seriesPairs, 0, newSeriesPairs, 0, top);
				System.arraycopy(indexPairs, 0, newIndexPairs, 0, top);
			}
			seriesPairs = newSeriesPairs;
			indexPairs = newIndexPairs;
			stackSize = size;
		}
	}
	static List<IPAddressSegmentSeries> splitIntoPrefixBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>();
		int previousSegmentBits = 0, currentSegment = 0;
		SeriesStack stack = null;
		while(true) {
			int differing = 0;
			int segCount = lower.getSegmentCount();
			int bitsPerSegment = lower.getBitsPerSegment();
			for(; currentSegment < segCount; currentSegment++) {
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment);
				int lowerValue = lowerSeg.getSegmentValue();
				int upperValue = upperSeg.getSegmentValue();
				differing = lowerValue ^ upperValue;
				if(differing != 0) {
					break;
				}
				previousSegmentBits += bitsPerSegment;
			}
			if(differing == 0) {
				blocks.add(lower.toPrefixBlock(lower.getBitCount()));
			} else {
				boolean differingIsLowestBit = (differing == 1);
				if(differingIsLowestBit && currentSegment + 1 == segCount) {
					blocks.add(lower.toPrefixBlock(lower.getBitCount() - 1));
				} else {
					int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
					int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
					if(lower.includesZeroHost(differingBitPrefixLen) && upper.includesMaxHost(differingBitPrefixLen)) {
						blocks.add(lower.toPrefixBlock(differingBitPrefixLen));
					} else {
						IPAddressSegmentSeries lowerTop = upper.toZeroHost(differingBitPrefixLen + 1);
						IPAddressSegmentSeries upperBottom = lowerTop.increment(-1);
						if(differingIsLowestBit) {
							previousSegmentBits += bitsPerSegment;
							currentSegment++;
						}
						if(stack == null) {
							stack = new SeriesStack(IPv6Address.BIT_COUNT);
						}
						stack.push(lowerTop, upper, previousSegmentBits, currentSegment); 
						upper = upperBottom; 
						continue;
					}
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	static final Comparator<? super IPAddressSegmentSeries> mergeListComparator = (one, two) ->  {
		Integer prefix1 = one.getPrefixLength();
		Integer prefix2 = two.getPrefixLength();
		int comparison = (prefix1 == prefix2) ? 0 : ((prefix1 == null) ? -1 : ((prefix2 == null) ? 1 : prefix2.compareTo(prefix1)));
		if(comparison != 0) {
			return comparison;
		}
		if(prefix1 == null || prefix1 != 0) {
			int networkSegIndex = (prefix1 == null) ? one.getSegmentCount() - 1 : getNetworkSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			int hostSegIndex = (prefix1 == null) ? one.getSegmentCount() : getHostSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			for(int i = 0; i < hostSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				int oneUpperValue = segOne.getUpperSegmentValue();
				int twoUpperValue = segTwo.getUpperSegmentValue();
				comparison = (oneUpperValue - oneValue) - (twoUpperValue - twoValue);
				if(comparison != 0) {
					return comparison;
				}
			}
			for(int i = 0; i <= networkSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				comparison = oneValue - twoValue;
				if(comparison != 0) {
					return comparison;
				}
			}
		}
		return comparison;
	};
	private static final ValueComparator REVERSE_LOW_COMPARATOR = new ValueComparator(true, false, true);
	private static final ValueComparator REVERSE_HIGH_COMPARATOR = new ValueComparator(true, true, true);
	protected static List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 1);
		boolean singleElement = organizeSequentialMerge(sections, list);
		if(singleElement) {
			list.set(0, list.get(0).withoutPrefixLength());
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		int ithRangeSegmentIndex = -1, jthRangeSegmentIndex = -1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
					jthRangeSegmentIndex = -1;
				} else {
					list.set(j, null);
					j = i;
					i--;
					jthRangeSegmentIndex = ithRangeSegmentIndex;
					ithRangeSegmentIndex = -1;
				}
				continue;
			}
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			if(ithRangeSegmentIndex < 0) {
				ithRangeSegmentIndex = item.getSequentialBlockIndex();
			}
			if(jthRangeSegmentIndex < 0) {
				jthRangeSegmentIndex = otherItem.getSequentialBlockIndex();
			}
			if(ithRangeSegmentIndex != jthRangeSegmentIndex) {
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			IPAddressSegment rangeSegment = item.getSegment(ithRangeSegmentIndex);
			IPAddressSegment otherRangeSegment = otherItem.getSegment(ithRangeSegmentIndex);
			int otherRangeItemValue = otherRangeSegment.getSegmentValue();
			int rangeItemUpperValue = rangeSegment.getUpperSegmentValue();
			if(rangeItemUpperValue < otherRangeItemValue && rangeItemUpperValue + 1 != otherRangeItemValue) {
				j = i;
				i--;
				ithRangeSegmentIndex = -1;
				continue;
			}
			for(int k = ithRangeSegmentIndex - 1; k >= 0; k--) {
				IPAddressSegment itemSegment = item.getSegment(k);
				IPAddressSegment otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					ithRangeSegmentIndex = -1;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = seriesCreator.apply(
					item,
					ithRangeSegmentIndex,
					rangeSegment.getSegmentValue(),
					Math.max(rangeItemUpperValue, otherRangeSegment.getUpperSegmentValue()));
			list.set(i, joinedItem);
			if(joinedItem.getSegment(ithRangeSegmentIndex).isFullRange()) {
				if(ithRangeSegmentIndex == 0) {
					list.clear();
					list.add(joinedItem);
					return list;
				}
				ithRangeSegmentIndex--;
			}
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
				jthRangeSegmentIndex = -1;
			} else {
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				list.set(k, list.get(l).withoutPrefixLength());
			}
			int last = list.size();
			while(removedCount-- > 0) {
				list.remove(--last);
			}
		} else for(int n = 0; n < list.size(); n++) {
			list.set(n, list.get(n).withoutPrefixLength());
		}
		return list;
	}
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 3);
		boolean singleElement = organizeSequentially(sections, list);
		if(singleElement) {
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		IPAddressSegmentSeries first = sections[0];
		int bitCount = first.getBitCount();
		int bitsPerSegment = first.getBitsPerSegment();
		int bytesPerSegment = first.getBytesPerSegment();
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
				} else {
					list.set(j, null);
					j = i;
					i--;
				}
				continue;
			}
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				continue;
			}
			Integer prefixLen = item.getPrefixLength();
			Integer otherPrefixLen = otherItem.getPrefixLength();
			if(!Objects.equals(prefixLen, otherPrefixLen)) {
				j = i;
				i--;
				continue;
			}
			int matchBitIndex = (prefixLen == null) ? bitCount - 1 : prefixLen - 1;
			int lastMatchSegmentIndex, lastBitSegmentIndex;
			if(matchBitIndex == 0) {
				lastMatchSegmentIndex = lastBitSegmentIndex = 0;
			} else {
				lastMatchSegmentIndex = getNetworkSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
				lastBitSegmentIndex = getHostSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
			}
			IPAddressSegment itemSegment = item.getSegment(lastMatchSegmentIndex);
			IPAddressSegment otherItemSegment = otherItem.getSegment(lastMatchSegmentIndex);
			int itemSegmentValue = itemSegment.getSegmentValue();
			int otherItemSegmentValue = otherItemSegment.getSegmentValue();
			int segmentLastBitIndex = bitsPerSegment - 1;
			if(lastBitSegmentIndex == lastMatchSegmentIndex) {
				int segmentBitToCheck = matchBitIndex % bitsPerSegment;
				int shift = segmentLastBitIndex - segmentBitToCheck;
				itemSegmentValue >>>= shift;
				otherItemSegmentValue >>>= shift;
			} else {
				int itemBitValue = item.getSegment(lastBitSegmentIndex).getSegmentValue();
				int otherItemBitalue = otherItem.getSegment(lastBitSegmentIndex).getSegmentValue();
				itemSegmentValue = (itemSegmentValue << 1) | (itemBitValue >>> segmentLastBitIndex);
				otherItemSegmentValue = (otherItemSegmentValue << 1) | (otherItemBitalue >>> segmentLastBitIndex);
			}
			if(itemSegmentValue != otherItemSegmentValue) {
				itemSegmentValue ^= 1;
				if(itemSegmentValue != otherItemSegmentValue) {
					j = i;
					i--;
					continue;
				} 
			}
			for(int k = lastMatchSegmentIndex - 1; k >= 0; k--) {
				itemSegment = item.getSegment(k);
				otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = otherItem.toPrefixBlock(matchBitIndex);
			list.set(i, joinedItem);
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
			} else {
				list.set(j, null);
				j = i;
				i--;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				if(k != l) {
					list.set(k, list.get(l));
				}
			}
			int last = list.size();
			while(removedCount-- > 0) { 
				list.remove(--last);
			}
		}
		return list;
	}
	private static boolean organizeSequentially(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		List<IPAddressSegmentSeries> sequentialList = null;
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(!section.isSequential()) {
				if(sequentialList == null) {
					sequentialList = new ArrayList<>(sections.length);
					for(int j = 0; j < i; j++) {
						IPAddressSegmentSeries series = sections[j];
						if(series != null) {
							sequentialList.add(series);
						}
					}
				}
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					sequentialList.add(iterator.next());
				}
			} else if(sequentialList != null) {
				sequentialList.add(section);
			}
		}
		if(sequentialList == null) {
			for(int i = 0; i < sections.length; i++) {
				IPAddressSegmentSeries series = sections[i];
				if(series != null) {
					if(series.isSinglePrefixBlock()) {
						list.add(series);
					} else {
						IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
						for(int k = 0; k < span.length; k++) {
							list.add(span[k]);
						}
					}
				}
			}
		} else for(int j = 0; j < sequentialList.size(); j++) {
			IPAddressSegmentSeries series = sequentialList.get(j);
			if(series.isSinglePrefixBlock()) {
				list.add(series);
			} else {
				IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
				for(int k = 0; k < span.length; k++) {
					list.add(span[k]);
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	private static boolean organizeSequentialMerge(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.isSequential()) {
				list.add(section);
			} else {
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					list.add(iterator.next());
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return IPAddress.spanWithBlocks(this, prefixBlocks);
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R[] subtract(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			SegFunction<R, R> prefixApplier) {
		first.checkSegmentCount(other);
		if(!first.isMultiple()) {
			if(other.contains(first)) {
				return null;
			}
			R result[] = addrCreator.createSectionArray(1);
			result[0] = first;
			return result;
		}
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				R result[] = addrCreator.createSectionArray(1);
				result[0] = first;
				return result;
			}
		}
		S intersections[] = addrCreator.createSegmentArray(segCount);
		ArrayList<R> sections = new ArrayList<R>();
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(lower >= otherLower) {
				if(higher <= otherHigher) {
					if(seg.isPrefixed()) {
						intersections[i] = addrCreator.createSegment(lower, higher, null);
					} else {
						intersections[i] = seg;
					}
					continue;
				}
				intersections[i] = addrCreator.createSegment(lower, otherHigher, null);
				R section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
				sections.add(section);
			} else {
				R section = createDiffSection(first, lower, otherLower - 1, i, addrCreator, segProducer, intersections);
				sections.add(section);
				if(higher <= otherHigher) {
					intersections[i] = addrCreator.createSegment(otherLower, higher, null);
				} else {
					intersections[i] = addrCreator.createSegment(otherLower, otherHigher, null);
					section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
					sections.add(section);
				}
			}
		}
		if(sections.size() == 0) {
			return null;
		}
		if(first.isPrefixed()) {
			int thisPrefix = first.getNetworkPrefixLength();
			for(int i = 0; i < sections.size(); i++) {
				R section = sections.get(i);
				int bitCount = section.getBitCount();
				int totalPrefix = bitCount;
				for(int j = first.getSegmentCount() - 1; j >= 0 ; j--) {
					IPAddressSegment seg = section.getSegment(j);
					int segBitCount = seg.getBitCount();
					int segPrefix = seg.getMinPrefixLengthForBlock();
					if(segPrefix == segBitCount) {
						break;
					} else {
						totalPrefix -= segBitCount;
						if(segPrefix != 0) {
							totalPrefix += segPrefix;
							break;
						}
					}
				}
				if(totalPrefix != bitCount) {
					if(totalPrefix < thisPrefix) {
						totalPrefix = thisPrefix;
					}
					section = prefixApplier.apply(section, totalPrefix);
					sections.set(i, section);
				}
			}
		}
		R result[] = addrCreator.createSectionArray(sections.size());
		sections.toArray(result);
		return result;
	}
	private static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createDiffSection(
			R original,
			int lower,
			int upper,
			int diffIndex,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			S intersectingValues[]) {
		int segCount = original.getSegmentCount();
		S segments[] = addrCreator.createSegmentArray(segCount);
		for(int j = 0; j < diffIndex; j++) {
			segments[j] = intersectingValues[j];
		}
		S diff = addrCreator.createSegment(lower, upper, null);
		segments[diffIndex] = diff;
		for(int j = diffIndex + 1; j < segCount; j++) {
			segments[j] = segProducer.apply(j);
		}
		R section = addrCreator.createSectionInternal(segments);
		return section;
	}
	@Override
	public abstract IPAddressSection toZeroHost();
	@Override
	public abstract IPAddressSection toZeroHost(int prefixLength);
	@Override
	public abstract IPAddressSection toZeroNetwork();
	@Override
	public abstract IPAddressSection toMaxHost();
	@Override
	public abstract IPAddressSection toMaxHost(int prefixLength);
	@Deprecated
	@Override
	public abstract IPAddressSection applyPrefixLength(int networkPrefixLength) throws PrefixLenException;
	protected void checkMaskSegmentCount(IPAddressSection mask) throws SizeMismatchException {
		if(mask.getSegmentCount() < getSegmentCount()) {
			throw new SizeMismatchException(this, mask);
		}
	}
	@Override
	public abstract IPAddressSection coverWithPrefixBlock();
	@Override
	public abstract IPAddressSection toPrefixBlock();
	@Override
	public abstract IPAddressSection toPrefixBlock(int networkPrefixLength);
	@Override
	public IPAddressSection getHostMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLen == null ? 0 : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	@Override
	public IPAddressSection getNetworkMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLen == null ? getBitCount() : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	@Override
	public IPAddressSection assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		if(newPrefix == null) {
			return null;
		}
		IPAddressSection result = setPrefixLength(newPrefix, false);
		if(result != this) { 
			result.hasNoPrefixCache();
			PrefixCache cache = result.prefixCache;
			cache.cachedIsSinglePrefixBlock = true;
			cache.cachedEquivalentPrefix = newPrefix;
			cache.cachedMinPrefix = newPrefix;
		}
		return result;
	}
	@Override
	public IPAddressSection assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	@Override
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesZeroHost(networkPrefixLength);
	}
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	public boolean includesMaxHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesMaxHost(networkPrefixLength);
	}
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getUpperSegmentValue()) != mask) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesMax()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	public boolean isSingleNetwork() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return !isMultiple();
		}
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
		if(prefixedSegmentIndex < 0) {
			return true;
		}
		for(int i = 0; i < prefixedSegmentIndex; i++) {
			IPAddressSegment div = getSegment(i);
			if(div.isMultiple()) {
				return false;
			}
		}
		IPAddressSegment div = getSegment(prefixedSegmentIndex);
		int differing = div.getSegmentValue() ^ div.getUpperSegmentValue();
		if(differing == 0) {
			return true;
		}
		int bitsPerSegment = div.getBitCount();
		int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
		return getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex) <= highestDifferingBitInRange;
	}
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		checkMaskSegmentCount(mask);
		checkSegmentCount(other);
		int divCount = getSegmentCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			IPAddressSegment maskSegment = mask.getSegment(i);
			IPAddressSegment otherSegment = other.getSegment(i);
			if(!div.matchesWithMask(
					otherSegment.getSegmentValue(), 
					otherSegment.getUpperSegmentValue(), 
					maskSegment.getSegmentValue())) {
				return false;
			}
		}
		return true;
	}
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength(boolean zeroed);
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength();
	@Override
	public abstract IPAddressSection withoutPrefixLength();
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R toPrefixBlock(
					R original,
					int networkPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSubnet(networkPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	protected boolean isNetworkSubnet(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex >= segmentCount) {
			if(networkPrefixLength == getBitCount()) {
				IPAddressSegment last = getSegment(segmentCount - 1);
				return !last.isNetworkChangedByPrefixNonNull(last.getBitCount());
			}
			return true;
		}
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);
		if(getSegment(prefixedSegmentIndex).isNetworkChangedByPrefixNonNull(segPrefLength)) {
			return false;
		}
		if(!getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = prefixedSegmentIndex + 1; i < segmentCount; i++) {
				if(!getSegment(i).isFullRange()) {
					return false;
				}
			}
		}
		return true;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R removePrefixLength(
			R original, boolean zeroed, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(!original.isPrefixed()) {
			return original;
		}
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		R mask = network.getNetworkMaskSection(zeroed ? original.getPrefixLength() : original.getBitCount());
		return getSubnetSegments(
				original,
				null,
				creator,
				zeroed,
				i -> segProducer.apply(original, i),
				i -> segProducer.apply(mask, i).getSegmentValue(),
				false);
	}
	@Override
	public IPAddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		int prefix = getAdjustedPrefix(nextSegment, getBitsPerSegment(), false);
		Integer existing = getNetworkPrefixLength();
		if(existing == null) {
			if(nextSegment ? prefix == getBitCount() : prefix == 0) {
				return this;
			}
		} else if(existing != null && existing == prefix && prefix != 0) {
			return removePrefixLength(zeroed);
		}
		return setPrefixLength(prefix, zeroed);
	}
	@Override
	public abstract IPAddressSection adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment, boolean zeroed);
	protected static <R extends IPAddressSection, S extends IPAddressSegment> IPAddressSection adjustPrefixLength(
			R original, int adjustment, boolean withZeros, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(adjustment == 0 && original.isPrefixed()) {
			return original;
		}
		int prefix = original.getAdjustedPrefix(adjustment, false, false);
		if(prefix > original.getBitCount()) {
			if(!original.isPrefixed()) {
				return original;
			}
			IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
			R mask = network.getNetworkMaskSection(withZeros ? original.getPrefixLength() : original.getBitCount());
			return getSubnetSegments(
					original,
					null,
					creator,
					withZeros,
					i -> segProducer.apply(original, i),
					i -> segProducer.apply(mask, i).getSegmentValue(),
					false);
		}
		if(prefix < 0) {
			prefix = 0;
		}
		return original.setPrefixLength(prefix, withZeros);
	}
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed);
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	private boolean hasNoPrefixCache() {
		if(prefixCache == null) {
			synchronized(this) {
				if(prefixCache == null) {
					prefixCache = new PrefixCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		Integer result;
		if(hasNoPrefixCache() || (result = prefixCache.cachedMinPrefix) == null) {
			prefixCache.cachedMinPrefix = result = cacheBits(super.getMinPrefixLengthForBlock());
		}
		return result;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		if(!hasNoPrefixCache()) {
			Integer result = prefixCache.cachedEquivalentPrefix;
			if(result != null) {
				if(result < 0) {
					return null;
				}
				return result;
			}
		}
		Integer res = super.getPrefixLengthForSingleBlock();
		if(res == null) {
			prefixCache.cachedEquivalentPrefix = NO_PREFIX_LENGTH;
			prefixCache.cachedIsSinglePrefixBlock = false;
			return null;
		}
		if(isPrefixed() && res.equals(getNetworkPrefixLength())) {
			prefixCache.cachedIsSinglePrefixBlock = true;
		}
		prefixCache.cachedEquivalentPrefix = res;
		return res;
	}
	@Override
	public abstract IPAddressSection getLowerNonZeroHost();
	@Override
	public abstract IPAddressSection getLower();
	@Override
	public abstract IPAddressSection getUpper();
	@Override
	public abstract IPAddressSection reverseSegments();
	@Override
	public abstract IPAddressSection reverseBits(boolean perByte);
	@Override
	public abstract IPAddressSection reverseBytes();
	@Override
	public abstract IPAddressSection reverseBytesPerSegment();
	protected IPAddressSegment[] getSegmentsInternal() {
		return (IPAddressSegment[]) getDivisionsInternal();
	}
	@Override
	public abstract IPAddressSection getSection(int index);
	@Override
	public abstract IPAddressSection getSection(int index, int endIndex);
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSegments(0, getDivisionCount(), segs, 0);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int destIndex) {
		System.arraycopy(getDivisionsInternal(), start, segs, destIndex, end - start);
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createEmbeddedSection(
			IPAddressCreator<T, R, ?, S, ?> creator, S segs[], IPAddressSection encompassingSection) {
		return creator.createEmbeddedSectionInternal(encompassingSection, segs);
	}
	@Override
	public abstract Iterable<? extends IPAddressSection> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSection> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddressSection> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> stream();
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixStream();
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixBlockStream();
	@Override
	public abstract Iterator<? extends IPAddressSection> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddressSection> blockStream(int segmentCount);
	@Override
	public Iterator<? extends IPAddressSection> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddressSection> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddressSection> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
	@Override
	public BigInteger getSequentialBlockCount() {
		int sequentialSegCount = getSequentialBlockIndex();
		return getPrefixCount(sequentialSegCount * getBitsPerSegment());
	}
	static <S extends AddressSegment> Iterator<S[]> iterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<Iterator<S>> segIteratorProducer,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> prefixedSegIteratorProducer) {
		return segmentsIterator(
				divCount, segmentCreator, null, segIteratorProducer, null,
				networkSegmentIndex,
				hostSegmentIndex,
				prefixedSegIteratorProducer);
	}
	static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator) {
		return iterator(original != null, original, creator, iterator, null);
	}
	@FunctionalInterface
	static interface SeqRangeIteratorProvider<S, T> extends IteratorProvider<S,T>{}
	static class IPAddressSeqRangeSpliterator<S extends AddressComponentRange, T> extends AddressItemRangeSpliterator<S, T> implements IPAddressSeqRangeSplitterSink<S, T> {
		final Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter;
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, null, null, longSizer);
			this.splitter = splitter;
		}
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, isLowest, false, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		@Override
		protected boolean split() {
			return splitter.test(this);
		}
		@Override
		protected IPAddressSeqRangeSpliterator<S, T> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangeSpliterator<S, T>(split, splitter, (SeqRangeIteratorProvider<S, T>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
	}
	static class IPAddressSeqRangePrefixSpliterator<S extends AddressComponentRange> 
		extends IPAddressSeqRangeSpliterator<S, S> implements AddressComponentSpliterator<S> {
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, longSizer);
		}
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
		}
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		@Override
		protected IPAddressSeqRangePrefixSpliterator<S> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangePrefixSpliterator<S>(split, splitter, (SeqRangeIteratorProvider<S, S>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		@Override
		public IPAddressSeqRangePrefixSpliterator<S> trySplit() {
			return (IPAddressSeqRangePrefixSpliterator<S>) super.trySplit();
		}
	}
	@Override
	public abstract IPAddressSection increment(long increment);
	@Override
	public abstract IPAddressSection incrementBoundary(long increment);
	public boolean isEntireAddress() {
		return getSegmentCount() == IPAddress.getSegmentCount(getIPVersion());
	}
	protected boolean isMultiple(int segmentCount) {
		for(int i = 0; i < segmentCount; i++) {
			if(getSegment(i).isMultiple()) {
				return true;
			}
		}
		return false;
	}
	public boolean isZeroHost() {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength());
	}
	public boolean isZeroHost(int prefixLength) {
		if(prefixLength < 0 || prefixLength > getBitCount()) {
			throw new PrefixLenException(this, prefixLength);
		}
		return isZeroHost(prefixLength, getSegments(), getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[]) {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength(), segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[], int prefixLength) {
		return isZeroHost(prefixLength, segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected static <S extends IPAddressSegment> boolean isZeroHost(int prefLen, S segments[], int bytesPerSegment, int bitsPerSegment, int bitCount) {
		if(segments.length == 0 ) {
			return false;
		}
		if(prefLen >= bitCount) {
			return false;
		}
		int divCount = segments.length;
		int prefixedSegmentIndex = getHostSegmentIndex(prefLen, bytesPerSegment, bitsPerSegment);
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefLen, prefixedSegmentIndex);
			S div = segments[i];
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if(div.isMultiple() || (mask & div.getSegmentValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = segments[i];
					if(!div.isZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	InetAddress toInetAddress(IPAddress address) {
		InetAddress result;
		if(hasNoValueCache() || (result = valueCache.inetAddress) == null) {
			valueCache.inetAddress = result = address.toInetAddressImpl();
		}
		return result;
	}
	static void checkLengths(int length, StringBuilder builder) {
		IPAddressStringParams.checkLengths(length, builder);
	}
	@Override
	public String toString() {
		return toNormalizedString();
	}
	@Override
	public String[] getSegmentStrings() {
		return getDivisionStrings();
	}
	protected abstract void cacheNormalizedString(String str);
	protected abstract IPStringCache getStringCache();
	protected abstract boolean hasNoStringCache();
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = getStringCache().binaryString) == null) {
			IPStringCache stringCache = getStringCache();
			stringCache.binaryString = result = toBinaryString(null);
		}
		return result;
	}
	protected String toBinaryString(CharSequence zone) {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(IPStringCache.binaryParams), getLower(), getUpper(), zone);
		}
		return toIPParams(IPStringCache.binaryParams).toString(this, zone);
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? getStringCache().octalStringPrefixed : getStringCache().octalString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toOctalString(with0Prefix, null);
			if(with0Prefix) {
				stringCache.octalStringPrefixed = result;
			} else {
				stringCache.octalString = result;
			}
		}
		return result;
	}
	protected String toOctalString(boolean with0Prefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressSection lower = getLower();
			IPAddressSection upper = getUpper();
			IPAddressBitsDivision lowerDivs[] = lower.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries lowerPart = new IPAddressDivisionGrouping(lowerDivs, getNetwork());
			IPAddressBitsDivision upperDivs[] = upper.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries upperPart = new IPAddressDivisionGrouping(upperDivs, getNetwork());
			return toNormalizedStringRange(toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams), lowerPart, upperPart, zone);
		}
		IPAddressBitsDivision divs[] = createNewPrefixedDivisions(3, null, null, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
		IPAddressStringDivisionSeries part = new IPAddressDivisionGrouping(divs, getNetwork());
		return toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams).toString(part, zone);
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? getStringCache().hexStringPrefixed : getStringCache().hexString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toHexString(with0xPrefix, null);
			if(with0xPrefix) {
				stringCache.hexStringPrefixed = result;
			} else {
				stringCache.hexString = result;
			}
		}
		return result;
	}
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams), getLower(), getUpper(), zone);
		}
		return toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams).toString(this, zone);
	}
	@Override
	public String toNormalizedString(IPStringOptions stringOptions) {
		return toNormalizedString(stringOptions, this);
	}
	public static String toNormalizedString(IPStringOptions opts, IPAddressStringDivisionSeries section) {
		return toIPParams(opts).toString(section);
	}
	protected static IPAddressStringParams<IPAddressStringDivisionSeries> toIPParams(IPStringOptions opts) {
		@SuppressWarnings("unchecked")
		IPAddressStringParams<IPAddressStringDivisionSeries> result = (IPAddressStringParams<IPAddressStringDivisionSeries>) getCachedParams(opts);
		if(result == null) {
			result = new IPAddressStringParams<IPAddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
			result.expandSegments(opts.expandSegments);
			result.setWildcards(opts.wildcards);
			result.setWildcardOption(opts.wildcardOption);
			result.setSegmentStrPrefix(opts.segmentStrPrefix);
			result.setAddressSuffix(opts.addrSuffix);
			result.setAddressLabel(opts.addrLabel);
			result.setReverse(opts.reverse);
			result.setSplitDigits(opts.splitDigits);
			result.setZoneSeparator(opts.zoneSeparator);
			setCachedParams(opts, result);
		}
		return result;
	}
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS));
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
	}
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(new IPStringBuilderOptions());
	}
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		if(options.includes(IPStringBuilderOptions.BASIC)) {
			return new IPAddressStringDivisionSeries[] { this };
		}
		return EMPTY_PARTS;
	}
	public void getStartsWithSQLClause(StringBuilder builder, String expression) {
		getStartsWithSQLClause(builder, expression, new MySQLTranslator());
	}
	public void getStartsWithSQLClause(StringBuilder builder, String expression, IPAddressSQLTranslator translator) {
		getStartsWithSQLClause(builder, expression, true, translator);
	}
	private void getStartsWithSQLClause(StringBuilder builder, String expression, boolean isFirstCall, IPAddressSQLTranslator translator) {
		if(isFirstCall && isMultiple()) {
			Iterator<? extends IPAddressSection> sectionIterator = iterator();
			builder.append('(');
			boolean isNotFirst = false;
			while(sectionIterator.hasNext()) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				IPAddressSection next = sectionIterator.next();
				next.getStartsWithSQLClause(builder, expression, false, translator);
			}
			builder.append(')');
		} else if(getSegmentCount() > 0) { 
			IPAddressPartStringCollection createdStringCollection = toDatabaseSearchStringCollection();
			boolean isNotFirst = false;
			if(createdStringCollection.size() > 1) {
				builder.append('(');
			}
			boolean isEntireAddress = isEntireAddress();
			for(IPAddressPartConfiguredString<?, ?> createdStr: createdStringCollection) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				SQLStringMatcher<?, ?, ?> matcher = createdStr.getNetworkStringMatcher(isEntireAddress, translator);
				matcher.getSQLCondition(builder.append('('), expression).append(')');
			}
			if(createdStringCollection.size() > 1) {
				builder.append(')');
			}
		}
	}
	protected static class IPStringCache extends StringCache {
		public static final IPStringOptions hexParams;
		public static final IPStringOptions hexPrefixedParams;
		public static final IPStringOptions octalParams;
		public static final IPStringOptions octalPrefixedParams;
		public static final IPStringOptions binaryParams;
		public static final IPStringOptions canonicalSegmentParams;
		static {
			WildcardOptions allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL);
			hexParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			hexPrefixedParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.HEX_PREFIX).toOptions();
			octalParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			octalPrefixedParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.OCTAL_PREFIX).toOptions();
			binaryParams = new IPStringOptions.Builder(2).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			canonicalSegmentParams = new IPStringOptions.Builder(10, ' ').toOptions();
		}
		public String normalizedWildcardString;
		public String fullString;
		public String sqlWildcardString;
		public String reverseDNSString;
		public String octalStringPrefixed;
		public String octalString;
		public String binaryString;
		public String segmentedBinaryString;
	}
	public static class WildcardOptions {
		public enum WildcardOption {
			NETWORK_ONLY, 
			ALL 
		}
		public final WildcardOption wildcardOption;
		public final Wildcards wildcards;
		public WildcardOptions() {
			this(WildcardOption.NETWORK_ONLY);
		}
		public WildcardOptions(WildcardOption wildcardOption) {
			this(wildcardOption, new Wildcards());
		}
		public WildcardOptions(WildcardOption wildcardOption, Wildcards wildcards) {
			this.wildcardOption = wildcardOption;
			this.wildcards = wildcards;
		}
	}
	public static class IPStringOptions extends StringOptions {
		public final String addrSuffix;
		public final WildcardOption wildcardOption;
		public final char zoneSeparator;
		protected IPStringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				char zoneSeparator,
				String label,
				String suffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcards, segmentStrPrefix, separator, label, reverse, splitDigits, uppercase);
			this.addrSuffix = suffix;
			this.wildcardOption = wildcardOption;
			this.zoneSeparator = zoneSeparator;
		}
		public static class Builder extends StringOptions.Builder {
			protected String addrSuffix = "";
			protected WildcardOption wildcardOption = WildcardOption.NETWORK_ONLY;
			protected char zoneSeparator = IPv6Address.ZONE_SEPARATOR;
			public Builder(int base) {
				this(base, ' ');
			}
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			@Override
			public Builder setWildcards(Wildcards wildcards) {
				return (Builder) super.setWildcards(wildcards);
			}
			public Builder setAddressSuffix(String suffix) {
				this.addrSuffix = suffix;
				return this;
			}
			public Builder setWildcardOptions(WildcardOptions wildcardOptions) {
				setWildcardOption(wildcardOptions.wildcardOption);
				return setWildcards(wildcardOptions.wildcards);
			}
			public Builder setWildcardOption(WildcardOption wildcardOption) {
				this.wildcardOption = wildcardOption;
				return this;
			}
			@Override
			public Builder setReverse(boolean reverse) {
				return (Builder) super.setReverse(reverse);
			}
			@Override
			public Builder setUppercase(boolean uppercase) {
				return (Builder) super.setUppercase(uppercase);
			}
			@Override
			public Builder setSplitDigits(boolean splitDigits) {
				return (Builder) super.setSplitDigits(splitDigits);
			}
			@Override
			public Builder setExpandedSegments(boolean expandSegments) {
				return (Builder) super.setExpandedSegments(expandSegments);
			}
			@Override
			public Builder setRadix(int base) {
				return (Builder) super.setRadix(base);
			}
			@Override
			public Builder setSeparator(Character separator) {
				return (Builder) super.setSeparator(separator);
			}
			public Builder setZoneSeparator(char separator) {
				this.zoneSeparator = separator;
				return this;
			}
			@Override
			public Builder setAddressLabel(String label) {
				return (Builder) super.setAddressLabel(label);
			}
			@Override
			public Builder setSegmentStrPrefix(String prefix) {
				return (Builder) super.setSegmentStrPrefix(prefix);
			}
			@Override
			public IPStringOptions toOptions() {
				return new IPStringOptions(base,
						expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, zoneSeparator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	public static class IPStringBuilderOptions {
		public static final int BASIC = 0x1;
		public static final int LEADING_ZEROS_FULL_ALL_SEGMENTS = 0x10; 
		public static final int LEADING_ZEROS_FULL_SOME_SEGMENTS = 0x20 | LEADING_ZEROS_FULL_ALL_SEGMENTS; 
		public static final int LEADING_ZEROS_PARTIAL_SOME_SEGMENTS = 0x40 | LEADING_ZEROS_FULL_SOME_SEGMENTS; 
		public final int options;
		public IPStringBuilderOptions() {
			this(BASIC);
		}
		public IPStringBuilderOptions(int options) {
			this.options = options;
		}
		public boolean includes(int option) {
			return (option & options) == option;
		}
		public boolean includesAny(int option) {
			return (option & options) != 0;
		}
		@Override
		public String toString() {
			TreeMap<Integer, String> options = new TreeMap<>();
			Field fields[] = getClass().getFields();
			for(Field field: fields) {
				int modifiers = field.getModifiers();
				if(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers)) {
					try {
						int constant = field.getInt(null);
						String option = field.getName() + ": " + includes(constant) + System.lineSeparator();
						options.put(constant, option);
					} catch(IllegalAccessException e) {}
				}
			}
			Collection<String> values = options.values(); 
			StringBuilder builder = new StringBuilder();
			for(String val : values) {
				builder.append(val);
			}
			return builder.toString();
		}
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.CountComparator;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
public abstract class Address implements AddressSegmentSeries {
	private static final long serialVersionUID = 4L;
	public static interface AddressValueProvider {
		int getSegmentCount();
		SegmentValueProvider getValues();
		default SegmentValueProvider getUpperValues() {
			return getValues();
		}
	}
	@FunctionalInterface
	public static interface SegmentValueProvider {
		int getValue(int segmentIndex);
	}
	public static final String HEX_PREFIX = "0x";
	public static final String OCTAL_PREFIX = "0";
	public static final char RANGE_SEPARATOR = '-';
	public static final String RANGE_SEPARATOR_STR = String.valueOf(RANGE_SEPARATOR);
	public static final char ALTERNATIVE_RANGE_SEPARATOR = '\u00bb'; 
	public static final String ALTERNATIVE_RANGE_SEPARATOR_STR = String.valueOf(ALTERNATIVE_RANGE_SEPARATOR);
	public static final char SEGMENT_WILDCARD = '*';
	public static final String SEGMENT_WILDCARD_STR = String.valueOf(SEGMENT_WILDCARD);
	public static final String ALTERNATIVE_SEGMENT_WILDCARD_STR = "";
	public static final char SEGMENT_SQL_WILDCARD = '%';
	public static final String SEGMENT_SQL_WILDCARD_STR = String.valueOf(SEGMENT_SQL_WILDCARD);
	public static final char SEGMENT_SQL_SINGLE_WILDCARD = '_';
	public static final String SEGMENT_SQL_SINGLE_WILDCARD_STR = String.valueOf(SEGMENT_SQL_SINGLE_WILDCARD);
	public static final AddressComparator DEFAULT_ADDRESS_COMPARATOR = new CountComparator(true);
	public static final AddressComparator ADDRESS_LOW_VALUE_COMPARATOR = new ValueComparator(true, false);
	public static final AddressComparator ADDRESS_HIGH_VALUE_COMPARATOR = new ValueComparator(true, true);
	private static MACAddressNetwork macNetwork;
	private static IPv6AddressNetwork ipv6Network;
	private static IPv4AddressNetwork ipv4Network;
	final AddressSection addressSection;
	protected HostIdentifierString fromString;
	protected Address(AddressSection section) {
		addressSection = section;
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	protected Address(Function<Address, AddressSection> supplier) {
		addressSection = supplier.apply(this);
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	public static IPv6AddressNetwork defaultIpv6Network() {
		if(ipv6Network == null) {
			synchronized(Address.class) {
				if(ipv6Network == null) {
					ipv6Network = new IPv6AddressNetwork();
				}
			}
		}
		return ipv6Network;
	}
	public static IPv4AddressNetwork defaultIpv4Network() {
		if(ipv4Network == null) {
			synchronized(Address.class) {
				if(ipv4Network == null) {
					ipv4Network = new IPv4AddressNetwork();
				}
			}
		}
		return ipv4Network;
	}
	public static MACAddressNetwork defaultMACNetwork() {
		if(macNetwork == null) {
			synchronized(Address.class) {
				if(macNetwork == null) {
					macNetwork = new MACAddressNetwork();
				}
			}
		}
		return macNetwork;
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	@Override
	public int getSegmentCount() {
		return getSection().getSegmentCount();
	}
	@Override
	public int getDivisionCount() {
		return getSection().getDivisionCount();
	}
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public AddressSection getSection() {
		return addressSection;
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSection().getSegments(segs);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int index) {
		getSection().getSegments(start, end, segs, index);
	}
	@Override
	public abstract Iterable<? extends Address> getIterable();
	@Override
	public abstract Iterator<? extends Address> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> spliterator();
	@Override
	public abstract Stream<? extends Address> stream();
	@Override
	public abstract Iterator<? extends Address> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixStream();
	@Override
	public abstract Iterator<? extends Address> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixBlockStream();
	@Override
	public abstract Address increment(long increment) throws AddressValueException;
	@Override
	public abstract Address incrementBoundary(long increment) throws AddressValueException;
	@Override
	public abstract Address getLower();
	@Override
	public abstract Address getUpper();
	@Override
	public boolean isMultiple() {
		return getSection().isMultiple();
	}
	@Override
	public boolean isPrefixed() {
		return getSection().isPrefixed();
	}
	public boolean isIPAddress() {
		return false;
	}
	public boolean isMACAddress() {
		return false;
	}
	public IPAddress toIPAddress() {
		return null;
	}
	public MACAddress toMACAddress() {
		return null;
	}
	@Override
	public Integer getPrefixLength() {
		return getSection().getPrefixLength();
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		return getSection().getMinPrefixLengthForBlock();
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getSection().getPrefixLengthForSingleBlock();
	}
	public abstract boolean isMulticast();
	@Override
	public BigInteger getCount() {
		return getSection().getCount();
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return getSection().getPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount() {
		return getSection().getPrefixCount();
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		return getSection().getBlockCount(segmentCount);
	}
	@Override
	public byte[] getBytes() {
		return getSection().getBytes();
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getSection().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getSection().getBytes(bytes, index);
	}
	@Override
	public byte[] getUpperBytes() {
		return getSection().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getSection().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getSection().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getSection().getValue();
	}
	@Override
	public BigInteger getUpperValue() {
		return getSection().getUpperValue();
	}
	@Override
	public boolean isZero() {
		return getSection().isZero();
	}
	@Override
	public boolean includesZero() {
		return getSection().includesZero();
	}
	@Override
	public boolean isMax() {
		return getSection().isMax();
	}
	@Override
	public boolean includesMax() {
		return getSection().includesMax();
	}
	@Override
	public boolean isFullRange() {
		return getSection().isFullRange();
	}
	public abstract boolean isLocal();
	@Override
	public int hashCode() {
		return getSection().hashCode();
	}
	protected abstract boolean isFromSameString(HostIdentifierString otherString);
	public boolean isSameAddress(Address other) {
		return other == this || getSection().equals(other.getSection());
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof Address) {
			Address other = (Address) o;
			if(isFromSameString(other.fromString)) {
				return true;
			}
			return isSameAddress(other);
		}
		return false;
	}
	public boolean prefixEquals(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixEquals(other.getSection());
	}
	public boolean overlaps(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().overlaps(other.getSection());
	}
	public boolean contains(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().contains(other.getSection());
	}
	public abstract BigInteger enumerate(Address other);
	@Override
	public boolean isSequential() {
		return getSection().isSequential();
	}
	public HostIdentifierString toAddressString() {
		return fromString;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		return getSection().toHexString(with0xPrefix);
	}
	@Override
	public String toNormalizedString() {
		return getSection().toNormalizedString();
	}
	@Override
	public String toCanonicalString() {
		return getSection().toCanonicalString();
	}
	@Override
	public String toCompressedString() {
		return getSection().toCompressedString();
	}
	@Override
	public String toString() {
		return toCanonicalString();
	}
	@Override
	public String[] getDivisionStrings() {
		return getSection().getDivisionStrings();
	}
	@Override
	public String[] getSegmentStrings() {
		return getSection().getSegmentStrings();
	}
	@Override
	public abstract Address reverseSegments();
	@Override
	public abstract Address reverseBits(boolean perByte);
	@Override
	public abstract Address reverseBytes();
	@Override
	public abstract Address reverseBytesPerSegment();
	@Override
	public boolean isPrefixBlock() {
		return getSection().isPrefixBlock();
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return getSection().containsPrefixBlock(prefixLength);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		return getSection().isSinglePrefixBlock();
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return getSection().containsSinglePrefixBlock(prefixLength);
	}
	@Override
	public abstract Address toPrefixBlock();
	@Override @Deprecated
	public abstract Address removePrefixLength();
	@Override
	public abstract Address withoutPrefixLength();
	@Override @Deprecated
	public abstract Address removePrefixLength(boolean zeroed);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract Address adjustPrefixLength(int adjustment);
	@Override
	public abstract Address adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract Address setPrefixLength(int prefixLength);
	@Override
	public abstract Address setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	@Override
	public abstract Address applyPrefixLength(int networkPrefixLength);
	public static boolean matchUnordered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		boolean sameLen = len1 == len2;
		boolean result;
		if(len1 == 0 || len2 == 0) {
			result = sameLen;
		} else if(len1 == 1 && sameLen) {
			result = addrs1[0].equals(addrs2[0]);
		} else if(len1 == 2 && sameLen) {
			if(addrs1[0].equals(addrs2[0])) {
				result = addrs1[1].equals(addrs2[1]);
			} else if(result = addrs1[0].equals(addrs2[1])) {
				result = addrs1[1].equals(addrs2[0]);
			}
		} else {
			result = Objects.equals(asSet(addrs1), asSet(addrs2));
		}
		return result;
	}
	private static HashSet<Address> asSet(Address addrs[])  {
		int addrLen = addrs.length;
		if(addrLen > 0) {
			HashSet<Address> result = new HashSet<>();
			for(int i = 0; i < addrs.length; i++) {
				Address addr = addrs[i];
				result.add(addr);
			}
			return result;
		}
		return null;
	}
	public static boolean matchOrdered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		if(len1 != len2) {
			return false;
		}
		for(int i = 0; i < len1; i++) {
			if(!addrs1[i].equals(addrs2[i])) {
				return false;
			}
		}
		return true;
	}
}
package inet.ipaddr.format;
import java.math.BigInteger;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
public interface AddressDivisionSeries extends AddressItem, AddressStringDivisionSeries {
	default int isMore(AddressDivisionSeries other) {
		if(!isMultiple()) {
			return other.isMultiple() ? -1 : 0;
		}
		if(!other.isMultiple()) {
			return 1;
		}
		return getCount().compareTo(other.getCount());
	}
	@Override
	AddressGenericDivision getDivision(int index);
	String[] getDivisionStrings();
	Integer getPrefixLength();
	boolean isPrefixed();
	boolean isPrefixBlock();
	boolean isSinglePrefixBlock();
	default BigInteger getPrefixCount() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getCount();
		}
		return getPrefixCount(prefixLength);
	}
	@Override
	default BigInteger getPrefixCount(int prefixLength) {
		if(prefixLength < 0 || prefixLength > getBitCount()) {
			throw new PrefixLenException(this, prefixLength);
		}
		BigInteger result = BigInteger.ONE;
		if(isMultiple()) {
			int divisionCount = getDivisionCount();
			int divPrefixLength = prefixLength;
			for(int i = 0; i < divisionCount; i++) {
				AddressGenericDivision division = getDivision(i);
				int divBitCount = division.getBitCount();
				if(division.isMultiple()) {
					BigInteger divCount = (divPrefixLength < divBitCount) ? division.getPrefixCount(divPrefixLength) : division.getCount();
					result = result.multiply(divCount);
				}
				if(divPrefixLength <= divBitCount) {
					break;
				}
				divPrefixLength -= divBitCount;
			}
		}
		return result;
	}
	@Override
	default BigInteger getCount() {
		BigInteger result = BigInteger.ONE;
		int count = getDivisionCount();
		if(count > 0) {
			for(int i = 0; i < count; i++) {
				AddressGenericDivision div = getDivision(i);
				if(div.isMultiple()) {
					BigInteger divCount = div.getCount();
					result = result.multiply(divCount);
				}
			}
		}
		return result;
	}
	default BigInteger getBlockCount(int divCount) {
		if(divCount < 0) {
			throw new IllegalArgumentException();
		}
		BigInteger result = BigInteger.ONE;
		int divisionCount = getDivisionCount();
		if(divCount < divisionCount) {
			divisionCount = divCount;
		}
		for(int i = 0; i < divisionCount; i++) {
			AddressGenericDivision division = getDivision(i);
			if(division.isMultiple()) {
				result = result.multiply(division.getCount());
			}
		}
		return result;
	}
	@Override
	default int getBitCount() {
		int count = getDivisionCount();
		int bitCount = 0;
		for(int i = 0; i < count; i++) {
			bitCount += getDivision(i).getBitCount();
		}
		return bitCount;
	}
	default boolean isSequential() {
		int count = getDivisionCount();
		if(count > 1) {
			for(int i = 0; i < count; i++) {
				if(getDivision(i).isMultiple()) {
					for(++i; i < count; i++) {
						if(!getDivision(i).isFullRange()) {
							return false;
						}
					}
					return true;
				}
			}
		}
		return true;
	}
	default int getSequentialBlockIndex() {
		int segCount = getDivisionCount();
		if(segCount == 0) {
			return 0;
		}
		for(segCount--; segCount > 0 && getDivision(segCount).isFullRange(); segCount--);
		return segCount;
	}
}
package inet.ipaddr.format.string;
import java.io.Serializable;
public interface AddressStringDivisionSeries extends Serializable {
	AddressStringDivision getDivision(int index);
	int getDivisionCount();
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.util.AddressComponentSpliterator;
public interface AddressSection extends AddressSegmentSeries {
	boolean contains(AddressSection other);
	boolean overlaps(AddressSection other);
	BigInteger enumerate(AddressSection other);
	boolean prefixEquals(AddressSection other);
	@Override
	AddressSection getLower();
	@Override
	AddressSection getUpper();
	@Override
	AddressSection reverseSegments();
	@Override
	AddressSection reverseBits(boolean perByte);
	@Override
	AddressSection reverseBytes();
	@Override
	AddressSection reverseBytesPerSegment();
	@Override
	AddressSection toPrefixBlock();
	@Override @Deprecated
	AddressSection removePrefixLength();
	@Override
	AddressSection withoutPrefixLength();
	@Override @Deprecated
	AddressSection removePrefixLength(boolean zeroed);
	@Override
	AddressSection adjustPrefixBySegment(boolean nextSegment);
	@Override
	AddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	AddressSection adjustPrefixLength(int adjustment);
	@Override
	AddressSection adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	AddressSection setPrefixLength(int prefixLength);
	@Override
	AddressSection setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	@Override
	AddressSection applyPrefixLength(int networkPrefixLength);
	@Override
	Iterable<? extends AddressSection> getIterable();
	@Override
	Iterator<? extends AddressSection> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSection> spliterator();
	@Override
	Stream<? extends AddressSection> stream();
	@Override
	Iterator<? extends AddressSection> prefixIterator();
	@Override
	AddressComponentSpliterator<? extends AddressSection> prefixSpliterator();
	@Override
	public abstract Stream<? extends AddressSection> prefixStream();
	@Override
	Iterator<? extends AddressSection> prefixBlockIterator();
	@Override
	AddressComponentSpliterator<? extends AddressSection> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends AddressSection> prefixBlockStream();
	@Override
	AddressSection increment(long increment);
	@Override
	AddressSection incrementBoundary(long increment);
}
package inet.ipaddr.format;
import java.io.Serializable;
import java.math.BigInteger;
import inet.ipaddr.Address;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
public interface AddressItem extends Comparable<AddressItem>, Serializable {
	@Override
	default int compareTo(AddressItem other) {
		return Address.DEFAULT_ADDRESS_COMPARATOR.compare(this, other);
	}
	default BigInteger getCount() {
		return getUpperValue().subtract(getValue()).add(BigInteger.ONE);
	}
	default BigInteger getPrefixCount(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= prefixLength) {
			return getCount();
		}
		int shiftAdjustment = bitCount - prefixLength;
		BigInteger lower = getValue(), upper = getUpperValue();
		return upper.shiftRight(shiftAdjustment).subtract(lower.shiftRight(shiftAdjustment)).add(BigInteger.ONE);
	}
	int getBitCount();
	default int getByteCount() {
		return (getBitCount() + (Byte.SIZE - 1)) >>> 3;
	}
	default boolean isMultiple() {
		return !getUpperValue().equals(getValue());
	}
	byte[] getBytes();
	byte[] getBytes(byte bytes[]);
	byte[] getBytes(byte bytes[], int index);
	byte[] getUpperBytes();
	byte[] getUpperBytes(byte bytes[]);
	byte[] getUpperBytes(byte bytes[], int index);
	BigInteger getValue();
	BigInteger getUpperValue();
	boolean isZero();
	boolean includesZero();
	boolean isMax();
	boolean includesMax();
	default boolean isFullRange() {
		return includesZero() && includesMax();
	}
	default boolean containsPrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger upper = getUpperValue();
		return AddressDivisionBase.testRange(getValue(), upper, upper, getBitCount(), divisionPrefixLen);
	}
	default boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger lower = getValue(), upper = getUpperValue();
		return AddressDivisionBase.testRange(lower, lower, upper, getBitCount(), divisionPrefixLen);
	}
	default int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		BigInteger lower = getValue(), upper = getUpperValue();
		if(!lower.equals(upper)) {
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				int lowerZeros = Long.numberOfTrailingZeros(low);
				if(lowerZeros == 0) {
					break;
				}
				long up = upper.longValue();
				int upperOnes = Long.numberOfTrailingZeros(~up);
				if(upperOnes == 0) {
					break;
				}
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
				if(prefixedBitCount < longBits) {
					break;
				}
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
			} while(upper.signum() != 0);
		}
		return result;
	}
	default Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		BigInteger lower = getValue(), upper = getUpperValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lower.equals(upper)) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lower.shiftRight(shift).equals(upper.shiftRight(shift))) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		}
		return null;
	}
	public static BigInteger getBlockSize(int bitCount) {
		return BigInteger.ONE.shiftLeft(bitCount);
	}
	public static Integer getBitsForCount(long count) {
		if(count <= 0) {
			return null;
		}
		int logBase2 = (Long.SIZE - 1) - Long.numberOfLeadingZeros(count);
		if((~(-1L << logBase2) & count) != 0) {
			logBase2++;
		}
		return logBase2;
	}
}
package inet.ipaddr;
import java.io.Serializable;
import java.util.Map;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.format.standard.AddressCreator;
public abstract class AddressNetwork<S extends AddressSegment> implements Serializable {
	private static final long serialVersionUID = 4L;
	public interface AddressSegmentCreator<S extends AddressSegment> {
		S[] createSegmentArray(int length);
		S createSegment(int value);
		S createSegment(int value, Integer segmentPrefixLength);
		S createSegment(int lower, int upper, Integer segmentPrefixLength);
	}
	public abstract AddressCreator<?, ?, ?, S> getAddressCreator();
	public void clearCaches() {
		getAddressCreator().clearCaches();
	}
	public void setSegmentCaching(boolean enable) {
		getAddressCreator().setSegmentCaching(enable);
	}
	public enum PrefixConfiguration {
		ALL_PREFIXED_ADDRESSES_ARE_SUBNETS,
		PREFIXED_ZERO_HOSTS_ARE_SUBNETS,
		EXPLICIT_SUBNETS;
		public boolean allPrefixedAddressesAreSubnets() {
			return this == ALL_PREFIXED_ADDRESSES_ARE_SUBNETS;
		}
		public boolean zeroHostsAreSubnets() {
			return this == PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
		}
		public boolean prefixedSubnetsAreExplicit() {
			return this == EXPLICIT_SUBNETS;
		}
	}
	private static PrefixConfiguration defaultPrefixConfiguration = PrefixConfiguration.PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
	public abstract PrefixConfiguration getPrefixConfiguration();
	public static PrefixConfiguration getDefaultPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	protected boolean isCompatible(AddressNetwork<?> other) {
		return IPAddressSection.isCompatibleNetworks(this, other);
	}
	public static abstract class HostIdentifierStringGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		protected final Map<String, T> backingMap;
		public HostIdentifierStringGenerator() {
			this(null);
		}
		public HostIdentifierStringGenerator(Map<String, T> backingMap) {
			this.backingMap = backingMap;
		}
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		protected void added(T added) {}
		public boolean contains(T value) {
			return backingMap.containsValue(value);
		}
		public T get(String key) {
			if(backingMap == null) {
				return create(key);
			}
			T result = backingMap.get(key);
			if(result == null) {
				result = create(key);
				String normalizedKey = result.toNormalizedString();
				result = create(normalizedKey);
				T existing = backingMap.putIfAbsent(normalizedKey, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
				}
				if(!normalizedKey.equals(key)) {
					backingMap.put(key, result);
				}
			}
			return result;
		}
		public abstract T get(byte bytes[]);
		public abstract T get(AddressValueProvider addressProvider);
		protected abstract T create(String key);
	}
}
package inet.ipaddr;
import inet.ipaddr.format.AddressItem;
public class SizeMismatchException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	private static String errorMessage = getMessage("ipaddress.address.error");
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public SizeMismatchException(AddressItem one, AddressItem two) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.sizeMismatch"));
	}
}
package inet.ipaddr.format.standard;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.IPAddressGenericDivision;
import inet.ipaddr.format.util.AddressSegmentParams;
public abstract class IPAddressDivision extends AddressDivision implements IPAddressGenericDivision {
	private static final long serialVersionUID = 4L;
	private final Integer divisionNetworkPrefix;
	protected transient String cachedString;
	private transient Boolean isSinglePrefixBlock;
	protected IPAddressDivision() {
		this(null);
	}
	protected IPAddressDivision(Integer networkPrefixLength) {
		if(networkPrefixLength != null && networkPrefixLength < 0) {
			throw new PrefixLenException(networkPrefixLength);
		}
		this.divisionNetworkPrefix = networkPrefixLength;
	}
	@Override
	public boolean isPrefixed() {
		return divisionNetworkPrefix != null;
	}
	@Override
	public Integer getDivisionPrefixLength() {
		return divisionNetworkPrefix;
	}
	public boolean matchesWithPrefixMask(long value, Integer divisionPrefixLen) {
		if(divisionPrefixLen == null) {
			return matches(value);
		}
		long mask = getDivisionNetworkMask(divisionPrefixLen);
		long matchingValue = value & mask;
		return matchingValue == (getDivisionValue() & mask) && matchingValue == (getUpperDivisionValue() & mask);
	}
	protected abstract long getDivisionNetworkMask(int bits);
	protected abstract long getDivisionHostMask(int bits);
	public Integer getBlockMaskPrefixLength(boolean network) {
		int hostLength = getTrailingBitCount(network);
		long shifted;
		if(network) {
			shifted = (~getDivisionValue() & getMaxValue()) >>> hostLength;
		} else {
			shifted = getDivisionValue() >>> hostLength;
		}
		return shifted == 0 ? AddressDivisionGrouping.cacheBits(getBitCount() - hostLength) : null;
	}
	public int getTrailingBitCount(boolean network) {
		if(network) {
			return Long.numberOfTrailingZeros(getDivisionValue() | (~0L << getBitCount()));
		}
		return Long.numberOfTrailingZeros(~getDivisionValue());  
	}
	public int getLeadingBitCount(boolean network) {
		int extraLeading = Long.SIZE - getBitCount();
		if(network) {
			return Long.numberOfLeadingZeros(~getDivisionValue() & getMaxValue()) - extraLeading;
		}
		return Long.numberOfLeadingZeros(getDivisionValue()) - extraLeading;
	}
	@Override
	protected boolean isPrefixBlock(long segmentValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return segmentValue == 0 && upperValue == getMaxValue();
		}
		return testRange(segmentValue,
				upperValue,
				upperValue,
				getDivisionNetworkMask(divisionPrefixLen),
				getDivisionHostMask(divisionPrefixLen));
	}
	@Override
	protected boolean isSinglePrefixBlock(long segmentValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return segmentValue == 0 && upperValue == getMaxValue();
		}
		return testRange(segmentValue,
				segmentValue,
				upperValue,
				getDivisionNetworkMask(divisionPrefixLen),
				getDivisionHostMask(divisionPrefixLen));
	}
	boolean isSinglePrefixBlock(long segmentValue, int divisionPrefixLen) {
		return isSinglePrefixBlock(segmentValue, getUpperDivisionValue(), divisionPrefixLen);
	}
	@Override
	public boolean containsPrefixBlock(int divisionPrefixLen) {
		return isPrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
	@Override
	public boolean isPrefixBlock() {
		return isPrefixed() && containsPrefixBlock(getDivisionPrefixLength());
	}
	@Override
	public boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		return isSinglePrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		if(isSinglePrefixBlock == null) {
			isSinglePrefixBlock = isPrefixed() && containsSinglePrefixBlock(getDivisionPrefixLength());
		}
		return isSinglePrefixBlock;
	}
	@Override
	public String getString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					if(isSinglePrefixBlock() || !isMultiple()) { 
						result = getDefaultLowerString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						long upperValue = getUpperDivisionValue();
						if(isPrefixBlock()) {
							upperValue &= getDivisionNetworkMask(getDivisionPrefixLength());
						}
						result = getDefaultRangeString(getDivisionValue(), upperValue, getDefaultTextualRadix());
					}
					cachedString = result;
				}
			}
		}
		return result;
	}
	@Override
	public String getWildcardString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					if(!isPrefixed() || !isMultiple()) {
						result = getString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						result = getDefaultRangeString();
					}
					cachedWildcardString = result;
				}
			}
		}
		return result;
	}
	@Override
	protected String getCachedDefaultLowerString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					cachedString = result = getDefaultLowerString();
				}
			}
		}
		return result;
	}
	@Override
	protected void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable) {
		long upperValue = getUpperDivisionValue();
		long mask = getDivisionNetworkMask(getDivisionPrefixLength());
		upperValue &= mask;
		toUnsignedStringCased(upperValue, radix, 0, uppercase, appendable);
	}
	@Override
	public int getPrefixAdjustedRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		return super.getPrefixAdjustedRangeString(segmentIndex, params, appendable);
	}
}
package inet.ipaddr.ipv6;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import java.util.function.IntUnaryOperator;
import java.util.function.Predicate;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.IPAddressPartStringSubCollection;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.util.sql.SQLStringMatcher;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringOptions;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.CompressOptions.CompressionChoiceOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection.IPv6StringBuilder;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection.IPv6v4MixedStringBuilder;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
public class IPv6AddressSection extends IPAddressSection implements Iterable<IPv6AddressSection> {
	private static final long serialVersionUID = 4L;
	static class IPv6StringCache extends IPStringCache {
		static final IPv6StringOptions mixedParams;
		static final IPv6StringOptions fullParams;
		static final IPv6StringOptions normalizedParams;
		static final IPv6StringOptions canonicalParams;
		static final IPv6StringOptions uncParams;
		static final IPv6StringOptions compressedParams;
		static final IPv6StringOptions wildcardNormalizedParams;
		static final IPv6StringOptions wildcardCanonicalParams;
		static final IPv6StringOptions sqlWildcardParams;
		static final IPv6StringOptions wildcardCompressedParams;
		static final IPv6StringOptions networkPrefixLengthParams;
		static final IPv6StringOptions reverseDNSParams;
		static final IPStringOptions base85Params;
		static final IPStringOptions segmentedBinaryParams;
		static {
			CompressOptions 
				compressAll = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.ZEROS_OR_HOST),
				compressMixed = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.MIXED_PREFERRED),
				compressAllNoSingles = new CompressOptions(false, CompressOptions.CompressionChoiceOptions.ZEROS_OR_HOST), 
				compressHostPreferred = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.HOST_PREFERRED),
				compressZeros = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.ZEROS),
				compressZerosNoSingles = new CompressOptions(false, CompressOptions.CompressionChoiceOptions.ZEROS);
			mixedParams = new IPv6StringOptions.Builder().setMakeMixed(true).setCompressOptions(compressMixed).toOptions();
			fullParams = new IPv6StringOptions.Builder().setExpandedSegments(true).setWildcardOptions(new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPAddress.RANGE_SEPARATOR_STR))).toOptions();
			canonicalParams = new IPv6StringOptions.Builder().setCompressOptions(compressAllNoSingles).toOptions();
			uncParams = new IPv6StringOptions.Builder().setSeparator(IPv6Address.UNC_SEGMENT_SEPARATOR).setZoneSeparator(IPv6Address.UNC_ZONE_SEPARATOR).
					setAddressSuffix(IPv6Address.UNC_SUFFIX).
					setWildcardOptions(new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPv6Address.UNC_RANGE_SEPARATOR_STR, IPAddress.SEGMENT_WILDCARD_STR, null))).toOptions();
			compressedParams = new IPv6StringOptions.Builder().setCompressOptions(compressAll).toOptions();
			normalizedParams = new IPv6StringOptions.Builder().toOptions();
			WildcardOptions 
				allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL),
				allSQLWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL, new Wildcards(IPAddress.SEGMENT_SQL_WILDCARD_STR, IPAddress.SEGMENT_SQL_SINGLE_WILDCARD_STR));
			wildcardCanonicalParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).setCompressOptions(compressZerosNoSingles).toOptions();
			wildcardNormalizedParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).toOptions(); 
			sqlWildcardParams = new IPv6StringOptions.Builder().setWildcardOptions(allSQLWildcards).toOptions(); 
			wildcardCompressedParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).setCompressOptions(compressZeros).toOptions();
			networkPrefixLengthParams = new IPv6StringOptions.Builder().setCompressOptions(compressHostPreferred).toOptions();
			reverseDNSParams = new IPv6StringOptions.Builder().setReverse(true).setAddressSuffix(IPv6Address.REVERSE_DNS_SUFFIX).setSplitDigits(true).setExpandedSegments(true).setSeparator('.').toOptions();
			base85Params = new IPStringOptions.Builder(85).setExpandedSegments(true).setWildcards(new Wildcards(Address.ALTERNATIVE_RANGE_SEPARATOR_STR)).setZoneSeparator(IPv6Address.ALTERNATIVE_ZONE_SEPARATOR).toOptions();
			segmentedBinaryParams = new IPStringOptions.Builder(2).setSeparator(IPv6Address.SEGMENT_SEPARATOR).setSegmentStrPrefix(IPAddress.BINARY_STR_PREFIX).setExpandedSegments(true).toOptions();
		}
		public String normalizedString;
		public String compressedString;
		public String mixedString;
		public String compressedWildcardString;									
		public String canonicalWildcardString;
		public String networkPrefixLengthString;
		public String base85String;
		public String uncString;
	}
	static class IPv6AddressCache extends SectionCache<IPv6Address> {
		public Inet6Address inetAddress;
	}
	private static IPv6AddressCreator creators[] = new IPv6AddressCreator[IPv6Address.SEGMENT_COUNT];
	private transient IPv6StringCache stringCache;
	private transient SectionCache<IPv6AddressSection> sectionCache;
	private transient long[] cachedLowerVals;
	transient IPv4AddressSection embeddedIPv4Section;
	transient IPv6v4MixedAddressSection defaultMixedAddressSection;
	public final int addressSegmentIndex;
	private transient RangeList zeroSegments;
	private transient RangeList zeroRanges;
	public IPv6AddressSection(IPv6AddressSegment segment) {
		this(new IPv6AddressSegment[] {segment}, 0, false);
	}
	public IPv6AddressSection(IPv6AddressSegment segment, int startIndex) throws AddressValueException {
		this(new IPv6AddressSegment[] {segment}, startIndex, false);
	}
	public IPv6AddressSection(IPv6AddressSegment segments[]) throws AddressValueException {
		this(segments, 0, true);
	}
	public IPv6AddressSection(IPv6AddressSegment segments[], Integer networkPrefixLength) throws AddressValueException {
		this(segments, 0, networkPrefixLength);
	}
	public IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, Integer networkPrefixLength) throws AddressValueException {
		this(segments, startIndex, true, networkPrefixLength, false);
	}
	protected IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments, Integer networkPrefixLength, boolean singleOnly) throws AddressValueException {
		this(segments, startIndex, cloneSegments, networkPrefixLength == null );
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segments.length << 4;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv6Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segments.length > 0) {
				if(cachedPrefixLength != NO_PREFIX_LENGTH && cachedPrefixLength < networkPrefixLength) {
					networkPrefixLength = cachedPrefixLength;
				}
				IPv6AddressNetwork network = getNetwork();
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(), 
						!singleOnly && isPrefixSubnetSegs(segments, networkPrefixLength, network, false) ? IPv6AddressSegment::toNetworkSegment : IPv6AddressSegment::toPrefixedSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} 
	}
	protected IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments) throws AddressValueException {
		this(segments, startIndex, cloneSegments, true);
	}
	IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments, boolean normalizeSegments) throws AddressValueException {
		super(segments, cloneSegments, true);
		if(normalizeSegments && isPrefixed()) {
			normalizePrefixBoundary(getNetworkPrefixLength(), getSegmentsInternal(), IPv6Address.BITS_PER_SEGMENT, IPv6Address.BYTES_PER_SEGMENT, IPv6AddressSegment::toPrefixNormalizedSeg);
		}
		this.addressSegmentIndex = startIndex;
		if(startIndex < 0) {
			throw new AddressPositionException(startIndex);
		} else if(startIndex + segments.length > IPv6Address.SEGMENT_COUNT) {
			throw new AddressValueException(startIndex + segments.length);
		}
	}
	public IPv6AddressSection(SegmentValueProvider valueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount, networkPrefixLength);
	}
	public IPv6AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv6AddressSegment[segmentCount], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		createSegments(
				segs,
				lowerValueProvider,
				upperValueProvider,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0 || networkPrefixLength > IPv6Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
					network,
					networkPrefixLength,
					getSegmentsInternal(),
					getBitsPerSegment(),
					getBytesPerSegment(),
					network.getAddressCreator(),
					IPv6AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
		this.addressSegmentIndex = 0;
	}
	public IPv6AddressSection(SegmentValueProvider valueProvider, int segmentCount) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount);
	}
	public IPv6AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount) {
		this(lowerValueProvider, upperValueProvider, segmentCount, null);
	}
	protected IPv6AddressSection(byte bytes[], int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, networkPrefixLength, cloneBytes, singleOnly);
	}
	protected IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		super(new IPv6AddressSegment[segmentCount >= 0 ? segmentCount : (Math.max(0, byteEndIndex - byteStartIndex) + IPv6Address.BYTES_PER_SEGMENT - 1) >> 1], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		toSegments(
				segs,
				bytes,
				byteStartIndex,
				byteEndIndex,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		boolean byteLengthIsExact = bytes.length == (segs.length << 1);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segs.length << 4;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv6Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segs.length > 0) {
				if(network.getPrefixConfiguration().zeroHostsAreSubnets() && !singleOnly) {
					if(isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
						setPrefixedSegments(
							network,
							networkPrefixLength,
							segs,
							getBitsPerSegment(),
							getBytesPerSegment(),
							network.getAddressCreator(),
							IPv6AddressSegment::toNetworkSegment);
					} else if(byteLengthIsExact && networkPrefixLength >= getBitCount()) {
						setBytes(cloneBytes ? bytes.clone() : bytes);
					}
				} else if(byteLengthIsExact && network.getPrefixConfiguration().prefixedSubnetsAreExplicit() || networkPrefixLength >= getBitCount()) {
					setBytes(cloneBytes ? bytes.clone() : bytes);
				}
			} else if(byteLengthIsExact) {
				setBytes(bytes);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
			if(byteLengthIsExact) {
				setBytes(cloneBytes ? bytes.clone() : bytes);
			}
		}
		this.addressSegmentIndex = 0;
	}
	protected IPv6AddressSection(byte bytes[], int segmentCount, Integer prefix, boolean cloneBytes) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, prefix, cloneBytes, false);
	}
	public IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
	}
	public IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, null, true, false);
	}
	public IPv6AddressSection(byte bytes[], Integer prefix) throws AddressValueException {
		this(bytes, 0, bytes.length, -1, prefix, true, false);
	}
	public IPv6AddressSection(byte bytes[]) throws AddressValueException {
		this(bytes, 0, bytes.length, -1, null, true, false);
	}
	public IPv6AddressSection(BigInteger val, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(val.toByteArray(), segmentCount, networkPrefixLength, false);
	}
	public IPv6AddressSection(BigInteger val, int segmentCount) throws AddressValueException {
		this(val, segmentCount, null);
	}
	public IPv6AddressSection(long highBytes, long lowBytes, int segmentCount, Integer networkPrefixLength) throws PrefixLenException {
		super(new IPv6AddressSegment[segmentCount], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		createSegments(
				segs,
				highBytes,
				lowBytes,
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0 || networkPrefixLength > IPv6Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
					network,
					networkPrefixLength,
					getSegmentsInternal(),
					getBitsPerSegment(),
					getBytesPerSegment(),
					network.getAddressCreator(),
					IPv6AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
		this.addressSegmentIndex = 0;
	}
	public IPv6AddressSection(long highBytes, long lowBytes, int segmentCount) {
		this(highBytes, lowBytes, segmentCount, null);
	}
	public IPv6AddressSection(MACAddress eui) {
		this(eui.getSection(), 4, 4);
	}
	public IPv6AddressSection(MACAddressSection eui) {
		this(eui, getIPv6StartIndex(eui), getIPv6SegmentCount(eui));
	}
	private IPv6AddressSection(MACAddressSection eui, int ipv6StartIndex, int ipv6SegmentCount) throws IncompatibleAddressException {
		super(ipv6SegmentCount <= 0 ? IPv6AddressNetwork.EMPTY_SEGMENTS : new IPv6AddressSegment[ipv6SegmentCount], false, false);
		cachedPrefixLength = NO_PREFIX_LENGTH;
		this.addressSegmentIndex = ipv6StartIndex;
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6Address.toEUI64Segments(segs, 0, eui, eui.addressSegmentIndex, eui.isExtended(), getNetwork().getAddressCreator(), getMACNetwork().getAddressCreator(), null);
		checkSegments(segs);
	}
	private static int getIPv6SegmentCount(MACAddressSection eui) {
		int euiStartIndex = eui.addressSegmentIndex;
		int euiEndIndex = euiStartIndex + eui.getSegmentCount();
		int result = (euiEndIndex + 1) >> 1;
		result -= euiStartIndex >> 1;
		if(!eui.isExtended() && euiStartIndex <= 2 && euiEndIndex >= 4) {
			result++;
		}
		return result;
	}
	private static int getIPv6StartIndex(MACAddressSection eui) {
		int euiStartIndex = eui.addressSegmentIndex;
		int result =  4 + (euiStartIndex >> 1);
		if(!eui.isExtended() && euiStartIndex >= 3) {
			result++;
		}
		return result;
	}
	@Override
	protected void initCachedValues(
			Integer prefixLen,
			boolean network,
			Integer cachedNetworkPrefix,
			Integer cachedMinPrefix,
			Integer cachedEquivalentPrefix,
			BigInteger cachedCount,
			RangeList zeroSegments,
			RangeList zeroRanges) {
		super.initCachedValues(prefixLen, network, cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix, cachedCount, zeroSegments, zeroRanges);
		this.zeroSegments = zeroSegments;
		this.zeroRanges = zeroRanges;
	}
	@Override
	protected void setInetAddress(InetAddress addr) {
		super.setInetAddress(addr);
	}
	@Override
	public IPv6AddressSection getSection() {
		return this;
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection(index, getSegmentCount());
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection(index, endIndex, this, getAddressCreator(addressSegmentIndex + index));
	}
	@Override
	public IPv6AddressSegment[] getSegments() {
		return (IPv6AddressSegment[]) getDivisionsInternal().clone();
	}
	void cache(IPv6AddressSection lower, IPv6AddressSection upper) {
		SectionCache<IPv6AddressSection> cache = sectionCache;
		if((lower != null || upper != null) && 
				(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null))) {
			synchronized(this) {
				cache = sectionCache;
				boolean create = (cache == null);
				if(create) {
					sectionCache = cache = new SectionCache<IPv6AddressSection>();
					cache.lower = lower;
					cache.upper = upper;
				} else {
					if(cache.lower == null) {
						cache.lower = lower;
					}
					if(cache.upper == null) {
						cache.upper = upper;
					}
				}
			}
		}
	}
	protected IPv6AddressSection getSingleLowestOrHighestSection() {
		return getSingleLowestOrHighestSection(this);
	}
	IPv6AddressSection getLowestOrHighestSection(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection result = getSingleLowestOrHighestSection();
		if(result == null) {
			SectionCache<IPv6AddressSection> cache = sectionCache;
			if(cache == null || 
					(lowest ? (excludeZeroHost ? ((result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull) : (result = cache.lower) == null) : (result = cache.upper) == null)) {
				synchronized(this) {
					cache = sectionCache;
					boolean create = (cache == null);
					if(create) {
						sectionCache = cache = new SectionCache<IPv6AddressSection>();
					} else {
						if(lowest) {
							if(excludeZeroHost) {
								create = (result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull;
							} else {
								create = (result = cache.lower) == null;
							}
						} else {
							create = (result = cache.upper) == null;
						}
					}
					if(create) {
						result = createLowestOrHighestSection(
								this,
								getAddressCreator(), 
								this::segmentsNonZeroHostIterator, 
								i -> lowest ? getSegment(i).getLower() : getSegment(i).getUpper(),
								lowest,
								excludeZeroHost);
						if(result == null) {
							cache.lowerNonZeroHostIsNull = true;
						} else if(lowest) {
							if(excludeZeroHost) {
								 cache.lowerNonZeroHost = result;
							} else {
								cache.lower = result;
							}
						} else {
							cache.upper = result;
						}
					}
				}
			}
		} else if(excludeZeroHost && includesZeroHost()) {
			return null;
		}
		return result;
	}
	@Override
	public IPv6AddressSection getLowerNonZeroHost() {
		return getLowestOrHighestSection(true, true);
	}
	@Override
	public IPv6AddressSection getLower() {
		return getLowestOrHighestSection(true, false);
	}
	@Override
	public IPv6AddressSection getUpper() {
		return getLowestOrHighestSection(false, false);
	}
	public long[] longValues() {
		long result[] = cachedLowerVals;
		if(result == null) {
			cachedLowerVals = result = calcLongValues(true);
		}
		return result;
	}
	public long[] upperLongValues() {
		if(!isMultiple()) {
			return longValues();
		}
		return calcLongValues(false);
	}
	private long[] calcLongValues(boolean lower) {
		int segCount = getSegmentCount();
		if(segCount != 0) {
			int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
			long low, high;
			if(segCount <= IPv6Address.SEGMENT_COUNT >> 1) {
				high = 0;
				low = getSegment(0).getDivisionValue();
				for(int i = 1; i < segCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					low = (low << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
			} else {
				high = getSegment(0).getDivisionValue();
				int highCount = segCount - 4;
				int i = 1;
				for(; i < highCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					high = (high << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
				low = getSegment(i).getDivisionValue();
				for(i++; i < segCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					low = (low << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
			}
			return new long[]{high, low};
		}
		return new long[2];
	}
	@Override
	public IPv6AddressSection reverseBits(boolean perByte) {
		return reverseBits(perByte, this, getAddressCreator(), i -> getSegment(i).reverseBits(perByte), true);
	}
	@Override
	public IPv6AddressSection reverseBytes() {
		return reverseBytes(false);
	}
	@Override
	public IPv6AddressSection reverseBytesPerSegment() {
		return reverseBytes(true);
	}
	private IPv6AddressSection reverseBytes(boolean perSegment) {
		return reverseBytes(perSegment, this, getAddressCreator(), i -> getSegment(i).reverseBytes(), true);
	}
	@Override
	public IPv6AddressSection reverseSegments() {
		if(getSegmentCount() <= 1) {
			return this;
		}
		return reverseSegments(this, getAddressCreator(), i -> getSegment(i).withoutPrefixLength(), true);
	}
	@Override
	public Iterable<IPv6AddressSection> getIterable() {
		return this;
	}
	private Iterator<IPv6AddressSection> iterator(Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		IPv6AddressSection original;
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		} else {
			original = this;
		}
		return iterator(
				useOriginal,
				original,
				getAddressCreator(),
				useOriginal ? null : segmentsIterator(excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	private AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(false);
		}
		return prefixSpliterator(isBlockIterator, prefLength);
	}
	private AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator(boolean isBlockIterator, int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		IPv6AddressCreator creator = getAddressCreator();
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, section) -> section.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, section) -> section.prefixIterator() : 
							((isLowest, isHighest, section) -> (isLowest || isHighest) ? section.prefixIterator() : section.prefixBlockIterator())), 
				IPv6AddressSection::getPrefixCount,
				section -> section.getPrefixCount().compareTo(LONG_MAX) <= 0,
				section -> longPrefixCount(section, prefixLength));
	}
	@Override
	public Iterator<IPv6AddressSection> nonZeroHostIterator() {
		return iterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv6AddressSection> iterator() {
		return iterator(null);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> spliterator() {
		return spliterator(false);
	}
	@Override
	public Stream<IPv6AddressSection> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6AddressSection> prefixIterator() {
		return prefixIterator(false);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator() {
		return prefixSpliterator(false);
	}
	@Override
	public Stream<IPv6AddressSection> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6AddressSection> prefixBlockIterator() {
		return prefixIterator(true);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> prefixBlockSpliterator() {
		return prefixSpliterator(true);
	}
	@Override
	public Stream<IPv6AddressSection> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	private Iterator<IPv6AddressSection> prefixIterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator();
		}
		IPv6AddressCreator creator = getAddressCreator();
		boolean useOriginal = isBlockIterator ? isSinglePrefixBlock() : getPrefixCount().equals(BigInteger.ONE);
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				prefLength);
	}
	@Override
	public Iterator<IPv6AddressSection> blockIterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return iterator();
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		IPv6AddressCreator creator = getAddressCreator();
		boolean useOriginal = true;
		for(int i = 0; i <= segmentCount - 1; i++) {
			if(getSegment(i).isMultiple()) {
				useOriginal = false;
				break;
			}
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
								segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(!isAllSubnets),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> blockSpliterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator();
		}
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv6AddressSection forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.blockIterator(segmentCount), 
				section -> section.getBlockCount(segmentCount),
				section -> section.getBlockCount(segmentCount).compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv6AddressSection> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AddressSection> sequentialBlockIterator() {
		return (Iterator<IPv6AddressSection>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6AddressSection>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6AddressSection> sequentialBlockStream() {
		return (Stream<IPv6AddressSection>) super.sequentialBlockStream();
	}
	private Iterator<IPv6AddressSegment[]> segmentsIterator(Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return super.segmentsIterator(
				getSegmentCount(),
				getSegmentCreator(),
				isMultiple() ? null : () -> getLower().getSegments(),
				index -> getSegment(index).iterator(!isAllSubnets),
				excludeFunc);
	}
	private Predicate<IPv6AddressSegment[]> excludeNonZeroHosts() {
		if(isPrefixed()) {
			int prefLength = getNetworkPrefixLength();
			return segments -> isZeroHost(segments, prefLength);
		}
		return null;
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return segmentsIterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return segmentsIterator(null);
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6AddressSection, IPv6AddressSegment[]> segmentsSpliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.segmentsIterator(),
				IPv6AddressSection::getCount,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator(IPv6Address address, IPv6AddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = address.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = address;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.segmentsIterator(),
				IPv6Address::getCount,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	protected IPv6AddressSegment[] getSegmentsInternal() {
		return (IPv6AddressSegment[])  super.getDivisionsInternal();
	}
	protected AddressComponentSpliterator<IPv6AddressSection> spliterator(boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		IteratorProvider<IPv6AddressSection, IPv6AddressSection> iteratorProvider;
		Function<IPv6AddressSection, BigInteger> sizer;
		ToLongFunction<IPv6AddressSection> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			int prefLength = prefixLength;
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator(segs -> isZeroHost(segs, prefLength));
			longSizer = section -> longCount(section, segmentCount) - section.longZeroHostCount(prefLength, segmentCount);
			sizer = section -> section.getCount().subtract(section.getZeroHostCountImpl(prefLength, segmentCount));
		} else {
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator();
			longSizer = section -> longCount(section, segmentCount);
			sizer = IPv6AddressSection::getCount;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				sizer,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				longSizer);
	}
	protected Iterator<IPv6Address> iterator(
			IPv6Address original,
			AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator,
			Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		}
		return iterator(
				useOriginal,
				original, 
				creator,
				useOriginal ? null : segmentsIterator(
										getSegmentCount(),
										creator,
										isMultiple() ? null : () -> (IPv6AddressSegment[]) getLower().getSegmentsInternal(),
										index -> getSegment(index).iterator(!isAllSubnets),
										excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	protected AddressComponentSpliterator<IPv6Address> spliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = original;
		}
		IteratorProvider<IPv6Address, IPv6Address> iteratorProvider;
		Function<IPv6Address, BigInteger> sizer;
		ToLongFunction<IPv6Address> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			int prefLength = prefixLength;
			iteratorProvider = (isLowest, isHighest, addr) -> addr.getSection().iterator(addr, addr.getCreator(), s -> isZeroHost(s, prefLength));
			longSizer = addr -> longCount(addr.getSection(), segmentCount) - addr.getSection().longZeroHostCount(prefLength, segmentCount);
			sizer = addr -> addr.getSection().getCount().subtract(addr.getSection().getZeroHostCountImpl(prefLength, segmentCount));
		} else {
			iteratorProvider = (isLowest, isHighest, addr) -> addr.iterator();
			longSizer = addr -> longCount(addr.getSection(), segmentCount);
			sizer = IPv6Address::getCount;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				sizer,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				longSizer);
	}
	Iterator<IPv6Address> prefixIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator(original, creator, null);
		}
		return prefixIterator(original, creator, isBlockIterator, prefLength);
	}
	Iterator<IPv6Address> prefixIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, boolean isBlockIterator, int prefLength) {
		if(prefLength > getBitCount() || prefLength < 0) {
			throw new PrefixLenException(original, prefLength);
		}
		boolean useOriginal = isBlockIterator ? containsSinglePrefixBlock(prefLength) : getPrefixCount(prefLength).equals(BigInteger.ONE);
		if(useOriginal) {
			original = original.setPrefixLength(prefLength, false);
		}
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original,
				creator,
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				cacheBits(prefLength));
	}
	AddressComponentSpliterator<IPv6Address> prefixSpliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(original, creator, false);
		}
		return prefixSpliterator(original, creator, isBlockIterator, prefLength);
	}
	AddressComponentSpliterator<IPv6Address> prefixSpliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean isBlockIterator,
			int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(original, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				original.setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, addr) -> addr.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, addr) -> addr.prefixIterator() : 
							((isLowest, isHighest, addr) -> (isLowest || isHighest) ? addr.prefixIterator() : addr.prefixBlockIterator())),
				IPv6Address::getPrefixCount,
				addr -> addr.getPrefixCount().compareTo(LONG_MAX) <= 0,
				addr -> longPrefixCount(addr.getSection(), prefixLength));
	}
	Iterator<IPv6Address> blockIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount > getSegmentCount()) {
			return iterator(original, creator, null);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = true;
		for(int i = 0; i < segmentCount; i++) {
			if(getSegment(i).isMultiple()) {
				useOriginal = false;
				break;
			}
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator,
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(!isAllSubnets),
							null,
							networkSegIndex,
							hostSegIndex,
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv6Address> blockSpliterator(IPv6Address original, IPv6AddressCreator creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator(original, creator, false);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv6Address forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = original;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.blockIterator(segmentCount),
				addr -> addr.getBlockCount(segmentCount),
				addr -> addr.getBlockCount(segmentCount).compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}	
	protected boolean isZeroHost(IPv6AddressSegment segments[], int prefixLength) {
		return super.isZeroHost(segments, prefixLength);
	}
	private static final BigInteger MAX_VALUES_BY_SEGMENT[] = {
			BigInteger.ZERO,
			BigInteger.valueOf(IPv6Address.MAX_VALUE_PER_SEGMENT),
			BigInteger.valueOf(0xffffffffL),
			BigInteger.valueOf(0xffffffffffffL),
			BigInteger.valueOf(1).shiftLeft(16 * 4).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 5).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 6).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 7).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 8).subtract(BigInteger.ONE),
	};
	public static BigInteger getMaxValue(int segmentCount) {
		return MAX_VALUES_BY_SEGMENT[segmentCount];
	}
	@Override
	public IPv6AddressSection incrementBoundary(long increment) {
		if(increment <= 0) {
			if(increment == 0) {
				return this;
			}
			return getLower().increment(increment);
		}
		return getUpper().increment(increment);
	}
	public IPv6AddressSection increment(BigInteger bigIncrement) {
		if(bigIncrement.signum() == 0 && !isMultiple()) {
			return this;
		}
		checkOverflow(bigIncrement, this::getValue, this::getUpperValue, this::getCount, this::isSequential, () -> getMaxValue(getSegmentCount()));
		Integer prefixLength = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength();
		return increment(
				this,
				bigIncrement,
				getAddressCreator(), 
				this::getLower,
				this::getUpper,
				prefixLength);
	};
	@Override
	public IPv6AddressSection increment(long increment) {
		if(increment == 0 && !isMultiple()) {
			return this;
		}
		BigInteger bigIncrement = BigInteger.valueOf(increment);
		checkOverflow(increment, bigIncrement, this::getValue, this::getUpperValue, this::getCount, this::isSequential, () -> getMaxValue(getSegmentCount()));
		Integer prefixLength = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength();
		IPv6AddressSection result = fastIncrement(
				this,
				increment,
				getAddressCreator(),
				this::getLower,
				this::getUpper,
				prefixLength);
		if(result != null) {
			return result;
		}
		return increment(
				this,
				increment,
				bigIncrement,
				getAddressCreator(), 
				this::getLower,
				this::getUpper,
				prefixLength);
	}
	@Override
	protected BigInteger getCountImpl(int segCount) {
		if(!isMultiple()) {
			return BigInteger.ONE;
		}
		BigInteger result = getCountIPv6(i -> getSegment(i).getValueCount(), segCount);
		return result;
	}
	private static BigInteger getCountIPv6(IntUnaryOperator segmentValueCountProvider, int segCount) {
		if(segCount < 0) {
			throw new IllegalArgumentException();
		}
		return count(segmentValueCountProvider, segCount, 2, 0x7fffffffffffL);
	}
	@Override
	protected BigInteger getZeroHostCountImpl(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				int prefixedSegment = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
				BigInteger zeroHostCount = getCountIPv6(i -> {
					if(i == prefixedSegment) {
						IPAddressSegment seg = getSegment(i);
						int shift = seg.getBitCount() - getPrefixedSegmentPrefixLength(getBitsPerSegment(), prefixLength, i);
						int count = ((seg.getUpperSegmentValue() >>> shift) - (seg.getSegmentValue() >>> shift)) + 1;
						return count;
					}
					return getSegment(i).getValueCount();
				}, prefixedSegment + 1);
				return zeroHostCount;
			} else {
				return BigInteger.ONE;
			}
		}
		return BigInteger.ZERO;
	}
	@Override
	protected BigInteger getPrefixCountImpl() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getCount();
		}
		return getPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		checkSubnet(this, prefixLength);
		if(isMultiple()) {
			int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			int hostSegmentIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			boolean hasPrefixedSegment = (networkSegmentIndex == hostSegmentIndex);
			return getCountIPv6(i -> {
				if(hasPrefixedSegment && i == networkSegmentIndex) {
					return getSegment(i).getPrefixValueCount();
				}
				return getSegment(i).getValueCount();
			}, networkSegmentIndex + 1);
		}
		return BigInteger.ONE;
	}
	private AddressSegmentCreator<IPv6AddressSegment> getSegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	private IPv6AddressCreator getAddressCreator() {
		return getAddressCreator(addressSegmentIndex);
	}
	protected IPv6AddressCreator getAddressCreator(int startIndex) {
		IPv6AddressCreator creator = null, defaultCreator = getNetwork().getAddressCreator();
		boolean useCached = startIndex < IPv6Address.SEGMENT_COUNT;
		if(useCached) {
			creator = creators[startIndex];
		}
		if(creator != null) {
			useCached |= creator.getNetwork().equals(getNetwork());
			if(useCached) {
				return creator;
			}
		}
		creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[]) {
				return getNetwork().getAddressCreator().createSectionInternal(segments, startIndex); 
			}
			@Override
			protected IPv6AddressSection createPrefixedSectionInternal(IPv6AddressSegment segments[], Integer prefix, boolean singleOnly) {
				return new IPv6AddressSection(segments, startIndex, false, prefix, singleOnly);
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		if(useCached) {
			creators[startIndex] = creator;
		}
		return creator;
	}
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return (IPv6AddressSegment) super.getDivision(index);
	}
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return (IPv6AddressSegment) super.getSegment(index);
	}
	public void getSegments(Collection<? super IPv6AddressSegment> segs) {
		getSegments(0, getSegmentCount(), segs);
	}
	public void getSegments(int start, int end, Collection<? super IPv6AddressSegment> segs) {
		for(int i = start; i < end; i++) {
			segs.add(getSegment(i));
		}
	}
	public boolean isEUI64() {
		return isEUI64(false);
	}
	public boolean isEUI64(boolean partial) {
		int segmentCount = getSegmentCount();
		int endIndex = addressSegmentIndex + segmentCount;
		if(addressSegmentIndex <= 5) {
			if(endIndex > 6) {
				int index3 = 5 - addressSegmentIndex;
				IPv6AddressSegment seg3 = getSegment(index3);
				IPv6AddressSegment seg4 = getSegment(index3 + 1);
				return seg4.matchesWithMask(0xfe00, 0xff00) && seg3.matchesWithMask(0xff, 0xff);
			} else if(partial && endIndex == 6) {
				IPv6AddressSegment seg3 = getSegment(5 - addressSegmentIndex);
				return seg3.matchesWithMask(0xff, 0xff);
			}
		} else if(partial && addressSegmentIndex == 6 && endIndex > 6) {
			IPv6AddressSegment seg4 = getSegment(6 - addressSegmentIndex);
			return seg4.matchesWithMask(0xfe00, 0xff00);
		}
		return partial;
	}
	public MACAddressSection toEUI(boolean extended) {
		MACAddressSegment[] segs = toEUISegments(extended);
		if(segs == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return createSectionInternal(creator, segs, Math.max(0, addressSegmentIndex - 4) << 1, extended);
	}
	protected static MACAddressSection createSectionInternal(MACAddressCreator creator, MACAddressSegment[] segments, int startIndex, boolean extended) {
		return AddressDivisionGrouping.createSectionInternal(creator, segments, startIndex, extended);
	}
	MACAddressSegment[] toEUISegments(boolean extended) {
		IPv6AddressSegment seg0, seg1, seg2, seg3;
		int start = addressSegmentIndex;
		int segmentCount = getSegmentCount();
		int segmentIndex;
		if(start < 4) {
			start = 0;
			segmentIndex = 4 - start;
		} else {
			start -= 4;
			segmentIndex = 0;
		}
		int originalSegmentIndex = segmentIndex;
		seg0 = (start == 0 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg1 = (start <= 1 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg2 = (start <= 2 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg3 = (start <= 3 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		int macSegCount = (segmentIndex - originalSegmentIndex) << 1;
		if(!extended) {
			macSegCount -= 2;
		}
		if((seg1 != null && !seg1.matchesWithMask(0xff, 0xff)) || (seg2 != null && !seg2.matchesWithMask(0xfe00, 0xff00)) || macSegCount == 0) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		MACAddressSegment ZERO_SEGMENT = creator.createSegment(0);
		MACAddressSegment newSegs[] = creator.createSegmentArray(macSegCount);
		int macStartIndex = 0;
		if(seg0 != null) {
			seg0.getSplitSegments(newSegs, macStartIndex, creator);
			MACAddressSegment macSegment0 = newSegs[0];
			int lower0 = macSegment0.getSegmentValue();
			int upper0 = macSegment0.getUpperSegmentValue();
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				return null;
			}
			lower0 ^= mask2ndBit;
			upper0 ^= mask2ndBit;
			newSegs[0] = creator.createSegment(lower0, upper0, null);
			macStartIndex += 2;
		}
		if(seg1 != null) {
			seg1.getSplitSegments(newSegs, macStartIndex, creator);  
			if(!extended) {
				newSegs[macStartIndex + 1] = ZERO_SEGMENT;
			}
			macStartIndex += 2;
		}
		if(seg2 != null) {
			if(!extended) {
				if(seg1 != null) {
					macStartIndex -= 2;
					MACAddressSegment first = newSegs[macStartIndex];
					seg2.getSplitSegments(newSegs, macStartIndex, creator);
					newSegs[macStartIndex] = first;
				} else {
					seg2.getSplitSegments(newSegs, macStartIndex, creator);
					newSegs[macStartIndex] = ZERO_SEGMENT;
				}
			} else {
				seg2.getSplitSegments(newSegs, macStartIndex, creator);
			}
			macStartIndex += 2;
		}
		if(seg3 != null) {
			seg3.getSplitSegments(newSegs, macStartIndex, creator);
		}
		return newSegs;
	}
	public IPv4AddressSection getEmbeddedIPv4AddressSection(int startIndex, int endIndex) {
		if(startIndex == ((IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - this.addressSegmentIndex) << 1) && endIndex == (getSegmentCount() << 1)) {
			return getEmbeddedIPv4AddressSection();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		IPv4AddressSegment[] segments = creator.createSegmentArray(endIndex - startIndex);
		int i = startIndex, j = 0;
		int bytesPerSegment = getBytesPerSegment();
		if(i % bytesPerSegment == 1) {
			IPv6AddressSegment ipv6Segment = getSegment(i >> 1);
			i++;
			ipv6Segment.getSplitSegments(segments, j - 1, creator);
			j++;
		}
		for(; i < endIndex; i += bytesPerSegment, j += bytesPerSegment) {
			IPv6AddressSegment ipv6Segment = getSegment(i >> 1);
			ipv6Segment.getSplitSegments(segments, j, creator);
		}
		return createEmbeddedSection(creator, segments, this);
	}
	public IPv4AddressSection getEmbeddedIPv4AddressSection() {
		if(embeddedIPv4Section == null) {
			synchronized(this) {
				if(embeddedIPv4Section == null) {
					int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
					int lastIndex = getSegmentCount() - 1;
					IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
					IPv4AddressSegment[] mixed;
					if(mixedCount == 0) {
						mixed = creator.createSegmentArray(0);
					} else {
						if(mixedCount == 1) {
							mixed = creator.createSegmentArray(getBytesPerSegment());
							IPv6AddressSegment last = getSegment(lastIndex);
							last.getSplitSegments(mixed, 0, creator);
						} else {
							mixed = creator.createSegmentArray(getBytesPerSegment() << 1);
							IPv6AddressSegment low = getSegment(lastIndex);
							IPv6AddressSegment high = getSegment(lastIndex - 1);
							high.getSplitSegments(mixed, 0, creator);
							low.getSplitSegments(mixed, getBytesPerSegment(), creator);
						}
					}
					embeddedIPv4Section = createEmbeddedSection(creator, mixed, this);
				}
			}
		}
		return embeddedIPv4Section;
	}
	public IPv6AddressSection createNonMixedSection() {
		int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
		if(mixedCount <= 0) {
			return this;
		}
		int nonMixedCount = Math.max(0, getSegmentCount() - mixedCount);
		IPv6AddressCreator creator = getNetwork().getAddressCreator();
		IPv6AddressSegment[] nonMixed = creator.createSegmentArray(nonMixedCount);
		getSegments(0, nonMixedCount, nonMixed, 0);
		return creator.createEmbeddedSectionInternal(this, nonMixed, addressSegmentIndex);
	}
	public IPv6v4MixedAddressSection getMixedAddressSection() {
		if(defaultMixedAddressSection == null) {
			synchronized(this) {
				if(defaultMixedAddressSection == null) {
					defaultMixedAddressSection = new IPv6v4MixedAddressSection(
							createNonMixedSection(),
							getEmbeddedIPv4AddressSection());
				}
			}
		}
		return defaultMixedAddressSection;
	}
	public static IPv6AddressSection createSection(IPv6AddressCreator creator, IPv6AddressSegment nonMixedSection[], IPv4Address mixedSection) throws IncompatibleAddressException {
		IPv4AddressSection ipv4Section = mixedSection.getSection();
		IPv6AddressSegment newSegs[] = creator.createSegmentArray(nonMixedSection.length + IPv6Address.MIXED_REPLACED_SEGMENT_COUNT);
		newSegs[0] = nonMixedSection[0];
		newSegs[1] = nonMixedSection[1];
		newSegs[2] = nonMixedSection[2];
		newSegs[3] = nonMixedSection[3];
		newSegs[4] = nonMixedSection[4];
		newSegs[5] = nonMixedSection[5];
		newSegs[6] = ipv4Section.getSegment(0).join(creator, ipv4Section.getSegment(1));
		newSegs[7] = ipv4Section.getSegment(2).join(creator, ipv4Section.getSegment(3));
		IPv6AddressSection result = creator.createSectionInternal(newSegs);
		result.embeddedIPv4Section = ipv4Section;
		return result;
	}
	public IPv6Address getIPv6Address(IPv4Address mixedSection) {
		return mixedSection.getIPv6Address(getSegmentsInternal());
	}
	@Override
	public int getBitsPerSegment() {
		return IPv6Address.BITS_PER_SEGMENT;
	}
	@Override
	public int getBytesPerSegment() {
		return IPv6Address.BYTES_PER_SEGMENT;
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() << 4;
	}
	@Override
	public int getByteCount() {
		return getSegmentCount() << 1;
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[getByteCount()];
		int segmentCount = getSegmentCount();
		for(int i = 0; i < segmentCount; i++) {
			IPv6AddressSegment seg = getSegment(i);
			int byteIndex = i << 1;
			int val = low ? seg.getSegmentValue() : seg.getUpperSegmentValue();
			bytes[byteIndex] = (byte) (val >>> 8);
			bytes[byteIndex + 1] = (byte) val;
		}
		return bytes;
	}
	@Override
	protected byte[] getBytesInternal() {
		return super.getBytesInternal();
	}
	public boolean hasUppercaseVariations(int base, boolean lowerOnly) {
		if(base > 10) {
			int count = getSegmentCount();
			for(int i = 0; i < count; i++) {
				IPv6AddressSegment seg = getSegment(i);
				if(seg.hasUppercaseVariations(base, lowerOnly)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV6;
	}
	public IPv6AddressSection append(IPv6AddressSection other) {
		int count = getSegmentCount();
		return replace(count, count, other, 0, other.getSegmentCount());
	}
	public IPv6AddressSection appendToNetwork(IPv6AddressSection other) {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null) {
			return append(other);
		}
		IPv6AddressSection thizz = this;
		int bitsPerSegment = getBitsPerSegment();
		int adjustment = prefixLength % bitsPerSegment;
		if(adjustment != 0) {
			prefixLength += bitsPerSegment - adjustment;
			thizz = setPrefixLength(prefixLength, false);
		}
		int index = prefixLength >>> 4;
		if(other.isPrefixed() && other.getPrefixLength() == 0) {
			return insert(index, other); 
		}
		return thizz.replace(index, index, other, 0, other.getSegmentCount(), true);
	}
	public IPv6AddressSection insert(int index, IPv6AddressSection other) {
		return replace(index, index, other, 0, other.getSegmentCount());
	}
	public IPv6AddressSection replace(int index, IPv6AddressSection replacement) {
		return replace(index, index + replacement.getSegmentCount(), replacement, 0, replacement.getSegmentCount());
	}
	public IPv6AddressSection replace(int startIndex, int endIndex, IPv6AddressSection replacement, int replacementStartIndex, int replacementEndIndex) {
		return replace(startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, false);
	}
	public IPv6AddressSection replace(int startIndex, int endIndex, IPv6AddressSection replacement, int replacementStartIndex, int replacementEndIndex, boolean appendNetwork) {
		int segmentCount = getSegmentCount();
		int replacedCount = endIndex - startIndex;
		int replacementCount = replacementEndIndex - replacementStartIndex;
		if(replacedCount < 0 || replacementCount < 0 || startIndex < 0 || replacementStartIndex < 0 || replacementEndIndex > replacement.getSegmentCount() || endIndex > segmentCount) {
			throw new IndexOutOfBoundsException();
		}
		IPv6AddressSection thizz = this;
		if(addressSegmentIndex + segmentCount + replacementCount - replacedCount > IPv6Address.SEGMENT_COUNT) {
			throw new AddressValueException(this, replacement);
		} else if(replacementCount == 0 && replacedCount == 0) {
			return this;
		} else if(addressSegmentIndex == replacement.addressSegmentIndex && segmentCount == replacedCount) {
			return replacement;
		} else if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(appendNetwork) {
				thizz = withoutPrefixLength();
				int replacementEndBits = replacementEndIndex << 4;
				if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
					replacement = replacement.setPrefixLength(replacementEndBits, false);
				}
			}
		} else {
			Integer prefixLength = getPrefixLength();
			if(appendNetwork) { 
				int additionalSegs = segmentCount - endIndex;
				if(additionalSegs > 0) {
					thizz = getSection(0, startIndex).withoutPrefixLength();
					replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
					replacementEndIndex += additionalSegs;
					endIndex = startIndex;
				} else {
					thizz = withoutPrefixLength();
					int replacementEndBits = replacementEndIndex << 4;
					if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
						replacement = replacement.setPrefixLength(replacementEndBits, false);
					}
				}
			} else if(prefixLength != null && prefixLength <= startIndex << 4) {
				replacement = replacement.setPrefixLength(0, false);
			} else if(endIndex < segmentCount) {
				int replacementEndBits = replacementEndIndex << 4;
				if(replacement.isPrefixed() && replacement.getNetworkPrefixLength() <= replacementEndBits) {
					int thisNextIndexBits = endIndex << 4;
					if(prefixLength == null || prefixLength > thisNextIndexBits) {
						if(replacedCount > 0 || replacement.getPrefixLength() == 0) {
							thizz = setPrefixLength(thisNextIndexBits, false);
						} else {
							int additionalSegs = segmentCount - endIndex;
							thizz = getSection(0, startIndex);
							replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
							replacementEndIndex += additionalSegs;
						}
					}
				}
			}
		}
		return replace(thizz, startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, getAddressCreator(), appendNetwork, false);
	}
	@Override
	public boolean overlaps(AddressSection other) {
		return other instanceof IPv6AddressSection &&
				addressSegmentIndex == ((IPv6AddressSection) other).addressSegmentIndex && 
				overlaps(this, other);
	}
	@Override
	public boolean contains(AddressSection other) {
		return other instanceof IPv6AddressSection &&
				addressSegmentIndex == ((IPv6AddressSection) other).addressSegmentIndex && 
				super.contains(other);
	}
	@Override
	protected boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength) {
		if(other instanceof IPv6AddressSection) {
			IPv6AddressSection remaining[] = ((IPv6AddressSection) other).subtract(this);
			if(remaining != null) {
				for(int i = 0; i < remaining.length; i++) {
					if(!remaining[i].isZeroHost(otherPrefixLength)) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}
	static BigInteger enumerate(IPv6AddressSection addr, AddressSection other) {
		return enumerateBig(addr, other);
	}
	@Override
	public BigInteger enumerate(AddressSection other) {
		if(other instanceof IPv6AddressSection) {
			IPv6AddressSection otherSec = (IPv6AddressSection) other;
			checkSegmentCount(other);
			if(addressSegmentIndex != otherSec.addressSegmentIndex) {
				throw new AddressPositionException(this, addressSegmentIndex, otherSec.addressSegmentIndex);
			} else if(getSegmentCount() < 4) {
				Long result = enumerateSmall(this, other);
				if(result == null) {
					return null;
				}
				return BigInteger.valueOf(result);
			}
			return enumerateBig(this, other);
		}
		return null;
	}
	@Override
	public boolean prefixEquals(AddressSection o) {
		if(o == this) {
			return true;
		} else if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			if(addressSegmentIndex >= other.addressSegmentIndex) {
				return prefixEquals(this, other, addressSegmentIndex - other.addressSegmentIndex);
			}
		}
		return false;
	}
	@Override
	public boolean prefixContains(IPAddressSection o) {
		if(o == this) {
			return true;
		} else if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			if(addressSegmentIndex >= other.addressSegmentIndex) {
				return prefixContains(this, other, addressSegmentIndex - other.addressSegmentIndex);
			}
		}
		return false;
	}
	@Override
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		return other instanceof IPv6AddressSection && mask instanceof IPv6AddressSection && super.matchesWithMask(other, mask);
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPv6AddressSection &&
				super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			return addressSegmentIndex == other.addressSegmentIndex && other.isSameGrouping(this);
		}
		return false;
	}
	public IPv6AddressSection intersect(IPv6AddressSection other) throws SizeMismatchException {
		return intersect(this, other, getAddressCreator(), this::getSegment, other::getSegment);
	}
	public IPv6AddressSection[] subtract(IPv6AddressSection other) throws SizeMismatchException {
		return subtract(this, other, getAddressCreator(), this::getSegment, (section, prefix) -> section.setPrefixLength(prefix, false, true));
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return Address.defaultIpv6Network();
	}
	public IPv4AddressNetwork getIPv4Network() {
		return Address.defaultIpv4Network();
	}
	public MACAddressNetwork getMACNetwork() {
		return Address.defaultMACNetwork();
	}
	@Override
	public IPv6AddressSection adjustPrefixBySegment(boolean nextSegment) {
		return adjustPrefixBySegment(nextSegment, true);
	}
	@Override
	public IPv6AddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return (IPv6AddressSection) super.adjustPrefixBySegment(nextSegment, zeroed);
	}
	@Override
	public IPv6AddressSection adjustPrefixLength(int adjustment) {
		return adjustPrefixLength(adjustment, true);
	}
	@Override
	public IPv6AddressSection adjustPrefixLength(int adjustment, boolean zeroed) {
		return (IPv6AddressSection) adjustPrefixLength(this, adjustment, zeroed, getAddressCreator(), (section, i) -> section.getSegment(i));
	}
	@Deprecated
	@Override
	public IPv6AddressSection applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, true, true, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, true, false, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean zeroHostIsBlock) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, zeroHostIsBlock);
	}
	private IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean noShrink, boolean zeroHostIsBlock) {
		return setPrefixLength(
				this,
				getAddressCreator(),
				networkPrefixLength,
				withZeros,
				noShrink,
				!zeroHostIsBlock,
				(section, i) -> section.getSegment(i));
	}
	@Override @Deprecated
	public IPv6AddressSection removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv6AddressSection withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv6AddressSection removePrefixLength(boolean zeroed) {
		return removePrefixLength(this, zeroed, getAddressCreator(), IPv6AddressSection::getSegment);
	}
	public IPv6AddressSection bitwiseOrNetwork(IPv6AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv6AddressSection networkMask = getNetwork().getNetworkMaskSection(networkPrefixLength);
		return getOredSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(), 
				true,
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = networkMask.getSegment(i).getSegmentValue();
					return val1 & val2;
				}
		);
	}
	public IPv6AddressSection bitwiseOr(IPv6AddressSection mask) throws IncompatibleAddressException {
		return bitwiseOr(mask, false);
	}
	public IPv6AddressSection bitwiseOr(IPv6AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getOredSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv6AddressSection toZeroHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address networkMask = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				networkMask = networkMask.getLower();
			}
			return networkMask.getSection(0, getSegmentCount());
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return createZeroHost(false);
	}
	IPv6AddressSection createZeroHost(boolean boundariesOnly) {
		int prefixLength = getNetworkPrefixLength();
		IPv6AddressNetwork network = getNetwork();
		IPv6Address mask = network.getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				network.getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : cacheBits(prefixLength),
				getAddressCreator(),
				!boundariesOnly,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		IPv6Address mask = getNetwork().getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toZeroNetwork() {
		if(!isPrefixed()) {
			IPv6Address hostMask = getNetwork().getHostMask(getBitCount());
			return hostMask.getSection(0, getSegmentCount());
		}
		return createZeroNetwork();
	}
	IPv6AddressSection createZeroNetwork() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getSubnetSegments(
				this,
				prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toMaxHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix.getSection(0, getSegmentCount());
			}
			return resultNoPrefix.setPrefixLength(0).getSection(0, getSegmentCount());
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return createMaxHost();
	}
	public IPv6AddressSection createMaxHost() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv6AddressSection toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == this.getNetworkPrefixLength()) {
			return toMaxHost();
		}
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	public IPv6AddressSection mask(IPv6AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getSubnetSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				false);
	}
	public IPv6AddressSection mask(IPv6AddressSection mask) throws IncompatibleAddressException, SizeMismatchException {
		return mask(mask, false);
	}
	public IPv6AddressSection maskNetwork(IPv6AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return getSubnetSegments(
					this,
					cacheBits(networkPrefixLength),
					getAddressCreator(),
					true,
					this::getSegment,
					i -> mask.getSegment(i).getSegmentValue(),
					false);
		}
		IPv6AddressSection hostMask = getNetwork().getHostMaskSection(networkPrefixLength);
		return getSubnetSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true, 
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = hostMask.getSegment(i).getSegmentValue();
					return val1 | val2;
				},
				false
		);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	@Override
	public IPv6AddressSection getHostMask() {
		return (IPv6AddressSection) super.getHostMask();
	}
	@Override
	public IPv6AddressSection getNetworkMask() {
		return (IPv6AddressSection) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		if(isPrefixed()) {
			return getNetworkSection(getNetworkPrefixLength());
		}
		return getNetworkSection(getBitCount());
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getNetworkSection(networkPrefixLength, true);
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getNetworkSection(this, networkPrefixLength, withPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, withPrefixLength));
	}
	@Override
	public IPv6AddressSection getHostSection() {
		if(isPrefixed()) {
			return getHostSection(getNetworkPrefixLength());
		}
		return getHostSection(0);
	}
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		int hostSegmentCount = getHostSegmentCount(networkPrefixLength);
		IPv6AddressCreator creator = getAddressCreator(addressSegmentIndex + (getSegmentCount() - hostSegmentCount));
		return getHostSection(this, networkPrefixLength, hostSegmentCount, creator, (prefix, i) -> getSegment(i).toHostSegment(prefix));
	}
	@Override
	public IPv6AddressSection toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6AddressSection assignPrefixForSingleBlock() {
		return (IPv6AddressSection) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6AddressSection assignMinPrefixForBlock() {
		return (IPv6AddressSection) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6AddressSection toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return toPrefixBlock(this, networkPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, true));
	}
	@Override
	public IPv6AddressSection coverWithPrefixBlock() {
		return (IPv6AddressSection) coverWithPrefixBlock(this, getLower(), getUpper());
	}
	public IPv6AddressSection coverWithPrefixBlock(IPv6AddressSection other) throws AddressConversionException {
		checkSegmentCount(other);
		return coverWithPrefixBlock(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return IPAddressSection.coverWithPrefixBlock(first, other, getLower, getUpper, comparator);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries original,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		return IPAddressSection.coverWithPrefixBlock(original, lower, upper);
	}
	@Override
	public IPv6AddressSection[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6AddressSection[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6AddressSection> list = (ArrayList<IPv6AddressSection>) spanWithBlocks(true);
		return list.toArray(new IPv6AddressSection[list.size()]);
	}
	public IPv6AddressSection[] spanWithPrefixBlocks(IPv6AddressSection other) throws AddressPositionException {
		if(other.addressSegmentIndex != addressSegmentIndex) {
			throw new AddressPositionException(other, other.addressSegmentIndex, addressSegmentIndex);
		}
		return getSpanningPrefixBlocks(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6AddressSection::assignPrefixForSingleBlock,
				IPv6AddressSection::withoutPrefixLength,
				getAddressCreator()::createSectionArray);
	}
	@Deprecated
	public IPv6AddressSection[] spanWithRangedSegments(IPv6AddressSection other) {
		return spanWithSequentialBlocks(other);
	}
	@Override
	public IPv6AddressSection[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6AddressSection[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6AddressSection> list = (ArrayList<IPv6AddressSection>) spanWithBlocks(false);
		return list.toArray(new IPv6AddressSection[list.size()]);
	}
	public IPv6AddressSection[] spanWithSequentialBlocks(IPv6AddressSection other) throws AddressPositionException {
		if(other.addressSegmentIndex != addressSegmentIndex) {
			throw new AddressPositionException(other, other.addressSegmentIndex, addressSegmentIndex);
		}
		return getSpanningSequentialBlocks(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6AddressSection::withoutPrefixLength,
				getAddressCreator());
	}
	@Deprecated
	public IPv6AddressSection[] mergePrefixBlocks(IPv6AddressSection ...sections) throws SizeMismatchException {
		return mergeToPrefixBlocks(sections);
	}
	public IPv6AddressSection[] mergeToPrefixBlocks(IPv6AddressSection ...sections) throws SizeMismatchException, AddressPositionException {
		checkSectionsMergeable(sections);
		IPv6AddressSection[] converted = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6AddressSection[blocks.size()]);
	}
	private IPv6AddressSection[] getCloned(IPv6AddressSection... sections) {
		IPv6AddressSection converted[] = new IPv6AddressSection[sections.length + 1];
		System.arraycopy(sections, 0, converted, 1, sections.length);
		converted[0] = this;
		return converted;
	}
	private void checkSectionsMergeable(IPv6AddressSection sections[]) {
		for(int i = 0; i < sections.length; i++) {
			IPv6AddressSection section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.addressSegmentIndex != addressSegmentIndex) {
				throw new AddressPositionException(section, section.addressSegmentIndex, addressSegmentIndex);
			}
			if(section.getSegmentCount() != getSegmentCount()) {
				throw new SizeMismatchException(this, section);
			}
		}
	}
	public IPv6AddressSection[] mergeToSequentialBlocks(IPv6AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv6AddressSection[] converted = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator()::createSequentialBlockSection);
		return blocks.toArray(new IPv6AddressSection[blocks.size()]);
	}
	@Override
	protected boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					stringCache = new IPv6StringCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	protected IPv6StringCache getStringCache() {
		return stringCache;
	}
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().compressedString) == null) {
			getStringCache().compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
		}
		return result;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
		}
		return result;
	}
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().mixedString) == null) {
			getStringCache().mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().fullString) == null) {
			getStringCache().fullString = result = toNormalizedString(IPv6StringCache.fullParams);
		}
		return result;
	}
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().compressedWildcardString) == null) {
			getStringCache().compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().networkPrefixLengthString) == null) {
			getStringCache().networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
		}
		return result;
	}
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().canonicalWildcardString) == null) {
			getStringCache().canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
		}
		return result;
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().normalizedWildcardString) == null) {
			getStringCache().normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
		}
		return result;
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().sqlWildcardString) == null) {
			getStringCache().sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
		}
		return result;
	}
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().normalizedString) == null) {
			getStringCache().normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
		}
		return result;
	}
	public String toBase85String() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = getStringCache().base85String) == null) {
			getStringCache().base85String = result = toBase85String(null);
		}
		return result;
	}
	String toBase85String(String zone) {
		Integer prefixLength = getNetworkPrefixLength();
		IPAddressLargeDivision largeDiv;
		if(isDualString()) {
			largeDiv = new IPAddressLargeDivision(getBytesInternal(), getUpperBytesInternal(), getBitCount(), 85, getNetwork(), prefixLength);
		} else {
			largeDiv = new IPAddressLargeDivision(getBytesInternal(), getBitCount(), 85, getNetwork(), prefixLength);
		}
		IPAddressStringDivisionSeries part = new IPAddressLargeDivisionGrouping(new IPAddressLargeDivision[] { largeDiv }, getNetwork());
		return toNormalizedString(IPv6StringCache.base85Params, zone, part);
	}
	@Override
	protected void cacheNormalizedString(String str) {
		if(hasNoStringCache() || getStringCache().normalizedString == null) {
			getStringCache().normalizedString = str;
		}
	}
	@Override
	public String toReverseDNSLookupString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().reverseDNSString) == null) {
			IPStringCache stringCache = getStringCache();
			stringCache.reverseDNSString = result = toNormalizedString(IPv6StringCache.reverseDNSParams, "");
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			getStringCache().segmentedBinaryString = result = toSegmentedBinaryString(null);
		}
		return result;
	}
	protected String toSegmentedBinaryString(CharSequence zone) {
		return toNormalizedString(IPv6StringCache.segmentedBinaryParams, zone);
	}
	@Override
	protected String toBinaryString(CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(IPStringCache.binaryParams);
			return toNormalizedStringRange(params, getLower(), getUpper(), zone);
		}
		return toNormalizedString(IPStringCache.binaryParams, zone);
	}
	@Override
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
			return toNormalizedStringRange(params, getLower(), getUpper(), zone);
		}
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams, zone);
	}
	@Override
	protected String toOctalString(boolean with0Prefix, CharSequence zone) throws IncompatibleAddressException {
		if(zone == null) {
			return super.toOctalString(with0Prefix, null);
		}
		IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams);
		if(isDualString()) {
			IPv6AddressSection lower = getLower();
			IPv6AddressSection upper = getUpper();
			IPAddressBitsDivision lowerDivs[] = lower.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries lowerPart = new IPAddressDivisionGrouping(lowerDivs, getNetwork());
			IPAddressBitsDivision upperDivs[] = upper.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries upperPart = new IPAddressDivisionGrouping(upperDivs, getNetwork());
			return toNormalizedStringRange(params, lowerPart, upperPart, zone);
		}
		IPAddressBitsDivision divs[] = createNewPrefixedDivisions(3, null, null, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
		IPAddressStringDivisionSeries part = new IPAddressDivisionGrouping(divs, getNetwork());
		return params.toString(part, zone);
	}
	@Override
	public String toNormalizedString(IPStringOptions options) {
		if(options instanceof IPv6StringOptions) {
			return toNormalizedString((IPv6StringOptions) options);
		}
		return super.toNormalizedString(options);
	}
	public String toNormalizedString(IPv6StringOptions options) {
		return toNormalizedString(options, (String) null);
	}
	private String toNormalizedMixedString(IPv6v4MixedParams mixedParams, CharSequence zone) {
		IPv6v4MixedAddressSection mixed = getMixedAddressSection();
		String result = mixedParams.toString(mixed, zone);
		return result;
	}
	String toNormalizedString(IPStringOptions options, CharSequence zone) {
		if(zone == null) {
			return toNormalizedString(options);
		}
		if(options instanceof IPv6StringOptions) {
			return toNormalizedString((IPv6StringOptions) options, zone);
		}
		IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(options);
		return params.toString(this, zone);
	}
	public String toNormalizedString(IPv6StringOptions options, CharSequence zone) {
		IPv6StringParams stringParams;
		if(options.isCacheable()) {
			IPAddressStringWriter<?> cachedParams = (IPAddressStringWriter<?>) getCachedParams(options);
			if(cachedParams == null) {
				stringParams = options.from(this);
				if(options.makeMixed()) {
					IPv6v4MixedParams mixedParams = new IPv6v4MixedParams(stringParams, options.ipv4Opts);
					setCachedParams(options, mixedParams);
					return toNormalizedMixedString(mixedParams, zone);
				} else {
					setCachedParams(options, stringParams);
				}
			} else {
				if(cachedParams instanceof IPv6v4MixedParams) {
					return toNormalizedMixedString((IPv6v4MixedParams) cachedParams, zone);
				}
				stringParams = (IPv6StringParams) cachedParams;
			}
		} else {
			stringParams = options.from(this);
			if(options.makeMixed() && stringParams.nextUncompressedIndex <= IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex) {
				return toNormalizedMixedString(new IPv6v4MixedParams(stringParams, options.ipv4Opts), zone);
			}
		}
		return stringParams.toString(this, zone);
	}
	public static String toNormalizedString(IPStringOptions options, CharSequence zone, IPAddressStringDivisionSeries part) {
		AddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(options);
		String result = params.toString(part, zone);
		return result;
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.DATABASE_SEARCH_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return toStringCollection(IPv6StringBuilderOptions.from(options));
	}
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		return toStringCollection(opts, null);
	}
	IPv6StringCollection toStringCollection(IPv6StringBuilderOptions opts, CharSequence zone) {
		IPv6StringCollection collection = new IPv6StringCollection();
		int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
		if(mixedCount > 0 && opts.includes(IPv6StringBuilderOptions.MIXED)) {
			IPv6v4MixedAddressSection mixed = getMixedAddressSection();
			IPv6v4MixedStringBuilder mixedBuilder = new IPv6v4MixedStringBuilder(mixed, opts, zone);
			IPv6v4MixedStringCollection mixedCollection = mixedBuilder.getVariations();
			collection.add(mixedCollection);
		}
		if(opts.includes(IPStringBuilderOptions.BASIC)) {
			IPv6StringBuilder ipv6Builder = new IPv6StringBuilder(this, opts, zone);
			IPv6AddressSectionStringCollection ipv6Collection = ipv6Builder.getVariations();
			collection.add(ipv6Collection);
		}
		return collection;
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions opts) {
		return getParts(IPv6StringBuilderOptions.from(opts));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions opts) {
		if(opts.includes(IPv6StringBuilderOptions.MIXED)) {
			if(opts.includes(IPStringBuilderOptions.BASIC)) {
				return new IPAddressStringDivisionSeries[] { this, getMixedAddressSection() };
			}
			return new IPAddressStringDivisionSeries[] { getMixedAddressSection() };
		}
		return super.getParts(opts);
	}
	private static class IPv6StringMatcher extends SQLStringMatcher<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString> {
		IPv6StringMatcher(
				IPv6AddressSectionString networkString,
				IPAddressSQLTranslator translator) {
			super(networkString, networkString.addr.isEntireAddress(), translator);
		}
		@Override
		public StringBuilder getSQLCondition(StringBuilder builder, String columnName) {
			if(networkString.addr.isEntireAddress()) {
				matchString(builder, columnName, networkString.getString());
			} else if(networkString.endIsCompressed()) { 
				char sep = networkString.getTrailingSegmentSeparator();
				String searchStr = networkString.getString().substring(0, networkString.getString().length() - 1);
				builder.append('(');
				matchSubString(builder, columnName, sep, networkString.getTrailingSeparatorCount(), searchStr);
				int extraSeparatorCountMax = (IPv6Address.SEGMENT_COUNT - 1) - networkString.addr.getSegmentCount();
				builder.append(") AND (");
				boundSeparatorCount(builder, columnName, sep, extraSeparatorCountMax + networkString.getTrailingSeparatorCount());
				builder.append(')');
			} else if(networkString.isCompressed()) { 
				char sep = networkString.getTrailingSegmentSeparator();
				builder.append('(');
				matchSubString(builder, columnName, sep, networkString.getTrailingSeparatorCount() + 1, networkString.getString());
				int extraSeparatorCount = IPv6Address.SEGMENT_COUNT - networkString.addr.getSegmentCount();
				builder.append(") AND (");
				matchSeparatorCount(builder, columnName, sep, extraSeparatorCount + networkString.getTrailingSeparatorCount());
				builder.append(')');
			} else {
				matchSubString(builder, columnName, networkString.getTrailingSegmentSeparator(), networkString.getTrailingSeparatorCount() + 1, networkString.getString());
			}
			return builder;
		}
	}
	public static class CompressOptions {
		public enum CompressionChoiceOptions {
			HOST_PREFERRED, 
			MIXED_PREFERRED, 
			ZEROS_OR_HOST, 
			ZEROS; 
			boolean compressHost() {
				return this != ZEROS;
			}
		}
		public enum MixedCompressionOptions {
			NO, 
			NO_HOST, 
			COVERED_BY_HOST, 
			YES; 
			boolean compressMixed(IPv6AddressSection addressSection) {
				switch(this) {
					default:
					case YES:
						return true;
					case NO:
						return false;
					case NO_HOST:
						return !addressSection.isPrefixed();
					case COVERED_BY_HOST:
						if(addressSection.isPrefixed()) {
							int mixedDistance = IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSection.addressSegmentIndex;
							int mixedCount = addressSection.getSegmentCount() - Math.max(mixedDistance, 0);
							if(mixedCount > 0) {
								return (mixedDistance * addressSection.getBitsPerSegment()) >= addressSection.getNetworkPrefixLength();
							}
						}
						return true;
				}
			}
		}
		public final boolean compressSingle;
		public final CompressionChoiceOptions rangeSelection;
		public final MixedCompressionOptions compressMixedOptions;
		public CompressOptions(boolean compressSingle, CompressionChoiceOptions rangeSelection) {
			this(compressSingle, rangeSelection, MixedCompressionOptions.YES);
		}
		public CompressOptions(boolean compressSingle, CompressionChoiceOptions rangeSelection, MixedCompressionOptions compressMixedOptions) {
			this.compressSingle = compressSingle;
			this.rangeSelection = rangeSelection;
			this.compressMixedOptions = compressMixedOptions == null ? MixedCompressionOptions.YES : compressMixedOptions;
		}
	}
	public static class IPv6StringOptions extends IPStringOptions {
		public final IPStringOptions ipv4Opts;
		public final CompressOptions compressOptions;
		IPv6StringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				boolean makeMixed,
				IPStringOptions ipv4Opts,
				CompressOptions compressOptions,
				Character separator,
				char zoneSeparator,
				String addressPrefix,
				String addressSuffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, zoneSeparator, addressPrefix, addressSuffix, reverse, splitDigits, uppercase);
			this.compressOptions = compressOptions;
			if(makeMixed) {
				if(ipv4Opts == null) {
					ipv4Opts = new IPv4StringOptions.Builder().
							setExpandedSegments(expandSegments).setWildcardOption(wildcardOption).setWildcards(wildcards).toOptions();
				}
				this.ipv4Opts = ipv4Opts;
			} else {
				this.ipv4Opts = null;
			}
		}
		boolean isCacheable() {
			return compressOptions == null;
		}
		boolean makeMixed() {
			return ipv4Opts != null;
		}
		private IPv6StringParams from(IPv6AddressSection addr) {
			IPv6StringParams result = new IPv6StringParams();
			if(compressOptions != null) {
				boolean makeMixed = makeMixed();
				int vals[] = addr.getCompressIndexAndCount(compressOptions, makeMixed);
				if(vals != null) {
					int maxIndex = vals[0];
					int maxCount = vals[1];
					result.firstCompressedSegmentIndex = maxIndex;
					result.nextUncompressedIndex = maxIndex + maxCount;
					result.hostCompressed = compressOptions.rangeSelection.compressHost() &&
							addr.isPrefixed() &&
							(result.nextUncompressedIndex > 
								getHostSegmentIndex(addr.getNetworkPrefixLength(), IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT));
				}
			}
			result.expandSegments(expandSegments);
			result.setWildcardOption(wildcardOption);
			result.setWildcards(wildcards);
			result.setSeparator(separator);
			result.setAddressSuffix(addrSuffix);
			result.setAddressLabel(addrLabel);
			result.setReverse(reverse);
			result.setSplitDigits(splitDigits);
			result.setZoneSeparator(zoneSeparator);
			result.setUppercase(uppercase);
			result.setRadix(base);
			result.setSegmentStrPrefix(segmentStrPrefix);
			return result;
		}
		public static IPv6StringOptions from(IPStringOptions opts) {
			if(opts instanceof IPv6StringOptions) {
				return (IPv6StringOptions) opts;
			}
			return new IPv6StringOptions(
					opts.base,
					opts.expandSegments,
					opts.wildcardOption,
					opts.wildcards,
					opts.segmentStrPrefix,
					false,
					null,
					null,
					opts.separator,
					IPv6Address.ZONE_SEPARATOR,
					opts.addrLabel,
					opts.addrSuffix,
					opts.reverse,
					opts.splitDigits,
					opts.uppercase);
		}
		public static class Builder extends IPStringOptions.Builder {
			private boolean makeMixed;
			private IPStringOptions ipv4Options;
			private CompressOptions compressOptions;
			public Builder() {
				super(IPv6Address.DEFAULT_TEXTUAL_RADIX, IPv6Address.SEGMENT_SEPARATOR);
			}
			public Builder setCompressOptions(CompressOptions compressOptions) {
				this.compressOptions = compressOptions;
				return this;
			}
			public Builder setMakeMixed(boolean makeMixed) {
				this.makeMixed = makeMixed;
				return this;
			}
			public Builder setMakeMixed(IPStringOptions ipv4Options) {
				this.makeMixed = true;
				this.ipv4Options = ipv4Options;
				return this;
			}
			@Override
			public Builder setWildcardOptions(WildcardOptions wildcardOptions) {
				return (Builder) super.setWildcardOptions(wildcardOptions);
			}
			@Override
			public Builder setExpandedSegments(boolean expandSegments) {
				return (Builder) super.setExpandedSegments(expandSegments);
			}
			@Override
			public Builder setRadix(int base) {
				return (Builder) super.setRadix(base);
			}
			@Override
			public Builder setSeparator(Character separator) {
				return (Builder) super.setSeparator(separator);
			}
			@Override
			public Builder setZoneSeparator(char separator) {
				return (Builder) super.setZoneSeparator(separator);
			}
			@Override
			public Builder setAddressSuffix(String suffix) {
				return (Builder) super.setAddressSuffix(suffix);
			}
			@Override
			public Builder setSegmentStrPrefix(String prefix) {
				return (Builder) super.setSegmentStrPrefix(prefix);
			}
			@Override
			public Builder setReverse(boolean reverse) {
				return (Builder) super.setReverse(reverse);
			}
			@Override
			public Builder setUppercase(boolean upper) {
				return (Builder) super.setUppercase(upper);
			}
			@Override
			public Builder setSplitDigits(boolean splitDigits) {
				return (Builder) super.setSplitDigits(splitDigits);
			}
			@Override
			public IPv6StringOptions toOptions() {
				return new IPv6StringOptions(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, makeMixed, ipv4Options, compressOptions, separator, zoneSeparator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	@Override
	public RangeList getZeroSegments() {
		if(zeroSegments == null) {
			zeroSegments = super.getZeroSegments();
		}
		return zeroSegments;
	}
	@Override
	public RangeList getZeroRangeSegments() {
		if(zeroRanges == null) {
			zeroRanges = super.getZeroRangeSegments();
		}
		return zeroRanges;
	}
	@Override
	public boolean isZero() {
		RangeList ranges = getZeroSegments();
		return ranges.size() == 1 && ranges.getRange(0).length == getSegmentCount();
	}
	private int[] getCompressIndexAndCount(CompressOptions options) {
		return getCompressIndexAndCount(options, false);
	}
	private int[] getCompressIndexAndCount(CompressOptions options, boolean createMixed) {
		if(options != null) {
			CompressionChoiceOptions rangeSelection = options.rangeSelection;
			RangeList compressibleSegs = rangeSelection.compressHost() ? getZeroRangeSegments() : getZeroSegments();
			int maxIndex = -1, maxCount = 0;
			int segmentCount = getSegmentCount();
			boolean compressMixed = createMixed && options.compressMixedOptions.compressMixed(this);
			boolean preferHost = (rangeSelection == CompressOptions.CompressionChoiceOptions.HOST_PREFERRED);
			boolean preferMixed = createMixed && (rangeSelection == CompressOptions.CompressionChoiceOptions.MIXED_PREFERRED);
			for(int i = compressibleSegs.size() - 1; i >= 0 ; i--) {
				Range range = compressibleSegs.getRange(i);
				int index = range.index;
				int count = range.length;
				if(createMixed) {
					int mixedIndex = IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex;
					if(!compressMixed ||
							index > mixedIndex || index + count < segmentCount) { 
						count = Math.min(count, mixedIndex - index);
					}
				}
				if(count > 0 && count >= maxCount && (options.compressSingle || count > 1)) {
					maxIndex = index;
					maxCount = count;
				}
				if(preferHost && isPrefixed() &&
						((index + count) * getBitsPerSegment()) > getNetworkPrefixLength()) { 
					break;
				}
				if(preferMixed && index + count >= segmentCount) { 
					break;
				}
			}
			if(maxIndex >= 0) {
				return new int[] {maxIndex, maxCount};
			}
		}
		return null;
	}
	static class IPv6StringParams extends IPAddressStringParams<IPv6AddressSection> {
		int firstCompressedSegmentIndex, nextUncompressedIndex; 
		boolean hostCompressed; 
		IPv6StringParams() {
			this(-1, 0);
		}
		IPv6StringParams(int firstCompressedSegmentIndex, int compressedCount) {
			this(false, firstCompressedSegmentIndex, compressedCount, false, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.ZONE_SEPARATOR);
		}
		private IPv6StringParams(
				boolean expandSegments,
				int firstCompressedSegmentIndex,
				int compressedCount,
				boolean uppercase, 
				char separator,
				char zoneSeparator) {
			super(IPv6Address.DEFAULT_TEXTUAL_RADIX, separator, uppercase, zoneSeparator);
			this.expandSegments(expandSegments);
			this.firstCompressedSegmentIndex = firstCompressedSegmentIndex;
			this.nextUncompressedIndex = firstCompressedSegmentIndex + compressedCount;
		}
		public boolean endIsCompressed(IPAddressStringDivisionSeries addr) {
			return nextUncompressedIndex >= addr.getDivisionCount();
		}
		public boolean isCompressed(IPAddressStringDivisionSeries addr) {
			return firstCompressedSegmentIndex >= 0;
		}
		@Override
		public int getTrailingSeparatorCount(IPv6AddressSection addr) {
			return getTrailingSepCount(addr);
		}
		public int getTrailingSepCount(IPAddressStringDivisionSeries addr) {
			int divisionCount = addr.getDivisionCount();
			if(divisionCount == 0) {
				return 0;
			}
			int count = divisionCount - 1;
			if(isCompressed(addr)) {
				count -= (nextUncompressedIndex - firstCompressedSegmentIndex) - 1; 
				if(firstCompressedSegmentIndex == 0  || 
						nextUncompressedIndex >= divisionCount ) {
					count++;
				}
			}
			return count;
		}
		@Override
		public int getStringLength(IPv6AddressSection addr) {
			int count = getSegmentsStringLength(addr);
			if(!isReverse() && (!preferWildcards() || hostCompressed)) {
				count += getPrefixIndicatorStringLength(addr);
			}
			count += getAddressSuffixLength();
			count += getAddressLabelLength();
			return count;
		}
		@Override
		public StringBuilder append(StringBuilder builder, IPv6AddressSection addr, CharSequence zone) {
			appendSuffix(appendZone(appendSegments(appendLabel(builder), addr), zone));
			if(!isReverse() && (!preferWildcards() || hostCompressed)) {
				appendPrefixIndicator(builder, addr);
			}
			return builder;
		}
		@Override
		public StringBuilder appendSegments(StringBuilder builder, IPv6AddressSection addr) {
			int divisionCount = addr.getDivisionCount();
			if(divisionCount <= 0) {
				return builder;
			}
			int lastIndex = divisionCount - 1;
			Character separator = getSeparator();
			boolean reverse = isReverse();
			int i = 0;
			while(true) {
				int segIndex = reverse ? lastIndex - i : i;
				if(segIndex < firstCompressedSegmentIndex || segIndex >= nextUncompressedIndex) {
					appendSegment(segIndex, builder, addr);
					if(++i > lastIndex) {
						break;
					}
					if(separator != null) {
						builder.append(separator);
					}
				} else {
					if(segIndex == (reverse ? nextUncompressedIndex - 1 :  firstCompressedSegmentIndex) && separator != null) { 
						builder.append(separator);
						if(i == 0) {
							builder.append(separator);
						}
					} 
					if(++i > lastIndex) {
						break;
					}
				}
			}
			return builder;
		}
		@Override
		public int getSegmentsStringLength(IPv6AddressSection part) {
			int count = 0;
			int divCount = part.getDivisionCount();
			if(divCount != 0) {
				Character separator = getSeparator();
				int i = 0;
				while(true) {
					if(i < firstCompressedSegmentIndex || i >= nextUncompressedIndex) {
						count += appendSegment(i, null, part);
						if(++i >= divCount) {
							break;
						}
						if(separator != null) {
							count++;
						}
					} else {
						if(i == firstCompressedSegmentIndex && separator != null) { 
							count++;
							if(i == 0) {
								count++;
							}
						} 
						if(++i >= divCount) {
							break;
						}
					}
				}
			}
			return count;
		}
		@Override
		public IPv6StringParams clone() {
			return (IPv6StringParams) super.clone();
		}
	}
	static class EmbeddedIPv6AddressSection extends IPv6AddressSection {
		private static final long serialVersionUID = 4L;
		private final IPAddressSection encompassingSection;
		EmbeddedIPv6AddressSection(IPAddressSection encompassingSection, IPv6AddressSegment subSegments[], int startIndex) {
			super(subSegments, startIndex, false);
			this.encompassingSection = encompassingSection;
		}
		@Override
		public boolean isPrefixBlock() {
			return encompassingSection.isPrefixBlock();
		}
	}
	public static class IPv6v4MixedAddressSection extends IPAddressDivisionGrouping {
		private static final long serialVersionUID = 4L;
		private final IPv6AddressSection ipv6Section;
		private final IPv4AddressSection ipv4Section;
		private String string;
		private IPv6v4MixedAddressSection(
				IPv6AddressSection ipv6Section,
				IPv4AddressSection ipv4Section) {
			super(createSegments(ipv6Section, ipv4Section), ipv6Section.getNetwork());
			if(ipv6Section.isPrefixed()) {
				if(!ipv4Section.isPrefixed() || ipv4Section.getNetworkPrefixLength() != 0) {
					throw new InconsistentPrefixException(ipv6Section, ipv4Section, ipv4Section.getNetworkPrefixLength());
				}
				cachedPrefixLength = ipv6Section.getNetworkPrefixLength();
			} else if(ipv4Section.isPrefixed()) {
				cachedPrefixLength = cacheBits(ipv4Section.getNetworkPrefixLength() + ipv6Section.getBitCount());
			} else {
				cachedPrefixLength = NO_PREFIX_LENGTH;
			}
			this.ipv4Section = ipv4Section;
			this.ipv6Section = ipv6Section;
		}
		private static IPAddressDivision[] createSegments(IPv6AddressSection ipv6Section, IPv4AddressSection ipv4Section) {
			int ipv6Len = ipv6Section.getSegmentCount();
			int ipv4Len = ipv4Section.getSegmentCount();
			if(ipv6Len + ((ipv4Len + 1) >> 1) + ipv6Section.addressSegmentIndex > IPv6Address.SEGMENT_COUNT) {
				throw new AddressValueException(ipv6Section, ipv4Section);
			}
			IPAddressSegment allSegs[] = new IPAddressSegment[ipv6Len + ipv4Len];
			ipv6Section.getSegments(0, ipv6Len, allSegs, 0);
			ipv4Section.getSegments(0, ipv4Len, allSegs, ipv6Len);
			return allSegs;
		}
		@Override
		public int getByteCount() {
			return ipv6Section.getByteCount() + ipv4Section.getByteCount();
		}
		@Override
		public int getBitCount() {
			return ipv6Section.getBitCount() + ipv4Section.getBitCount();
		}
		@Override
		public boolean isPrefixBlock() {
			Integer networkPrefixLength = getNetworkPrefixLength();
			if(networkPrefixLength == null) {
				return false;
			}
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return true;
			}
			if(ipv6Section.isPrefixed()) {
				return ipv6Section.isPrefixBlock() && ipv4Section.isFullRange();
			}
			return ipv4Section.isPrefixBlock();
		}
		@Override
		public String toString() {
			if(string == null) {
				IPv6StringOptions mixedParams = IPv6StringCache.mixedParams;
				IPv6StringParams ipv6Params = mixedParams.from(ipv6Section);
				IPStringOptions ipv4Opts = mixedParams.ipv4Opts;
				IPv6v4MixedParams parms = new IPv6v4MixedParams(ipv6Params, ipv4Opts);
				string = parms.toString(this);
			}
			return string;
		}
		@Override
		protected boolean isSameGrouping(AddressDivisionGroupingBase o) {
			if(o instanceof IPv6v4MixedAddressSection) {
				IPv6v4MixedAddressSection other = (IPv6v4MixedAddressSection) o;
				return ipv6Section.equals(other.ipv6Section) && ipv4Section.equals(other.ipv4Section);
			}
			return false;
		}
		@Override
		public boolean equals(Object o) {
			if(o == this) {
				return true;
			}
			if(o instanceof IPv6v4MixedAddressSection) {
				IPv6v4MixedAddressSection other = (IPv6v4MixedAddressSection) o;
				return ipv6Section.equals(other.ipv6Section) && ipv4Section.equals(other.ipv4Section);
			}
			return false;
		}
	}
	static class IPv6v4MixedParams implements IPAddressStringWriter<IPv6v4MixedAddressSection>, Cloneable {
		private IPAddressStringParams<IPAddressStringDivisionSeries> ipv4Params; 
		private IPv6StringParams ipv6Params;
		@SuppressWarnings("unchecked")
		IPv6v4MixedParams(IPv6AddressSectionString ipv6Variation, IPAddressPartConfiguredString<?, ?> ipv4Variation) {
			this.ipv4Params = (IPAddressStringParams<IPAddressStringDivisionSeries>) ipv4Variation.stringParams;
			this.ipv6Params = ipv6Variation.stringParams;
		}
		IPv6v4MixedParams(IPv6StringParams ipv6Params, IPStringOptions ipv4Opts) {
			this.ipv4Params = IPAddressSection.toIPParams(ipv4Opts);
			this.ipv6Params = ipv6Params;
		}
		@Override
		public char getTrailingSegmentSeparator() {
			return ipv4Params.getTrailingSegmentSeparator();
		}
		@Override
		public int getTrailingSeparatorCount(IPv6v4MixedAddressSection addr) {
			return ipv4Params.getTrailingSeparatorCount(addr.ipv4Section);
		}
		public int getStringLength(IPv6v4MixedAddressSection addr, CharSequence zone) {
			int ipv6length = ipv6Params.getSegmentsStringLength(addr.ipv6Section);
			int ipv4length = ipv4Params.getSegmentsStringLength(addr.ipv4Section);
			int length = ipv6length + ipv4length;
			if(ipv6Params.nextUncompressedIndex < addr.ipv6Section.getSegmentCount()) {
				length++;
			}
			length += getPrefixStringLength(addr);
			length += ipv6Params.getZoneLength(zone);
			length += ipv6Params.getAddressSuffixLength();
			length += ipv6Params.getAddressLabelLength();
			return length;
		}
		@Override
		public String toString(IPv6v4MixedAddressSection addr) {
			return toString(addr, null);
		}
		@Override
		public String toString(IPv6v4MixedAddressSection addr, CharSequence zone) {
			int length = getStringLength(addr, zone);
			StringBuilder builder = new StringBuilder(length);
			append(builder, addr, zone);
			AddressStringParams.checkLengths(length, builder);
			return builder.toString();
		}
		@Override
		public int getDivisionStringLength(AddressStringDivision seg) {
			return ipv6Params.getDivisionStringLength(seg);
		}
		@Override
		public StringBuilder appendDivision(StringBuilder builder, AddressStringDivision seg) {
			return ipv6Params.appendDivision(builder, seg);
		}
		public StringBuilder append(StringBuilder builder, IPv6v4MixedAddressSection addr, CharSequence zone) {
			ipv6Params.appendLabel(builder);
			ipv6Params.appendSegments(builder, addr.ipv6Section);
			if(ipv6Params.nextUncompressedIndex < addr.ipv6Section.getSegmentCount()) {
				builder.append(ipv6Params.getTrailingSegmentSeparator());
			}
			ipv4Params.appendSegments(builder, addr.ipv4Section);
			ipv6Params.appendZone(builder, zone);
			ipv6Params.appendSuffix(builder);
			appendPrefixIndicator(builder, addr);
			return builder;
		}
		protected int getPrefixStringLength(IPv6v4MixedAddressSection addr) {
			if(requiresPrefixIndicator(addr.ipv6Section) || requiresPrefixIndicator(addr.ipv4Section)) {
				return IPAddressStringParams.getPrefixIndicatorStringLength(addr);
			}
			return 0;
		}
		public void appendPrefixIndicator(StringBuilder builder, IPv6v4MixedAddressSection addr) {
			if(requiresPrefixIndicator(addr.ipv6Section) || requiresPrefixIndicator(addr.ipv4Section)) {
				ipv6Params.appendPrefixIndicator(builder, addr);
			}
		}
		protected boolean requiresPrefixIndicator(IPv4AddressSection ipv4Section)    {
			return ipv4Section.isPrefixed() && !ipv4Params.preferWildcards();
		}
		protected boolean requiresPrefixIndicator(IPv6AddressSection ipv6Section)    {
			return ipv6Section.isPrefixed() && (!ipv6Params.preferWildcards() || ipv6Params.hostCompressed);
		}
		@Override
		public IPv6v4MixedParams clone() {
			try {
				IPv6v4MixedParams params = (IPv6v4MixedParams) super.clone();
				params.ipv6Params = ipv6Params.clone();
				params.ipv4Params = ipv4Params.clone();
				return params;
			} catch(CloneNotSupportedException e) {
				 return null;
			}
		}
	}
	static class IPv6AddressSectionStringCollection extends IPAddressPartStringSubCollection<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString> {
		private final CharSequence zone;
		IPv6AddressSectionStringCollection(IPv6AddressSection addr, CharSequence zone) {
			super(addr);
			this.zone = zone;
		}
		@Override
		public Iterator<IPv6AddressSectionString> iterator() {
			return new IPAddressConfigurableStringIterator() {
				@Override
				public IPv6AddressSectionString next() {
					return new IPv6AddressSectionString(part, iterator.next(), zone); 
				}
			};
		}
	}
	static class IPv6v4MixedStringCollection
		extends IPAddressPartStringSubCollection<IPv6v4MixedAddressSection, IPv6v4MixedParams, IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>> {
		private final CharSequence zone;
		public IPv6v4MixedStringCollection(IPv6v4MixedAddressSection part, CharSequence zone) {
			super(part);
			this.zone = zone;
		}
		@Override
		public Iterator<IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>> iterator() {
			return new IPAddressConfigurableStringIterator() {
				@Override
				public IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams> next() {
					return new IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>(part, iterator.next()) {
						@Override
						public String getString() {
							if(string == null) {
								string = stringParams.toString(addr, zone);
							}
							return string;
						}
					};
				}
			};
		}
	}
	static class IPv6StringCollection extends IPAddressPartStringCollection {
		@Override
		protected void add(IPAddressPartStringSubCollection<?, ?, ?> collection) {
			super.add(collection);
		}
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
		static class IPv6StringBuilder
				extends AddressPartStringBuilder<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString, IPv6AddressSectionStringCollection, IPv6StringBuilderOptions> {
			IPv6StringBuilder(IPv6AddressSection address, IPv6StringBuilderOptions opts, CharSequence zone) {
				super(address,  opts, new IPv6AddressSectionStringCollection(address, zone));
			}
			private void addUppercaseVariations(ArrayList<IPv6StringParams> allParams, int base) {
				boolean lowerOnly = true; 
				if(options.includes(IPv6StringBuilderOptions.UPPERCASE) && addressSection.hasUppercaseVariations(base, lowerOnly)) {
					int len = allParams.size();
					for(int j=0; j<len; j++) {
						IPv6StringParams clone = allParams.get(j);
						clone = clone.clone();
						clone.setUppercase(true);
						allParams.add(clone);
					}
				}
			}
			private void addAllExpansions(int firstCompressedIndex, int count, int segmentCount) {
				IPv6StringParams stringParams = new IPv6StringParams(firstCompressedIndex, count);
				int base = stringParams.getRadix();
				final ArrayList<IPv6StringParams> allParams = new ArrayList<>();
				allParams.add(stringParams);
				int radix = IPv6Address.DEFAULT_TEXTUAL_RADIX;
				if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS)) {
					int expandables[] = getExpandableSegments(radix);
					int nextUncompressedIndex = firstCompressedIndex + count;
					int ipv6SegmentEnd = addressSection.getSegmentCount();
					for(int i=0; i < ipv6SegmentEnd; i++) {
						if(i < firstCompressedIndex || i >= nextUncompressedIndex) {
							int expansionLength = expandables[i];
							int len = allParams.size();
							while(expansionLength > 0) {		
								for(int j=0; j<len; j++) {
									IPv6StringParams clone = allParams.get(j);
									clone = clone.clone();
									clone.expandSegment(i, expansionLength, addressSection.getSegmentCount());
									allParams.add(clone);
								}
								if(!options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS)) {
									break;
								}
								expansionLength--;
							}
						}
					}
				} else if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS)) {
					boolean isExpandable = isExpandableOutsideRange(radix, firstCompressedIndex, count);
					if(isExpandable) {
						int len = allParams.size();
						for(int j=0; j<len; j++) {
							IPv6StringParams clone = allParams.get(j);
							clone = clone.clone();
							clone.expandSegments(true);
							allParams.add(clone);
						}
					}
				}
				addUppercaseVariations(allParams, base);
				for(int i=0; i<allParams.size(); i++) {
					IPv6StringParams param = allParams.get(i);
					addStringParam(param);
				}	
			}
			private void addAllCompressedStrings(int zeroStartIndex, int count, boolean partial, int segmentCount) {
				int end = zeroStartIndex + count;
				if(partial) {
					for(int i = zeroStartIndex; i < end; i++) {
						for(int j = i + 1; j <= end; j++) {
							addAllExpansions(i, j - i, segmentCount);
						}	
					}
				} else {
					int len = end - zeroStartIndex;
					if(len > 0) {
						addAllExpansions(zeroStartIndex, len, segmentCount);
					}
				}
			}
			@Override
			protected void addAllVariations() {
				int segmentCount = addressSection.getSegmentCount();
				addAllExpansions(-1, 0, segmentCount);
				if(options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_FULL)) {
					RangeList zeroSegs  = addressSection.getZeroSegments();
					for(int i = 0; i < zeroSegs.size(); i++) {
						Range range = zeroSegs.getRange(i);
						addAllCompressedStrings(range.index, range.length, options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_PARTIAL), segmentCount);
					}
				} else if(options.includes(IPv6StringBuilderOptions.COMPRESSION_CANONICAL)) {
					CompressOptions opts = new CompressOptions(options.includes(IPv6StringBuilderOptions.COMPRESSION_SINGLE), CompressOptions.CompressionChoiceOptions.ZEROS);
					int indexes[] = addressSection.getCompressIndexAndCount(opts);
					if(indexes != null) {
						if(options.includes(IPv6StringBuilderOptions.COMPRESSION_LARGEST)) {
							int maxCount = indexes[1];
							RangeList zeroSegs  = addressSection.getZeroSegments();
							for(int i = 0; i < zeroSegs.size(); i++) {
								Range range = zeroSegs.getRange(i);
								int count = range.length;
								if(count == maxCount) {
									addAllCompressedStrings(range.index, count, options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_PARTIAL), segmentCount);
								}
							}
						} else {
							int maxIndex = indexes[0];
							int maxCount = indexes[1];
							addAllCompressedStrings(maxIndex, maxCount, false, segmentCount);
						}
					} 
				}
			}
		}
		static class IPv6v4MixedStringBuilder
				extends AddressPartStringBuilder<
					IPv6v4MixedAddressSection,
					IPv6v4MixedParams,
					IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>,
					IPv6v4MixedStringCollection,
					IPv6StringBuilderOptions> {
			private final CharSequence zone;
			IPv6v4MixedStringBuilder(IPv6v4MixedAddressSection address, IPv6StringBuilderOptions opts, CharSequence zone) {
				super(address, opts, new IPv6v4MixedStringCollection(address, zone));
				this.zone = zone;
			}
			@Override
			protected void addAllVariations() {
				IPv6StringBuilder ipv6Builder = new IPv6StringBuilder(addressSection.ipv6Section, options, zone);
				IPv6AddressSectionStringCollection ipv6Variations = ipv6Builder.getVariations();
				IPAddressPartStringCollection ipv4Collection = 
						addressSection.ipv4Section.toStringCollection(options.mixedOptions);
				for(IPv6AddressSectionString ipv6Variation : ipv6Variations) {
					for(IPAddressPartConfiguredString<?, ?> ipv4Variation : ipv4Collection) {
						IPv6v4MixedParams mixed = new IPv6v4MixedParams(ipv6Variation, ipv4Variation);
						addStringParam(mixed);
					}
				}
			}
		}
	}
	private static class IPv6AddressSectionString extends IPAddressPartConfiguredString<IPv6AddressSection, IPv6StringParams> {
		private final CharSequence zone;
		IPv6AddressSectionString(IPv6AddressSection addr, IPv6StringParams stringParams, CharSequence zone) {
			super(addr, stringParams);
			this.zone = zone;
		}
		@SuppressWarnings("unchecked")
		@Override
		public IPv6StringMatcher getNetworkStringMatcher(boolean isEntireAddress, IPAddressSQLTranslator translator) {
			return new IPv6StringMatcher(this, translator);
		}
		public boolean endIsCompressed() {
			return stringParams.endIsCompressed(addr);
		}
		public boolean isCompressed() {
			return stringParams.isCompressed(addr);
		}
		@Override
		public String getString() {
			if(string == null) {
				string = stringParams.toString(addr, zone);
			}
			return string;
		}
	}
	public static class IPv6StringBuilderOptions extends IPStringBuilderOptions {
		public static final int MIXED = 0x2;
		public static final int UPPERCASE = 0x4;
		public static final int COMPRESSION_CANONICAL = 0x100; 
		public static final int COMPRESSION_SINGLE = COMPRESSION_CANONICAL | 0x200; 
		public static final int COMPRESSION_LARGEST = COMPRESSION_SINGLE | 0x400; 
		public static final int COMPRESSION_ALL_FULL = COMPRESSION_LARGEST | 0x800; 
		public static final int COMPRESSION_ALL_PARTIAL = COMPRESSION_ALL_FULL | 0x1000;
		public static final int IPV4_CONVERSIONS = 0x10000;
		public final IPv4StringBuilderOptions mixedOptions;
		public final IPv4StringBuilderOptions ipv4ConverterOptions;
		public final IPv4AddressConverter converter;
		public static final IPv6StringBuilderOptions STANDARD_OPTS = new IPv6StringBuilderOptions(
				IPStringBuilderOptions.BASIC |
					IPv6StringBuilderOptions.UPPERCASE |
					IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS |
					IPv6StringBuilderOptions.COMPRESSION_ALL_FULL, 
			new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS));
		public static final IPv6StringBuilderOptions ALL_OPTS =  
				new IPv6StringBuilderOptions(
						IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.MIXED | 
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL |
							IPv6StringBuilderOptions.IPV4_CONVERSIONS |
							IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS, 
						new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS),
						null,
						new IPv4StringBuilderOptions(
							IPStringBuilderOptions.BASIC | 
								IPv4StringBuilderOptions.JOIN_ALL | 
								IPv4StringBuilderOptions.JOIN_TWO | 
								IPv4StringBuilderOptions.JOIN_ONE |
								IPv4StringBuilderOptions.HEX |
								IPv4StringBuilderOptions.OCTAL |IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
		public static final IPv6StringBuilderOptions DATABASE_SEARCH_OPTS =
				new IPv6StringBuilderOptions(IPStringBuilderOptions.BASIC | IPv6StringBuilderOptions.COMPRESSION_LARGEST);
		public IPv6StringBuilderOptions(int options) {
			this(options, null, null, null);
		}
		public IPv6StringBuilderOptions(int options, IPv4StringBuilderOptions mixedOptions) {
			this(options, mixedOptions, null, null);
		}
		public IPv6StringBuilderOptions(int options, IPv4StringBuilderOptions mixedOptions, IPv4AddressConverter ipv4AddressConverter, IPv4StringBuilderOptions ipv4ConverterOptions) {
			super(options | (mixedOptions == null ? 0 : MIXED) | (ipv4ConverterOptions == null ? 0 : IPV4_CONVERSIONS));
			if(includes(MIXED) && mixedOptions == null) {
				mixedOptions = new IPv4StringBuilderOptions();
			}
			this.mixedOptions = mixedOptions;
			if(includes(IPV4_CONVERSIONS)) {
				if(ipv4ConverterOptions == null) {
					ipv4ConverterOptions = new IPv4StringBuilderOptions();
				}
				if(ipv4AddressConverter == null) {
					ipv4AddressConverter = IPAddress.DEFAULT_ADDRESS_CONVERTER;
				}
			}
			this.ipv4ConverterOptions = ipv4ConverterOptions;
			this.converter = ipv4AddressConverter;
		}
		public static IPv6StringBuilderOptions from(IPStringBuilderOptions opts) {
			if(opts instanceof IPv6StringBuilderOptions) {
				return (IPv6StringBuilderOptions) opts;
			}
			return new IPv6StringBuilderOptions(opts.options & ~(MIXED | UPPERCASE | COMPRESSION_ALL_PARTIAL | IPV4_CONVERSIONS));
		}
	}
}
package inet.ipaddr.format.validate;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.AddressItem;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv4.IPv4AddressSeqRange;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public class ParsedIPAddress extends IPAddressParseData implements IPAddressProvider {
	private static final long serialVersionUID = 4L;
	private static final ExtendedMasker DEFAULT_MASKER = new ExtendedMasker(true);
	private static final ExtendedMasker DEFAULT_NON_SEQUENTIAL_MASKER = new ExtendedMasker(false);
	private static final ExtendedFullRangeMasker EXTENDED_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	private static final ExtendedFullRangeMasker EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	private static final WrappedMasker WRAPPED_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	private static final WrappedMasker WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	private static final FullRangeMasker FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	private static final FullRangeMasker SEQUENTIAL_FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	private static final BitwiseOrer DEFAULT_OR_MASKER = new BitwiseOrer(true);
	private static final BitwiseOrer DEFAULT_NON_SEQUENTIAL_OR_MASKER = new BitwiseOrer(false);
	private static final FullRangeBitwiseOrer FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final FullRangeBitwiseOrer SEQUENTIAL_FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final BigInteger ONE_EXTENDED = new BigInteger(1, new byte[] {1, 0, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger HIGH_BIT = new BigInteger(1, new byte[] {(byte) 0x80, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger ONE_SHIFTED[] = new BigInteger[64];
	private static final BigInteger ONE_SHIFTED_EXTENDED[] = new BigInteger[64];
	private static final BigInteger NETWORK_MASK_EXTENDED[] = new BigInteger[64];
	private static final BigInteger HOST_MASK_EXTENDED[] = new BigInteger[64];
	static class CachedIPAddresses<T extends IPAddress> implements Serializable {
		private static final long serialVersionUID = 4L;
		protected T address, hostAddress;
		CachedIPAddresses() {}
		public CachedIPAddresses(T address) {
			this(address, address);
		}
		public CachedIPAddresses(T address, T hostAddress) {
			this.address = address;
			this.hostAddress = hostAddress;
		}
		public T getAddress() {
			return address;
		}
		public T getHostAddress() {
			return hostAddress;
		}
	}
	abstract class TranslatedResult<T extends IPAddress, R extends IPAddressSection> extends CachedIPAddresses<T> {
		private static final long serialVersionUID = 4L;
		private R section, hostSection, lowerSection, upperSection;
		private IncompatibleAddressException joinHostException, joinAddressException , mixedException, maskException;
		private IPAddressSeqRange range;
		private T rangeLower, rangeUpper;
		private IPAddressDivisionSeries series;
		abstract ParsedAddressCreator<T, R, ?, ?> getCreator();
		@Override
		public T getAddress() {
			if(address == null) {
				if(range == null) {
					address = getCreator().createAddressInternal(section, getZone(), originator);
				} else {
					address = getCreator().createAddressInternal(section, getZone(), originator, rangeLower, rangeUpper);
				}
			}
			return address;
		}
		boolean hasLowerSection() {
			return lowerSection != null;
		}
		boolean hasHostAddress() {
			return hostAddress != null;
		}
		boolean hasAddress() {
			return address != null;
		}
		@Override
		public T getHostAddress() {
			if(hostSection == null) {
				return getAddress();
			}
			if(hostAddress == null) {
				hostAddress = getCreator().createAddressInternal(hostSection, getZone(), null);
			}
			return hostAddress;
		}
		R getSection() {
			return section;
		}
		private CharSequence getZone() {
			return getQualifier().getZone();
		}
		boolean withoutSections() {
			return section == null;
		}
		boolean withoutAddressException() {
			return joinAddressException == null && mixedException == null && maskException == null;
		}
		boolean withoutRange() {
			return range == null;
		}
		boolean withoutGrouping() {
			return series == null;
		}
		IPAddressSeqRange createRange() {
			rangeLower = getCreator().createAddressInternal(lowerSection, getZone(), null);
			rangeUpper = upperSection == null ? rangeLower : getCreator().createAddressInternal(upperSection, getZone(), null);
			return range = rangeLower.spanWithRange(rangeUpper);
		}
		IPAddress getValForMask() {
			return getCreator().createAddressInternal(lowerSection, null, null);
		}
	}
	private final IPAddressStringParameters options;
	private final HostIdentifierString originator;
	private TranslatedResult<?,?> values;
	private Masker maskers[];
	private Masker mixedMaskers[];
	ParsedIPAddress(
			HostIdentifierString from, 
			CharSequence addressString,
			IPAddressStringParameters options) {
		super(addressString);
		this.options = options;
		this.originator = from;
	}
	private IPv6AddressCreator getIPv6AddressCreator() {
		return getParameters().getIPv6Parameters().getNetwork().getAddressCreator();
	}
	private IPv4AddressCreator getIPv4AddressCreator() {
		return getParameters().getIPv4Parameters().getNetwork().getAddressCreator();
	}
	@Override
	public boolean isProvidingIPAddress() {
		return true;
	}
	@Override
	public IPAddressProvider.IPType getType() {
		return IPType.from(getProviderIPVersion());
	}
	@Override
	public IPAddressStringParameters getParameters() {
		return options;
	}
	void createSections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		IPVersion version = getProviderIPVersion();
		if(version.isIPv4()) {
			createIPv4Sections(doAddress, doRangeBoundaries, withUpper);
		} else if(version.isIPv6()) {
			createIPv6Sections(doAddress, doRangeBoundaries, withUpper);
		}
	}
	@Override
	public IPAddressSeqRange getProviderSeqRange() {
		TranslatedResult<?,?> val = values;
		if(val == null || val.range == null) {
			synchronized(this) {
				val = values;
				if(val == null || val.range == null) {
					if(val != null && !val.withoutSections() && val.withoutAddressException()) {
						val.range = val.getAddress().toSequentialRange();
					} else {
						createSections(false, true, true);
						val = values;
						val.createRange();
						if(isDoneTranslating()) {
							releaseSegmentData();
						}
					}
				}
			}
		}
		return val.range;
	}
	IPAddress getValForMask() {
		TranslatedResult<?,?> val = values;
		if(val == null || !val.hasLowerSection()) {
			synchronized(this) {
				val = values;
				if(val == null || !val.hasLowerSection()) {
					createSections(false, true, false);
					val = values;
					releaseSegmentData(); 
				}
			}
		}
		return val.getValForMask();
	}
	@Override
	public IPAddress getProviderMask() {
		return getQualifier().getMaskLower();
	}
	boolean isDoneTranslating() {
		TranslatedResult<?,?> val = values;
		return !val.withoutSections()  && 
				(val.withoutAddressException() 
						|| !val.withoutRange() ) &&
				!val.withoutGrouping();
	}
	TranslatedResult<?,?> getCachedAddresses(boolean forHostAddr)  {
		TranslatedResult<?,?> val = values;
		if(val == null || val.withoutSections()) {
			synchronized(this) {
				val = values;
				if(val == null || val.withoutSections()) {
					createSections(true, false, false);
					val = values;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				} 
				if(forHostAddr) {
					val.getHostAddress();
				} else {
					val.getAddress();
				}
			}
		} else {
			if(forHostAddr ? !val.hasHostAddress() : !val.hasAddress()) {
				synchronized(this) {
					if(forHostAddr) {
						val.getHostAddress();
					} else {
						val.getAddress();
					}
				}
			}
		}
		return val;
	}
	@Override
	public IPAddress getProviderHostAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(true);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.joinHostException != null) {
			throw addrs.joinHostException;
		}
		return addrs.getHostAddress();
	}
	@Override
	public IPAddress getProviderAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(false);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.maskException != null) {
			throw addrs.maskException;
		} else if(addrs.joinAddressException != null) {
			throw addrs.joinAddressException;
		}
		return addrs.getAddress();
	}
	@Override
	public IPAddress getProviderAddress(IPVersion version) throws IncompatibleAddressException {
		IPVersion thisVersion = getProviderIPVersion();
		if(!version.equals(thisVersion)) {
			return null;
		}
		return getProviderAddress();
	}
	@Override
	public IPAddressDivisionSeries getDivisionGrouping() throws IncompatibleAddressException {
		TranslatedResult<?,?> val = values;
		IPAddressDivisionSeries grouping = null;
		if(val != null) {
			grouping = val.series;
			if(grouping != null) {
				return grouping;
			}
		}		
		if(val == null || (val.withoutSections() && val.withoutRange())) {
			synchronized(this) {
				val = values;
				if(val == null || (val.withoutSections() && val.withoutRange())) {
					createSections(true, false, false); 
				}
			}
		}
		val = values;
		grouping = val.series;
		if(grouping == null) {
			synchronized(val) {
				grouping = val.series;
				if(grouping == null) {
					ParsedHostIdentifierStringQualifier qualifier = getQualifier();
					IPVersion version = getProviderIPVersion();
					int defaultRadix;
					IPAddressNetwork<?, ?, ?, ?, ?> network;
					if(version.isIPv4()) {
						defaultRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv4Parameters().getNetwork();
					} else {
						defaultRadix = IPv6Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv6Parameters().getNetwork();
					}
					PrefixConfiguration prefixConfiguration = network.getPrefixConfiguration();
					boolean mixed = isProvidingMixedIPv6();
					AddressParseData addrParseData = getAddressParseData();
					int segmentCount = addrParseData.getSegmentCount();
					int totalCount = segmentCount;
					if(mixed) {
						totalCount += mixedParsedAddress.getSegmentCount();
					}
					Integer prefLength = getPrefixLength(qualifier);
					IPAddress mask = getProviderMask();
					if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
						mask = null;
					}
					boolean hasMask = mask != null;
					boolean isPrefixSubnet = false;
					if(prefLength != null) {
						if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
							isPrefixSubnet = true;
						} else if(prefixConfiguration.zeroHostsAreSubnets()) {
							if(mixed) {
								int k = segmentCount;
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_UPPER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_UPPER)),
										i -> (i < k ? addrParseData.getBitLength(i) : mixedParsedAddress.getBitLength(i - k)),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							} else {
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> addrParseData.getValue(i, AddressParseData.KEY_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_UPPER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER),
										i -> addrParseData.getBitLength(i),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							}
						} else {
							isPrefixSubnet = false;
						}
					}
					boolean isLarge = false;
					for(int i = 0; i < segmentCount; i++) {
						int bitLength = addrParseData.getBitLength(i);
						if(bitLength >= Long.SIZE) {
							isLarge = true;
							break;
						}
					}
					boolean isMergedMixed;
					if(mixed && (isMergedMixed = addrParseData.isMergedMixed(segmentCount - 1))) {
						totalCount--;
						segmentCount--;
						if(!isLarge && addrParseData.getBitLength(segmentCount) + mixedParsedAddress.getBitLength(0) >= Long.SIZE) {
							isLarge = true;
						}
					} else {
						isMergedMixed = false;
					}
					long maskVal = 0, extendedMaskVal = 0;
					int maskBits = 0;
					if(hasMask) {
						int bitsPerSegment = mask.getBitsPerSegment();
						for(int i = 0; i < IPv4Address.SEGMENT_COUNT; i++) {
							maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i).getSegmentValue();
						}
						if(mask.isIPv6()) {
							extendedMaskVal = maskVal; maskVal = 0;
							int remainingSegs = IPv6Address.SEGMENT_COUNT >> 1;
							for(int i = 0; i < remainingSegs; i++) {
								maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i + IPv4Address.SEGMENT_COUNT).getSegmentValue();
							}
							maskBits = bitsPerSegment * IPv6Address.SEGMENT_COUNT;
						} else {
							maskBits = bitsPerSegment * IPv4Address.SEGMENT_COUNT;
						}
					}
					int bitsSoFar = 0;
					int divRadix;
					if(isLarge) {
						IPAddressLargeDivision divs[] = new IPAddressLargeDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper, extendedLower, extendedUpper;
							int bitLength;
							boolean isExtended;
							boolean isNotMixed = i < segmentCount;
							if(isNotMixed) {
								bitLength = addrParseData.getBitLength(i);
								isExtended = bitLength > Long.SIZE;
								if(addrParseData.isWildcard(i)) {
									extendedLower = lower = 0;
									if(isExtended) {
										upper = 0xffffffffffffffffL;
										int shift = bitLength - Long.SIZE;
										extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
									} else {
										extendedUpper = 0;
										upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									}
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
									extendedLower = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);
									extendedUpper = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								isNotMixed = true;
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								extendedLower = lower = 0;
								isExtended = bitLength > Long.SIZE;
								if(isExtended) {
									upper = 0xffffffffffffffffL;
									int shift = bitLength - Long.SIZE;
									extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
								} else {
									upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									extendedUpper = 0;
								}
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								isExtended = false;
								extendedLower = extendedUpper = 0;
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									ExtendedMasker masker = (ExtendedMasker) (isNotMixed ? maskers[i] : mixedParsedAddress.maskers[i]);
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, (extendedMaskVal << 64) | maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(isExtended) {
										int extraMaskBits = maskBits - bitLength;
										long extendedDivMask = extendedMaskVal >>> extraMaskBits;
										divMask = (maskVal >>> extraMaskBits) | (extendedMaskVal << (Long.SIZE - extraMaskBits));
										extendedLower = masker.getExtendedMaskedLower(extendedLower, extendedDivMask);
										extendedUpper = masker.getExtendedMaskedUpper(extendedUpper, extendedDivMask);
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									} else {
										if(maskBits > Long.SIZE) {
											int extendedBits = maskBits - Long.SIZE;
											if(extendedBits >= bitLength) {
												divMask = extendedMaskVal >>> (extendedBits - bitLength);
											} else {
												int shortBits = bitLength - extendedBits;
												divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
											}
										} else {
											divMask = maskVal >>> (maskBits - bitLength);
										}
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									}
									maskBits -= bitLength;
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null && divPrefixLength < bitLength) {
									int unextendedBitLength, unextendedDivPrefixLength;
									if(isExtended) {
										int extendedDivBitLength = bitLength - Long.SIZE;
										unextendedBitLength = Long.SIZE;
										if(divPrefixLength > extendedDivBitLength) {
											unextendedDivPrefixLength = divPrefixLength - extendedDivBitLength;
										} else {
											unextendedDivPrefixLength = 0;
											int shift = extendedDivBitLength - divPrefixLength;
											if(shift == Long.SIZE) {
												extendedLower = 0;
												extendedUpper = 0xffffffffffffffffL;
											} else {
												long networkMask = ~0L << shift;
												extendedLower = extendedLower & networkMask;
												extendedUpper = extendedUpper | ~networkMask;
											}
										}
									} else {
										unextendedBitLength = bitLength;
										unextendedDivPrefixLength = divPrefixLength;
									}
									int shift = unextendedBitLength - unextendedDivPrefixLength;
									if(shift == Long.SIZE) {
										lower = 0;
										upper = 0xffffffffffffffffL;
									} else {
										long networkMask = ~0L << shift;
										lower = lower & networkMask;
										upper = upper | ~networkMask;
									}
								}
							}
							int numBytes = (bitLength + 7) / Byte.SIZE;
							byte lowerBytes[] = toBytes(lower, extendedLower, numBytes);
							byte upperBytes[] = toBytes(upper, extendedUpper, numBytes);
							divs[i] = new IPAddressLargeDivision(lowerBytes, upperBytes, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressLargeDivisionGrouping(divs, network);
					} else {
						IPAddressBitsDivision divs[] = new IPAddressBitsDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper;
							int bitLength;
							if(i < segmentCount) {
								bitLength = addrParseData.getBitLength(i);
								if(addrParseData.isWildcard(i)) {
									lower = 0;
									upper = ~(~0L << bitLength);
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								lower = 0;
								upper = ~(~0L << bitLength);
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									Masker masker = maskers[i];
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(maskBits > Long.SIZE) {
										int extendedBits = maskBits - Long.SIZE;
										if(extendedBits >= bitLength) {
											divMask = extendedMaskVal >>> (extendedBits - bitLength);
										} else {
											int shortBits = bitLength - extendedBits;
											divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
										}
									} else {
										divMask = maskVal >>> (maskBits - bitLength);
									}	
									maskBits -= bitLength;
									lower = masker.getMaskedLower(lower, divMask);
									upper = masker.getMaskedUpper(upper, divMask);
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null) {
									long networkMask = ~0L << (bitLength - divPrefixLength);
									lower = lower & networkMask;
									upper = upper | ~networkMask;
								}
							}
							divs[i] = new IPAddressBitsDivision(lower, upper, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressDivisionGrouping(divs, network);
					}
					val.series = grouping;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				}
			}
		}
		return grouping;
	}
	public static class BitwiseOrer implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		public BitwiseOrer(boolean isSequential) {
			this.isSequential = isSequential;
		}
		public long getOredLower(long value, long maskValue) {
			return value | maskValue;
		}
		public long getOredUpper(long upperValue, long maskValue) {
			return upperValue | maskValue;
		}
		public boolean isSequential() {
			return isSequential;
		}
	}
	public static class FullRangeBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		public FullRangeBitwiseOrer(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upperValue | upperMask, maskValue);
		}
	}
	public static class SpecificValueBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		public SpecificValueBitwiseOrer(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(lower, maskValue);
		}
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upper, maskValue);
		}
	}
	public static abstract class Masker implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		public Masker(boolean isSequential) {
			this.isSequential = isSequential;
		}
		public long getMaskedLower(long value, long maskValue) {
			return value & maskValue;
		}
		public long getMaskedUpper(long upperValue, long maskValue) {
			return upperValue & maskValue;
		}
		public boolean isSequential() {
			return isSequential;
		}
	}
	public static class FullRangeMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		public FullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
	}
	public static class SpecificValueMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		public SpecificValueMasker(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
	}
	public static class ExtendedMasker extends Masker {
		private static final long serialVersionUID = 1L;
		public ExtendedMasker(boolean isSequential) {
			super(isSequential);
		}
		@Deprecated
		public long getExtendedLowerMasked(long extendedValue, long extendedMaskValue) {
			return getExtendedMaskedLower(extendedValue, extendedMaskValue);
		}
		@Deprecated
		public long getExtendedUpperMasked(long extendedUpperValue, long extendedMaskValue) {
			return getExtendedMaskedUpper(extendedUpperValue, extendedMaskValue);
		}
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return extendedValue & extendedMaskValue;
		}
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return extendedUpperValue & extendedMaskValue;
		}
	}
	public static class ExtendedFullRangeMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final long upperMask, extendedUpperMask;
		ExtendedFullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			if(fullRangeBit >= Long.SIZE) {
				extendedUpperMask = 0;
				upperMask = ~0L >>> (fullRangeBit - Long.SIZE);
			} else {
				extendedUpperMask = ~0L >>> fullRangeBit;
				upperMask = 0xffffffffffffffffL;
			}
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedValue & ~extendedUpperMask, extendedMaskValue);
		}
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getMaskedUpper(extendedUpperValue | extendedUpperMask, extendedMaskValue);
		}
	}
	public static class ExtendedSpecificValueMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final long extendedLower, lower, extendedUpper, upper;
		public ExtendedSpecificValueMasker(long extendedLower, long lower, long extendedUpper, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
			this.extendedLower = extendedLower;
			this.extendedUpper = extendedUpper;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedLower, extendedMaskValue);
		}
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getExtendedMaskedUpper(extendedUpper, extendedMaskValue);
		}
	}
	public static class WrappedMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final Masker masker;
		WrappedMasker(Masker masker) {
			super(masker.isSequential());
			this.masker = masker;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return masker.getMaskedLower(value, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return masker.getMaskedUpper(upperValue, maskValue);
		}
	}
	@Deprecated
	public static ExtendedMasker maskRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		return maskExtendedRange(value, extendedValue, 
				upperValue, extendedUpperValue, 
				maskValue, extendedMaskValue, 
				maxValue, extendedMaxValue);
	}
	public static ExtendedMasker maskExtendedRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		long extendedDiffering = extendedValue ^ extendedUpperValue;
		if(extendedDiffering == 0) {
			Masker masker = maskRange(value, upperValue, maskValue, maxValue);
			if(masker == DEFAULT_MASKER) {
				return DEFAULT_MASKER;
			}
			if(masker instanceof FullRangeMasker) {
				int fullRangeBit = ((FullRangeMasker) masker).fullRangeBit;
				WrappedMasker cache[] = masker.isSequential() ? WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS : WRAPPED_FULL_RANGE_MASKERS;
				WrappedMasker result = cache[fullRangeBit];
				if(result == null) {
					cache[fullRangeBit] = result = new WrappedMasker(masker);
				}
				return result;
			}
			return new WrappedMasker(masker);
		}
		if(extendedValue > extendedUpperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if((maskValue == maxValue && extendedMaskValue == extendedMaxValue ) ||
				(maskValue == 0 && extendedMaskValue == 0 )) {
			return DEFAULT_MASKER;
		}
		int highestDifferingBitInRange = Long.numberOfLeadingZeros(extendedDiffering);
		long extendedDifferingMasked = extendedMaskValue & (~0L >>> highestDifferingBitInRange);
		int highestDifferingBitMasked;
		if(extendedDifferingMasked != 0) {
			boolean differingIsLowestBit = (extendedDifferingMasked == 1);
			highestDifferingBitMasked = Long.numberOfLeadingZeros(extendedDifferingMasked);
			boolean maskedIsSequential;
			long hostMask = ~0L >>> (highestDifferingBitMasked + 1);
			if(!differingIsLowestBit) { 
				maskedIsSequential = (extendedMaskValue & hostMask) == hostMask && maskValue == maxValue; 
			} else {
				maskedIsSequential = maskValue == maxValue;
			}
			if(value == 0 && extendedValue == 0 && 
					upperValue == maxValue && extendedUpperValue == extendedMaxValue) {
				if(maskedIsSequential) {
					return DEFAULT_MASKER;
				} else {
					return DEFAULT_NON_SEQUENTIAL_MASKER;
				}
			}
			if(highestDifferingBitMasked > highestDifferingBitInRange) {
				if(maskedIsSequential) {
					int shift = Long.SIZE - highestDifferingBitMasked; 
					BigInteger countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift];
					if(countRequiredForSequential == null) {
						countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift] = BigInteger.valueOf(1L << shift).shiftLeft(Long.SIZE);
					}
					BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
					BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
					BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
					maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
				}
				ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
				ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
				if(result == null) {
					cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
				}
				return result;
			} else if(!maskedIsSequential) {
				BigInteger bigHostMask = HOST_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostMask == null) {
					bigHostMask = BigInteger.valueOf(hostMask);
					bigHostMask = bigHostMask.shiftLeft(Long.SIZE);
					byte b = (byte) 0xff;
					bigHostMask = bigHostMask.or(new BigInteger(1, new byte[] {b, b, b, b, b, b, b, b}));
					HOST_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask;
				}
				BigInteger bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostZeroed == null) {
					bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask.not();
				}
				BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
				BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
				BigInteger upperToBeMaskedBig = upperBig.and(bigHostZeroed);
				BigInteger lowerToBeMaskedBig = lowerBig.or(bigHostMask);
				BigInteger maskBig = new BigInteger(1, toBytesSizeAdjusted(maskValue, extendedMaskValue, 16));
				for(int nextBit = 128 - (highestDifferingBitMasked + 1) - 1; nextBit >= 0; nextBit--) {
					if(maskBig.testBit(nextBit)) {
						BigInteger candidate = upperToBeMaskedBig.setBit(nextBit);
						if(candidate.compareTo(upperBig) <= 0) {
							upperToBeMaskedBig = candidate;
						}
						candidate = lowerToBeMaskedBig.clearBit(nextBit);
						if(candidate.compareTo(lowerBig) >= 0) {
							lowerToBeMaskedBig = candidate;
						}
					} 
				}
				return new ExtendedSpecificValueMasker(
						lowerToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						lowerToBeMaskedBig.longValue(), 
						upperToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						upperToBeMaskedBig.longValue());
			}
			return DEFAULT_MASKER;
		}
		if(maskValue == 0) {
			return DEFAULT_MASKER;
		}
		boolean maskedIsSequential = true;
		int highestDifferingBitMaskedLow = Long.numberOfLeadingZeros(maskValue);
		if(maskValue != maxValue && highestDifferingBitMaskedLow < Long.SIZE - 1) {
			long hostMask = ~0L >>> (highestDifferingBitMaskedLow + 1); 
			maskedIsSequential = (maskValue & hostMask) == hostMask; 
		}
		if(maskedIsSequential) {
			BigInteger countRequiredForSequential;
			if(highestDifferingBitMaskedLow == 0) {
				countRequiredForSequential = ONE_EXTENDED;
			} else if(highestDifferingBitMaskedLow == 1) { 
				countRequiredForSequential = HIGH_BIT;
			} else {
				int shift = Long.SIZE - highestDifferingBitMaskedLow;
				countRequiredForSequential = ONE_SHIFTED[shift];
				if(countRequiredForSequential == null) {
					countRequiredForSequential = ONE_SHIFTED[shift] = BigInteger.valueOf(1L << shift);
				}
			}
			BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
			BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
			BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
			maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
		}
		highestDifferingBitMasked = highestDifferingBitMaskedLow + Long.SIZE;
		ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
		ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
		if(result == null) {
			cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
		}
		return result;
	}
	public static Masker maskRange(long value, long upperValue, long maskValue) {
		return maskRange(value, upperValue, maskValue, -1);
	}
	public static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_MASKER;
		}
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != 0);
			if(foundDiffering) {
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(differingMasked); 
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1);
				boolean maskedIsSequential = (maskValue & hostMask) == hostMask;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					if(maskedIsSequential) {
						return DEFAULT_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								maskedIsSequential = false;
							}
						} 
					}
					FullRangeMasker cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_MASKERS : FULL_RANGE_MASKERS;
					FullRangeMasker result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					for(long nextBit = (1 << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						if((maskValue & nextBit) != 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} 
					}
					return new SpecificValueMasker(lowerToBeMasked, upperToBeMasked);
				} 
			} 
		} 
		return DEFAULT_MASKER;
	}
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue) {
		return bitwiseOrRange(value, upperValue, maskValue, -1);
	}
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_OR_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_OR_MASKER;
		}
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != maskMask);
			if(foundDiffering) {
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(~differingMasked & maskMask); 
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1); 
				boolean maskedIsSequential = (maskValue & hostMask) == 0;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					if(maskedIsSequential) {
						return DEFAULT_OR_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_OR_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								maskedIsSequential = false;
							}
						}
					}
					FullRangeBitwiseOrer cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_OR_MASKERS : FULL_RANGE_OR_MASKERS;
					FullRangeBitwiseOrer result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeBitwiseOrer(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					for(long nextBit = (1L << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						if((maskValue & nextBit) == 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} 
					}
					return new SpecificValueBitwiseOrer(lowerToBeMasked, upperToBeMasked);
				}
			}
		}
		return DEFAULT_OR_MASKER;
	}
	static byte[] toBytesSizeAdjusted(long val, long extended, int numBytes) {
		int adjustedNumBytes = numBytes;
		for(int j = 1, boundary = numBytes - 8, adj = numBytes + boundary; j <= numBytes; j++) {
			byte b;
			if(j <= boundary) {
				b = (byte) (extended >>> ((numBytes - j) << 3));
			} else {
				b = (byte) (val >>> ((adj - j) << 3));
			}
			if(b != 0) {
				break;
			}
			adjustedNumBytes--;
		}
		return toBytes(val, extended, adjustedNumBytes);
	}
	static byte[] toBytes(long val, long extended, int numBytes) {
		byte bytes[] = new byte[numBytes];
		for(int j = numBytes - 1, boundary = numBytes - 8; j >= 0; j--) {
			if(j >= boundary) {
				bytes[j] = (byte) (val & 0xff);
				val >>>= Byte.SIZE;
			} else {
				bytes[j] = (byte) (extended & 0xff);
				extended >>>= Byte.SIZE;
			}
		}
		return bytes;
	}
	private boolean groupingIsSequential() {
		try {
			return getDivisionGrouping().isSequential();
		} catch(IncompatibleAddressException e) {
			return false;
		}
	}
	@Override
	public boolean isSequential() {
		TranslatedResult<?,?> val = values;
		if(val != null) {
			if(!val.withoutSections()) {
				if(val.withoutAddressException()) {
					return val.getAddress().isSequential();
				}
				return groupingIsSequential();
			}
			if(!val.withoutGrouping()) {
				return groupingIsSequential();
			}
		}
		val = getCachedAddresses(false);
		if(val.withoutAddressException()) {
			return val.getAddress().isSequential();
		}
		return groupingIsSequential();
	}
	private boolean skipContains(boolean skipMixed) {
		AddressParseData parseData = getAddressParseData();
		int segmentCount = parseData.getSegmentCount();
		if(isProvidingIPv4()) {
			if(segmentCount != IPv4Address.SEGMENT_COUNT) { 
				return true;
			}
		} else {
			int expectedSegmentCount;
			if(isProvidingMixedIPv6()) {
				if(skipMixed) {
					return true;
				}
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT - 2;
			} else {
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT;
			}
			if(segmentCount != expectedSegmentCount && !isCompressed()) { 
				return true;
			}
		}
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) == null) { 
			return true;
		}
		return false;
	}
	@Override
	public Boolean contains(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		IPAddressStringParameters options = getParameters();
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network = (isProvidingIPv4() ? options.getIPv4Parameters() : options.getIPv6Parameters()).getNetwork();
		if(pref != null && !isPrefixSubnet(pref, network, segmentData)) {
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	@Override
	public Boolean prefixContains(String other) {
		Boolean b = prefixEquals(other);
		if(b != null && b.booleanValue()) {
			return b;
		}
		return null;
	}
	@Override
	public Boolean prefixEquals(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	private Boolean matchesPrefix(String other, int segmentData[]) {
		int otherLen = other.length();
		boolean isIPv4 = isProvidingIPv4();
		if(otherLen >= 4)	{
			char prefixLenSep = IPAddress.PREFIX_LEN_SEPARATOR;
			if(other.charAt(otherLen - 2) == prefixLenSep || other.charAt(otherLen - 3) == prefixLenSep) {
				return null;
			}
			if(!isIPv4) {
				if(other.charAt(otherLen - 4) == prefixLenSep) {
					return null;
				}
			}
		}
		AddressParseData parseData = getAddressParseData();
		Integer pref = getProviderNetworkPrefixLength();
		int expectedCount;
		boolean compressedAlready = false;
		boolean networkSegIsCompressed = false;
		boolean prefixIsMidSegment;
		int prefixEndCharIndex, remainingSegsCharIndex, networkSegIndex, networkSegCharIndex, networkSegsCount, adjustment; 
		remainingSegsCharIndex = networkSegCharIndex = networkSegIndex = networkSegsCount = adjustment = 0;
		if(pref == null) {
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			networkSegIndex = expectedCount - 1;
			prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
			if(otherLen > prefixEndCharIndex) {
				return null;
			}
			prefixIsMidSegment = false;
		} else if(pref == 0) {
			prefixIsMidSegment = false;
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			prefixEndCharIndex = 0;
		} else {
			if(isIPv4) {
				expectedCount = IPv4Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				prefixIsMidSegment = segPrefLength != bitsPerSegment;
				networkSegsCount = networkSegIndex + 1;
				remainingSegsCharIndex = prefixEndCharIndex + 1;
				if(prefixIsMidSegment) {
					networkSegCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
				}
			} else {
				expectedCount = IPv6Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				int missingSegmentCount = IPv6Address.SEGMENT_COUNT - parseData.getSegmentCount();
				int compressedSegIndex = getConsecutiveSeparatorSegmentIndex();
				compressedAlready = compressedSegIndex <= networkSegIndex;
				networkSegIsCompressed = compressedAlready && compressedSegIndex + missingSegmentCount >= networkSegIndex;
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				if(networkSegIsCompressed) {
					prefixIsMidSegment = segPrefLength != bitsPerSegment;
					networkSegsCount = networkSegIndex + 1;
					prefixEndCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData) + 1; 
					if (prefixIsMidSegment && compressedSegIndex > 0) {
						networkSegCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					}
					remainingSegsCharIndex = prefixEndCharIndex + 1;
				} else {
					int actualNetworkSegIndex;
					if(compressedSegIndex < networkSegIndex) {
						actualNetworkSegIndex = networkSegIndex - missingSegmentCount;
					} else {
						actualNetworkSegIndex = networkSegIndex;
					}
					prefixEndCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
					adjustment = IPv6AddressSegment.MAX_CHARS - ((segPrefLength + 3) >> 2); 
					if(adjustment > 0) {
						prefixIsMidSegment = true;
						remainingSegsCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_START_INDEX, segmentData);
						if(remainingSegsCharIndex + adjustment > prefixEndCharIndex) {
							adjustment = prefixEndCharIndex - remainingSegsCharIndex;
						}
						prefixEndCharIndex -= adjustment;
						networkSegsCount = networkSegIndex;
						networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					} else {
						prefixIsMidSegment = segPrefLength != bitsPerSegment;
						networkSegsCount = actualNetworkSegIndex + 1;
						remainingSegsCharIndex = prefixEndCharIndex + 1;
						if(prefixIsMidSegment) {
							networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
						}
					}
				}
			}
		}
		CharSequence str = this.str;
		int otherSegmentCount = 0;
		boolean currentSegHasNonZeroDigits = false;
		for(int i = 0; i < prefixEndCharIndex; i++) {
			char c = str.charAt(i);
			char otherChar;
			if(i < otherLen) {
				otherChar = other.charAt(i);
			} else {
				otherChar = 0;
			}
			if(c != otherChar) {
				if(c >= '1' && c <= '9') {
				} else if(c >= 'a' && c <= 'f') {
				} else if(c >= 'A' && c <= 'F') {
					char adjustedChar = (char) (c - ('A' - 'a'));
					if(c == adjustedChar) {
						continue;
					}
				} else if(c <= Address.RANGE_SEPARATOR && c >= Address.SEGMENT_SQL_WILDCARD) {
					if(c == Address.SEGMENT_WILDCARD || c == Address.RANGE_SEPARATOR || c == Address.SEGMENT_SQL_WILDCARD) {
						return null;
					}
				} else if(c == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
					return null;
				}
				if(otherChar >= 'A' && otherChar <= 'F') {
					char adjustedChar = (char) (otherChar - ('A' - 'a'));
					if(otherChar == adjustedChar) {
						continue;
					}
				} 
				if(prefixIsMidSegment && (i >= networkSegCharIndex || networkSegCharIndex == 1)) { 
					return null;
				}
				if(hasRange(otherSegmentCount)) {
					return null;
				}
				if(otherChar >= '1' && otherChar <= '9') {
				} else if(otherChar >= 'a' && otherChar <= 'f') {
				} else {
					if(otherChar <= Address.RANGE_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == Address.SEGMENT_WILDCARD || otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD) {
							return null;
						}
					} else if(otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
						return null;
					}
					if(!currentSegHasNonZeroDigits) {
						if(c == '0') {
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR || otherChar == 0) {
								return null;
							}
							int k = i + 1;
							if(k < str.length()) {
								char nextChar = str.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
						} else if(otherChar == '0') {
							if(c == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
							int k = i + 1;
							if(k < otherLen) {
								char nextChar = other.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
							return Boolean.FALSE;
						}
					}
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE; 
					} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
						if(!isIPv4) {
							return null; 
						}
						otherSegmentCount++;
					}
				}
				for(int k = i + 1; k < otherLen; k++) {
					otherChar = other.charAt(k);
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE;
					} else if(otherChar <= IPAddress.PREFIX_LEN_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(!isIPv4) {
								return null; 
							}
							otherSegmentCount++;
						} else {
							if(otherChar == IPAddress.PREFIX_LEN_SEPARATOR || otherChar == Address.SEGMENT_WILDCARD || 
									otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD ||
									otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
								return null;
							}
						}
					}
				}
				if(isIPv4) {
					if(otherSegmentCount + 1 == IPv4Address.SEGMENT_COUNT) {
						return Boolean.FALSE;
					}
				} else {
					if(otherSegmentCount > 0) {
						return Boolean.FALSE;
					}
				}
				return null;
			}
			if(c != '0') {
				boolean isSegmentEnd = c == IPv6Address.SEGMENT_SEPARATOR || c == IPv4Address.SEGMENT_SEPARATOR;
				if(isSegmentEnd) {
					otherSegmentCount++;
					currentSegHasNonZeroDigits = false;
				} else {
					currentSegHasNonZeroDigits = true;
				}
			}
		}
		if(pref != null) {
			if(prefixEndCharIndex == otherLen) {  
				if(networkSegsCount != expectedCount) {
					if(!compressedAlready || networkSegsCount > expectedCount) {
						return null;
					}
				}
			} else {
				if(isIPv4) {
					if(pref != 0) {
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv4Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					int digitCount = 0;
					int remainingSegCount = 0;
					boolean firstIsHighIPv4 = false;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);
						if(otherChar <= '9' && otherChar >= '0') {
							if(digitCount == 0 && otherChar >= '3') {
								firstIsHighIPv4 = true;
							}
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(digitCount == 0) {
								return Boolean.FALSE;
							}
							if(firstIsHighIPv4) {
								if(digitCount >= IPv4AddressSegment.MAX_CHARS) {
									return Boolean.FALSE;
								}
							} else if(digitCount > IPv4AddressSegment.MAX_CHARS) {
								return null;
							}
							digitCount = 0;
							remainingSegCount++;
							firstIsHighIPv4 = false;
						} else { 
							return null; 
						}
					} 
					if(digitCount == 0) {
						return Boolean.FALSE;
					}
					if(digitCount > IPv4AddressSegment.MAX_CHARS) {
						return null;
					} else if(firstIsHighIPv4 && digitCount == IPv4AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount != expectedCount) {
						return null;
					}
				} else {
					if(pref != 0) {
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv6Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					int digitCount = 0;
					int remainingSegCount = 0;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);		
						if(otherChar <= '9' && otherChar >= '0') {
							++digitCount;
						} else if((otherChar >= 'a' && otherChar <= 'f') || (otherChar >= 'A' && otherChar <= 'F')) {
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							return null; 
						} else if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
							if(digitCount > IPv6AddressSegment.MAX_CHARS) {
								return null;
							}
							if(digitCount == 0) {
								if(compressedAlready) {
									return Boolean.FALSE;
								}
								compressedAlready = true;
							} else {
								digitCount = 0;
							}
							remainingSegCount++;
						} else { 
							return null; 
						}
					} 
					if(digitCount == 0) {
						int prevIndex = i - 1;
						if(prevIndex < 0) {
							return Boolean.FALSE;
						}
						char prevChar = other.charAt(prevIndex);
						if(prevChar != IPv6Address.SEGMENT_SEPARATOR) { 
							return Boolean.FALSE;
						}
					} else if(digitCount > IPv6AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount > expectedCount || (totalSegCount < expectedCount && !compressedAlready)) {
						return null;
					}
					if(networkSegIsCompressed && expectedCount - remainingSegCount <= networkSegIndex) {
						return null;
					}
				}
			}
		}
		return Boolean.TRUE;
	}
	@Override
	public Boolean contains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, false, false);
			} 
		}
		return null;
	}
	@Override
	public Boolean parsedEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				ParsedIPAddress parsedOther = (ParsedIPAddress) other;
				Boolean result = contains(parsedOther, false, true);
				if(result != null) {
					return result && Objects.equals(getQualifier().getZone(), parsedOther.getQualifier().getZone());
				} 
			}
		}
		return null;
	}
	@Override
	public Boolean prefixContains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, true, false);
			} 
		}
		return null;
	}
	@Override
	public Boolean prefixEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, true, true);
			} 
		}
		return null;
	}
	private Boolean contains(ParsedIPAddress other, boolean networkOnly, boolean equals) {
		AddressParseData parseData = getAddressParseData();
		AddressParseData otherParseData = other.getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		int otherSegmentData[] = otherParseData.getSegmentData(); 
		if(segmentData == null || otherSegmentData == null) {
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		boolean skipMixed = !networkOnly || pref == null || pref > (IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT << 4);
		if(skipContains(skipMixed) || other.skipContains(skipMixed)) { 
			return null;
		}
		IPVersion ipVersion = getProviderIPVersion();
		if(!ipVersion.equals(other.getProviderIPVersion())) {
			return Boolean.FALSE;
		}
		int max;
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network;
		boolean compressedAlready, otherCompressedAlready;
		int expectedSegCount, expectedOtherSegCount, bitsPerSegment, bytesPerSegment;
		IPAddressStringParameters options = getParameters();
		int segmentCount = parseData.getSegmentCount();
		int otherSegmentCount = otherParseData.getSegmentCount();
		if(isProvidingIPv4()) {
			max = IPv4Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv4Address.SEGMENT_COUNT;
			bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
			network = options.getIPv4Parameters().getNetwork();
			compressedAlready = true;
			otherCompressedAlready = true;
		} else {
			max = IPv6Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv6Address.SEGMENT_COUNT;
			if(isProvidingMixedIPv6()) {
				expectedSegCount -= 2;
			}
			if(other.isProvidingMixedIPv6()) {
				expectedOtherSegCount -= 2;
			}
			bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
			network = options.getIPv6Parameters().getNetwork();
			compressedAlready = expectedSegCount == segmentCount;
			otherCompressedAlready = expectedOtherSegCount == otherSegmentCount;
		}
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		boolean zeroHostsAreSubnets = prefConf.zeroHostsAreSubnets();
		boolean allPrefixedAddressesAreSubnets = prefConf.allPrefixedAddressesAreSubnets();
		Integer otherPref = other.getProviderNetworkPrefixLength();
		int networkSegIndex, hostSegIndex, endIndex, otherHostAllSegIndex, hostAllSegIndex;
		endIndex = segmentCount;
		Integer adjustedOtherPref = null;
		if(pref == null) {
			networkOnly = false;
			hostAllSegIndex = hostSegIndex = expectedSegCount;
			otherHostAllSegIndex = expectedOtherSegCount;
			networkSegIndex = hostSegIndex - 1;
		} else if(networkOnly) {
			hostAllSegIndex = otherHostAllSegIndex = hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			adjustedOtherPref = pref;
		} else {
			otherHostAllSegIndex = expectedOtherSegCount;
			hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			if(allPrefixedAddressesAreSubnets || 
					(zeroHostsAreSubnets && isPrefixSubnet(pref, network, segmentData))) {
				hostAllSegIndex = hostSegIndex;
				if(!equals) {
					networkOnly = true;
				}
			} else {
				hostAllSegIndex = expectedSegCount;
			}
		}
		if(otherPref != null) {
			int otherPrefLen = otherPref.intValue();
			if (adjustedOtherPref == null || otherPrefLen < adjustedOtherPref) {
				int otherHostIndex = ParsedAddressGrouping.getHostSegmentIndex(otherPrefLen, bytesPerSegment, bitsPerSegment);
				if(otherHostIndex < otherHostAllSegIndex &&
						(allPrefixedAddressesAreSubnets || (zeroHostsAreSubnets && other.isPrefixSubnet(otherPrefLen, network, otherSegmentData)))) {
					otherHostAllSegIndex = otherHostIndex;
				}
			} else {
				otherPref = adjustedOtherPref;
			}
		} else {
			otherPref = adjustedOtherPref;
		}
		int i = 0, j = 0, normalizedCount = 0;
		int compressedCount, otherCompressedCount;
		compressedCount = otherCompressedCount = 0;
		while(i < endIndex || compressedCount > 0) {
			if(networkOnly && normalizedCount > networkSegIndex) {
				break;
			}		
			long lower, upper;
		    if(compressedCount > 0) {
		    	lower = upper = 0;
		    } else {
		    	lower = getValue(i, AddressParseData.KEY_LOWER, segmentData);
		    	upper = getValue(i, AddressParseData.KEY_UPPER, segmentData);
		    }
		    if(normalizedCount >= hostAllSegIndex) { 
			   	Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, pref, normalizedCount);
				lower &= network.getSegmentNetworkMask(segPrefLength);
				upper |= network.getSegmentHostMask(segPrefLength);
			}
			long otherLower, otherUpper;
			if(normalizedCount > otherHostAllSegIndex) {
				otherLower = 0;
				otherUpper = max;
			} else {
				if(otherCompressedCount > 0) {
					otherLower = otherUpper = 0;
				} else {
					otherLower = getValue(j, AddressParseData.KEY_LOWER, otherSegmentData);
					otherUpper = getValue(j, AddressParseData.KEY_UPPER, otherSegmentData);
				}
				if(normalizedCount == otherHostAllSegIndex) { 
					Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, otherPref, normalizedCount);
					otherLower &= network.getSegmentNetworkMask(segPrefLength);
					otherUpper |= network.getSegmentHostMask(segPrefLength);
				}
			}
			if(equals ? (lower != otherLower || upper != otherUpper) : (lower > otherLower || upper < otherUpper)) {
				return Boolean.FALSE;
			}
			if(!compressedAlready) {
				if(compressedCount > 0) {
					if(--compressedCount == 0) {
						compressedAlready = true;
					}
				} else if(isCompressed(i, segmentData)) {
					i++;
					compressedCount = expectedSegCount - segmentCount;
				} else {
					i++;
				}
			} else {
				i++;
			}
			if(!otherCompressedAlready) {
				if(otherCompressedCount > 0) {
					if(--otherCompressedCount == 0) {
						otherCompressedAlready = true;
					}
				} else if(other.isCompressed(j, otherSegmentData)) {
					j++;
					otherCompressedCount = expectedOtherSegCount - otherSegmentCount;
				} else {
					j++;
				}
			} else {
				j++;
			}
			normalizedCount++;
		}
		return Boolean.TRUE;
	}
	protected boolean isPrefixSubnet(Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, int segmentData[]) {
		IPVersion version = network.getIPVersion();
		int bytesPerSegment = IPAddressSection.bytesPerSegment(version);
		int bitsPerSegment = IPAddressSection.bitsPerSegment(version);
		int max = IPAddressSegment.getMaxSegmentValue(version);
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(isCompressed()) {
			int compressedCount = IPv6Address.SEGMENT_COUNT - segmentCount;
			int compressedIndex = addressParseData.getConsecutiveSeparatorSegmentIndex();
			return ParsedAddressGrouping.isPrefixSubnet(
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData);
					},
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData);
					},
					segmentCount + compressedCount,
					bytesPerSegment,
					bitsPerSegment,
					max,
					networkPrefixLength,
					prefConf,
					false);
		}
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData),
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData),
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				max,
				networkPrefixLength,
				prefConf,
				false);
	}
	@Override 
	public Integer getProviderNetworkPrefixLength() {
		return getQualifier().getEquivalentPrefixLength();
	}
	private static <S extends IPAddressSegment> S[] allocateSegments(
			S segments[],
			S originalSegments[],
			AddressSegmentCreator<S> creator,
			int segmentCount,
			int originalCount) {
		if(segments == null) {
			segments = creator.createSegmentArray(segmentCount);
			if(originalCount > 0) {
				System.arraycopy(originalSegments, 0, segments, 0, originalCount);
			}
		}
		return segments;
	}
	private void createIPv4Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null; 
		}
		boolean hasMask = mask != null;
		AddressParseData addrParseData = getAddressParseData();
		int segmentCount = addrParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv4AddressCreator creator = getIPv4AddressCreator();
		int ipv4SegmentCount = IPv4Address.SEGMENT_COUNT;
		int missingCount = ipv4SegmentCount - segmentCount;
		IPv4AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv4SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv4SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv4Address, IPv4AddressSection> finalResult = 
				(TranslatedResult<IPv4Address, IPv4AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv4Address, IPv4AddressSection>() {
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, ?> getCreator() {
					return getIPv4AddressCreator();
				}
			};
		}
		boolean expandedSegments = (missingCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		for(int i = 0, normalizedSegmentIndex = 0; i < segmentCount; i++) {
			long lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
			if(!expandedSegments) {
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addrParseData.isWildcard(i);
				expandedSegments = isLastSegment;
				if(!expandedSegments) {
					expandedSegments = !is_inet_aton_joined() && isWildcard;
					if(expandedSegments) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addrParseData.isWildcard(j)) {
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					if(isWildcard) {
						upper = 0xffffffff >>> ((3 - missingCount) << 3);
					} else {
						expandedStart = i;
						expandedEnd = i + missingCount;
					}
					int bits = IPv4Address.BITS_PER_SEGMENT * (missingCount + 1);
					long maskedLower, maskedUpper;
					if(hasMask) {
						long divMask = 0;
						for(int k = 0; k <= missingCount; k++) {
							divMask = (divMask << IPv4Address.BITS_PER_SEGMENT) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
						}
						Masker masker = maskers[i];
						if(masker == null) {
							long maxValue = (bits == Integer.SIZE) ? 0xffffffffL : ~(~0 << bits);
							maskers[i] = masker = maskRange(lower, upper, divMask, maxValue);
						}
						if(!masker.isSequential() && finalResult.maskException == null) {
							finalResult.maskException = new IncompatibleAddressException(lower, upper, divMask, "ipaddress.error.maskMismatch");
						}
						maskedLower = masker.getMaskedLower(lower, divMask);
						maskedUpper = masker.getMaskedUpper(upper, divMask);
						maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
					} else {
						maskedLower = lower;
						maskedUpper = upper;
					}
					int shift = bits;
					int count = missingCount;
					while(count >= 0) { 
						shift -= IPv4Address.BITS_PER_SEGMENT;
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
						int segmentBitsMask = IPv4Address.MAX_VALUE_PER_SEGMENT;
						int hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
						int hostSegUpper = (lower == upper) ? hostSegLower : (int) (upper >>> shift) & segmentBitsMask;
						int maskedSegLower, maskedSegUpper;
						if(hasMask) {
							maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
							maskedSegUpper = (maskedLower == maskedUpper) ? maskedSegLower : (int) (maskedUpper >>> shift) & segmentBitsMask;
						} else {
							maskedSegLower = hostSegLower;
							maskedSegUpper = hostSegUpper;
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								} 
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV4,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addrParseData.setBitLength(i, bits);
					continue;
				} 
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked = hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
						addressString,
						IPVersion.IPV4,
						(int) lower,
						(int) upper,
						unmasked,
						i,
						segmentPrefixLength,
						creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					} 
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addrParseData.setBitLength(i, IPv4Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		IPv4AddressSection result, hostResult = null;
		if(doAddress) {
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv4Parameters().getNetwork();
				IPv4AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv4Address.BYTES_PER_SEGMENT,
						IPv4Address.BITS_PER_SEGMENT,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
					if(upperSegments == null) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower();
			}
			if(upperSegments != null) {
				IPv4AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	private void createIPv6Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;
		}
		boolean hasMask = mask != null;
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv6AddressCreator creator = getIPv6AddressCreator();
		int ipv6SegmentCount = IPv6Address.SEGMENT_COUNT;
		IPv6AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv6SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv6SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv6Address,IPv6AddressSection> finalResult = 
				(TranslatedResult<IPv6Address, IPv6AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv6Address,IPv6AddressSection>() {
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, ?> getCreator() {
					return getIPv6AddressCreator();
				}
			};
		}
		boolean mixed = isProvidingMixedIPv6();
		int normalizedSegmentIndex = 0;
		int missingSegmentCount = (mixed ? IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT : ipv6SegmentCount) - segmentCount;
		boolean expandedSegments = (missingSegmentCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		for(int i = 0; i < segmentCount; i++) {
			long lower = addressParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addressParseData.getValue(i, AddressParseData.KEY_UPPER);
			if(!expandedSegments) {
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addressParseData.isWildcard(i);
				boolean isCompressed = isCompressed(i);
				expandedSegments = isLastSegment || isCompressed;
				if(!expandedSegments) {
					if(expandedSegments = isWildcard) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addressParseData.isWildcard(j) || isCompressed(j)) {
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					long lowerHighBytes, upperHighBytes;
					boolean hostIsRange;
					 if(isCompressed) {
						lower = upper = lowerHighBytes = upperHighBytes = 0;
						hostIsRange = false;
					} else if(isWildcard) {
						if(missingSegmentCount > 3) {
							upperHighBytes = 0xffffffffffffffffL >>> ((7 - missingSegmentCount) << 4);
							upper = 0xffffffffffffffffL;
						} else {
							upperHighBytes = 0;
							upper = 0xffffffffffffffffL >>> ((3 - missingSegmentCount) << 4);
						}
						lower = lowerHighBytes = 0;
						hostIsRange = true;
					} else {
						if(missingSegmentCount > 3) {
							lowerHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);
							upperHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);
							hostIsRange = (lower != upper) || (lowerHighBytes != upperHighBytes);
						} else {
							lowerHighBytes = upperHighBytes = 0;
							hostIsRange = (lower != upper);
						}
						expandedStart = i;
						expandedEnd = i + missingSegmentCount;
					}
					int bits = IPv6Address.BITS_PER_SEGMENT * (missingSegmentCount + 1);
					long maskedLower, maskedUpper, maskedLowerHighBytes, maskedUpperHighBytes;
					boolean maskedIsRange;
					if(hasMask) {
						if(isCompressed) {
							maskers[i] = DEFAULT_MASKER;
							maskedLower = maskedUpper = maskedLowerHighBytes = maskedUpperHighBytes = 0;
							maskedIsRange = false;
						} else {
							int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
							long maskVal = 0;
							if(missingSegmentCount >= 4) {
								ExtendedMasker masker = (ExtendedMasker) maskers[i];
								long extendedMaskVal = 0;
								int extendedCount = missingSegmentCount - 3;
								for(int k = 0; k < extendedCount; k++) {
									extendedMaskVal = (extendedMaskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								for(int k = extendedCount; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									long extendedMaxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << (bits - Long.SIZE));
									maskers[i] = masker = maskExtendedRange(
											lower, lowerHighBytes, 
											upper, upperHighBytes, 
											maskVal, extendedMaskVal, 
											0xffffffffffffffffL, extendedMaxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									int byteCount = (missingSegmentCount + 1) * IPv6Address.BYTES_PER_SEGMENT;
									finalResult.maskException = new IncompatibleAddressException(
										new BigInteger(1, toBytesSizeAdjusted(lower, lowerHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(upper, upperHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(maskVal, extendedMaskVal, byteCount)).toString(),
										"ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = masker.getExtendedMaskedLower(lowerHighBytes, extendedMaskVal);
								maskedUpperHighBytes = masker.getExtendedMaskedUpper(upperHighBytes, extendedMaskVal);
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = (maskedLower != maskedUpper) || (maskedLowerHighBytes != maskedUpperHighBytes);
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper|| maskedLowerHighBytes != lowerHighBytes || maskedUpperHighBytes != upperHighBytes;
							} else {
								Masker masker = maskers[i];
								for(int k = 0; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									long maxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bits);
									maskers[i] = masker = maskRange(lower, upper, maskVal, maxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									finalResult.maskException = new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = maskedUpperHighBytes = 0;
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = maskedLower != maskedUpper;
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
							}
						}
					} else {
						maskedLowerHighBytes = lowerHighBytes;
						maskedUpperHighBytes = upperHighBytes;
						maskedLower = lower;
						maskedUpper = upper;
						maskedIsRange = hostIsRange;
					}
					int shift = bits;
					int count = missingSegmentCount;
					while(count >= 0) { 
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
						int hostSegLower, hostSegUpper, maskedSegLower, maskedSegUpper;
						if(isCompressed) {
							hostSegLower = hostSegUpper = maskedSegLower = maskedSegUpper = 0;
						} else {
							shift -= IPv6Address.BITS_PER_SEGMENT;
							int segmentBitsMask = IPv6Address.MAX_VALUE_PER_SEGMENT;
							if(count >= 4) {
								int shorterShift = shift - (IPv6Address.BITS_PER_SEGMENT << 2);
								hostSegLower = (int) (lowerHighBytes >>> shorterShift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upperHighBytes >>> shorterShift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLowerHighBytes >>> shorterShift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpperHighBytes >>> shorterShift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							} else {
								hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upper >>> shift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpper >>> shift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							}
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isSegRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isSegRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								} 
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isSegRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV6,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addressParseData.setBitLength(i, bits);
					continue;
				} 
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked =  hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
					addressString,
					IPVersion.IPV6,
					(int) lower,
					(int) upper,
					unmasked,
					i,
					segmentPrefixLength,
					creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					} 
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addressParseData.setBitLength(i, IPv6Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<?, IPv6AddressSection, IPv4AddressSection, IPv6AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		if(mixed) {
			IPv4AddressSeqRange ipv4Range = (IPv4AddressSeqRange) mixedParsedAddress.getProviderSeqRange();
			if(hasMask && mixedMaskers == null) {
				mixedMaskers = new Masker[IPv4Address.SEGMENT_COUNT];
			}
			for(int n = 0; n < 2; n++) {
				int m = n << 1;
				Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
				IPv4AddressSegment oneLow = ipv4Range.getLower().getSegment(m);
				int o = m + 1;
				IPv4AddressSegment twoLow = ipv4Range.getLower().getSegment(o);
				IPv4AddressSegment oneUp = ipv4Range.getUpper().getSegment(m);
				IPv4AddressSegment twoUp = ipv4Range.getUpper().getSegment(o);
				int oneLower = oneLow.getSegmentValue();
				int twoLower = twoLow.getSegmentValue();
				int oneUpper = oneUp.getSegmentValue();
				int twoUpper = twoUp.getSegmentValue();
				int originalOneLower = oneLower;
				int originalTwoLower = twoLower;
				int originalOneUpper = oneUpper;
				int originalTwoUpper = twoUpper;
				if(hasMask) {
					int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
					int shift = IPv4Address.BITS_PER_SEGMENT;
					int shiftedMask = maskInt >> shift;
					Masker masker = mixedMaskers[m];
					if(masker == null) {
						mixedMaskers[m] = masker = maskRange(oneLower, oneUpper, shiftedMask, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(oneLower, oneUpper, shiftedMask, "ipaddress.error.maskMismatch");
					}
					oneLower = (int) masker.getMaskedLower(oneLower, shiftedMask);
					oneUpper = (int) masker.getMaskedUpper(oneUpper, shiftedMask);
					masker = mixedMaskers[m + 1];
					if(masker == null) {
						mixedMaskers[m + 1] = masker = maskRange(twoLower, twoUpper, maskInt, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(twoLower, twoUpper, maskInt, "ipaddress.error.maskMismatch");
					}
					twoLower = (int) masker.getMaskedLower(twoLower, maskInt);
					twoUpper = (int) masker.getMaskedUpper(twoUpper, maskInt);
					maskedIsDifferent = maskedIsDifferent || oneLower != originalOneLower || oneUpper != originalOneUpper ||
							twoLower != originalTwoLower || twoUpper != originalTwoUpper;
				}
				boolean isRange = oneLower != oneUpper || twoLower != twoUpper;
				if(doAddress) {
					boolean doHostSegment = maskedIsDifferent || segmentPrefixLength != null;
					if(doHostSegment) {
						hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					}
					if(!isRange) {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6Segment(originalOneLower, originalTwoLower, null, creator);
						}
						segments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6RangeSegment(
									finalResult,
									ipv4Range,
									originalOneLower,
									originalOneUpper,
									originalTwoLower,
									originalTwoUpper,
									null,
									creator);
						}
						segments[normalizedSegmentIndex] = createIPv6RangeSegment(
								finalResult,
								ipv4Range,
								oneLower,
								oneUpper,
								twoLower,
								twoUpper,
								segmentPrefixLength,
								creator);
					}
				}
				if(doRangeBoundaries) {
					if(!doAddress || isRange) {
						if(doAddress) {
							lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						} 
						lowerSegments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else if(lowerSegments != null) {
						lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
					}
					if(withUpper) {
						if(isRange) {
							upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
							upperSegments[normalizedSegmentIndex] = createIPv6Segment(
									oneUpper,
									twoUpper,
									segmentPrefixLength, 
									creator);
						} else if(upperSegments != null) {
							upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
						}
					}
				}
				normalizedSegmentIndex++;
			}
		}
		IPv6AddressSection result, hostResult = null;
		if(doAddress) {
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv6Parameters().getNetwork();
				IPv6AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv6Address.BYTES_PER_SEGMENT,
						IPv6Address.BITS_PER_SEGMENT,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
					if(upperSegments == null) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower(); 
			}
			if(upperSegments != null) {
				IPv6AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	private static boolean checkExpandedValues(IPAddressSection section, int start, int end) {
		if(section != null && start < end) {
			IPAddressSegment seg = section.getSegment(start);
			boolean lastWasRange = seg.isMultiple();
			do {
				seg = section.getSegment(++start);
				if(lastWasRange) {
					if(!seg.isFullRange()) {
						return true;
					}
				} else {
					lastWasRange = seg.isMultiple();
				}
			} while(start < end);
		}
		return false;
	}
	private <S extends IPAddressSegment> S createSegment(
			CharSequence addressString,
			IPVersion version,
			int val,
			int upperVal,
			boolean useFlags,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		AddressParseData parseData = getAddressParseData();
		if(val != upperVal) {
			return createRangeSeg(addressString, version, val, upperVal,
					useFlags, parseData, parsedSegIndex,
					segmentPrefixLength, creator);
		}
		S result;
		if(!useFlags) {
			result = creator.createSegment(val, val, segmentPrefixLength);
		} else {
			result = creator.createSegmentInternal(
				val,
				segmentPrefixLength,
				addressString,
				val,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX));
		}
		return result;
	}
	private IPv6AddressSegment createIPv6Segment(int value1, int value2, Integer segmentPrefixLength, IPv6AddressCreator creator) {
		int value = (value1 << IPv4Address.BITS_PER_SEGMENT) | value2;
		IPv6AddressSegment result = creator.createSegment(value, segmentPrefixLength);
		return result;
	}
	private static IPv6AddressSegment createIPv6RangeSegment(
			TranslatedResult<?,?> finalResult,
			AddressItem item,
			int upperRangeLower,
			int upperRangeUpper,
			int lowerRangeLower,
			int lowerRangeUpper,
			Integer segmentPrefixLength,
			IPv6AddressCreator creator) {
		int shift = IPv4Address.BITS_PER_SEGMENT;
		if(upperRangeLower != upperRangeUpper) {
			if(segmentPrefixLength != null && creator.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				if(segmentPrefixLength > shift) {
					int lowerPrefixLength = segmentPrefixLength - shift;
					int fullMask = ~(~0 << shift); 
					int networkMask = fullMask & (fullMask << (shift - lowerPrefixLength));
					int hostMask = ~networkMask & fullMask;
					lowerRangeLower &= networkMask;
					lowerRangeUpper |= hostMask;
					if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
						finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
					}
				} else {
					lowerRangeLower = 0;
					lowerRangeUpper = IPv4Address.MAX_VALUE_PER_SEGMENT;
				}
			} else if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
				finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
			}
		}
		return creator.createSegment(
				(upperRangeLower << shift) | lowerRangeLower,
				(upperRangeUpper << shift) | lowerRangeUpper,
				segmentPrefixLength);
	}
	private static <S extends IPAddressSegment> S createRangeSeg(
			CharSequence addressString,
			IPVersion version,
			int stringLower,
			int stringUpper,
			boolean useFlags,
			AddressParseData parseData,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		int lower = stringLower, upper = stringUpper;
		S result;
		if(!useFlags) {
			result = creator.createSegment(lower, upper, segmentPrefixLength);
		} else {
			result = creator.createRangeSegmentInternal(
				lower,
				upper,
				segmentPrefixLength,
				addressString,
				stringLower,
				stringUpper,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_RANGE_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX));
		}
		return result;
	}
	private static <S extends IPAddressSegment> S createFullRangeSegment(
			IPVersion version,
			int stringLower,
			int stringUpper,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			Integer mask,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		boolean hasMask = (mask != null);
		if(hasMask) {
			int maskInt = mask.intValue();
			Masker masker = maskRange(stringLower, stringUpper, maskInt, creator.getMaxValuePerSegment());
			if(!masker.isSequential()) {
				throw new IncompatibleAddressException(stringLower, stringUpper, maskInt, "ipaddress.error.maskMismatch");
			}
			stringLower = (int) masker.getMaskedLower(stringLower, maskInt);
			stringUpper = (int) masker.getMaskedUpper(stringUpper, maskInt);
		}
		S result = createRangeSeg(null, version, stringLower, stringUpper,
				false, null, parsedSegIndex, segmentPrefixLength, creator);
		return result;
	}
	static IPAddress createAllAddress(
			IPVersion version,
			ParsedHostIdentifierStringQualifier qualifier,
			HostIdentifierString originator, 
			IPAddressStringParameters options) {
		int segmentCount = IPAddress.getSegmentCount(version);
		IPAddress mask = qualifier.getMaskLower();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;
		}
		boolean hasMask = mask != null;
		Integer prefLength = getPrefixLength(qualifier);
		if(version.isIPv4()) {
			ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> creator = options.getIPv4Parameters().getNetwork().getAddressCreator();
			IPv4AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, originator, prefLength);
		} else {
			ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, IPv6AddressSegment> creator = options.getIPv6Parameters().getNetwork().getAddressCreator();
			IPv6AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, qualifier.getZone(), originator, prefLength);
		}
	}
	private static Integer getPrefixLength(ParsedHostIdentifierStringQualifier qualifier) {
		return qualifier.getEquivalentPrefixLength();
	}
	private static Integer getSegmentPrefixLength(int segmentIndex, int bitsPerSegment, ParsedHostIdentifierStringQualifier qualifier) {
		Integer bits = getPrefixLength(qualifier);
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, bits, segmentIndex);
	}
	private static Integer getSegmentPrefixLength(int segmentIndex, IPVersion version, ParsedHostIdentifierStringQualifier qualifier) {
		return getSegmentPrefixLength(segmentIndex, IPAddressSection.bitsPerSegment(version), qualifier);
	}
	private static Integer cacheSegmentMask(int i) {
		return ParsedAddressGrouping.cache(i);
	}
}
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
public interface AddressSegmentSeries extends AddressDivisionSeries, AddressComponent {
	int getSegmentCount();
	int getBitsPerSegment();
	int getBytesPerSegment();
	int getMaxSegmentValue();
	AddressSection getSection();
	AddressSection getSection(int index);
	AddressSection getSection(int index, int endIndex);
	AddressSegment getSegment(int index);
	String[] getSegmentStrings();
	void getSegments(AddressSegment segs[]);
	void getSegments(int start, int end, AddressSegment segs[], int index);
	AddressSegment[] getSegments();
	@Override
	AddressSegmentSeries getLower();
	@Override
	AddressSegmentSeries getUpper();
	default boolean testBit(int n) {
		return isOneBit(getBitCount() - (n + 1));
	}
	default boolean isOneBit(int prefixBitIndex) {
		int bitsPerSegment = getBitsPerSegment();
		AddressSegment segment = getSegment(prefixBitIndex / bitsPerSegment);
		int segmentBitIndex = prefixBitIndex % bitsPerSegment;
		int value = segment.getSegmentValue();
		return (value & (1 << (bitsPerSegment - (segmentBitIndex + 1)))) != 0;
	}
	@Override
	Iterable<? extends AddressSegmentSeries> getIterable();
	@Override
	Iterator<? extends AddressSegmentSeries> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegmentSeries> spliterator();
	@Override
	Stream<? extends AddressSegmentSeries> stream();
	Iterator<? extends AddressSegmentSeries> prefixIterator();
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixSpliterator();
	Iterator<? extends AddressSegmentSeries> prefixBlockIterator();
	Stream<? extends AddressSegmentSeries> prefixStream();
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixBlockSpliterator();
	Stream<? extends AddressSegmentSeries> prefixBlockStream();
	Iterator<? extends AddressSegment[]> segmentsIterator();
	AddressComponentRangeSpliterator<? extends AddressSegmentSeries, ? extends AddressSegment[]> segmentsSpliterator();
	Stream<? extends AddressSegment[]> segmentsStream();
	AddressSegmentSeries increment(long increment) throws AddressValueException;
	AddressSegmentSeries incrementBoundary(long increment) throws AddressValueException;
	String toCanonicalString();
	String toCompressedString();
	AddressSegmentSeries reverseSegments();
	@Override
	AddressSegmentSeries reverseBits(boolean perByte);
	@Override
	AddressSegmentSeries reverseBytes();
	AddressSegmentSeries reverseBytesPerSegment();
	AddressSegmentSeries toPrefixBlock();
	@Deprecated
	AddressSegmentSeries removePrefixLength();
	AddressSegmentSeries withoutPrefixLength();
	@Deprecated
	AddressSegmentSeries removePrefixLength(boolean zeroed);
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment);
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	AddressSegmentSeries adjustPrefixLength(int adjustment);
	AddressSegmentSeries adjustPrefixLength(int adjustment, boolean zeroed);
	AddressSegmentSeries setPrefixLength(int prefixLength);
	AddressSegmentSeries setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	AddressSegmentSeries applyPrefixLength(int prefixLength);
}
package inet.ipaddr.format;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.function.Supplier;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.AddressDivisionGroupingBase.AddressStringParams;
import inet.ipaddr.format.AddressDivisionGroupingBase.IPAddressStringParams;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressSegmentParams;
public abstract class AddressDivisionBase implements AddressGenericDivision {
	private static final long serialVersionUID = 4L;
	private static final IPStringOptions OCTAL_PARAMS, HEX_PARAMS, DECIMAL_PARAMS;
	static {
		Wildcards rangeWildcard = new Wildcards(IPAddress.RANGE_SEPARATOR_STR);
		OCTAL_PARAMS = new IPStringOptions.Builder(8).setSegmentStrPrefix("0").setWildcards(rangeWildcard).toOptions();
		HEX_PARAMS = new IPStringOptions.Builder(16).setSegmentStrPrefix("0x").setWildcards(rangeWildcard).toOptions();
		DECIMAL_PARAMS = new IPStringOptions.Builder(10).setWildcards(rangeWildcard).toOptions();
	}
	private static final String zeros[];
	static {
		int zerosLength = 20;
		zeros = new String[zerosLength];
		zeros[0] = "";
		for(int i = 1; i < zerosLength; i++) {
			zeros[i] = zeros[i - 1] + '0';
		}
	}
	protected static final char[] DIGITS = {
		'0', '1', '2', '3', '4', '5',
		'6', '7', '8', '9', 'a', 'b',
		'c', 'd', 'e', 'f', 'g', 'h',
		'i', 'j', 'k', 'l', 'm', 'n',
		'o', 'p', 'q', 'r', 's', 't',
		'u', 'v', 'w', 'x', 'y', 'z',
    };
	public static final char[] EXTENDED_DIGITS = {
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 
		'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 
		'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
		'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 
		'y', 'z', '!', '#', '$', '%', '&', '(', ')', '*', '+', '-', 
		';', '<', '=', '>', '?', '@', '^', '_', '`', '{', '|', '}', 
		'~' };
	protected static final int MIN_RADIX = 2, MAX_RADIX = 85;
	protected static final BigInteger BIG_MIN_RADIX = BigInteger.valueOf(MIN_RADIX),
			BIG_MAX_RADIX = BigInteger.valueOf(MAX_RADIX);
	protected static final char[] UPPERCASE_DIGITS = IPAddressLargeDivision.EXTENDED_DIGITS; 
	protected static final char[] DOUBLE_DIGITS_DEC = {
		'0', '0', '0', '1', '0', '2', '0', '3', '0', '4',
		'0', '5', '0', '6', '0', '7', '0', '8', '0', '9',
		'1', '0', '1', '1', '1', '2', '1', '3', '1', '4',
		'1', '5', '1', '6', '1', '7', '1', '8', '1', '9',
		'2', '0', '2', '1', '2', '2', '2', '3', '2', '4',
		'2', '5', '2', '6', '2', '7', '2', '8', '2', '9',
		'3', '0', '3', '1', '3', '2', '3', '3', '3', '4',
		'3', '5', '3', '6', '3', '7', '3', '8', '3', '9',
		'4', '0', '4', '1', '4', '2', '4', '3', '4', '4',
		'4', '5', '4', '6', '4', '7', '4', '8', '4', '9',
		'5', '0', '5', '1', '5', '2', '5', '3', '5', '4',
		'5', '5', '5', '6', '5', '7', '5', '8', '5', '9',
		'6', '0', '6', '1', '6', '2', '6', '3', '6', '4',
		'6', '5', '6', '6', '6', '7', '6', '8', '6', '9',
		'7', '0', '7', '1', '7', '2', '7', '3', '7', '4',
		'7', '5', '7', '6', '7', '7', '7', '8', '7', '9',
		'8', '0', '8', '1', '8', '2', '8', '3', '8', '4',
		'8', '5', '8', '6', '8', '7', '8', '8', '8', '9',
		'9', '0', '9', '1', '9', '2', '9', '3', '9', '4',
		'9', '5', '9', '6', '9', '7', '9', '8', '9', '9',
	};
	private static TreeMap<Long, Integer> maxDigitMap = new TreeMap<Long, Integer>();
	private static TreeMap<Long, BigInteger> radixPowerMap = new TreeMap<Long, BigInteger>();
	protected transient String cachedWildcardString;
	private transient byte[] lowerBytes, upperBytes;
	protected transient int hashCode;
	protected AddressDivisionBase() {}
	protected boolean isSameValues(AddressDivisionBase other) {
		return getValue().equals(other.getValue()) && getUpperValue().equals(other.getUpperValue());
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionBase) {
			AddressDivisionBase other = (AddressDivisionBase) o;
			return getBitCount() == other.getBitCount() && other.isSameValues(this);
		}
		return false;
	}
	protected static int createHashCode(long value, long upperValue) {
		return adjustHashCode(1, value, upperValue);
	}
	static int adjustHashCode(int currentHash, long value, long upperValue) {
		long shifted = value >>> 32;
		int adjusted = (int) ((shifted == 0) ? value : (value ^ shifted));
		currentHash = 31 * currentHash + adjusted;
		if(upperValue != value) {
			shifted = upperValue >>> 32;
			adjusted = (int) ((shifted == 0) ? upperValue : (upperValue ^ shifted));
			currentHash = 31 * currentHash + adjusted;
		}
		return currentHash;
	}
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			BigInteger lower = getValue(), upper = getUpperValue();
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				long up = upper.longValue();
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
				res = adjustHashCode(res, low, up);
			} while(upper.signum() != 0);
			hashCode = res;
		}
		return res;
	}
	@Override
	public byte[] getBytes() {
		byte cached[] = lowerBytes;
		if(cached == null) {
			lowerBytes = cached = getBytesImpl(true);
		}
		return cached.clone();
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		byte cached[] = lowerBytes;
		if(cached == null) {
			lowerBytes = cached = getBytesImpl(true);
		}
		return getBytes(bytes, index, cached);
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getBytes(bytes, 0);
	}
	private byte[] getBytes(byte[] provided, int startIndex, byte[] cached) {
		int byteCount = (getBitCount() + 7) >> 3;
		if(provided == null || provided.length < byteCount + startIndex) {
			if(startIndex > 0) {
				byte bytes2[] = new byte[byteCount + startIndex];
				if(provided != null) {
					System.arraycopy(provided, 0, bytes2, 0, Math.min(startIndex, provided.length));
				}
				System.arraycopy(cached, 0, bytes2, startIndex, cached.length);
				return bytes2;
			}
			return cached.clone();
		} 
		System.arraycopy(cached, 0, provided, startIndex, byteCount);
		return provided;
	}
	@Override
	public byte[] getUpperBytes() {
		if(!isMultiple()) {
			return getBytes();
		}
		byte cached[] = upperBytes;
		if(cached == null) {
			upperBytes = cached = getBytesImpl(false);
		}
		return cached.clone();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		if(!isMultiple()) {
			return getBytes(bytes, index);
		}
		byte cached[] = upperBytes;
		if(cached == null) {
			upperBytes = cached = getBytesImpl(false);
		}
		return getBytes(bytes, index, cached);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getUpperBytes(bytes, 0);
	}
	protected abstract byte[] getBytesImpl(boolean low);
	protected abstract int getDefaultTextualRadix();
	protected abstract int getMaxDigitCount();
	protected static int getMaxDigitCount(int radix, int bitCount, BigInteger maxValue) {
		int result = getDigitCount(radix, bitCount); 
		if(result > 0) {
			return result;
		}
		long key = (((long) radix) << 32) | bitCount;
		Integer digs = maxDigitMap.get(key);
		if(digs == null) {
			if(maxValue == null) {
				maxValue = getMaxValue(bitCount);
			}
			digs = getDigitCount(maxValue, BigInteger.valueOf(radix));
			@SuppressWarnings("unchecked")
			TreeMap<Long, Integer> newMaxDigitMap = (TreeMap<Long, Integer>) maxDigitMap.clone();
			newMaxDigitMap.put(key, digs);
			maxDigitMap = newMaxDigitMap;
		}
		return digs;
	}
	protected static BigInteger getMaxValue(int bitCount) {
		if(bitCount < 0) {
			throw new IllegalArgumentException();
		}
		int maxBytes = (bitCount + 7) >>> 3;
		byte max[] = new byte[maxBytes];
		if(maxBytes > 0) {
			int topBits = bitCount % 8;
			if(topBits == 0) {
				topBits = 8;
			}
			max[0] = (byte) ~(~0 << topBits);
			for(int i = 1; i < max.length; i++) {
				max[i] = ~0;
			}
		}
		return new BigInteger(1, max);
	}
	public static int getDigitCount(BigInteger val, BigInteger radix) {
		if(radix.compareTo(BIG_MIN_RADIX) < 0 || radix.compareTo(BIG_MAX_RADIX) > 0) {
			throw new IllegalArgumentException();
		} else if(val.signum() == 0 || val.equals(BigInteger.ONE)) {
			return 1;
		}
		if(val.signum() > 0) {
			int smallRadix = radix.intValue();
			if(smallRadix == 16) {
				return getDigitCount(16, val.bitLength());
			} else if(smallRadix == 8) {
				int result = 1;
				while(true) {
					val = val.shiftRight(3);
					if(val.signum() == 0) {
						break;
					}
					result++;
				}
				return result;
			} else if(smallRadix == 4) {
				return getDigitCount(4, val.bitLength());
			} else if(smallRadix == 2) {
				return val.bitLength();
			}
		}
		int result = 1;
		while(true) {
			val = val.divide(radix);
			if(val.signum() == 0) {
				break;
			}
			result++;
		}
		return result;
	}
	protected static int getMaxDigitCount(int radix, int bitCount, long maxValue) {
		int result = getDigitCount(radix, bitCount); 
		if(result > 0) {
			return result;
		}
		if(radix == 10) {
			if(maxValue < 10) {
				return 1;
			} else if(maxValue < 100) {
				return 2;
			} else if(maxValue < 1000) {
				return 3;
			} else if(maxValue < 10000) {
				return 4;
			} else if(maxValue < 100000) {
				return 5;
			} else if(maxValue < 1000000) {
				return 6;
			} else if(maxValue < 10000000) {
				return 7;
			} else if(maxValue < 100000000) {
				return 8;
			} else if(maxValue < 1000000000) {
				return 9;
			} else if(maxValue < 10000000000L) {
				return 10;
			} else if(maxValue < 100000000000L) {
				return 11;
			} else if(maxValue < 1000000000000L) {
				return 12;
			} else if(maxValue < 10000000000000L) {
				return 13;
			} else if(maxValue < 100000000000000L) {
				return 14;
			} else if(maxValue < 1000000000000000L) {
				return 15;
			} else if(maxValue < 10000000000000000L) {
				return 16;
			} else if(maxValue < 100000000000000000L) {
				return 17;
			} else if(maxValue < 1000000000000000000L) {
				return 18;
			}
			return 19;
		} else {
			long key = (((long) radix) << 32) | bitCount;
			Integer digs = maxDigitMap.get(key);
			if(digs == null) {
				result = 1;
				while(true) {
					maxValue /= radix;
					if(maxValue == 0) {
						break;
					}
					result++;
				}
				@SuppressWarnings("unchecked")
				TreeMap<Long, Integer> newMaxDigitMap = (TreeMap<Long, Integer>) maxDigitMap.clone();
				newMaxDigitMap.put(key, result);
				maxDigitMap = newMaxDigitMap;
			} else {
				result = digs;
			}
			return result;
		}
	}
	private static int getDigitCount(int radix, int bitCount) {
		if(bitCount <= 0) {
			if(bitCount == 0 && radix >= MIN_RADIX && radix <= MAX_RADIX) {
				return 1;
			}
			throw new IllegalArgumentException();
		}
		switch(radix) {
		case 16:
			return (bitCount + 3) >> 2; 
		case 8:
			return (bitCount + 2) / 3; 
		case 4:
			return (bitCount + 1) >> 1; 
		case 2:
			return bitCount; 
		case 10:
			break;
		default:
			if(radix < MIN_RADIX || radix > MAX_RADIX) {
				throw new IllegalArgumentException();
			}
		}
		return -1;
	}
	public static int getDigitCount(long value, int radix) {
		int result = 1;
		if(radix == 16 && value >= 0) {
			return getDigitCount(16, Long.SIZE - Long.numberOfLeadingZeros(value));
		} else if(radix == 10 && value > -10) {
			if(value < 10) {
				return 1;
			} else if(value < 100) {
				return 2;
			} else if(value < 1000) {
				return 3;
			}
			value /= 1000;
			result = 3; 
		} else if(radix == 8 && value >= 0) {
			while(true) {
				value >>>= 3;
				if(value == 0) {
					break;
				}
				result++;
			}
			return result;
		} else if(radix == 4 && value >= 0) {
			return getDigitCount(4, Long.SIZE - Long.numberOfLeadingZeros(value));
		} else if(radix == 2 && value > 0) {
			return Long.SIZE - Long.numberOfLeadingZeros(value);
		} else if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		while(true) {
			value /= radix;
			if(value == 0) {
				break;
			}
			result++;
		}
		return result;
	}
	protected static BigInteger getRadixPower(BigInteger radix, int power) {
		long key = (((long) radix.intValue()) << 32) | power;
		BigInteger result = radixPowerMap.get(key);
		if(result == null) {
			if(radix.compareTo(BIG_MIN_RADIX) < 0 || radix.compareTo(BIG_MAX_RADIX) > 0) {
				throw new IllegalArgumentException();
			} else if(power == 1) {
				result = radix;
			} else if((power & 1) == 0) {
				BigInteger halfPower = getRadixPower(radix, power >> 1);
				result = halfPower.multiply(halfPower);
			} else {
				BigInteger halfPower = getRadixPower(radix, (power - 1) >> 1);
				result = halfPower.multiply(halfPower).multiply(radix);
			}
			@SuppressWarnings("unchecked")
			TreeMap<Long, BigInteger> newRadixPowerMap = (TreeMap<Long, BigInteger>) radixPowerMap.clone();
			newRadixPowerMap.put(key, result);
			radixPowerMap = newRadixPowerMap;
		}
		return result;
	}
	protected abstract int adjustLowerLeadingZeroCount(int leadingZeroCount, int radix);
	protected abstract int adjustUpperLeadingZeroCount(int leadingZeroCount, int radix);
	private static void getSplitChar(int count, char splitDigitSeparator, String characters, String stringPrefix, StringBuilder builder) {
		while(count-- > 0) {
			if(stringPrefix.length() > 0) {
				builder.append(stringPrefix);
			}
			builder.append(characters);
			builder.append(splitDigitSeparator);
		}
		builder.setLength(builder.length() - 1);
	}
	private static void getSplitChar(int count, char splitDigitSeparator, char character, String stringPrefix, StringBuilder builder) {
		int prefLen = stringPrefix.length();
		while(count-- > 0) {
			if(prefLen > 0) {
				builder.append(stringPrefix);
			}
			builder.append(character);
			builder.append(splitDigitSeparator);
		}
		builder.setLength(builder.length() - 1);
	}
	private static void getSplitLeadingZeros(int leadingZeroCount, char splitDigitSeparator, String stringPrefix, StringBuilder builder) {
		getSplitChar(leadingZeroCount, splitDigitSeparator, '0', stringPrefix, builder);
	}
	protected static void getLeadingZeros(int leadingZeroCount, StringBuilder builder) {
		if(leadingZeroCount > 0) {
			String stringArray[] = zeros;
			if(leadingZeroCount >= stringArray.length) {
				int increment = stringArray.length - 1;
				String incrementStr = stringArray[increment];
				while(leadingZeroCount >= increment) {
					builder.append(incrementStr);
					leadingZeroCount -= increment;
				}
				builder.append(stringArray[leadingZeroCount]);
				return;
			}
			builder.append(stringArray[leadingZeroCount]);
		}
	}
	@Override
	public String toString() {
		int radix = getDefaultTextualRadix();
		IPStringOptions opts;
		switch(radix) {
		case 8:
			opts = OCTAL_PARAMS;
			break;
		case 16:
			opts = HEX_PARAMS;
			break;
		case 10:
			opts = DECIMAL_PARAMS;
			break;
		default:
			opts = new IPStringOptions.Builder(radix).setWildcards(new Wildcards(IPAddress.RANGE_SEPARATOR_STR)).toOptions();
			break;
		}
		StringBuilder builder = new StringBuilder(34);
		toParams(opts).appendSingleDivision(this, builder);
		return builder.toString();
	}
	protected static AddressStringParams<IPAddressStringDivisionSeries> toParams(IPStringOptions opts) {
		@SuppressWarnings("unchecked")
		AddressStringParams<IPAddressStringDivisionSeries> result = (AddressStringParams<IPAddressStringDivisionSeries>) AddressDivisionGroupingBase.getCachedParams(opts);
		if(result == null) {
			result = new IPAddressStringParams<IPAddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
			result.expandSegments(opts.expandSegments);
			result.setWildcards(opts.wildcards);
			result.setSegmentStrPrefix(opts.segmentStrPrefix);
			result.setAddressLabel(opts.addrLabel);
			result.setReverse(opts.reverse);
			result.setSplitDigits(opts.splitDigits);
			result.setRadix(opts.base);
			result.setUppercase(opts.uppercase);
			result.setSeparator(opts.separator);
			result.setZoneSeparator(opts.zoneSeparator);
			AddressDivisionGroupingBase.setCachedParams(opts, result);
		}
		return result;
	}
	protected abstract String getDefaultLowerString();
	protected abstract String getDefaultRangeString();
	protected String getDefaultSegmentWildcardString() {
		return null;
	}
	protected abstract String getDefaultRangeSeparatorString();
	protected String getString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					if(!isMultiple()) {
						result = getDefaultLowerString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						result = getDefaultRangeString();
					}
					cachedWildcardString = result;
				}
			}
		}
		return result;
	}
	protected String getCachedDefaultLowerString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					cachedWildcardString = result = getDefaultLowerString();
				}
			}
		}
		return result;
	}
	protected String getWildcardString() {
		return getString();
	}
	protected void setDefaultAsFullRangeWildcardString() {
		if(cachedWildcardString == null) {
			String result = getDefaultSegmentWildcardString(); 
			if(result != null) {
				synchronized(this) {
					cachedWildcardString = result;
				}
			}
		}
	}
	protected abstract int getLowerStringLength(int radix);
	protected abstract int getUpperStringLength(int radix);
	protected abstract void getLowerString(int radix, boolean uppercase, StringBuilder appendable);
	protected abstract void getLowerString(int radix, int choppedDigits, boolean uppercase, StringBuilder appendable);
	protected abstract void getUpperString(int radix, boolean uppercase, StringBuilder appendable);
	protected abstract void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable);
	protected abstract void getSplitLowerString(int radix, int choppedDigits, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable);
	protected abstract void getSplitRangeString(String rangeSeparator, String wildcard, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable);
	protected abstract int getSplitRangeStringLength(String rangeSeparator, String wildcard, int leadingZeroCount, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix);
	protected abstract int getRangeDigitCount(int radix);
	protected static int toUnsignedStringLength(long value, int radix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int result;
		if(value > 0xffff || (result = toUnsignedStringLengthFast((int) value, radix)) < 0) {
			result = toUnsignedStringLengthSlow(value, radix);
		}
		return result;
	}
	private static int toUnsignedStringLengthSlow(long value, int radix) {
		int count = 1;
		boolean useInts = value <= Integer.MAX_VALUE;
		int intValue = useInts ? (int) value : radix;
		while(intValue >= radix) {
			if(useInts) {
				intValue /= radix;
			} else {
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					intValue = (int) value;
				}
			}
			++count;
		}
		return count;
	}
	private static int toUnsignedStringLengthFast(int value, int radix) {
		if(value <= 1) {
			return 1;
		}
		if(radix == 10) {
			if(value < 10) {
				return 1;
			} else if(value < 100) {
				return 2;
			} else if(value < 1000) {
				return 3;
			} else if(value < 10000) {
				return 4;
			}
			return 5;
	    }
		if(radix == 16) {
			if(value < 0x10) {
				return 1;
			} else if(value < 0x100) {
				return 2;
			} else if(value < 0x1000) {
				return 3;
			}
			return 4;
		}
		if(radix == 8) {
			if(value < 010) {
				return 1;
			} else if(value < 0100) {
				return 2;
			} else if(value < 01000) {
				return 3;
			} else if(value < 010000) {
				return 4;
			} else if(value < 0100000) {
				return 5;
			}
			return 6;
		}
		if(radix == 2) {
			int digitCount = 15;
			int val = value;
			if (val >>> 8 == 0) { 
				digitCount -=  8;
			} else {
				val >>>= 8;
			}
			if (val >>> 4 == 0) {
				digitCount -=  4;
			} else {
				val >>>= 4;
			}
			if (val >>> 2 == 0) {
				digitCount -= 2;
			} else {
				val >>>= 2;
			}
			if((val & 2) != 0) {
				++digitCount;
			}
			return digitCount;
		}
		return -1;
	}
	protected static StringBuilder toUnsignedStringCased(long value, int radix, int choppedDigits, boolean uppercase, StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		} else if(value > 0xffff || !toUnsignedStringFastChopped((int) value, radix, choppedDigits, uppercase, appendable)) {
			toUnsignedStringSlow(value, radix, choppedDigits, uppercase, appendable);
		}
		return appendable;
	}
	private static boolean toUnsignedStringFastChopped(int value, int radix, int choppedDigits, boolean uppercase, StringBuilder appendable) {
		if(toUnsignedStringFast(value, radix, uppercase, appendable)) {
			if(choppedDigits > 0) {
				appendable.setLength(appendable.length() - choppedDigits);
			}
			return true;
		}
		return false;
	}
	private static char[] getDigits(boolean uppercase, int radix) {
		if(uppercase || radix > 36) {
			return UPPERCASE_DIGITS;
		}
		return DIGITS;
	}
	private static boolean toUnsignedStringFast(int value, int radix, boolean uppercase, StringBuilder appendable) {
		if(value <= 1) {
			appendable.append(value == 0 ? '0' : '1');
			return true;
		}
		int quotient, remainder; 
		if(radix == 10) {
			if(value < 10) {
				char dig[] = getDigits(uppercase, radix);
				appendable.append(dig[value]);
				return true;
			} else if(value < 100) {
				char dig[] = DOUBLE_DIGITS_DEC;
				int digIndex = value << 1;
				appendable.append(dig[digIndex]);
				appendable.append(dig[digIndex + 1]);
				return true;
			} else if(value < 200) {
				int index = appendable.length();
				appendable.append("127");
				if(value != 127) {
					char dig[] = DOUBLE_DIGITS_DEC;
					index++;
					int digIndex = (value - 100) << 1;
					appendable.setCharAt(index, dig[digIndex]);
					appendable.setCharAt(index + 1, dig[digIndex + 1]);
				}
				return true;
			} else if(value < 300) {
				int index = appendable.length();
				appendable.append("255");
				if(value != 255) {
					char dig[] = DOUBLE_DIGITS_DEC;
					index++;
					int digIndex = (value - 200) << 1;
					appendable.setCharAt(index, dig[digIndex]);
					appendable.setCharAt(index + 1, dig[digIndex + 1]);
				}
				return true;
			} else if(value < 1000) {
				appendable.append("   ");
			} else if(value < 10000) {
				appendable.append("    ");
			} else {
				appendable.append("     ");
			}
			char dig[] = DIGITS;
			int index = appendable.length();
			do { 
				quotient = (value * 0xcccd) >>> 19; 
				remainder = value - ((quotient << 3) + (quotient << 1)); 
				appendable.setCharAt(--index, dig[remainder]);
				value = quotient;
	        } while(value != 0);
			return true;
	    } else if(radix == 16) {
			if(value < 0x10) {
				char dig[] = getDigits(uppercase, radix);
				appendable.append(dig[value]);
				return true;
			} else if(value < 0x100) {
				appendable.append("  ");
			} else if(value < 0x1000) {
				appendable.append("   ");
			} else {
				if(value == 0xffff) {
					appendable.append(uppercase ? "FFFF" : "ffff");
					return true;
				}
				appendable.append("    ");
			}
			char dig[] = getDigits(uppercase, radix);
			int index = appendable.length();
			do {
				remainder = value & 15;
				value >>>= 4;
				appendable.setCharAt(--index, dig[remainder]);
			} while(value != 0);
			return true;
		} else if(radix == 8) {
			char dig[] = DIGITS;
			if(value < 010) {
				appendable.append(dig[value]);
				return true;
			} else if(value < 0100) {
				appendable.append("  ");
			} else if(value < 01000) {
				appendable.append("   ");
			} else if(value < 010000) {
				appendable.append("    ");
			} else if(value < 0100000) { 
				appendable.append("     ");
			} else {
				appendable.append("      ");
			}
			int index = appendable.length();
			do {
				remainder = value & 7;
				value >>>= 3;
				appendable.setCharAt(--index, dig[remainder]);
			} while(value != 0);
			return true;
		} else if(radix == 2) {
			int digitIndex;
			if (value >>> 8 == 0) {
				if(value == 0xff) {
					appendable.append("11111111");
					return true;
				} else if (value >>> 4 == 0) {
					digitIndex = 4;
				} else {
					digitIndex = 8;
				}
			} else {
				if(value == 0xffff) {
					appendable.append("1111111111111111");
					return true;
				} else if (value >>> 4 == 0) {
					digitIndex = 12;
				} else {
					digitIndex = 16;
				}
			}
			while(--digitIndex > 0) {
				int digit = (value >>> digitIndex) & 1;
				if(digit == 1) {
					appendable.append('1');
					while(--digitIndex > 0) {
						digit = (value >>> digitIndex) & 1;
						appendable.append(digit == 0 ? '0' : '1');
					}
					break;
				}
			}
			appendable.append((value & 1) == 0 ? '0' : '1');
			return true;
		}
		return false;
	}
	private static void toUnsignedStringSlow(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase,
			StringBuilder appendable) {
		int front = appendable.length();
		appendDigits(value, radix, choppedDigits, uppercase, appendable);
		int back = appendable.length() - 1;
		while(front < back) {
			char frontChar = appendable.charAt(front);
			appendable.setCharAt(front++, appendable.charAt(back));
			appendable.setCharAt(back--, frontChar);
		}
	}
	private static void appendDigits(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase,
			StringBuilder appendable) {
		boolean useInts = value <= Integer.MAX_VALUE;
		int value2 = useInts ? (int) value : radix;
		int index;
		char dig[] = getDigits(uppercase, radix);
		while(value2 >= radix) {
			if(useInts) {
				int val2 = value2;
				value2 /= radix;
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = val2 % radix;
			} else {
				long val = value;
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					value2 = (int) value;
				}
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = (int) (val % radix);
			}
			appendable.append(dig[index]);
		}
		if(choppedDigits == 0) {
			appendable.append(dig[value2]);
		}
	}
	protected void appendUppercase(CharSequence str, int radix, StringBuilder appendable) {
		if(radix > 10) {
			for(int i = 0; i < str.length(); i++) {
				char c = str.charAt(i);
				if(c >= 'a' && c <= 'z') {
					c += 'A' - 'a';
				}
				appendable.append(c);
			}
		} else {
			appendable.append(str);
		}
	}
	private static int getFullRangeString(String wildcard, StringBuilder appendable) {
		if(appendable == null) {
			return wildcard.length();
		}
		appendable.append(wildcard);
		return 0;
	}
	protected int getPrefixAdjustedRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		int radix = params.getRadix();
		int lowerLeadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
		int upperLeadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		Wildcards wildcards = params.getWildcards();
		String rangeSeparator = wildcards.rangeSeparator;
		int rangeDigitCount = wildcards.singleWildcard == null ? 0 : getRangeDigitCount(radix);
		if(rangeDigitCount == 0 && radix == getDefaultTextualRadix() && !isFullRange()) {
			String str = getString();
			String rangeSep = getDefaultRangeSeparatorString();
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(lowerLeadingZeroCount == 0 && upperLeadingZeroCount == 0 && rangeSep.equals(rangeSeparator) && prefLen == 0) {
				if(appendable == null) {
					return str.length();
				} else {
					if(params.isUppercase()) {
						appendUppercase(str, radix, appendable);
					} else {
						appendable.append(str);
					}
					return 0;
				}
			} else {
				if(appendable == null) {
					int count = str.length() + (rangeSeparator.length() - rangeSep.length()) +
							lowerLeadingZeroCount + upperLeadingZeroCount;
					if(prefLen > 0) {
						count += prefLen << 1;
					}
					return count;
				} else {
					int firstEnd = str.indexOf(rangeSep);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(lowerLeadingZeroCount > 0) {
						getLeadingZeros(lowerLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(0, firstEnd));
					appendable.append(rangeSeparator);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(upperLeadingZeroCount > 0) {
						getLeadingZeros(upperLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(firstEnd + rangeSep.length()));
					return 0;
				}
			}
		}
		rangeDigitCount = adjustRangeDigits(rangeDigitCount);
		if(leadingZeroCount < 0 && appendable == null) {
			int charLength = getMaxDigitCount(radix);
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(rangeDigitCount != 0) {
				int count = charLength;
				if(prefLen > 0) {
					count += prefLen;
				}
				return count;
			}
			int count = charLength << 1;
			if(prefLen > 0) {
				count += prefLen << 1;
			}
			count += rangeSeparator.length();
			return count;
		}
		if(rangeDigitCount != 0) {
			return getRangeDigitString(segmentIndex, params, appendable);
		}
		return getRangeString(segmentIndex, params, lowerLeadingZeroCount, upperLeadingZeroCount, true, appendable);
	}
	@Override
	public int getLowerStandardString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		int count = 0;
		String stringPrefix = params.getSegmentStrPrefix();
		int prefLen = stringPrefix.length();
		if(prefLen > 0) {
			if(appendable == null) {
				count += prefLen;
			} else {
				appendable.append(stringPrefix);
			}
		}
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		if(leadingZeroCount != 0) {
			if(appendable == null) {
				if(leadingZeroCount < 0) {
					return count + getMaxDigitCount(radix);
				} else {
					count += leadingZeroCount;
				}
			} else {
				leadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
				getLeadingZeros(leadingZeroCount, appendable);
			}
		}
		boolean uppercase = params.isUppercase();
		if(radix == getDefaultTextualRadix()) {
			String str = getCachedDefaultLowerString();
			if(appendable == null) {
				return count + str.length();
			} else if(uppercase) {
				appendUppercase(str, radix, appendable);
			} else {
				appendable.append(str);
			}
		} else {
			if(appendable == null) {
				return count + getLowerStringLength(radix);
			} else {
				getLowerString(radix, uppercase, appendable);
			}
		}
		return 0;
	}
	@Override
	public int getStandardString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		if(!isMultiple()) {
			boolean splitDigits = params.isSplitDigits();
			if(splitDigits) {
				int radix = params.getRadix();
				int leadingZeroCount = params.getLeadingZeros(segmentIndex);
				leadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
				String stringPrefix = params.getSegmentStrPrefix();
				int prefLen = stringPrefix.length();
				if(appendable == null) {
					int len;
					if(leadingZeroCount != 0) {
						if(leadingZeroCount < 0) {
							len = getMaxDigitCount(radix);
						} else {
							len = getLowerStringLength(radix) + leadingZeroCount;
						}
					} else {
						len = getLowerStringLength(radix);
					}
					int count = (len << 1) - 1;
					if(prefLen > 0) {
						count += len * prefLen;
					}
					return count;
				} else {
					char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
					boolean reverseSplitDigits = params.isReverseSplitDigits();
					boolean uppercase = params.isUppercase();
					if(reverseSplitDigits) {
						getSplitLowerString(radix, 0, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
						if(leadingZeroCount != 0) {
							appendable.append(splitDigitSeparator);
							getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
						}
					} else {
						if(leadingZeroCount != 0) {
							getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
							appendable.append(splitDigitSeparator);
						}
						getSplitLowerString(radix, 0, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
					}
					return 0;
				}
			}
			return getLowerStandardString(segmentIndex, params, appendable);
		}
		if(isFullRange()) {
			String wildcard = params.getWildcards().wildcard;
			if(wildcard != null) {
				if(wildcard.equals(getDefaultSegmentWildcardString())) {
					setDefaultAsFullRangeWildcardString();
				}
				boolean splitDigits = params.isSplitDigits();
				if(splitDigits) {
					int radix = params.getRadix();
					if(appendable == null) {
						int len = getMaxDigitCount(radix);
						int count = len * (wildcard.length() + 1) - 1;
						return count;
					}
					char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
					getSplitChar(getMaxDigitCount(radix), splitDigitSeparator, wildcard, "", appendable);
					return 0;
				}
				return getFullRangeString(wildcard, appendable);
			}
		}
		return getRangeString(segmentIndex, params, appendable);
	}
	protected int getRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		boolean splitDigits = params.isSplitDigits();
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		Wildcards wildcards = params.getWildcards();
		String rangeSeparator = wildcards.rangeSeparator;
		int rangeDigitCount = wildcards.singleWildcard == null ? 0 : getRangeDigitCount(radix);
		int lowerLeadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
		int upperLeadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		if(rangeDigitCount == 0 && 
				radix == getDefaultTextualRadix() && 
				!splitDigits &&
				!isFullRange()) {
			String str = getWildcardString();
			String rangeSep = getDefaultRangeSeparatorString();
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(lowerLeadingZeroCount == 0 && upperLeadingZeroCount == 0 &&
					prefLen == 0 &&
					rangeSeparator.equals(rangeSep)) {
				if(appendable == null) {
					return str.length();
				}
				appendable.append(str);
				return 0;
			} else {
				if(appendable == null) {
					int count = str.length() + (rangeSeparator.length() - rangeSep.length())  + lowerLeadingZeroCount + upperLeadingZeroCount;
					if(prefLen > 0) {
						count += prefLen << 1;
					}
					return count;
				} else {
					int firstEnd = str.indexOf(rangeSep);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(lowerLeadingZeroCount > 0) {
						getLeadingZeros(lowerLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(0, firstEnd));
					appendable.append(rangeSeparator);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(upperLeadingZeroCount > 0) {
						getLeadingZeros(upperLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(firstEnd + rangeSep.length()));
					return 0;
				}
			}
		}
		if(!splitDigits && leadingZeroCount < 0 && appendable == null) {
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			int charLength = getMaxDigitCount(radix);
			if(rangeDigitCount != 0) {
				int count = charLength;
				if(prefLen > 0) {
					count += prefLen;
				}
				return count;
			}
			int count = charLength << 1;
			if(prefLen > 0) {
				count += prefLen << 1;
			}
			count += rangeSeparator.length();
			return count;
		}
		rangeDigitCount = adjustRangeDigits(rangeDigitCount);
		if(rangeDigitCount != 0) {
			if(splitDigits) {
				return getSplitRangeDigitString(segmentIndex, params, appendable);
			} else {
				return getRangeDigitString(segmentIndex, params, appendable);
			}
		}
		if(splitDigits) {
			return getSplitRangeString(segmentIndex, params, appendable);
		}
		return getRangeString(segmentIndex, params, lowerLeadingZeroCount, upperLeadingZeroCount, false, appendable);
	}
	protected int getSplitRangeDigitString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		int radix = params.getRadix();
		int leadingZerosCount = params.getLeadingZeros(segmentIndex);
		leadingZerosCount = adjustLowerLeadingZeroCount(leadingZerosCount, radix);
		String stringPrefix = params.getSegmentStrPrefix();
		if(appendable == null) {
			int len = getLowerStringLength(radix) + leadingZerosCount;
			int count = (len << 1) - 1;
			int prefLen = stringPrefix.length();
			if(prefLen > 0) {
				count += len * prefLen;
			}
			return count;
		} else {
			Wildcards wildcards = params.getWildcards();
			int rangeDigits = adjustRangeDigits(getRangeDigitCount(radix));
			char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
			boolean reverseSplitDigits = params.isReverseSplitDigits();
			boolean uppercase = params.isUppercase();
			if(reverseSplitDigits) {
				getSplitChar(rangeDigits, splitDigitSeparator, wildcards.singleWildcard, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				getSplitLowerString(radix, rangeDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
				if(leadingZerosCount > 0) {
					appendable.append(splitDigitSeparator);
					getSplitLeadingZeros(leadingZerosCount, splitDigitSeparator, stringPrefix, appendable);
				}
			} else {
				if(leadingZerosCount != 0) {
					getSplitLeadingZeros(leadingZerosCount, splitDigitSeparator, stringPrefix, appendable);
					appendable.append(splitDigitSeparator);
				}
				getSplitLowerString(radix, rangeDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				getSplitChar(rangeDigits, splitDigitSeparator, wildcards.singleWildcard, stringPrefix, appendable);
			}
		}
		return 0;
	}
	protected int getRangeDigitString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		int radix = params.getRadix();
		int leadingZerosCount = params.getLeadingZeros(segmentIndex);
		leadingZerosCount = adjustLowerLeadingZeroCount(leadingZerosCount, radix);
		String stringPrefix = params.getSegmentStrPrefix();
		int prefLen = stringPrefix.length();
		Wildcards wildcards = params.getWildcards();
		int rangeDigits = adjustRangeDigits(getRangeDigitCount(radix));
		if(appendable == null) {
			return getLowerStringLength(radix) + leadingZerosCount + prefLen;
		} else {
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			if(leadingZerosCount > 0) {
				getLeadingZeros(leadingZerosCount, appendable);
			}
			boolean uppercase = params.isUppercase();
			getLowerString(radix, rangeDigits, uppercase, appendable);
			for(int i = 0; i < rangeDigits; i++) {
				appendable.append(wildcards.singleWildcard);
			}
		}
		return 0;
	}
	int adjustRangeDigits(int rangeDigits) {
		if(rangeDigits != 0) {
			if(!includesZero() || rangeDigits == 1) { 
				return rangeDigits;
			}
		}
		return 0;
	}
	protected int getRangeString(
			int segmentIndex,
			AddressSegmentParams params,
			int lowerLeadingZerosCount,
			int upperLeadingZerosCount,
			boolean maskUpper,
			StringBuilder appendable) {
		String stringPrefix = params.getSegmentStrPrefix();
		int radix = params.getRadix();
		String rangeSeparator = params.getWildcards().rangeSeparator;
		boolean uppercase = params.isUppercase();
		return getRangeString(rangeSeparator, lowerLeadingZerosCount, upperLeadingZerosCount, stringPrefix, radix, uppercase, maskUpper, appendable);
	}
	protected int getRangeString(
			String rangeSeparator,
			int lowerLeadingZerosCount,
			int upperLeadingZerosCount,
			String stringPrefix,
			int radix,
			boolean uppercase,
			boolean maskUpper,
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int prefLen = stringPrefix.length();
		boolean hasStringPrefix = prefLen > 0;
		if(appendable == null) {
			int count = lowerLeadingZerosCount + upperLeadingZerosCount + 
					getLowerStringLength(radix) + getUpperStringLength(radix) + rangeSeparator.length();
			if(hasStringPrefix) {
				count += prefLen << 1;
			}
			return count;
		} else {
			if(hasStringPrefix) {
				appendable.append(stringPrefix);
			}
			if(lowerLeadingZerosCount > 0) {
				getLeadingZeros(lowerLeadingZerosCount, appendable);
			}
			getLowerString(radix, uppercase, appendable);
			appendable.append(rangeSeparator);
			if(hasStringPrefix) {
				appendable.append(stringPrefix);
			}
			if(upperLeadingZerosCount > 0) {
				getLeadingZeros(upperLeadingZerosCount, appendable);
			}
			if(maskUpper) {
				getUpperStringMasked(radix, uppercase, appendable);
			} else {
				getUpperString(radix, uppercase, appendable);
			}
		}
		return 0;
	}
	protected int getSplitRangeString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		String stringPrefix = params.getSegmentStrPrefix();
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		leadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		Wildcards wildcards = params.getWildcards();
		boolean uppercase = params.isUppercase();
		char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
		boolean reverseSplitDigits = params.isReverseSplitDigits();
		String rangeSeparator = wildcards.rangeSeparator;
		if(appendable == null) {
			return getSplitRangeStringLength(
					rangeSeparator,
					wildcards.wildcard,
					leadingZeroCount,
					radix,
					uppercase, 
					splitDigitSeparator,
					reverseSplitDigits,
					stringPrefix);
		} else {
			boolean hasLeadingZeros = leadingZeroCount != 0;
			if(hasLeadingZeros && !reverseSplitDigits) {
				getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				hasLeadingZeros = false;
			}
			getSplitRangeString(
					rangeSeparator,
					wildcards.wildcard,
					radix,
					uppercase, 
					splitDigitSeparator,
					reverseSplitDigits,
					stringPrefix,
					appendable);
			if(hasLeadingZeros) {
				appendable.append(splitDigitSeparator);
				getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
			}
		}
		return 0;
	}
	@FunctionalInterface
	protected static interface SegmentCreator<R extends AddressSegment> {
		R applyAsInt(int low, int high);
	}
	@FunctionalInterface
	protected static interface IntBinaryIteratorProvider<R> {
		Iterator<R> applyAsInt(boolean isLowest, boolean isHighest, int low, int high);
	}
	protected static <T extends AddressSegment> AddressComponentSpliterator<T> createSegmentSpliterator(
			T splitForIteration,
			int value,
			int upperValue,
			Supplier<Iterator<T>> iteratorProvider,
			IntBinaryIteratorProvider<T> subIteratorProvider,
			SegmentCreator<T> itemProvider) {
		return new AddressSegmentSpliterator<T>(splitForIteration, value, upperValue, iteratorProvider, subIteratorProvider, itemProvider);
	}
	static boolean testRange(BigInteger lowerValue, BigInteger upperValue, BigInteger finalUpperValue, BigInteger networkMask, BigInteger hostMask) {
		return lowerValue.equals(lowerValue.and(networkMask)) && finalUpperValue.equals(upperValue.or(hostMask));
	}
	static boolean testRange(BigInteger lowerValue, BigInteger upperValue, BigInteger finalUpperValue, int bitCount, int divisionPrefixLen) {
		BigInteger networkMask = AddressDivisionGroupingBase.ALL_ONES.shiftLeft(bitCount - divisionPrefixLen);
		BigInteger hostMask = networkMask.not();
		return testRange(lowerValue, upperValue, finalUpperValue, networkMask, hostMask);
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import inet.ipaddr.format.AddressItem;
public class AddressValueException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	static String errorMessage = getMessage("ipaddress.address.error");
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public AddressValueException(long value) {
		super(value + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	public AddressValueException(String key, long value) {
		super(value + ", " + errorMessage + " " + getMessage(key));
	}
	public AddressValueException(BigInteger value) {
		super(value + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	public AddressValueException(AddressItem one, AddressItem two, int count) {
		super(count + ", " + one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	public AddressValueException(AddressItem one, AddressItem two) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	public AddressValueException(AddressItem one, String key) {
		super(one + ", "  + errorMessage + " " + getMessage(key));
	}
	public AddressValueException(String message) {
        super(message);
    }
	public AddressValueException(String message, Throwable cause) {
        super(message, cause);
    }
}
package inet.ipaddr;
import inet.ipaddr.format.AddressComponentRange;
import inet.ipaddr.format.util.AddressComponentSpliterator;
public interface AddressComponent extends AddressComponentRange {
	AddressNetwork<?> getNetwork();
	String toHexString(boolean with0xPrefix) throws IncompatibleAddressException;
	String toNormalizedString();
	AddressComponent reverseBits(boolean perByte);
	AddressComponent reverseBytes();
	@Override
	AddressComponentSpliterator<? extends  AddressComponent> spliterator();
}
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressGenericDivision;
import inet.ipaddr.format.util.AddressComponentSpliterator;
public interface AddressSegment extends AddressComponent, AddressGenericDivision {
	int getValueCount();
	int getPrefixValueCount(int segmentPrefixLength);
	int getSegmentValue();
	int getUpperSegmentValue();
	@Override
	AddressSegment getLower();
	@Override
	AddressSegment getUpper();
	@Override
	AddressSegment reverseBits(boolean perByte);
	@Override
	AddressSegment reverseBytes();
	@Override
	Iterable<? extends AddressSegment> getIterable();
	@Override
	Iterator<? extends AddressSegment> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegment> spliterator();
	@Override
	Stream<? extends AddressSegment> stream();
	boolean matches(int value);
	boolean matchesWithMask(int value, int mask);
	boolean matchesWithMask(int lowerValue, int upperValue, int mask);
	boolean overlaps(AddressSegment other);
	boolean contains(AddressSegment other);
	@Override
	boolean equals(Object other);
	boolean prefixEquals(AddressSegment other, int prefixLength);
	default boolean testBit(int n) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(n < 0 || n >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << n)) != 0;
	}
	default boolean isOneBit(int segmentBitIndex) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(segmentBitIndex < 0 || segmentBitIndex >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << (bitCount - (segmentBitIndex + 1)))) != 0;
	}
	int getMaxSegmentValue();
}
package inet.ipaddr.format.standard;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.BooleanSupplier;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongSupplier;
import java.util.function.Predicate;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.NetworkMismatchException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public class AddressDivisionGrouping extends AddressDivisionGroupingBase {
	private static final long serialVersionUID = 4L;
	public static interface DivisionValueProvider {
		long getValue(int segmentIndex);
	}
	public static interface DivisionLengthProvider {
		int getLength(int segmentIndex);
	}
	protected static class SectionCache<R extends AddressSegmentSeries> {
		public R lower;
		public R lowerNonZeroHost;
		public R upper;
		public boolean lowerNonZeroHostIsNull;
		public SectionCache() {}
	}
	protected static class StringCache {
		public String canonicalString;
		public String hexString;
		public String hexStringPrefixed;
	}
	public AddressDivisionGrouping(AddressDivision divisions[]) {
		super(divisions);
	}
	public AddressDivisionGrouping(AddressDivision divisions[], boolean checkDivisions) {
		super(divisions, checkDivisions);
	}
	@Override
	public AddressDivision getDivision(int index) {
		return (AddressDivision) super.getDivision(index);
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[(getBitCount() + 7) >> 3];
		int byteCount = bytes.length;
		int divCount = getDivisionCount();
		for(int k = divCount - 1, byteIndex = byteCount - 1, bitIndex = 8; k >= 0; k--) {
			AddressDivision div = getDivision(k);
			long segmentValue = low ? div.getDivisionValue() : div.getUpperDivisionValue();
			int divBits = div.getBitCount();
			while(divBits > 0) {
				bytes[byteIndex] |= segmentValue << (8 - bitIndex);
				segmentValue >>>= bitIndex;
				if(divBits < bitIndex) {
					bitIndex -= divBits;
					break;
				} else {
					divBits -= bitIndex;
					bitIndex = 8;
					byteIndex--;
				}
			}
		}
		return bytes;
	}
	protected static Integer cacheBits(int i) {
		return ParsedAddressGrouping.cache(i);
	}
	protected static <R extends AddressSection, S extends AddressSegment> boolean overlaps(R original, R other) {
		int count = original.getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		for(int i = count - 1; i >= 0; i--) {
			AddressSegment seg = original.getSegment(i);
			if(!seg.overlaps(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength < totalBitCount) {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isPrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(division.isMultiple()) {
					return false;
				}
			} else {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isSinglePrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			int count = getDivisionCount();
			for(int i = 0; i < count; i++) {
				AddressDivision combo = getDivision(i);
				res = adjustHashCode(res, combo.getDivisionValue(), combo.getUpperDivisionValue());
			}
			hashCode = res;
		}
		return res;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof AddressDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionGrouping) {
			AddressDivisionGrouping other = (AddressDivisionGrouping) o;
			return other.isSameGrouping(this);
		}
		return false;
	}
	protected static long getLongCount(IntUnaryOperator countProvider, int segCount) {
		if(segCount == 0) {
			return 1;
		}
		long result = countProvider.applyAsInt(0);
		for(int i = 1; i < segCount; i++) {
			result *= countProvider.applyAsInt(i);
		}
		return result;
	}
	protected static <R extends AddressSection, S extends AddressSegment> long longPrefixCount(R section, int prefixLength) {
		int bitsPerSegment = section.getBitsPerSegment();
		int bytesPerSegment = section.getBytesPerSegment();
		int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		int hostSegmentIndex = getHostSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		boolean hasPrefixedSegment = (networkSegmentIndex == hostSegmentIndex);
		return getLongCount(i -> {
			if(hasPrefixedSegment && i == networkSegmentIndex) {
				int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
				return AddressDivision.getPrefixValueCount(section.getSegment(i), segmentPrefixLength);
			}
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, networkSegmentIndex + 1);
	}
	protected static <R extends AddressSection, S extends AddressSegment> long longCount(R section, int segCount) {
		long result = getLongCount(i -> {
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, segCount);
		return result;
	}
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static Integer getSegmentPrefixLength(int segmentBits, int segmentPrefixedBits) {
		return ParsedAddressGrouping.getDivisionPrefixLength(segmentBits, segmentPrefixedBits);
	}
	protected static int getNetworkPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getNetworkPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected int getAdjustedPrefix(boolean nextSegment, int bitsPerSegment, boolean skipBitCountPrefix) {
		Integer prefix = getPrefixLength();
		int bitCount = getBitCount();
		if(nextSegment) {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				return bitCount;
			}
			if(prefix == bitCount) {
				return bitCount;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = existingPrefixLength % bitsPerSegment;
			return existingPrefixLength + bitsPerSegment - adjustment;
		} else {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				if(skipBitCountPrefix) {
					prefix = bitCount;
				} else {
					return bitCount;
				}
			} else if(prefix == 0) {
				return 0;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = ((existingPrefixLength - 1) % bitsPerSegment) + 1;
			return existingPrefixLength - adjustment;
		}
	}
	protected int getAdjustedPrefix(int adjustment, boolean floor, boolean ceiling) {
		Integer prefix = getPrefixLength();
		if(prefix == null) {
			if(getMinPrefixLengthForBlock() == 0) {
				prefix = cacheBits(0);
			} else {
				prefix = cacheBits(getBitCount());
			}
		}
		int result = prefix + adjustment;
		if(ceiling) {
			result = Math.min(getBitCount(), result);
		}
		if(floor) {
			result = Math.max(0, result);
		}
		return result;
	}
	protected static <S extends IPAddressSegment> void normalizePrefixBoundary(
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			Function<S, S> segProducer) {
		int networkSegmentIndex = getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount);
		if(networkSegmentIndex >= 0) {
			S segment = segments[networkSegmentIndex];
			if(!segment.isPrefixed()) {
				segments[networkSegmentIndex] = segProducer.apply(segment);
			}
		}
	}
	protected static <S extends AddressSegment> S[] setPrefixedSegments(
			AddressNetwork<?> network,
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			AddressSegmentCreator<S> segmentCreator,
			BiFunction<S, Integer, S> segProducer) {
		boolean allPrefsSubnet = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = (sectionPrefixBits == 0) ? 0 : getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount); i < segments.length; i++) {
			Integer pref = getPrefixedSegmentPrefixLength(segmentBitCount, sectionPrefixBits, i);
			if(pref != null) {
				segments[i] = segProducer.apply(segments[i], pref);
				if(allPrefsSubnet) {
					if(++i < segments.length) {
						S allSeg = segmentCreator.createSegment(0, cacheBits(0));
						Arrays.fill(segments, i, segments.length, allSeg);
					}
				}
			}
		}
		return segments;
	}
	@FunctionalInterface
	protected interface SegPrefFunction<S> {
	    S apply(S s, Integer u, Integer v);
	}
	protected static <R extends AddressSection, S extends AddressSegment> S[] removePrefix(
			R original,
			S segments[],
			int segmentBitCount,
			SegPrefFunction<S> prefixSetter 
			) {
		Integer oldPrefix = original.getPrefixLength();
		if(oldPrefix != null) {
			segments = segments.clone();
			int networkSegIndex = 0;
			if(oldPrefix > 0) {
				networkSegIndex = getNetworkSegmentIndex(oldPrefix, original.getBytesPerSegment(), segmentBitCount);
			}
			for(int i = networkSegIndex; i < segments.length; i++) {
				Integer oldPref = getPrefixedSegmentPrefixLength(segmentBitCount, oldPrefix, i);
				segments[i] = prefixSetter.apply(segments[i], oldPref, null);
			}
		}
		return segments;
	}
	protected static boolean prefixEquals(AddressSection first, AddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				AddressSegment one = first.getSegment(prefixedSection);
				AddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixEquals(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			AddressSegment one = first.getSegment(prefixedSection);
			AddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.equals(two)) {
				return false;
			}
		}
		return true;
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			long highBytes,
			long lowBytes,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentMask = ~(~0 << bitsPerSegment);
		int lowIndex = Math.max(0, segments.length - (Long.SIZE / bitsPerSegment));
		int segmentIndex = segments.length - 1;
		long bytes = lowBytes;
		while(true) {
			while(true) {
				Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
				int value = segmentMask & (int) bytes;
				S seg = creator.createSegment(value, segmentPrefixLength);
				if(!isCompatibleNetworks(network, seg.getNetwork())) {
					throw new NetworkMismatchException(seg);
				}
				segments[segmentIndex] = seg;
				if(--segmentIndex < lowIndex) {
					break;
				}
				bytes >>>= bitsPerSegment;
			}
			if(lowIndex == 0) {
				break;
			}
			lowIndex = 0;
			bytes = highBytes;
		}
		return segments;
	}
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return one.getPrefixConfiguration().equals(two.getPrefixConfiguration());
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		for(int segmentIndex = 0; segmentIndex < segmentCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(segmentPrefixLength != null && segmentPrefixLength == 0 && network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			int value = 0, value2 = 0;
			if(lowerValueProvider == null) {
				value = upperValueProvider.getValue(segmentIndex);
			} else {
				value = lowerValueProvider.getValue(segmentIndex);
				if(upperValueProvider != null) {
					value2 = upperValueProvider.getValue(segmentIndex);
				}
			}
			S seg = (lowerValueProvider != null && upperValueProvider != null) ? 
					creator.createSegment(value, value2, segmentPrefixLength) : 
						creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <S extends AddressSegment> S[] toSegments(
			S segments[],
			byte bytes[],
			int startIndex,
			int endIndex,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		if(endIndex < 0 || endIndex > bytes.length) {
			throw new AddressValueException(endIndex);
		}
		if(startIndex < 0 || startIndex > endIndex) {
			throw new AddressValueException(startIndex);
		}
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		int expectedByteCount = segmentCount * bytesPerSegment;
		int missingBytes = expectedByteCount + startIndex - endIndex;
		if(missingBytes < 0) {
			int expectedStartIndex = endIndex - expectedByteCount;
			int higherStartIndex = expectedStartIndex - 1;
			byte expectedExtendedValue = bytes[higherStartIndex];
			if(expectedExtendedValue != 0) {
				int mostSignificantBit = bytes[expectedStartIndex] >>> 7;
				if(mostSignificantBit != 0) {
					if(expectedExtendedValue != -1) {
						throw new AddressValueException(expectedExtendedValue);
					}
				} else {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			while(startIndex < higherStartIndex) {
				if(bytes[--higherStartIndex] != expectedExtendedValue) {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			startIndex = expectedStartIndex;
			missingBytes = 0;
		}
		boolean allPrefixedAddressesAreSubnets = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0, segmentIndex = 0; i < expectedByteCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(allPrefixedAddressesAreSubnets && segmentPrefixLength != null && segmentPrefixLength == 0) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			int value = 0;
			int k = bytesPerSegment + i;
			int j = i;
			if(j < missingBytes) {
				int mostSignificantBit = bytes[startIndex] >>> 7;
				if(mostSignificantBit == 0) {
					j = missingBytes;
				} else {
					int upper = Math.min(missingBytes, k);
					for(; j < upper; j++) {
						value <<= 8;
						value |= 0xff;
					}
				}
			}
			for(; j < k; j++) {
				int byteValue = 0xff & bytes[startIndex + j - missingBytes];
				value <<= 8;
				value |= byteValue;
			}
			i = k;
			S seg = creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <R extends AddressSection, S extends AddressSegment> S[] createSingle(
			R original,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<S> segProducer) {
		int segmentCount = original.getSegmentCount();
		S segs[] = segmentCreator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			segs[i] = segProducer.apply(i);
		}
		return segs;
	}
	protected static <R extends AddressSegmentSeries> R getSingleLowestOrHighestSection(R section) {
		if(!section.isMultiple() && !(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets())) {
			return section;
		}
		return null;
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseSegments(R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segProducer, boolean removePrefix) {
		int count = section.getSegmentCount();
		S newSegs[] = creator.createSegmentArray(count);
		int halfCount = count >>> 1;
		int i = 0;
		boolean isSame = !removePrefix || !section.isPrefixed();
		for(int j = count - 1; i < halfCount; i++, j--) {
			newSegs[j] = segProducer.apply(i);
			newSegs[i] = segProducer.apply(j);
			if(isSame && !(newSegs[i].equals(section.getSegment(i)) && newSegs[j].equals(section.getSegment(j)))) {
				isSame = false;
			}
		}
		if((count & 1) == 1) {
			newSegs[i] = segProducer.apply(i);
			if(isSame && !newSegs[i].equals(section.getSegment(i))) {
				isSame = false;
			}
		}
		if(isSame) {
			return section;
		}
		return creator.createSectionInternal(newSegs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBits(
			boolean perByte, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segBitReverser, boolean removePrefix) {
		if(perByte) {
			boolean isSame = !removePrefix || !section.isPrefixed();
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segBitReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segBitReverser, removePrefix);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBytes(
			boolean perSegment, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segByteReverser, boolean removePrefix) {
		if(perSegment) {
			boolean isSame = !removePrefix || !section.isPrefixed();
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segByteReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segByteReverser, removePrefix);
	}
	protected static interface GroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix);
	}
	protected <S extends AddressDivisionBase> S[] createNewDivisions(int bitsPerDigit, GroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		return createNewPrefixedDivisions(bitsPerDigit, null, null,
				(value, upperValue, bitCount, radix, network, prefixLength) -> groupingCreator.createDivision(value, upperValue, bitCount, radix),
				groupingArrayCreator);
	}
	protected static interface PrefixedGroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer prefixLength);
	}
	protected <S extends AddressDivisionBase> S[] createNewPrefixedDivisions(int bitsPerDigit, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer networkPrefixLength, PrefixedGroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		if(bitsPerDigit >= Integer.SIZE) {
			throw new AddressValueException(bitsPerDigit);
		}
		int bitCount = getBitCount();
		List<Integer> bitDivs = new ArrayList<Integer>(bitsPerDigit);
		int largestBitCount = Long.SIZE - 1;
		largestBitCount -= largestBitCount % bitsPerDigit;
		do {
			if(bitCount <= largestBitCount) {
				int mod = bitCount % bitsPerDigit;
				int secondLast = bitCount - mod;
				if(secondLast > 0) {
					bitDivs.add(cacheBits(secondLast));
				}
				if(mod > 0) {
					bitDivs.add(cacheBits(mod));
				}
				break;
			} else {
				bitCount -= largestBitCount;
				bitDivs.add(cacheBits(largestBitCount));
			}
		} while(true);
		int bitDivSize = bitDivs.size();
		S divs[] = groupingArrayCreator.apply(bitDivSize);
		int currentSegmentIndex = 0;
		AddressDivision seg = getDivision(currentSegmentIndex);
		long segLowerVal = seg.getDivisionValue();
		long segUpperVal = seg.getUpperDivisionValue();
		int segBits = seg.getBitCount();
		int bitsSoFar = 0;
		int radix = AddressDivision.getRadixPower(BigInteger.valueOf(2), bitsPerDigit).intValue();
		for(int i = bitDivSize - 1; i >= 0; i--) {
			int originalDivBitSize, divBitSize;
			originalDivBitSize = divBitSize = bitDivs.get(i);
			long divLowerValue, divUpperValue;
			divLowerValue = divUpperValue = 0;
			while(true) {
				if(segBits >= divBitSize) {
					int diff = segBits - divBitSize;
					divLowerValue |= segLowerVal >>> diff;
					long shift = ~(~0L << diff);
					segLowerVal &= shift;
					divUpperValue |= segUpperVal >>> diff;
					segUpperVal &= shift;
					segBits = diff;
					Integer segPrefixBits = networkPrefixLength == null ? null : getSegmentPrefixLength(originalDivBitSize, networkPrefixLength - bitsSoFar);
					S div = groupingCreator.createDivision(divLowerValue, divUpperValue, originalDivBitSize, radix, network, segPrefixBits);
					divs[bitDivSize - i - 1] = div;
					if(segBits == 0 && i > 0) {
						seg = getDivision(++currentSegmentIndex);
						segLowerVal = seg.getDivisionValue();
						segUpperVal = seg.getUpperDivisionValue();
						segBits = seg.getBitCount();
					}
					break;
				} else {
					int diff = divBitSize - segBits;
					divLowerValue |= segLowerVal << diff;
					divUpperValue |= segUpperVal << diff;
					divBitSize = diff;
					seg = getDivision(++currentSegmentIndex);
					segLowerVal = seg.getDivisionValue();
					segUpperVal = seg.getUpperDivisionValue();
					segBits = seg.getBitCount();
				}
			}
			bitsSoFar += originalDivBitSize;
		}
		return divs;
	}
	protected static <I extends AddressSegmentSeries, S extends AddressSegment> boolean split(
			SplitterSink<I, ?> beingSplit,
			Function<S[], I> transformer,
			AddressSegmentCreator<S> segmentCreator,
			S originalSegments[],
			int networkSegmentIndex, 
			int hostSegmentIndex, 
			Integer prefixLength) {
		int i = 0;
		S lowerSeg, upperSeg;
		lowerSeg = upperSeg = null;
		boolean isSplit = false;
		for(; i < hostSegmentIndex; i++) {
			S seg = originalSegments[i];
			if(seg.isMultiple()) {
				isSplit = true;
				int lower = seg.getSegmentValue();
				int upper = seg.getUpperSegmentValue();
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				Integer pref = getSegmentPrefixLength(seg.getBitCount(), prefixLength, i);
				lowerSeg = segmentCreator.createSegment(lower, mid, pref);
				upperSeg = segmentCreator.createSegment(mid + 1, upper, pref);
				break;
			}
		}
		if(i == networkSegmentIndex && !isSplit) {
			S seg = originalSegments[i];
			int segBitCount = seg.getBitCount();
			Integer pref = getSegmentPrefixLength(segBitCount, prefixLength, i);
			int shiftAdjustment = segBitCount - pref;
			int lower = seg.getSegmentValue();
			int upper = seg.getUpperSegmentValue();
			int originalLower = lower, originalUpper = upper;
			lower >>>= shiftAdjustment;
			upper >>>= shiftAdjustment;
			if(lower != upper) {
				isSplit = true;
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				int next = mid + 1;
				mid = (mid << shiftAdjustment) | ~(~0 << shiftAdjustment);
				next <<= shiftAdjustment;
				lowerSeg = segmentCreator.createSegment(originalLower, mid, pref);
				upperSeg = segmentCreator.createSegment(next, originalUpper, pref);
			}
		}
		if(isSplit) {
			int len = originalSegments.length;
			S lowerSegs[] = segmentCreator.createSegmentArray(len);
			S upperSegs[] = segmentCreator.createSegmentArray(len);
			System.arraycopy(originalSegments, 0, lowerSegs, 0, i);
			System.arraycopy(originalSegments, 0, upperSegs, 0, i);
			int j = i + 1;
			lowerSegs[i] = lowerSeg;
			upperSegs[i] = upperSeg;
			System.arraycopy(originalSegments, j, lowerSegs, j, len - j);
			System.arraycopy(originalSegments, j, upperSegs, j, len - j);
			beingSplit.setSplitValues(transformer.apply(lowerSegs), transformer.apply(upperSegs));
		}
		return isSplit;
	}
	protected static <R extends AddressSection, S extends AddressSegment> Iterator<R> iterator(
			boolean useOriginal,
			R original,
			AddressCreator<?, R, ?, S> creator,
			Iterator<S[]> iterator,
			Integer prefixLength) {
		if(useOriginal) {
			return new Iterator<R>() {
				R orig = original;
				@Override
				public R next() {
					if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
					R result = orig;
			    	orig = null;
				    return result;
			    }
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<R>() {
			@Override
			public R next() {
				if(!iterator.hasNext()) {
		    		throw new NoSuchElementException();
		    	}
				S next[] = iterator.next();
				return createIteratedSection(next, creator, prefixLength);
			}
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <T extends Address, S extends AddressSegment> T createIteratedAddress(
			S next[],
			AddressCreator<T, ?, ?, S> creator,
			Integer prefixLength) {
		return creator.createAddressInternal(next, prefixLength, true);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R createIteratedSection(
			S next[],
			AddressCreator<?, R, ?, S> creator,
			Integer prefixLength) {
		return creator.createPrefixedSectionInternal(next, prefixLength, true);
	}
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc) {
		return segmentsIterator(divCount, segmentCreator, segSupplier, segIteratorProducer, excludeFunc, divCount - 1, divCount, null);
	}
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> hostSegIteratorProducer) {
		if(segSupplier != null) {
			return new Iterator<S[]>() {
				S result[] = segSupplier.get(); {
					if(excludeFunc != null && excludeFunc.test(result)) {
						result = null;
					}
				}
				@Override
				public boolean hasNext() {
					return result != null;
				}
			    @Override
				public S[] next() {
			    	if(result == null) {
			    		throw new NoSuchElementException();
			    	}
			    	S res[] = result;
			    	result = null;
			    	return res;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<S[]>() {
			private boolean done;
			@SuppressWarnings("unchecked")
			private final Iterator<S> variations[] = new Iterator[divCount];
			private S nextSet[] = segmentCreator.createSegmentArray(divCount);  {
				updateVariations(0);
				for(int i = networkSegmentIndex + 1; i < divCount; i++) {
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(excludeFunc != null && excludeFunc.test(nextSet)) {
					increment();
				}
			}
			private void updateVariations(int start) {
				int i = start;
				for(; i < hostSegmentIndex; i++) {
					variations[i] = segIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(i == networkSegmentIndex) {
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
			}
			@Override
			public boolean hasNext() {
				return !done;
			}
		    @Override
			public S[] next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	return increment();
		    }
		    private S[] increment() {
		    	S previousSegs[] = null;
		    	for(int j = networkSegmentIndex; j >= 0; j--) {
		    		while(variations[j].hasNext()) {
		    			if(previousSegs == null) {
		    				previousSegs = nextSet.clone();
		    			}
		    			nextSet[j] = variations[j].next();
		    			updateVariations(j + 1);
		    			if(excludeFunc != null && excludeFunc.test(nextSet)) {
		    				j = networkSegmentIndex;
						} else {
							return previousSegs;
						}
		    		}
		    	}
		    	done = true;
		    	return previousSegs == null ? nextSet : previousSegs;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			boolean useOriginal,
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator, 
			Integer prefixLength ) {
		if(useOriginal) {
			return new Iterator<T>() {
				T orig = original;
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public T next() {
			    	if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
			    	T result = orig;
			    	orig = null;
			    	return result;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<T>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		    @Override
			public T next() {
		    	if(!hasNext()) {
		    		throw new NoSuchElementException();
		    	}
		    	S[] next = iterator.next();
		    	return createIteratedAddress(next, creator, prefixLength);
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static void checkOverflow(
			long increment,
			LongSupplier lower,
			LongSupplier upper,
			LongSupplier counter,
			BooleanSupplier isSequential,
			LongSupplier maxValue) {
		if(increment < 0) {
			if(lower.getAsLong() < -increment) {
				throw new AddressValueException(increment);
			}
		} else if(isSequential.getAsBoolean()) {
			if(increment > maxValue.getAsLong() - lower.getAsLong()) {
				throw new AddressValueException(increment);
			}
		} else {
			long count = counter.getAsLong();
			if(increment >= count && increment - (count - 1) > maxValue.getAsLong() - upper.getAsLong()) {
				throw new AddressValueException(increment);
			}
		}
	}
	protected static void checkOverflow(
			long increment,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(increment < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	protected static void checkOverflow(
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(bigIncrement.signum() < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	private static void checkOverflow(
			boolean incrementIsNegative,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		if(incrementIsNegative) {
			if(lower.get().compareTo(bigIncrement.negate()) < 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else if(isSequential.getAsBoolean()) {
			if(bigIncrement.compareTo(maxValue.get().subtract(lower.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else {
			BigInteger count = counter.get();
			if(bigIncrement.compareTo(count) >= 0 && bigIncrement.subtract(count.subtract(BigInteger.ONE)).compareTo(maxValue.get().subtract(upper.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		}
	}
	protected static <R extends AddressSection, S extends AddressSegment> R fastIncrement(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(increment >= 0) {
			BigInteger count = section.getCount();
			if(count.compareTo(LONG_MAX) <= 0) {
				long longCount = count.longValue();
				if(longCount > increment) {
					if(longCount == increment + 1) {
						return upperProducer.get();
					}
					return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
				}
				BigInteger upperValue = section.getUpperValue();
				if(upperValue.compareTo(LONG_MAX) <= 0) {
					return increment(
							section,
							increment,
							addrCreator,
							count::longValue,
							() -> section.getValue().longValue(),
							upperValue::longValue,
							lowerProducer,
							upperProducer,
							prefixLength);
				}
			}
		} else {
			BigInteger value = section.getValue();
			if(value.compareTo(LONG_MAX) <= 0) {
				return add(lowerProducer.get(), value.longValue(), increment, addrCreator, prefixLength);
			}
		}
		return null;
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			LongSupplier counter,
			LongSupplier lower,
			LongSupplier upper,
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, lower.getAsLong(), increment, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), lower.getAsLong(), increment, addrCreator, prefixLength);
		} 
		long count = counter.getAsLong();
		if(count > increment) {
			if(count == increment + 1) {
				return upperProducer.get();
			}
			return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
		}
		long upperValue = upper.getAsLong();
		if(increment <= Long.MAX_VALUE - upperValue) {
			return add(upperProducer.get(), upperValue, increment - (count - 1), addrCreator, prefixLength);
		}
		return add(upperProducer.get(), BigInteger.valueOf(increment - (count - 1)), addrCreator, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = bigIncrement.signum() <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, bigIncrement, addrCreator, lowerProducer, prefixLength);
	}
	@SuppressWarnings("unchecked")
	protected static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(increment == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[];
		if(segCount > 0) {
			int i = segCount - 1;
			AddressSegment seg = section.getSegment(i);
			int bitCount = seg.getBitCount();
			newSegments = addrCreator.createSegmentArray(segCount);
			while(true) {
				int segValue = seg.getSegmentValue();
				long revolutions;
				int remainder;
				S newSegment;
				long segRange = seg.getValueCount();
				if(bitCount == IPv6Address.BITS_PER_SEGMENT && segRange == IPv6Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv6Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv6Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(bitCount == IPv4Address.BITS_PER_SEGMENT && segRange == IPv4Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv4Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv4Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(segRange == 1) {
					revolutions = increment;
					newSegment = addrCreator.createSegment(segValue);
				} else {
					revolutions = increment / segRange;
					remainder = (int) (increment % segRange);
					newSegment = addrCreator.createSegment(segValue + remainder);
				}
				newSegments[i] = newSegment;
				if(revolutions == 0) {
					for(i--; i >= 0; i--) {
						AddressSegment original = section.getSegment(i);
						newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
					}
					break;
				}
				if(--i < 0) {
					break;
				}
				increment = revolutions;
				seg = section.getSegment(i);
			}
		} else {
			newSegments = (S[]) section.getSegments();
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	private static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(bigIncrement.signum() == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[] = addrCreator.createSegmentArray(segCount);
		for(int i = segCount - 1; i >= 0; i--) {
			AddressSegment seg = section.getSegment(i);
			int segValue = seg.getSegmentValue();
			long segRange = (seg.getUpperSegmentValue() - segValue) + 1L;
			BigInteger divs[] = bigIncrement.divideAndRemainder(BigInteger.valueOf(segRange)); 
			BigInteger revolutions = divs[0];
			int remainder = divs[1].intValue();
			S newSegment = addrCreator.createSegment(segValue + remainder);
			newSegments[i] = newSegment;
			if(revolutions.signum() == 0) {
				for(i--; i >= 0; i--) {
					AddressSegment original = section.getSegment(i);
					newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
				}
				break;
			} else {
				bigIncrement = revolutions;
			}
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, BigInteger increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		BigInteger fullValue = section.getValue();
		fullValue = fullValue.add(increment);
		byte bytes[] = fullValue.toByteArray();
		return addrCreator.createSectionInternal(bytes, segCount, prefixLength, true);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, long fullValue, long increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		S newSegs[] = addrCreator.createSegmentArray(segCount);
		createSegments(
					newSegs,
					0,
					fullValue + increment,
					section.getBitsPerSegment(),
					addrCreator.getNetwork(),
					prefixLength);
		return createIteratedSection(newSegs, addrCreator, prefixLength);
	}
	protected static Long enumerateSmall(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { 
			return 0L;
		}
		return enumerateSmallImpl(series, otherSeries);
	}
	protected static Long enumerateSmallImpl(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return (otherSeries.getValue().longValue() - series.getUpperValue().longValue()) + (series.getCount().longValue() - 1L);
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					long total = 0;
					long cumulativeSize = 1;
					for(int i = series.getSegmentCount() - 1; ; i--) {
						AddressSegment segment = series.getSegment(i), otherSegment = otherSeries.getSegment(i);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total += cumulativeSize * (otherValue - segValue);
						if(i == 0) {
							return total;
						}
						cumulativeSize *= segment.getValueCount();
					}
				}
			}
		}
		return otherSeries.getValue().longValue() - series.getValue().longValue();
	}
	protected static BigInteger enumerateBig(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		int segmentCount = series.getSegmentCount();
		if(segmentCount != otherSeries.getSegmentCount()) {
			throw new SizeMismatchException(series, otherSeries);
		} else if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { 
			return BigInteger.ZERO;
		}
		boolean initialSegsMatch = true;
		int bitsPerSegment = series.getBitsPerSegment();
		int totalBits = ParsedAddressGrouping.getTotalBits(segmentCount, series.getBytesPerSegment(), bitsPerSegment);
		int i = 0;
		while(totalBits > Long.SIZE) {
			AddressSegment seg = series.getSegment(i);
			AddressSegment otherSeg = otherSeries.getSegment(i);
			if(!seg.matches(otherSeg.getSegmentValue())) {
				initialSegsMatch = false;
				break;
			}
			totalBits -= bitsPerSegment;
			i++;
		}
		if(initialSegsMatch) {
			if(totalBits == Long.SIZE) {
				AddressSegment seg = series.getSegment(i);
				AddressSegment otherSeg = otherSeries.getSegment(i);
				int mask = (1 << bitsPerSegment) >>> 1;
				if(seg.matchesWithMask(otherSeg.getSegmentValue() & mask, mask)) {
					Long result = enumerateSmallImpl(series, otherSeries);
					if(result == null) {
						return null;
					}
					return BigInteger.valueOf(result);
				}
			} else {
				Long result = enumerateSmallImpl(series, otherSeries);
				if(result == null) {
					return null;
				}
				return BigInteger.valueOf(result);
			}
		}
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return otherSeries.getValue().subtract(series.getUpperValue()).add(series.getCount().subtract(BigInteger.ONE));
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					BigInteger total = BigInteger.ZERO;
					BigInteger cumulativeSize = BigInteger.ONE;
					for(int j = series.getSegmentCount() - 1; ; j--) {
						AddressSegment segment = series.getSegment(j), otherSegment = otherSeries.getSegment(j);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total = total.add(cumulativeSize.multiply(BigInteger.valueOf(otherValue - segValue)));
						if(j == 0) {
							return total;
						}
						cumulativeSize = cumulativeSize.multiply(segment.getCount());
					}
				}
			}
		}
		return otherSeries.getValue().subtract(series.getValue());
	}
	protected static BigInteger count(IntUnaryOperator segmentValueCountProvider, int segCount, int safeMultiplies, long safeLimit) {
		int i = 0;
		BigInteger result = BigInteger.ONE;
		if(segCount == 0) {
			return result;
		}
		while(true) {
			long curResult = segmentValueCountProvider.applyAsInt(i++);
			if(i == segCount) {
				return mult(result, curResult);
			}
			int limit = i + safeMultiplies;
			if(segCount <= limit) {
				while(i < segCount) {
					curResult *= segmentValueCountProvider.applyAsInt(i++);
				}
				return mult(result, curResult);
			}
			while(i < limit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
			}
			while(curResult <= safeLimit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
				if(i == segCount) {
					return mult(result, curResult);
				}
			}
			result = mult(result, curResult);
		}
	}
	private static BigInteger mult(BigInteger currentResult, long newResult) {
		if(newResult == 1) {
			return currentResult;
		}
		BigInteger newBig = BigInteger.valueOf(newResult);
		if(currentResult == BigInteger.ONE) {
			return newBig;
		}
		return currentResult.multiply(newBig);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R getSection(
			int index,
			int endIndex,
			R section,
			AddressCreator<?, R, ?, S> creator) {
		if(index == 0 && endIndex == section.getSegmentCount()) {
			return section;
		}
		int segmentCount = endIndex - index;
		if(segmentCount < 0) {
			throw new IndexOutOfBoundsException();
		}
		S segs[] = creator.createSegmentArray(segmentCount);
		section.getSegments(index, endIndex, segs, 0);
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R append(
			R section,
			R other,
			AddressCreator<?, R, ?, S> creator) {
		int otherSegmentCount = other.getSegmentCount();
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount;
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, segmentCount, segs, 0);
		if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			S allSegment = creator.createSegment(0, cacheBits(0));
			Arrays.fill(segs, segmentCount, totalSegmentCount, allSegment);
		} else {
			other.getSegments(0, otherSegmentCount, segs, segmentCount);
		}
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R replace(
			R section,
			int index,
			int endIndex,
			R replacement,
			int replacementStartIndex,
			int replacementEndIndex,
			AddressCreator<?, R, ?, S> creator,
			boolean appendNetwork,
			boolean isMac) {
		int otherSegmentCount = replacementEndIndex  - replacementStartIndex;
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount - (endIndex - index);
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, index, segs, 0);
		if(index < totalSegmentCount) {
			if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() &&
					(appendNetwork ?
							(getHostSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index) :
							(getNetworkSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index)) && 
					(isMac || index > 0)) { 
				S allSegment = creator.createSegment(0, cacheBits(0));
				Arrays.fill(segs, index, totalSegmentCount, allSegment);
				return creator.createSectionInternal(segs);
			}
			replacement.getSegments(replacementStartIndex, replacementEndIndex, segs, index);
			if(index + otherSegmentCount < totalSegmentCount) {
				if(replacement.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && 
						getNetworkSegmentIndex(replacement.getPrefixLength(), replacement.getBytesPerSegment(), replacement.getBitsPerSegment()) < replacementEndIndex && 
						(isMac || otherSegmentCount > 0)) {
					S allSegment = creator.createSegment(0, cacheBits(0));
					Arrays.fill(segs, index + otherSegmentCount, totalSegmentCount, allSegment);
				} else {
					section.getSegments(endIndex, segmentCount, segs, index + otherSegmentCount);
				}
			}
		}
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R createSectionInternal(AddressCreator<?, R, ?, S> creator, S[] segments, int startIndex, boolean extended) {
		return creator.createSectionInternal(segments, startIndex, extended);
	}
	protected boolean isDualString() throws IncompatibleAddressException {
		int count = getDivisionCount();
		for(int i = 0; i < count; i++) {
			AddressDivision division = getDivision(i);
			if(division.isMultiple()) {
				boolean isLastFull = true;
				AddressDivision lastDivision = null;
				for(int j = count - 1; j >= 0; j--) {
					division = getDivision(j);
					if(division.isMultiple()) {
						if(!isLastFull) {
							throw new IncompatibleAddressException(division, i, lastDivision, i + 1, "ipaddress.error.segmentMismatch");
						}
						isLastFull = division.isFullRange();
					} else {
						isLastFull = false;
					}
					lastDivision = division;
				}
				return true;
			}
		}
		return false;
	}
	protected static <T extends AddressStringDivisionSeries, E extends AddressStringDivisionSeries> String 
			toNormalizedStringRange(AddressStringParams<T> params, T lower, T upper, CharSequence zone) {
		int length = params.getStringLength(lower, null) + params.getStringLength(upper, zone);
		StringBuilder builder;
		String separator = params.getWildcards().rangeSeparator;
		if(separator != null) {
			length += separator.length();
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null).append(separator), upper, zone);
		} else {
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null), upper, zone);
		}
		AddressStringParams.checkLengths(length, builder);
		return builder.toString();
	}
	protected void checkSegmentCount(AddressSection sec) throws SizeMismatchException {
		if(sec.getDivisionCount() != getDivisionCount()) {
			throw new SizeMismatchException(this, sec);
		}
	}
	public static class StringOptions extends StringOptionsBase {
		public static class Wildcards {
			public final String rangeSeparator;
			public final String wildcard;
			public final String singleWildcard;
			public Wildcards() {
				this(Address.RANGE_SEPARATOR_STR, Address.SEGMENT_WILDCARD_STR, null);
			}
			public Wildcards(String wildcard, String singleWildcard) {
				this(Address.RANGE_SEPARATOR_STR, wildcard, singleWildcard);
			}
			public Wildcards(String rangeSeparator) {
				this(rangeSeparator, null, null);
			}
			public Wildcards(String rangeSeparator, String wildcard, String singleWildcard) {
				if(rangeSeparator == null) {
					rangeSeparator = Address.RANGE_SEPARATOR_STR;
				}
				this.rangeSeparator = rangeSeparator;
				this.wildcard = wildcard;
				this.singleWildcard = singleWildcard;
			}
			@Override
			public String toString() {
				return "range separator: " + rangeSeparator + "\nwildcard: " + wildcard + "\nsingle wildcard: " + singleWildcard;
			}
		}
		public final Wildcards wildcards;
		public final boolean expandSegments;
		public final int base;
		public final String segmentStrPrefix;
		public final Character separator;
		public final String addrLabel;
		public final boolean reverse;
		public final boolean splitDigits;
		public final boolean uppercase;
		protected StringOptions(
				int base,
				boolean expandSegments,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			this.expandSegments = expandSegments;
			this.wildcards = wildcards;
			this.base = base;
			if(segmentStrPrefix == null) {
				throw new NullPointerException("segment str");
			}
			this.segmentStrPrefix = segmentStrPrefix;
			this.separator = separator;
			if(label == null) {
				throw new NullPointerException("label");
			}
			this.addrLabel = label;
			this.reverse = reverse;
			this.splitDigits = splitDigits;
			this.uppercase = uppercase;
		}
		public static class Builder {
			public static final Wildcards DEFAULT_WILDCARDS = new Wildcards();
			protected Wildcards wildcards = DEFAULT_WILDCARDS;
			protected boolean expandSegments;
			protected int base;
			protected String segmentStrPrefix = "";
			protected Character separator;
			protected String addrLabel = "";
			protected boolean reverse;
			protected boolean splitDigits;
			protected boolean uppercase;
			public Builder(int base) {
				this.base = base;
				this.separator = ' ';
			}
			public Builder(int base, char separator) {
				this.base = base;
				this.separator = separator;
			}
			public Builder setWildcards(Wildcards wildcards) {
				this.wildcards = wildcards;
				return this;
			}
			public Builder setReverse(boolean reverse) {
				this.reverse = reverse;
				return this;
			}
			public Builder setUppercase(boolean uppercase) {
				this.uppercase = uppercase;
				return this;
			}
			public Builder setSplitDigits(boolean splitDigits) {
				this.splitDigits = splitDigits;
				return this;
			}
			public Builder setExpandedSegments(boolean expandSegments) {
				this.expandSegments = expandSegments;
				return this;
			}
			public Builder setRadix(int base) {
				this.base = base;
				return this;
			}
			public Builder setSeparator(Character separator) {
				this.separator = separator;
				return this;
			}
			public Builder setAddressLabel(String label) {
				this.addrLabel = label;
				return this;
			}
			public Builder setSegmentStrPrefix(String prefix) {
				this.segmentStrPrefix = prefix;
				return this;
			}
			public StringOptions toOptions() {
				return new StringOptions(base, expandSegments, wildcards, segmentStrPrefix, separator, addrLabel, reverse, splitDigits, uppercase);
			}
		}
	}
}
package inet.ipaddr.format.standard;
import java.util.Arrays;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.ipv6.IPv6Address;
public class IPAddressDivisionGrouping extends AddressDivisionGrouping implements IPAddressDivisionSeries {
	private static final long serialVersionUID = 4L;
	private final IPAddressNetwork<?, ?, ?, ?, ?> network;
	protected static final RangeCache ZEROS_CACHE = new RangeCache();
	static {
		if(RangeCache.PRELOAD_CACHE) {
			ZEROS_CACHE.preloadCache(-1);
		}
	}
	public IPAddressDivisionGrouping(IPAddressDivision divisions[], IPAddressNetwork<?, ?, ?, ?, ?> network) throws AddressValueException {
		super(divisions);
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
		this.network = network;
		int totalPrefixBits = 0;
		for(int i = 0; i < divisions.length; i++) {
			IPAddressDivision division = divisions[i];
			Integer divPrefix = division.getDivisionPrefixLength();
			if(divPrefix != null) {
				cachedPrefixLength = cacheBits(totalPrefixBits + divPrefix);
				for(++i; i < divisions.length; i++) {
					division = divisions[i];
					divPrefix = division.getDivisionPrefixLength();
					if(divPrefix == null || divPrefix != 0) {
						throw new InconsistentPrefixException(divisions[i - 1], division, divPrefix);
					}
				}
				return;
			}
			totalPrefixBits += division.getBitCount();
		}
		cachedPrefixLength = NO_PREFIX_LENGTH;
	}
	protected IPAddressDivisionGrouping(IPAddressDivision divisions[], boolean checkSegs) {
		super(divisions, checkSegs);
		network = getNetwork();
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
	}
	@Override
	public IPAddressNetwork<?, ?, ?, ?, ?> getNetwork() {
		return network;
	}
	@Override
	public IPAddressDivision getDivision(int index) {
		return (IPAddressDivision) super.getDivision(index);
	}
	@Override
	public int isMore(AddressDivisionSeries other) {
		if(!isMultiple()) {
			return other.isMultiple() ? -1 : 0;
		}
		if(!other.isMultiple()) {
			return 1;
		}
		if(isSinglePrefixBlock() && other.isSinglePrefixBlock()) {
			int bits = getBitCount() - getPrefixLength();
			int otherBits = other.getBitCount() - other.getPrefixLength();
			return bits - otherBits;
		}
		return getCount().compareTo(other.getCount());
	}
	@Override
	public Integer getPrefixLength() {
		return getNetworkPrefixLength();
	}
	@Override
	public Integer getNetworkPrefixLength() {
		Integer ret = cachedPrefixLength;
		if(ret == null) {
			Integer result = calculatePrefix(this);
			if(result != null) {
				return cachedPrefixLength = result;
			}
			cachedPrefixLength = NO_PREFIX_LENGTH;
			return null;
		}
		if(ret.intValue() == NO_PREFIX_LENGTH.intValue()) {
			return null;
		}
		return ret;
	}
	public int getTrailingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long back = network ? 0 : getDivision(0).getMaxValue();
		int bitLen = 0;
		for(int i = count - 1; i >= 0; i--) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != back) {
				return bitLen + seg.getTrailingBitCount(network);
			}
			bitLen += seg.getBitCount();
		}
		return bitLen;
	}
	public int getLeadingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long front = network ? getDivision(0).getMaxValue() : 0;
		int prefixLen = 0;
		for(int i = 0; i < count; i++) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != front) {
				return prefixLen + seg.getLeadingBitCount(network);
			}
			prefixLen += seg.getBitCount();
		}
		return prefixLen;
	}
	@Override
	public boolean isPrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		return containsPrefixBlock(networkPrefixLength);
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return containsPrefixBlock(this, prefixLength);
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return containsSinglePrefixBlock(this, prefixLength);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		return containsSinglePrefixBlock(networkPrefixLength);
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getPrefixLengthForSingleBlock(this);
	}
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressDivision div = getDivision(i);
			Integer segmentPrefixLength = div.getDivisionPrefixLength();
			if(segmentPrefixLength != null) {
				long mask = ~(~0L << (div.getBitCount() - segmentPrefixLength));
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getDivision(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPAddressDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressDivisionGrouping) {
			IPAddressDivisionGrouping other = (IPAddressDivisionGrouping) o;
			return other.isSameGrouping(this); 
		}
		return false;
	}
	protected static boolean prefixContains(IPAddressSection first, IPAddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				IPAddressSegment one = first.getSegment(prefixedSection);
				IPAddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixContains(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			IPAddressSegment one = first.getSegment(prefixedSection);
			IPAddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.contains(two)) {
				return false;
			}
		}
		return true;
	}
	public RangeList getZeroSegments() {
		return getZeroSegments(false);
	}
	public RangeList getZeroRangeSegments() {
		if(isPrefixed()) {
			return getZeroSegments(true);
		}
		return getZeroSegments();
	}
	protected static RangeList getNoZerosRange() {
		return RangeCache.NO_ZEROS;
	}
	protected static RangeList getSingleRange(int index, int len) {
		RangeCache cache = ZEROS_CACHE.addRange(index, -1, len);
		return cache.get();
	}
	protected RangeList getZeroSegments(boolean includeRanges) {
		RangeCache cache = ZEROS_CACHE;
		int divisionCount = getDivisionCount();
		boolean isFullRangeHost = !getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() && isPrefixBlock();
		includeRanges &= isFullRangeHost;
		int currentIndex = -1, lastIndex = -1, currentCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			IPAddressDivision division = getDivision(i);
			boolean isCompressible = division.isZero() || 
					(includeRanges && division.isPrefixed() && division.isSinglePrefixBlock(0, division.getDivisionPrefixLength()));
			if(isCompressible) {
				if(++currentCount == 1) {
					currentIndex = i;
				}
				if(i == divisionCount - 1) {
					cache = cache.addRange(currentIndex, lastIndex, currentCount);
					lastIndex = currentIndex + currentCount;
				}
			} else if(currentCount > 0) {
				cache = cache.addRange(currentIndex, lastIndex, currentCount);
				lastIndex = currentIndex + currentCount;
				currentCount = 0;
			}
		}
		return cache.get();
	}
	public static class Range {
		public final int index;
		public final int length;
		Range(int index, int length) {
			this.index = index;
			this.length = length;
		}
		@Override
		public String toString() {
			return "[" + index + ',' + (index + length) + ']';
		}
	}
	public static class RangeList {
		final Range ranges[];
		RangeList(Range ranges[]) {
			if(ranges == null) {
				throw new NullPointerException();
			}
			this.ranges = ranges;
		}
		public int size() {
			return ranges.length;
		}
		public Range getRange(int index) {
			return ranges[index];
		}
		@Override
		public String toString() {
			return Arrays.asList(ranges).toString();
		}
	}
	private static class RangeCache {
		static boolean PRELOAD_CACHE;
		static final int MAX_DIVISION_COUNT = IPv6Address.SEGMENT_COUNT;
		static final RangeList NO_ZEROS = new RangeList(new Range[0]);
		RangeCache nextRange[][];
		RangeCache parent;
		RangeList zeroRanges;
		Range range;
		RangeCache() {
			this(null, MAX_DIVISION_COUNT, null);
			zeroRanges = NO_ZEROS;
		}
		private RangeCache(RangeCache parent, int potentialZeroOffsets, Range range) {
			if(potentialZeroOffsets > 0) {
				nextRange = new RangeCache[potentialZeroOffsets][];
				for(int i = 0; i < potentialZeroOffsets; i++) {
					nextRange[i] = new RangeCache[potentialZeroOffsets - i];
				}
			}
			this.parent = parent;
			this.range = range;
		}
		private void get(Range ranges[], int rangesIndex) {
			ranges[--rangesIndex] = range;
			if(rangesIndex > 0) {
				parent.get(ranges, rangesIndex);
			}
		}
		public RangeList get() {
			RangeList result = zeroRanges;
			if(result == null) {
				int depth = 0;
				RangeCache up = parent;
				while(up != null) {
					depth++;
					up = up.parent;
				}
				Range ranges[] = new Range[depth];
				if(depth > 0) {
					ranges[--depth] = range;
					if(depth > 0) {
						parent.get(ranges, depth);
					}
				}
				zeroRanges = result = new RangeList(ranges);
			}
			return result;
		}
		void preloadCache(int lastIndex) {
			if(nextRange != null) {
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						Range newRange;
						if(lastIndex == -1) {
							newRange = new Range(i + lastIndex + 1, j + 1);
						} else {
							newRange = ZEROS_CACHE.nextRange[i + lastIndex + 1][j].range;
						}
						int nextPotentialZeroIndex = i + lastIndex + j + 3;
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						RangeCache newRangeCache = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
						newRangeCache.get();
						next[j] = newRangeCache;
					}
				}
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						RangeCache nextCache = next[j];
						Range nextRange = nextCache.range;
						nextCache.preloadCache(nextRange.index + nextRange.length);
					}
				}
			}
		}
		public RangeCache addRange(int currentIndex, int lastIndex, int currentCount) {
			int offset = currentIndex - lastIndex;
			int cacheOffset = offset - 1;
			int cacheCount = currentCount - 1;
			RangeCache next = nextRange[cacheOffset][cacheCount];
			if(next == null) {
				synchronized(this) {
					next = nextRange[cacheOffset][cacheCount];
					if(next == null) {
						int nextPotentialZeroIndex = lastIndex + 1;
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						Range newRange;
						if(this == ZEROS_CACHE) {
							newRange = new Range(currentIndex, currentCount);
						} else {
							RangeCache rootNext = ZEROS_CACHE.nextRange[currentIndex][currentCount - 1];
							if(rootNext == null) {
								ZEROS_CACHE.nextRange[currentIndex][currentCount - 1] = new RangeCache(ZEROS_CACHE, RangeCache.MAX_DIVISION_COUNT, newRange = new Range(currentIndex, currentCount));
							} else {
								newRange = rootNext.range;
							}
						}
						nextRange[cacheOffset][cacheCount] = next = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
					}
				}
			}
			return next;
		}
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Supplier;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringCache;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class IPAddressSegment extends IPAddressDivision implements AddressSegment {
	private static final long serialVersionUID = 4L;
	private final int value; 
	private final int upperValue; 
	protected IPAddressSegment(int value) {
		if(value < 0) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	protected IPAddressSegment(int value, Integer segmentPrefixLength) {
		this(value, value, segmentPrefixLength);
	}
	protected IPAddressSegment(int lower, int upper, Integer segmentPrefixLength) {
		super(segmentPrefixLength);
		if(lower < 0 || upper < 0) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		segmentPrefixLength = getSegmentPrefixLength();
		if(segmentPrefixLength == null || segmentPrefixLength >= getBitCount() || !getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			this.value = lower;
			this.upperValue = upper;
		} else {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			this.value = lower & mask;
			this.upperValue = upper | getSegmentHostMask(segmentPrefixLength);
		}
	}
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	protected static Integer getSplitSegmentPrefix(int bitsPerSegment, Integer networkPrefixLength, int segmentIndex) {
		return IPAddressSection.getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, segmentIndex);
	}
	@Override
	protected long getDivisionNetworkMask(int bits) {
		return getSegmentNetworkMask(bits);
	}
	@Override
	protected long getDivisionHostMask(int bits) {
		return getSegmentHostMask(bits);
	}
	protected abstract int getSegmentNetworkMask(int bits);
	protected abstract int getSegmentHostMask(int bits);
	@Override
	public int getMinPrefixLengthForBlock() {
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getSegmentPrefixLength() == 0) {
			return 0;
		}
		return super.getMinPrefixLengthForBlock();
	}
	public static int getMaxSegmentValue(IPVersion version) {
		return version.isIPv4() ? IPv4Address.MAX_VALUE_PER_SEGMENT : IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	protected boolean isChangedByPrefix(Integer bits, boolean smallerOnly) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(smallerOnly) {
			if(isPrefixed()) {
				return hasBits && bits < getSegmentPrefixLength();
			}
		} else {
			if(isPrefixed()) {
				return !hasBits || bits != getSegmentPrefixLength().intValue();
			}
		}
		return hasBits;
	}
	protected <S extends IPAddressSegment> S toPrefixedSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		boolean hasBits = (segmentPrefixLength != null);
		if(lower != upper) {
			if(!hasBits) {
				return creator.createSegment(lower, upper, null);
			}
			return creator.createSegment(lower, upper, segmentPrefixLength);
		}
		return hasBits ? creator.createSegment(lower, segmentPrefixLength) : creator.createSegment(lower);
	}
	@Override
	public boolean isPrefixBlock() {
		return (isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) || super.isPrefixBlock();
	}
	protected boolean isNetworkChangedByPrefix(Integer bits, boolean withPrefixLength) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		withPrefixLength &= hasBits;
		boolean thisHasPrefix = isPrefixed();
		if(withPrefixLength != thisHasPrefix) {
			return true;
		}
		if(!hasBits || bits != getDivisionPrefixLength()) {
			return true;
		}
		return
			!containsPrefixBlock(bits);
	}
	protected boolean isNetworkChangedByPrefixNonNull(int prefixBitCount) {
		return !isPrefixed() || prefixBitCount != getDivisionPrefixLength() || !containsPrefixBlock(prefixBitCount);
	}
	public IPAddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	public abstract IPAddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength);
	protected <S extends IPAddressSegment> S toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength, AddressSegmentCreator<S> creator) {
		int newLower = getSegmentValue();
		int newUpper = getUpperSegmentValue();
		boolean hasPrefLen = segmentPrefixLength != null;
		if(hasPrefLen) {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			newLower &= mask;
			newUpper |= getSegmentHostMask(segmentPrefixLength);
		}
		withPrefixLength = withPrefixLength && hasPrefLen;
		if(newLower != newUpper) {
			if(!withPrefixLength) {
				return creator.createSegment(newLower, newUpper, null);
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		}
		return withPrefixLength ? creator.createSegment(newLower, segmentPrefixLength) : creator.createSegment(newLower);
	}
	public abstract IPAddressSegment toHostSegment(Integer segmentPrefixLength);
	protected <S extends IPAddressSegment> S toHostSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int mask = (segmentPrefixLength == null) ? 0 : getSegmentHostMask(segmentPrefixLength);
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		Masker masker = maskRange(lower, upper, mask, getMaxValue());
		int newLower = (int) masker.getMaskedLower(lower, mask);
		int newUpper = (int) masker.getMaskedUpper(upper, mask);
		if(newLower != newUpper) {
			return creator.createSegment(newLower, newUpper, null);
		}
		return creator.createSegment(newLower);
	}
	protected boolean isHostChangedByPrefix(Integer bits) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(isPrefixed()) {
			return true;
		}
		int mask = !hasBits ? 0 : getSegmentHostMask(bits);
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != (value & mask) || upperValue != (upperValue & mask);
	}
	protected boolean isChangedBy(int newValue, int newUpperValue, Integer segmentPrefixLength) throws IncompatibleAddressException {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != newValue ||
				upperValue != newUpperValue ||
						(isPrefixed() ? !getSegmentPrefixLength().equals(segmentPrefixLength) : (segmentPrefixLength != null));
	}
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.maskRange(value, upperValue, maskValue, maxValue);
	}
	public MaskResult maskRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		Masker masker = AddressDivision.maskRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public BitwiseOrResult bitwiseOrRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		BitwiseOrer orer = AddressDivision.bitwiseOrRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new BitwiseOrResult(value, upperValue, maskValue, orer);
	}
	@Override
	public abstract IPAddressSegment getLower();
	@Override
	public abstract IPAddressSegment getUpper();
	protected static <S extends IPAddressSegment> S getLowestOrHighest(S original, AddressSegmentCreator<S> segmentCreator, boolean lowest) {
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(!original.isMultiple() && !(isAllSubnets && original.isPrefixed())) {
			return original;
		}
		return segmentCreator.createSegment(lowest ? original.getSegmentValue() : original.getUpperSegmentValue(), 
				isAllSubnets ? null : original.getSegmentPrefixLength());
	}
	@Override
	public abstract Iterable<? extends IPAddressSegment> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSegment> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSegment> stream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator();
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream();
	public abstract Iterator<? extends IPAddressSegment> prefixIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixSpliterator();
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		int originalValue = seg.getSegmentValue();
		int originalUpperValue = seg.getUpperSegmentValue();
		int originalValuePrefix = originalValue >>> shiftAdjustment;
		int originalUpperValuePrefix = originalUpperValue >>> shiftAdjustment;
		Integer segPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		IntBinaryIteratorProvider<S> subIteratorProvider = (isLowest, isHighest, value, upperValue) -> {
			if(isLowest || isHighest) {
				value = isLowest ? originalValue : value << shiftAdjustment;
				upperValue = isHighest ?  originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
				return iterator(null, value, upperValue, bitCount, creator, segPrefixLength, true, false);
			}
			return iterator(null, value << shiftAdjustment, upperValue << shiftAdjustment, bitCount, creator, segPrefixLength, true, true);
		};
		return createSegmentSpliterator(
				seg,
				originalValuePrefix,
				originalUpperValuePrefix,
				iteratorProvider,
				subIteratorProvider,
				(value, upperValue) -> {
					value = (value == originalValuePrefix) ? originalValue : value << shiftAdjustment;
					upperValue = (upperValue == originalUpperValuePrefix) ? 
							originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
					return creator.createSegment(value, upperValue, segPrefLength);
				});
	}
	public abstract Stream<? extends IPAddressSegment> prefixStream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator(int prefixLength);
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixBlockSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		Integer segmentPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		return createSegmentSpliterator(
				seg,
				seg.getSegmentValue() >>> shiftAdjustment,
				seg.getUpperSegmentValue() >>> shiftAdjustment,
				iteratorProvider,
				(isLowest, isHighest, value, upperValue) -> iterator(
							null,
							value << shiftAdjustment,
							(upperValue << shiftAdjustment) | upperShiftMask,
							bitCount,
							creator,
							segmentPrefixLength,
							true,
							true),
				(value, upperValue) -> creator.createSegment(
						value << shiftAdjustment,
						(upperValue << shiftAdjustment) | upperShiftMask,
						segmentPrefixLength));
	}
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator(int prefixLength);
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream(int prefixLength);
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BITS_PER_SEGMENT : IPv6Address.BITS_PER_SEGMENT;
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
	}
	public static int getDefaultTextualRadix(IPVersion version) {
		return version.isIPv4() ? IPv4Address.DEFAULT_TEXTUAL_RADIX : IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	public boolean matchesWithPrefixMask(int value, Integer segmentPrefixLength) {
		return super.matchesWithPrefixMask(value, segmentPrefixLength);
	}
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	public int getPrefixValueCount() {
		Integer prefixLength = getSegmentPrefixLength();
		if(prefixLength == null) {
			return (int) getValueCount();
		}
		return getPrefixValueCount(this, prefixLength);
	}
	@Override
	public BigInteger getCount() {
		return BigInteger.valueOf(getValueCount());
	}
	@Override
	public BigInteger getPrefixCount(int segmentPrefixLength) {
		return BigInteger.valueOf(getPrefixValueCount(segmentPrefixLength));
	}
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(this, segmentPrefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= segmentPrefixLength) {
			return getValueCount();
		}
		int shiftAdjustment = bitCount - segmentPrefixLength;
		return (getUpperSegmentValue() >>> shiftAdjustment) - (getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected int highByte() {
		return highByte(getSegmentValue());
	}
	protected int lowByte() {
		return lowByte(getSegmentValue());
	}
	protected static int highByte(int value) {
		return value >> 8;
	}
	protected static int lowByte(int value) {
		return value & 0xff;
	}
	@Override
	public long getMaxValue() {
		return getMaxSegmentValue();
	}
	@Override
	public boolean isMultiple() {
		return getSegmentValue() != getUpperSegmentValue();
	}
	@Override
	public int getSegmentValue() {
		return value;
	}
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	@Override
	public abstract IPAddressSegment reverseBits(boolean perByte);
	@Override
	public abstract IPAddressSegment reverseBytes();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength();
	public abstract IPAddressSegment toZeroHost();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength(boolean zeroed);
	public abstract IPAddressSegment withoutPrefixLength();
	protected static <S extends IPAddressSegment> S toZeroHost(S original, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			Integer segmentPrefixLength = original.getSegmentPrefixLength();
			int mask = original.getSegmentNetworkMask(segmentPrefixLength);
			int newLower = lower & mask;
			int newUpper = upper & mask;
			boolean allPrefsSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			if(allPrefsSubnets) {
				return creator.createSegment(newLower, newUpper, null);
			}
			if(newLower == lower && newUpper == upper) {
				return original;
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		} else if(original.isZero()) {
			return original;
		}
		return creator.createSegment(0, null);
	}
	protected static <S extends IPAddressSegment> S removePrefix(S original, boolean zeroed, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			if(zeroed) {
				int maskBits = original.getSegmentNetworkMask(original.getSegmentPrefixLength());
				long value = original.getDivisionValue();
				long upperValue = original.getUpperDivisionValue();
				long maxValue = original.getMaxValue();
				Masker masker = maskRange(value, upperValue, maskBits, maxValue);
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(original, maskBits, "ipaddress.error.maskMismatch");
				}
				return creator.createSegment((int) masker.getMaskedLower(lower, maskBits), (int) masker.getMaskedUpper(upper, maskBits), null);
			}
			return creator.createSegment(lower, upper, null);
		}
		return original;
	}
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	public Integer getSegmentPrefixLength() {
		return getDivisionPrefixLength();
	}
	@Override
	public int hashCode() {
		return hash(getSegmentValue(), getUpperSegmentValue(), getBitCount());
	}
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	protected boolean isSameValues(AddressSegment otherSegment) {
		return getSegmentValue() == otherSegment.getSegmentValue() && getUpperSegmentValue() == otherSegment.getUpperSegmentValue();
	}
	public boolean prefixEquals(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixEquals(other, prefLength);
	}
	@Override
	public boolean prefixEquals(AddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return isSameValues(other);
		}
		return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) == (getUpperSegmentValue() >>> shift);
	}
	public boolean prefixContains(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixContains(other, prefLength);
	}
	public boolean prefixContains(IPAddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return contains(other);
		}
		return (other.getSegmentValue() >>> shift) >= (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
	}
	protected boolean containsSeg(AddressSegment other) {
		return other.getSegmentValue() >= getSegmentValue() && other.getUpperSegmentValue() <= getUpperSegmentValue();
	}
	protected boolean overlapsSeg(AddressSegment other) {
		return other.getSegmentValue() <= getUpperSegmentValue() && other.getUpperSegmentValue() >= getSegmentValue();
	}
	@Override
	public boolean includesZero() {
		return getSegmentValue() == 0;
	}
	@Override
	public boolean includesMax() {
		return getUpperSegmentValue() == getMaxSegmentValue();
	}
	boolean containsPrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isPrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	boolean containsSinglePrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isSinglePrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(IPStringCache.canonicalSegmentParams);
	}
	public String toNormalizedString(IPStringOptions options) {
		IPAddressStringWriter<IPAddressStringDivisionSeries> params =  IPAddressSection.toIPParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	protected static int toUnsignedStringLength(int value, int radix) {
		return AddressDivision.toUnsignedStringLength(value, radix);
	}
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return toUnsignedStringCased(value, radix, 0, false, appendable);
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int lowerValue) {
		if(cachedWildcardString == null && isStandardString && lowerValue == getDivisionValue() && lowerValue == getUpperDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedString == null) {
			if(isSinglePrefixBlock()) {
				if(isStandardString && rangeLower == getDivisionValue()) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
				}
			} else if(isFullRange()) {
				cachedString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue()) {
				long upper = getUpperDivisionValue();
				if(isPrefixed()) {
					upper &= getDivisionNetworkMask(getDivisionPrefixLength());
				}
				if(rangeUpper == upper) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
				}
			}
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
}
package inet.ipaddr;
import inet.ipaddr.format.AddressItem;
public class IncompatibleAddressException extends RuntimeException {
	private static final long serialVersionUID = 4L;
	private static String errorMessage = getMessage("ipaddress.address.error");
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public IncompatibleAddressException(AddressItem one, String key) {
		super(one + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(CharSequence one, String key) {
		super(one + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(long lower, long upper, String key) {
		super(lower + "-" + upper + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(long lower, long upper, long prefixLengthOrMask, String key) {
		super(lower + "-" + upper + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(String lower, String upper, String prefixLengthOrMask, String key) {
		super(lower + "-" + upper + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(AddressItem one, int prefixLengthOrMask, String key) {
		super(one + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(AddressItem one, int oneIndex, AddressItem two, int twoIndex, String key) {
		super((oneIndex + 1) + ":" + one + ", " + (twoIndex + 1) + ":" + two + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(AddressItem one, AddressItem two, String key) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage(key));
	}
	public IncompatibleAddressException(String message) {
        super(message);
    }
	public IncompatibleAddressException(String message, Throwable cause) {
        super(message, cause);
    }
}
package inet.ipaddr.format.standard;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.format.validate.ParsedAddressCreator;
public abstract class AddressCreator<T extends Address, R extends AddressSection, E extends AddressSection, S extends AddressSegment> extends ParsedAddressCreator<T, R, E, S>  implements AddressSegmentCreator<S> {
	private static final long serialVersionUID = 4L;
	public abstract AddressNetwork<S> getNetwork();
	protected abstract T createAddressInternal(S segments[]);
	protected abstract T createAddressInternal(S segments[], Integer prefix);
	protected abstract T createAddressInternal(S segments[], Integer prefix, boolean singleOnly);
	protected abstract R createSectionInternal(byte bytes[], int segmentCount, Integer prefix, boolean singleOnly);
	@Override
	protected abstract R createSectionInternal(S segments[]);
	@Override
	protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
	protected abstract R createSectionInternal(S segments[], int startIndex, boolean extended);
	public abstract T createAddress(R section);
}
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6AddressCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
public class IPv6Address extends IPAddress implements Iterable<IPv6Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = ':';
	public static final char ZONE_SEPARATOR = '%';
	public static final char ALTERNATIVE_ZONE_SEPARATOR = '\u00a7';
	public static final char UNC_SEGMENT_SEPARATOR = '-';
	public static final char UNC_ZONE_SEPARATOR = 's';
	public static final char UNC_RANGE_SEPARATOR = ALTERNATIVE_RANGE_SEPARATOR;
	public static final String UNC_RANGE_SEPARATOR_STR = String.valueOf(UNC_RANGE_SEPARATOR);
	public static final String UNC_SUFFIX = ".ipv6-literal.net";
	public static final String REVERSE_DNS_SUFFIX = ".ip6.arpa";
	public static final String REVERSE_DNS_SUFFIX_DEPRECATED = ".ip6.int";
	public static final int BITS_PER_SEGMENT = 16;
	public static final int BYTES_PER_SEGMENT = 2;
	public static final int SEGMENT_COUNT = 8;
	public static final int MIXED_REPLACED_SEGMENT_COUNT = 2; 
	public static final int MIXED_ORIGINAL_SEGMENT_COUNT = 6; 
	public static final int BYTE_COUNT = 16;
	public static final int BIT_COUNT = 128;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int BASE_85_RADIX = 85;
	public static final int MAX_VALUE_PER_SEGMENT = 0xffff;
	private final IPv6Zone zone;
	public static class IPv6Zone implements Serializable {
		private static final long serialVersionUID = 1L;
		String zoneStr;
		private int scopeId;
		private transient NetworkInterface networkInterface;
		private Boolean referencesInterface;
		public IPv6Zone(String zoneStr) {
			if(zoneStr == null) {
				throw new NullPointerException();
			}
			this.zoneStr = zoneStr.trim();
			scopeId = -1;
		}
		public IPv6Zone(int scopeId) {
			if(scopeId < 0) {
				throw new IllegalArgumentException();
			}
			this.scopeId = scopeId;
			referencesInterface = Boolean.FALSE;
		}
		public IPv6Zone(NetworkInterface networkInterface) {
			if(networkInterface == null) {
				throw new NullPointerException();
			}
			this.networkInterface = networkInterface;
			referencesInterface = Boolean.TRUE;
			scopeId = -1;
			zoneStr = networkInterface.getName();
		}
		public boolean referencesIntf() {
			if(referencesInterface == null) {
				scopeId = checkIfScope(zoneStr);
				referencesInterface = scopeId < 0;
			}
			return referencesInterface;
		}
		public boolean referencesScopeId() {
			return !referencesIntf();
		}
		public NetworkInterface getAssociatedIntf() {
			try {
				if(referencesIntf()) {
					if(networkInterface == null) {
						networkInterface = NetworkInterface.getByName(zoneStr);
					}
				} else {
					if(networkInterface == null) {
						Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
						top:
						while(interfaces.hasMoreElements()) {
							NetworkInterface nif = interfaces.nextElement();
							Enumeration<InetAddress> addrs = nif.getInetAddresses();
							while(addrs.hasMoreElements()) {
								InetAddress addr = addrs.nextElement();
								if(addr instanceof Inet6Address) {
									Inet6Address inetAddr = (Inet6Address) addr;
									if(inetAddr.getScopeId() == scopeId) {
										networkInterface = nif;
										break top;
									}
								}
							}
						}
					}
				}
			} catch(SocketException e) {}
			return networkInterface;
		}
		public MACAddress getAssociatedIntfMacAddr() {
			NetworkInterface intf = getAssociatedIntf();
			try {
				if(intf != null) {
					byte bytes[] = intf.getHardwareAddress();
					if(bytes != null) {
						return new MACAddress(bytes);
					}
				}
			} catch(SocketException e) {}
			return null;
		}
		public int getAssociatedScopeId() {
			if(referencesIntf()) {
				if(scopeId == -1) {
					NetworkInterface nif = getAssociatedIntf();
					if(nif != null) {
						Enumeration<InetAddress> addrs = nif.getInetAddresses();
						int newScopeId = -1;
						while(addrs.hasMoreElements()) {
							InetAddress addr = addrs.nextElement();
							if(addr instanceof Inet6Address) {
								Inet6Address inetAddr = (Inet6Address) addr;
								int sid = inetAddr.getScopeId();
								if(sid != 0) {
									if(newScopeId != -1 && sid != newScopeId) {
										newScopeId = -1;
										break;
									}
									newScopeId = sid;
								}
							}
						}
						if(newScopeId != -1) {
							this.scopeId = newScopeId;
						}
					}
				}
			}
			return scopeId;
		}
		@Override
		public int hashCode() {
			return toString().hashCode();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6Zone && toString().equals(o.toString());
		}
		public String getName() {
			if(zoneStr == null) {
				if(referencesIntf()) {
					zoneStr = networkInterface.getName();
				} else {
					zoneStr = IPv6AddressSegment.toUnsignedString(scopeId, 10,
							new StringBuilder(IPv6AddressSegment.toUnsignedStringLength(scopeId, 10))).toString();
				}
			}
			return zoneStr;
		}
		@Override
		public String toString() {
			return getName();
		}
		static int checkIfScope(String zoneStr) {
			long digits = 0;
			for(int i = 0, len = zoneStr.length(); i < len; i++) {
				char c = zoneStr.charAt(i);
				int digit = Character.digit(c, 10);
				if(digit < 0) {
					return -1;
				}
				digits = (digits * 10) + digit;
				if(digits > Integer.MAX_VALUE) {
					return -1;
				}
			}
			return (int) digits;
		}
	}
	private transient IPv6StringCache stringCache;
	private transient IPv6TrieKeyData cachedTrieKeyData;
	transient IPv6AddressCache addressCache;
	IPv6Address(IPv6AddressSection section, CharSequence zone, boolean checkZone) throws AddressValueException {
		this(section, checkZone ? 
					checkZone(zone) : 
					(zone != null && zone.length() > 0 ? 
							new IPv6Zone(zone.toString()) :
							null));
	}
	public IPv6Address(IPv6AddressSection section, IPv6Zone zone) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", section.getSegmentCount());
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
		this.zone = zone;
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, CharSequence zone) throws AddressValueException {
		this(section, zone, true);
	}
	public IPv6Address(IPv6AddressSection section) throws AddressValueException {
		this(section, (CharSequence) null);
	}
	public IPv6Address(IPv6AddressSegment[] segments) throws AddressValueException {
		this(segments, null, null);
	}
	public IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, networkPrefixLength, null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSegment[] segments, CharSequence zone) throws AddressValueException {
		this(segments, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSegment[] segments, IPv6Zone zone) throws AddressValueException {
		this(segments, null, zone);
	}
	private IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(segments, networkPrefixLength));
		if(segments.length != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", segments.length);
		}
		this.zone = zone;
	}
	public IPv6Address(Inet6Address inet6Address) {
		this(inet6Address, inet6Address.getAddress(), null, getZone(inet6Address));
	}
	public IPv6Address(Inet6Address inet6Address, Integer networkPrefixLength) {
		this(inet6Address, inet6Address.getAddress(), networkPrefixLength, getZone(inet6Address));
	}
	private IPv6Address(Inet6Address inet6Address, byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, 0, bytes.length, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
		getSection().setInetAddress(inet6Address);
	}
	@Deprecated
	public IPv6Address(byte[] bytes, CharSequence zone) throws AddressValueException {
		this(bytes, checkZone(zone));
	}
	public IPv6Address(byte[] bytes, IPv6Zone zone) throws AddressValueException {
		this(bytes, null, zone);
	}
	public IPv6Address(byte[] bytes) throws AddressValueException {
		this(bytes, null, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null, null);
	}
	public IPv6Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, networkPrefixLength, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
	}
	public IPv6Address(BigInteger val) throws AddressValueException {
		this(val, null, (IPv6Zone) null);
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength) throws AddressValueException {
		this(val, networkPrefixLength, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(BigInteger val, CharSequence zone) throws AddressValueException {
		this(val, checkZone(zone));
	}
	public IPv6Address(BigInteger val, IPv6Zone zone) throws AddressValueException {
		this(val, null, zone);
	}
	@Deprecated
	public IPv6Address(BigInteger val, Integer networkPrefixLength, CharSequence zone) throws AddressValueException {	
		this(val, networkPrefixLength, checkZone(zone));
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {	
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSectionInternal(val.toByteArray(), IPv6Address.SEGMENT_COUNT, networkPrefixLength, false));
		this.zone = zone;
	}
	private IPv6Address(byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength, zone);
	}
	private IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(long highBytes, long lowBytes, IPv6Zone zone) throws AddressValueException {
		this(highBytes, lowBytes, null, zone);
	}
	public IPv6Address(long highBytes, long lowBytes) throws AddressValueException {
		this(highBytes, lowBytes, null, null);
	}
	public IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength) throws AddressValueException {
		this(highBytes, lowBytes, networkPrefixLength, null);
	}
	private IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(highBytes, lowBytes, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, networkPrefixLength, null);
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null, null);
	}
	public IPv6Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv6Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Deprecated
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, CharSequence zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, checkZone(zone));
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, IPv6Zone zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, null, zone);
	}
	private IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(IPv6Address prefix, MACAddress eui) throws IncompatibleAddressException {
		this(prefix.getSection(), eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddress eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, CharSequence zone) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, IPv6Zone zone) throws IncompatibleAddressException, AddressValueException  {
		super(thisAddress -> toFullEUI64Section(section, eui, ((IPv6Address) thisAddress).getDefaultCreator(), ((IPv6Address) thisAddress).getMACNetwork().getAddressCreator()));
		this.zone = zone;
	}
	static IPv6Zone checkZone(CharSequence zone) throws AddressValueException {
		if(zone == null) {
			return null;
		}
		String zoneStr = zone.toString().trim();
		if(zone.length() == 0) {
			return null;
		}
		int invalidIndex = Validator.validateZone(zoneStr);
		if(invalidIndex >= 0) {
			throw new AddressValueException("ipaddress.error.invalid.zone", invalidIndex);
		}
		return new IPv6Zone(zoneStr);
	}
	IPv6AddressCreator getDefaultCreator() {
		return getNetwork().getAddressCreator();
	}
	IPv6AddressCreator getCreator() {
		IPv6AddressCreator defaultCreator = getDefaultCreator();
		if(!hasZone()) {
			return defaultCreator;
		}
		IPv6AddressCreator creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(segments, zone); 
			}
			@Override
			public IPv6Address createAddress(IPv6AddressSection section) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(section, zone); 
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		return creator;
	}
	private static IPv6Zone getZone(Inet6Address inet6Address) {
		NetworkInterface networkInterface = inet6Address.getScopedInterface();
		if(networkInterface != null) {
			return new IPv6Zone(networkInterface);
		}
		int scopeId = inet6Address.getScopeId();
		if(scopeId != 0) {
			return new IPv6Zone(scopeId);
		}
		return null;
	}
	private static IPv6AddressSection toFullEUI64Section(IPv6AddressSection section, MACAddressSection eui, IPv6AddressCreator creator, MACAddressCreator macCreator) throws AddressValueException, IncompatibleAddressException {
		boolean euiIsExtended = eui.isExtended();
		if(eui.addressSegmentIndex != 0) {
			throw new AddressPositionException(eui, eui.addressSegmentIndex);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section, section.addressSegmentIndex);
		}
		if(section.getSegmentCount() < 4) {
			throw new AddressValueException(section, "ipaddress.mac.error.not.eui.convertible");
		}
		if(eui.getSegmentCount() != (euiIsExtended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(eui, "ipaddress.mac.error.not.eui.convertible");
		}
		IPv6AddressSegment segments[] = creator.createSegmentArray(8);
		section.getSegments(0, 4, segments, 0);
		Integer prefLength = section.getNetworkPrefixLength();
		Integer prefixLength = prefLength != null && (prefLength <= 64) ? prefLength : null;
		toEUI64Segments(segments, 4, eui, 0, eui.isExtended(), creator, macCreator, prefixLength);
		return creator.createSectionInternal(segments);
	}
	static IPv6AddressSegment[] toEUI64Segments(
			IPv6AddressSegment segments[],
			int ipv6StartIndex,
			MACAddressSection eui,
			int euiStartIndex,
			boolean isExtended,
			IPv6AddressCreator creator,
			MACAddressCreator macCreator,
			Integer prefixLength) 
					throws IncompatibleAddressException {
		int euiSegmentIndex = 0;
		int euiSegmentCount = eui.getSegmentCount();
		MACAddressSegment seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
		seg0 = (euiStartIndex == 0 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg1 = (euiStartIndex <= 1 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg2 = (euiStartIndex <= 2 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg3 = (euiStartIndex <= 3 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg4 = (euiStartIndex <= 4 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg5 = (euiStartIndex <= 5 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg6 = (euiStartIndex <= 6 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg7 = (euiStartIndex <= 7 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex) : null;
		boolean isNotNull;
		MACAddressSegment zeroSegment = macCreator.createSegment(0);
		MACAddressSegment ffSegment = macCreator.createSegment(0xff);
		MACAddressSegment feSegment = macCreator.createSegment(0xfe);
		Integer currentPrefix = null;
		if(prefixLength != null) {
			currentPrefix = 0;
		}
		if((isNotNull = (seg0 != null)) || seg1 != null) {
			if(isNotNull) {
				if(seg1 == null) {
					seg1 = zeroSegment;
				}
			} else {
				seg0 = zeroSegment;
			}
			segments[ipv6StartIndex++] = join(creator, seg0, seg1, true , currentPrefix);
		}
		if(isExtended) {
			if((isNotNull = (seg2 != null)) || seg3 != null) {
				if(!isNotNull) {
					seg2 = zeroSegment;
					if(!seg3.matches(0xff)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
				}
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(!seg4.matches(0xfe)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				}
				segments[ipv6StartIndex++] = join(creator, feSegment, seg5, currentPrefix);
			}
		} else {
			if(seg2 != null) {
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if(seg3 != null) {
				segments[ipv6StartIndex++] = join(creator, feSegment, seg3, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				} else {
					seg4 = zeroSegment;
				}
				segments[ipv6StartIndex++] = join(creator, seg4, seg5, currentPrefix);
			}
		}
		if((isNotNull = (seg6 != null)) || seg7 != null) {
			if(isNotNull) {
				if(seg7 == null) {
					seg7 = zeroSegment;
				}
			} else {
				seg6 = zeroSegment;
			}
			segments[ipv6StartIndex] = join(creator, seg6, seg7, currentPrefix);
		}
		return segments;
	} 
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, Integer prefixLength) {
		return join(creator, macSegment0, macSegment1, false, prefixLength);
	}
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, boolean flip, Integer prefixLength) {
		if(macSegment0.isMultiple()) {
			if(!macSegment1.isFullRange()) {
				throw new IncompatibleAddressException(macSegment0, macSegment1, "ipaddress.error.invalidMACIPv6Range");
			}
		}
		int lower0 = macSegment0.getSegmentValue();
		int upper0 = macSegment0.getUpperSegmentValue();
		if(flip) {
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				throw new IncompatibleAddressException(macSegment0, "ipaddress.mac.error.not.eui.convertible");
			}
			lower0 ^= mask2ndBit;
			upper0 ^= mask2ndBit;
		}
		return creator.createSegment(
				(lower0 << 8) | macSegment1.getSegmentValue(), 
				(upper0 << 8) | macSegment1.getUpperSegmentValue(),
				prefixLength);
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return defaultIpv6Network();
	}
	public MACAddressNetwork getMACNetwork() {
		return defaultMACNetwork();
	}
	public IPv4AddressNetwork getIPv4Network() {
		return defaultIpv4Network();
	}
	@Override
	public IPv6AddressSection getSection() {
		return (IPv6AddressSection) super.getSection();
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv6AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public boolean isEUI64() {
		return getSection().isEUI64();
	}
	public MACAddress toEUI(boolean extended) {
		MACAddressSection section = getSection().toEUI(extended);
		if(section == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return creator.createAddress(section);
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv6StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv4Address ipv4Addr = getConverted(options);
		if(ipv4Addr != null) {
			IPAddressStringDivisionSeries ipv4Parts[] = ipv4Addr.getParts(options.ipv4ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv4Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv4Parts,  0, parts, tmp.length, ipv4Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	void cache(IPv6Address lower, IPv6Address upper) {
		if((lower != null || upper != null) && getSection().getSingleLowestOrHighestSection() == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv6AddressCache cache = addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = addressCache;
					boolean create = (cache == null);
					if(create) {
						addressCache = cache = new IPv6AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	private IPv6Address getLowestOrHighest(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection currentSection = getSection();
		IPv6AddressSection sectionResult = currentSection.getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == currentSection) {
			return this;
		} else if(sectionResult == null) {
			return null;
		}
		IPv6Address result = null;
		IPv6AddressCache cache = addressCache;
		if(cache == null || 
			(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addressCache;
				boolean create = (cache == null);
				if(create) {
					addressCache = cache = new IPv6AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	@Override
	public IPv6Address getLowerNonZeroHost() {
		return getLowestOrHighest(true, true);
	}
	@Override
	public IPv6Address getLower() {
		return getLowestOrHighest(true, false);
	}
	@Override
	public IPv6Address getUpper() {
		return getLowestOrHighest(false, false);
	}
	public long[] longValues() {
		return getSection().longValues();
	}
	public long[] upperLongValues() {
		return getSection().upperLongValues();
	}
	IPv6TrieKeyData getTrieKeyCache() {
		IPv6TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv6TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			long vals[] = longValues();
			keyData.uint64HighVal = vals[0];
			keyData.uint64LowVal = vals[1];
			if(prefLen != null) {
				int bits = prefLen;
				IPv6Address mask = getNetwork().getNetworkMask(bits, false);
				vals = mask.longValues();
				keyData.mask64HighVal = vals[0];
				keyData.mask64LowVal = vals[1];
				if(bits > 63) {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> (bits - 64);
				} else {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> bits;
				}
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv6Address replace(int startIndex, int endIndex, IPv6Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv6Address replace(int startIndex, IPv6AddressSection replacement) {
		int replacementCount = Math.min(IPv6Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv6Address reverseBits(boolean perByte) {
		return getCreator().createAddress(getSection().reverseBits(perByte));
	}
	@Override
	public IPv6Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv6Address reverseBytesPerSegment() {
		return checkIdentity(getSection().reverseBytesPerSegment());
	}
	@Override
	public IPv6Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getCreator());
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), true);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator() {
		return getSection().prefixIterator(this, getCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getCreator(), segmentCount);
	}
	@Override
	public Stream<IPv6Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6Address> sequentialBlockIterator() {
		return (Iterator<IPv6Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6Address> sequentialBlockStream() {
		return (Stream<IPv6Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		return getSection().iterator(this, getCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> spliterator() {
		return getSection().spliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> nonZeroHostIterator() {
		Predicate<IPv6AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = segments -> getSection().isZeroHost(segments, prefLength);
		}
		return getSection().iterator(this, getCreator(), excludeFunc);
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	public IPv6Address increment(BigInteger increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	@Override
	public IPv4Address toIPv4() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv4(this);
	}
	@Override
	public IPv6Address toIPv6() {
		return this;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public boolean isIPv4Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv4Convertible(this);
	}
	@Override
	public boolean isIPv6Convertible() {
		return true;
	}
	public IPv4AddressSection toMappedIPv4Segments() {
		if(isIPv4Mapped()) {
			return getSection().getEmbeddedIPv4AddressSection();
		}
		return null;
	}
	public IPv4Address get6To4IPv4Address() {
		return getEmbeddedIPv4Address(2);
	}
	public IPv4Address getEmbeddedIPv4Address() {
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection()); 
	}
	public IPv4Address getEmbeddedIPv4Address(int byteIndex) {
		if(byteIndex == IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT * IPv6Address.BYTES_PER_SEGMENT) {
			return getEmbeddedIPv4Address();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection(byteIndex, byteIndex + IPv4Address.BYTE_COUNT)); 
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv6AddressSegment firstSeg = getSegment(0);
			if(firstSeg.matchesWithMask(8, 0xf)) {
				return true;
			}
			if(firstSeg.getValueCount() <= 5 && 
					(firstSeg.getSegmentValue() & 0xf) >= 1 && (firstSeg.getUpperSegmentValue() & 0xf) <= 5) {
				return true;
			}
			if(firstSeg.matchesWithPrefixMask(0xff30, 12) && getSegment(6).matchesWithPrefixMask(0x8000, 1)) {
				return true;
			}
		}
		return isLinkLocal() || isSiteLocal() || isUniqueLocal() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(2, 0xf)) || 
				firstSeg.matchesWithPrefixMask(0xfe80, 10);
	}
	public boolean isSiteLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(5, 0xf)) ||  
				firstSeg.matchesWithPrefixMask(0xfec0, 10); 
	}
	public boolean isUniqueLocal() {
		return getSegment(0).matchesWithPrefixMask(0xfc00, 7);
	}
	public boolean isIPv4Mapped() {
		if(getSegment(5).matches(IPv6Address.MAX_VALUE_PER_SEGMENT)) {
			for(int i = 0; i < 5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	public boolean isIPv4Compatible() {
		return getSegment(0).isZero() && getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() && getSegment(5).isZero();
	}
	public boolean is6To4() {
		return getSegment(0).matches(0x2002);
	}
	public boolean is6Over4() {
		return getSegment(0).matches(0xfe80) && 
				getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() &&
				getSegment(5).isZero();
	}
	public boolean isTeredo() {
		return getSegment(0).matches(0x2001) && getSegment(1).isZero();
	}
	public boolean isIsatap() {
		return getSegment(0).matches(0xfe80) &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero() &&
				(getSegment(4).isZero() || getSegment(4).matches(0x200)) && 
				getSegment(5).matches(0x5efe);
	}
	public boolean isIPv4Translatable() { 
		return getSegment(4).matches(0xffff) && 
				getSegment(5).isZero() &&
				getSegment(0).isZero() &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero();
	}
	public boolean isWellKnownIPv4Translatable() { 
		if(getSegment(0).matches(0x64) && getSegment(1).matches(0xff9b)) {
			for(int i=2; i<=5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xff00, 8);
	}
	@Override
	public boolean isLoopback() {
		int i=0;
		for(; i < getSegmentCount() - 1; i++) {
			if(!getSegment(i).isZero()) {
				return false;
			}
		}
		return getSegment(i).matches(1);
	}
	@Override
	public IPv6Address intersect(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6Address otherAddr = convertArg(other);
		IPv6AddressSection section = thisSection.intersect(otherAddr.getSection());
		if(section == null) {
			return null;
		}
		IPv6AddressCreator creator = isSameZone(otherAddr) ? getCreator() : getDefaultCreator();
		IPv6Address result = creator.createAddress(section);
		return result;
	}
	@Override
	public IPv6Address[] subtract(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv6Address result[] = new IPv6Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = getCreator().createAddress(sections[i]); 
		}
		return result;
	}
	private IPv6Address checkIdentity(IPv6AddressSection newSection) {
		if(newSection == getSection()) {
			return this;
		}
		return getCreator().createAddress(newSection);
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength) throws PrefixLenException {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv6Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv6Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	protected IPv6Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv6Address converted = arg.toIPv6();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv6Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv6Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv6Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv6Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv6Address toMaxHost() {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv6Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv6Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv6Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv6Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address getHostMask() {
		return (IPv6Address) super.getHostMask();
	}
	@Override
	public IPv6Address getNetworkMask() {
		return (IPv6Address) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv6Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv6Address assignPrefixForSingleBlock() {
		return (IPv6Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6Address assignMinPrefixForBlock() {
		return (IPv6Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return (IPv6Address) IPv6AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv6Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv6AddressSection.coverWithPrefixBlock(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(true);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::assignPrefixForSingleBlock,
				IPv6Address::withoutPrefixLength,
				getCreator()::createAddressArray);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6Address[] { withoutPrefixLength().removeZone() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(false);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::withoutPrefixLength,
				getDefaultCreator());
	}
	@Override
	public IPv6AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv6Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]).removeZone();
		}
		converted[0] = removeZone();
		return converted;
	}
	@Override
	public IPv6Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		addresses = addresses.clone();
		for(int i = 0; i < addresses.length; i++) {
			addresses[i] = convertArg(addresses[i]).removeZone();
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getDefaultCreator());
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getDefaultCreator()::createSequentialBlockAddress;
	}
	public boolean hasZone() {
		return zone != null;
	}
	public String getZone() {
		return getZoneString();
	}
	public IPv6Address setZone(IPv6Zone newZone) {
		if(newZone == null) {
			return removeZone();
		}
		return getDefaultCreator().createAddress(getSection(), newZone); 
	}
	public IPv6Zone getIPv6Zone() {
		return zone;
	}
	public IPv6Address removeZone() {
		if(hasZone()) {
			return getDefaultCreator().createAddress(getSection()); 
		}
		return this;
	}
	protected boolean hasNoValueCache() {
		if(addressCache == null) {
			synchronized(this) {
				if(addressCache == null) {
					addressCache = new IPv6AddressCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public Inet6Address toInetAddress() {
		if(hasZone()) {
			Inet6Address result;
			if(hasNoValueCache() || (result = addressCache.inetAddress) == null) {
				addressCache.inetAddress = result = (Inet6Address) toInetAddressImpl();
			}
			return result;
		}
		return (Inet6Address) super.toInetAddress();
	}
	@Override
	public Inet6Address toUpperInetAddress() {
		return (Inet6Address) super.toUpperInetAddress();
	}
	@Override
	protected Inet6Address toInetAddressImpl() {
		Inet6Address result;
		byte bytes[] = getSection().getBytesInternal();
		try {
			if(hasZone()) {
				if(zone.referencesScopeId()) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedScopeId());
				} else if(zone.referencesIntf() && zone.getAssociatedIntf() != null) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedIntf());
				} else {
					IPv6Address adjusted = getLower().withoutPrefixLength();
					InetAddress resultIP = InetAddress.getByName(adjusted.toNormalizedString());
					if(resultIP instanceof Inet6Address) {
						result = (Inet6Address) resultIP;
					} else {
						result = Inet6Address.getByAddress(null, bytes, null);
					}
				}
			} else {
				result = Inet6Address.getByAddress(null, bytes, null);
			}
		} catch(UnknownHostException e) {
			result = null;
		}
		return result;
	}
	@Override
	@Deprecated
	public IPv6AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv6AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		IPv6Address thiz = removeZone().withoutPrefixLength();
		return new IPv6AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public int hashCode() {
		int result = super.hashCode();
		if(hasZone()) {
			result *= zone.getName().hashCode();
		}
		return result;
	}
	@Override
	public boolean isSameAddress(Address other) {
		return other instanceof IPv6Address && super.isSameAddress(other) && isSameZone((IPv6Address) other);
	}
	private boolean isSameZone(IPv6Address otherIPv6Address) {
		return Objects.equals(zone, otherIPv6Address.zone);
	}
	@Override
	public boolean overlaps(Address other) {
		if(super.overlaps(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean contains(Address other) {
		if(super.contains(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv6Address) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv6()) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getIPv4Network()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().toParams();
	}
	private boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					if(hasZone()) {
						stringCache = new IPv6StringCache();
						return true;
					} else {
						IPv6AddressSection section = getSection();
						boolean result = section.hasNoStringCache();
						stringCache = section.getStringCache();
						return result;
					}
				}
			}
		}
		return false;
	}
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.mixedString) == null) {
			if(hasZone()) {
				stringCache.mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
			} else {
				result = getSection().toMixedString();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			if(hasZone()) {
				stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
			} else {
				result = getSection().toCanonicalString();
			}
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			if(hasZone()) {
				stringCache.fullString = result = toNormalizedString(IPv6StringCache.fullParams);
			} else {
				result = getSection().toFullString();
			}
		}
		return result;
	}
	public static String toNormalizedString(IPv6AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, zone);
	}
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedString) == null) {
			if(hasZone()) {
				stringCache.normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
			} else {
				result = getSection().toNormalizedString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedString) == null) {
			if(hasZone()) {
				stringCache.compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
			} else {
				result = getSection().toCompressedString();
			}
		}
		return result;
	}
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			if(hasZone()) {
				stringCache.normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
			} else {
				result = getSection().toNormalizedWildcardString();
			}
		}
		return result;
	}
	public String toBase85String() throws IncompatibleAddressException {
		IPAddressString originator = getAddressfromString();
		if(originator != null && (!isPrefixed() || getNetworkPrefixLength() == IPv6Address.BIT_COUNT) && 
				originator.isBase85IPv6()) {
			return originator.toString();
		}
		String result;
		if(hasNoStringCache() || (result = stringCache.base85String) == null) {
			if(hasZone()) {
				stringCache.base85String = result = getSection().toBase85String(getZone());
			} else {
				result = getSection().toBase85String();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalWildcardString) == null) {
			if(hasZone()) {
				stringCache.canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
			} else {
				result = getSection().toCanonicalWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedWildcardString) == null) {
			if(hasZone()) {
				stringCache.compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
			} else {
				result = getSection().toCompressedWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			if(hasZone()) {
				stringCache.sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
			} else {
				result = getSection().toSQLWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			if(hasZone()) {
				result = getSection().toHexString(with0xPrefix, zone.getName());
				if(with0xPrefix) {
					stringCache.hexStringPrefixed = result;
				} else {
					stringCache.hexString = result;
				}
			} else {
				result = getSection().toHexString(with0xPrefix);
			}
		}
		return result;
	}
	private String getZoneString() {
		return hasZone() ? zone.getName() : null;
	}
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = stringCache.binaryString) == null) {
			if(hasZone()) {
				result = getSection().toBinaryString(zone.getName());
				stringCache.binaryString = result;
			} else {
				result = getSection().toBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			if(hasZone()) {
				result = getSection().toSegmentedBinaryString(zone.getName());
				stringCache.segmentedBinaryString = result;
			} else {
				result = getSection().toSegmentedBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? stringCache.octalStringPrefixed : stringCache.octalString)) == null) {
			if(hasZone()) {
				result = getSection().toOctalString(with0Prefix, zone.getName());
				if(with0Prefix) {
					stringCache.octalStringPrefixed = result;
				} else {
					stringCache.octalString = result;
				}
			} else {
				result = getSection().toOctalString(with0Prefix);
			}
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.networkPrefixLengthString) == null) {
			if(hasZone()) {
				stringCache.networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
			} else {
				result = getSection().toPrefixLengthString();
			}
		}
		return result;
	}
	@Override
	public String toConvertedString() {
		if(isIPv4Convertible()) {
			return toMixedString();
		}
		return toNormalizedString();
	}
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(IPv6StringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(boolean keepMixed, IPv6StringOptions params) {
		if(keepMixed && fromString != null && getAddressfromString().isMixedIPv6() && !params.makeMixed()) {
			params = new IPv6StringOptions(
					params.base,
					params.expandSegments,
					params.wildcardOption,
					params.wildcards,
					params.segmentStrPrefix,
					true,
					params.ipv4Opts,
					params.compressOptions,
					params.separator,
					params.zoneSeparator,
					params.addrLabel,
					params.addrSuffix,
					params.reverse,
					params.splitDigits,
					params.uppercase);
		}
		return toNormalizedString(params);
	}
	@Override
	public String toUNCHostName() {
		String result;
		if(hasNoStringCache() || (result = stringCache.uncString) == null) {
			String newZone;
			if(hasZone()) {
				newZone = zone.getName().replace(IPv6Address.ZONE_SEPARATOR, IPv6Address.UNC_ZONE_SEPARATOR).replace(IPv6Address.SEGMENT_SEPARATOR, IPv6Address.UNC_SEGMENT_SEPARATOR);
			} else {
				newZone = null;
			}
			stringCache.uncString = result = getSection().toNormalizedString(IPv6StringCache.uncParams, newZone);
		}
		return result;
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv6StringBuilderOptions.from(opts));
	}
	private IPv4Address getConverted(IPv6StringBuilderOptions opts) {
		if(!hasZone() && opts.includes(IPv6StringBuilderOptions.IPV4_CONVERSIONS)) {
			IPv4AddressConverter converter = opts.converter;
			return converter.toIPv4(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		IPv6StringCollection coll = getSection().toStringCollection(opts, getZoneString());
		IPv4Address ipv4Addr = getConverted(opts);
		if(ipv4Addr != null) {
			IPAddressPartStringCollection ipv4StringCollection = ipv4Addr.toStringCollection(opts.ipv4ConverterOptions);
			coll.addAll(ipv4StringCollection);
		}
		return coll;
	}
	public interface IPv6AddressConverter {
		IPv6Address toIPv6(IPAddress address);
	}
}
package inet.ipaddr.format.standard;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.validate.ParsedIPAddress;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
public abstract class AddressDivision extends AddressDivisionBase {
	private static final long serialVersionUID = 4L;
	protected AddressDivision() {}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int bitCount = getBitCount();
		byte bytes[] = new byte[getByteCount()];
		int byteIndex = bytes.length - 1;
		long segmentValue = low ? getDivisionValue() : getUpperDivisionValue();
		while(true) {
			bytes[byteIndex] |= segmentValue;
			segmentValue >>= 8;
			if(bitCount <= 8) {
				return bytes;
			}
			bitCount -= 8;
			byteIndex--;
		}
	}
	@Override
	public boolean isMultiple() {
		return getDivisionValue() != getUpperDivisionValue();
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		if(!isMultiple()) {
			return result;
		} else if(isFullRange()) {
			return 0;
		}
		int lowerZeros = Long.numberOfTrailingZeros(getDivisionValue());
		if(lowerZeros != 0) {
			int upperOnes = Long.numberOfTrailingZeros(~getUpperDivisionValue());
			if(upperOnes != 0) {
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
			}
		}
		return result;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		long lowerValue = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lowerValue == upperValue) {
				return AddressDivisionGrouping.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lowerValue >>> shift == upperValue >>> shift) {
				return AddressDivisionGrouping.cacheBits(divPrefix);
			}
		}
		return null;
	}
	@Override
	protected String getDefaultRangeSeparatorString() {
		return Address.RANGE_SEPARATOR_STR;
	}
	public long getMaxValue() {
		return ~(~0L << getBitCount());
	}
	@Override
	public boolean isZero() {
		return !isMultiple() && includesZero();
	}
	@Override
	public boolean includesZero() {
		return getDivisionValue() == 0L;
	}
	@Override
	public boolean isMax() {
		return !isMultiple() && includesMax();
	}
	@Override
	public boolean includesMax() {
		return getUpperDivisionValue() == getMaxValue();
	}
	public abstract long getDivisionValue();
	public abstract long getUpperDivisionValue();
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			hashCode = res = createHashCode(getDivisionValue(), getUpperDivisionValue());
		}
		return res;
	}
	@Override
	public BigInteger getValue() {
		return BigInteger.valueOf(getDivisionValue());
	}
	@Override
	public BigInteger getUpperValue() {
		return BigInteger.valueOf(getUpperDivisionValue());
	}
	static boolean testRange(long lowerValue, long upperValue, long finalUpperValue, long networkMask, long hostMask) {
		return lowerValue == (lowerValue & networkMask)
				&& finalUpperValue == (upperValue | hostMask);
	}
	protected boolean isPrefixBlock(long divisionValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return divisionValue == 0 && upperValue == getMaxValue();
		}
		int bitCount = getBitCount();
		long ones = ~0L;
		long divisionBitMask = ~(ones << bitCount);
		long divisionPrefixMask = ones << (bitCount - divisionPrefixLen);
		long divisionNonPrefixMask = ~divisionPrefixMask;
		return testRange(divisionValue,
				upperValue,
				upperValue,
				divisionPrefixMask & divisionBitMask,
				divisionNonPrefixMask);
	}
	protected boolean isSinglePrefixBlock(long divisionValue, long upperValue, int divisionPrefixLen) {
		long ones = ~0L;
		int bitCount = getBitCount();
		long divisionBitMask = ~(ones << bitCount);
		long divisionPrefixMask = ones << (bitCount - divisionPrefixLen);
		long divisionNonPrefixMask = ~divisionPrefixMask;
		return testRange(divisionValue,
				divisionValue,
				upperValue,
				divisionPrefixMask & divisionBitMask,
				divisionNonPrefixMask);
	}
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperDivisionValue() < value;
	}
	public boolean matches(long value) {
		return !isMultiple() && value == getDivisionValue();
	}
	public boolean matchesWithMask(long value, long mask) {
		if(isMultiple()) {
			long diffBits = getDivisionValue() ^ getUpperDivisionValue();
			int leadingZeros = Long.numberOfLeadingZeros(diffBits);
			long fullMask = ~0L >>> leadingZeros;
			if((fullMask & mask) != 0L) {
				return false;
			} 
		}
		return value == (getDivisionValue() & mask);
	}
	public boolean matchesWithMask(long lowerValue, long upperValue, long mask) {
		if(lowerValue == upperValue) {
			return matchesWithMask(lowerValue, mask);
		}
		if(!isMultiple()) {
			return false;
		}
		long thisValue = getDivisionValue();
		long thisUpperValue = getUpperDivisionValue();
		Masker masker = maskRange(thisValue, thisUpperValue, mask, getMaxValue());
		if(!masker.isSequential()) {
			return false;
		}
		return lowerValue == masker.getMaskedLower(thisValue, mask) && upperValue == masker.getMaskedUpper(thisUpperValue, mask);
	}
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		if(other instanceof AddressDivision) {
			AddressDivision otherDivision = (AddressDivision) other;
			return getDivisionValue() == otherDivision.getDivisionValue() &&
					getUpperDivisionValue() == otherDivision.getUpperDivisionValue();
		}
		return false;
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivision) {
			AddressDivision other = (AddressDivision) o;
			return getBitCount() == other.getBitCount() && other.isSameValues(this);
		}
		return false;
	}
	public static class MaskResult {
		private final long value, upperValue, maskValue;
		private final Masker masker;
		public MaskResult(long value, long upperValue, long maskValue, Masker masker) {
			this.value = value;
			this.upperValue = upperValue;
			this.maskValue = maskValue;
			this.masker = masker;
		}
		public long getMaskedLower() {
			return masker.getMaskedLower(value, maskValue);
		}
		public long getMaskedUpper() {
			return masker.getMaskedUpper(upperValue, maskValue);
		}
		public boolean isSequential() {
			return masker.isSequential();
		}
	}
	public boolean isMaskCompatibleWithRange(int maskValue) {
		long value = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		long maxValue = getMaxValue();
		return maskRange(value, upperValue, maskValue, maxValue).isSequential();
	}
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return ParsedIPAddress.maskRange(value, upperValue, maskValue, maxValue);
	}
	public static MaskResult maskRange(long value, long upperValue, long maskValue) {
		Masker masker = ParsedIPAddress.maskRange(value, upperValue, maskValue);
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	public static class BitwiseOrResult {
		private final long value, upperValue, maskValue;
		private final BitwiseOrer masker;
		public BitwiseOrResult(long value, long upperValue, long maskValue, BitwiseOrer masker) {
			this.value = value;
			this.upperValue = upperValue;
			this.maskValue = maskValue;
			this.masker = masker;
		}
		public long getOredLower() {
			return masker.getOredLower(value, maskValue);
		}
		public long getOredUpper() {
			return masker.getOredUpper(upperValue, maskValue);
		}
		public boolean isSequential() {
			return masker.isSequential();
		}
	}
	public boolean isBitwiseOrCompatibleWithRange(int maskValue) {
		if(!isMultiple()) {
			return true;
		}
		long value = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		long maxValue = getMaxValue();
		return bitwiseOrRange(value, upperValue, maskValue, maxValue) != null;
	}
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return ParsedIPAddress.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public static BitwiseOrResult bitwiseOrRange(long value, long upperValue, long maskValue) {
		BitwiseOrer masker = ParsedIPAddress.bitwiseOrRange(value, upperValue, maskValue);
		return new BitwiseOrResult(value, upperValue, maskValue, masker);
	}
	public boolean hasUppercaseVariations(int radix, boolean lowerOnly) {
		if(radix < MIN_RADIX) {
			throw new IllegalArgumentException();
		} else if(radix <= 10) {
			return false;
		}
		boolean isPowerOfTwo;
		int shift = 0;
		long mask = 0;
		switch(radix) {
			case 0x10:
				isPowerOfTwo = true;
				shift = 4; 
				mask = 0xf; 
				break;
			default:
				isPowerOfTwo = (radix & (radix - 1)) == 0;
				if(isPowerOfTwo) {
					shift = Integer.numberOfTrailingZeros(radix);
					mask = ~(~0L << shift); 
				}
		}
		boolean handledUpper = false;
		long value = getDivisionValue();
		do {
			while(value > 0) {
				long checkVal = isPowerOfTwo ? (mask & value) : (value % radix);
				if(checkVal >= 0xa) {
					return true;
				}
				if(isPowerOfTwo) {
					value >>>= shift;
				} else {
					value /= radix;
				}
			}
			if(handledUpper || lowerOnly) {
				break;
			}
			value = getUpperDivisionValue();
			handledUpper = true;
		} while(true);
		return false;
	}
	@Override
	public int getDigitCount(int radix) {
		if(!isMultiple() && radix == getDefaultTextualRadix()) {
			return getWildcardString().length();
		}
		return getDigitCount(getUpperDivisionValue(), radix);
	}
	@Override
	public int getMaxDigitCount(int radix) {
		int defaultRadix = getDefaultTextualRadix();
		if(radix == defaultRadix) {
			return getMaxDigitCount();
		}
		return getMaxDigitCount(radix, getBitCount(), getMaxValue());
	}
	@Override
	protected int adjustLowerLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getDivisionValue(), radix);
	}
	@Override
	protected int adjustUpperLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getUpperDivisionValue(), radix);
	}
	private int adjustLeadingZeroCount(int leadingZeroCount, long value, int radix) {
		if(leadingZeroCount < 0) {
			int width = getDigitCount(value, radix);
			return Math.max(0, getMaxDigitCount(radix) - width);
		}
		return leadingZeroCount;
	}
	@Override
	protected String getWildcardString() {
		return super.getWildcardString();
	}
	@Override
	protected int getLowerStringLength(int radix) {
		return toUnsignedStringLength(getDivisionValue(), radix);
	}
	@Override
	protected int getUpperStringLength(int radix) {
		return toUnsignedStringLength(getUpperDivisionValue(), radix);
	}
	@Override
	protected void getLowerString(int radix, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getDivisionValue(), radix, 0, uppercase, appendable);
	}
	@Override
	protected void getUpperString(int radix, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getUpperDivisionValue(), radix, 0, uppercase, appendable);
	}
	@Override
	protected void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable) {
		getUpperString(radix, uppercase, appendable);
	}
	@Override
	protected void getLowerString(int radix, int rangeDigits, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getDivisionValue(), radix, rangeDigits, uppercase, appendable);
	}
	@Override
	protected void getSplitLowerString(int radix, int choppedDigits, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		toSplitUnsignedString(getDivisionValue(), radix, choppedDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
	}
	@Override
	protected void getSplitRangeString(String rangeSeparator, String wildcard, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		toUnsignedSplitRangeString(
			getDivisionValue(),
			getUpperDivisionValue(),
			rangeSeparator,
			wildcard,
			radix,
			uppercase, 
			splitDigitSeparator,
			reverseSplitDigits,
			stringPrefix,
			appendable);
	}
	@Override
	protected int getSplitRangeStringLength(String rangeSeparator, String wildcard, int leadingZeroCount, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix) {
		return toUnsignedSplitRangeStringLength(
			getDivisionValue(),
			getUpperDivisionValue(),
			rangeSeparator,
			wildcard,
			leadingZeroCount,
			radix,
			uppercase, 
			splitDigitSeparator,
			reverseSplitDigits,
			stringPrefix);
	}
	@Override
	protected String getDefaultLowerString() {
		return toDefaultString(getDivisionValue(), getDefaultTextualRadix());
	}
	@Override
	protected String getDefaultRangeString() {
		return getDefaultRangeString(getDivisionValue(), getUpperDivisionValue(), getDefaultTextualRadix());
	}
	protected String getDefaultRangeString(long val1, long val2, int radix) {
		int len1, len2, value1, value2, quotient, remainder; 
		if(radix == 10) {
			if(val2 < 10) {
				len2 = 1;
			} else if(val2 < 100) {
				len2 = 2;
			} else if(val2 < 1000) {
				len2 = 3;
			} else {
				return buildDefaultRangeString(radix);
			}
			value2 = (int) val2;
			if(val1 < 10) {
				len1 = 1;
			} else if(val1 < 100) {
				len1 = 2;
			} else if(val1 < 1000) {
				len1 = 3;
			} else {
				return buildDefaultRangeString(radix);
			}
			value1 = (int) val1;
			len2 += len1 + 1;
			char chars[] = new char[len2];
			chars[len1] = IPAddress.RANGE_SEPARATOR;
			char dig[] = DIGITS;
			do {
				quotient = (value1 * 0xcccd) >>> 19; 
				remainder = value1 - ((quotient << 3) + (quotient << 1)); 
				chars[--len1] = dig[remainder];
				value1 = quotient;
	        } while(value1 != 0);
			do {
				quotient = (value2 * 0xcccd) >>> 19;
				remainder = value2 - ((quotient << 3) + (quotient << 1));
				chars[--len2] = dig[remainder];
				value2 = quotient;
	        } while(value2 != 0);
			return new String(chars);
		} else if(radix == 16) {
			if(val2 < 0x10) {
				len2 = 1;
			} else if(val2 < 0x100) {
				len2 = 2;
			} else if(val2 < 0x1000) {
				len2 = 3;
			} else if(val2 < 0x10000) {
				len2 = 4;
			} else {
				return buildDefaultRangeString(radix);
			}
			value2 = (int) val2;
			if(val1 < 0x10) {
				len1 = 1;
			} else if(val1 < 0x100) {
				len1 = 2;
			} else if(val1 < 0x1000) {
				len1 = 3;
			} else if(val1 < 0x10000) {
				len1 = 4;
			} else {
				return buildDefaultRangeString(radix);
			}
			value1 = (int) val1;
			len2 += len1 + 1;
			char chars[] = new char[len2];
			chars[len1] = IPAddress.RANGE_SEPARATOR;
			char dig[] = DIGITS;
			do {
				quotient = value1 >>> 4;
				remainder = value1 - (quotient << 4);
				chars[--len1] = dig[remainder];
				value1 = quotient;
			} while(value1 != 0);
			do {
				quotient = value2 >>> 4;
				remainder = value2 - (quotient << 4);
				chars[--len2] = dig[remainder];
				value2 = quotient;
			} while(value2 != 0);
			return new String(chars);
		}
		return buildDefaultRangeString(radix);
	}
	private String buildDefaultRangeString(int radix) {
		StringBuilder builder = new StringBuilder(20);
		getRangeString(IPAddress.RANGE_SEPARATOR_STR, 0, 0, "", radix, false, false, builder);
		return builder.toString();
	}
	protected static String toDefaultString(long val, int radix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX || val < 0) {
			throw new IllegalArgumentException();
		}
		if(val == 0L) {
			return "0";
		} else if(val == 1L) {
			return "1";
		}
		int len, quotient, remainder, value; 
		if(radix == 10) {
			if(val < 10) {
				return String.valueOf(DIGITS, (int) val, 1);
			} else if(val < 100) {
				len = 2;
				value = (int) val;
			} else if(val < 1000) {
				len = 3;
				value = (int) val;
			} else {
				return Long.toString(val, radix);
			}
			char chars[] = new char[len];
			char dig[] = DIGITS;
			do {
				quotient = (value * 0xcccd) >>> 19; 
				remainder = value - ((quotient << 3) + (quotient << 1)); 
				chars[--len] = dig[remainder];
				value = quotient;
	        } while(value != 0);
			return new String(chars);
		} else if(radix == 16) {
			if(val < 0x10) {
				return String.valueOf(DIGITS, (int) val, 1);
			} else if(val < 0x100) {
				len = 2;
				value = (int) val;
			} else if(val < 0x1000) {
				len = 3;
				value = (int) val;
			} else if(val < 0x10000) {
				if(val == 0xffff) {
					return "ffff";
				}
				value = (int) val;
				len = 4;
			} else {
				return Long.toString(val, radix);
			}
			char chars[] = new char[len];
			char dig[] = DIGITS;
			do {
				quotient = value >>> 4;
				remainder = value - (quotient << 4);
				chars[--len] = dig[remainder];
				value = quotient;
			} while(value != 0);
			return new String(chars);
		}
		return Long.toString(val, radix);
	}
	private static int toUnsignedSplitRangeStringLength(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int leadingZerosCount,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int digitsLength = -1;
		int stringPrefixLength = stringPrefix.length();
		do {
			int upperDigit = (int) (upper % radix);
			int lowerDigit = (int) (lower % radix);
			boolean isFull = (lowerDigit == 0) && (upperDigit == radix - 1);
			if(isFull) {
				digitsLength += wildcard.length() + 1;
			} else {
				digitsLength += (stringPrefixLength << 1) + 4 ;
			}
			upper /= radix;
			lower /= radix;
		} while(upper != lower);
		int remaining = (upper == 0) ? 0 : toUnsignedStringLength(upper, radix);
		remaining += leadingZerosCount;
		if(remaining > 0) {
			digitsLength += remaining * (stringPrefixLength + 2 );
		}
		return digitsLength;
	}
	protected static BigInteger getRadixPower(BigInteger radix, int power) {
		return AddressDivisionBase.getRadixPower(radix, power);
	}
	private static void toSplitUnsignedString(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix,
			StringBuilder appendable) {
		int front = appendable.length();
		appendDigits(value, radix, choppedDigits, uppercase, splitDigitSeparator, stringPrefix, appendable);
		if(!reverseSplitDigits) {
			int back = appendable.length() - 1;
			int stringPrefixLen = stringPrefix.length();
			front += stringPrefixLen;
			while(front < back) {
				char frontChar = appendable.charAt(front);
				appendable.setCharAt(front, appendable.charAt(back));
				appendable.setCharAt(back, frontChar);
				front += 2;
				back -= 2;
				front += stringPrefixLen;
				back -= stringPrefixLen;
			}
		}
	}
	private static void toUnsignedSplitRangeString(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix,
			StringBuilder appendable) {
		int front = appendable.length();
		appendDigits(lower, upper, rangeSeparator, wildcard, radix, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
		if(!reverseSplitDigits) {
			int back = appendable.length() - 1;
			while(front < back) {
				char frontChar = appendable.charAt(front);
				appendable.setCharAt(front++, appendable.charAt(back));
				appendable.setCharAt(back--, frontChar);
			}
		}
	}
	private static void appendDigits(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase, 
			char splitDigitSeparator,
			String stringPrefix,
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		boolean useInts = value <= Integer.MAX_VALUE;
		int value2 = useInts ? (int) value : radix;
		char dig[] = uppercase ? UPPERCASE_DIGITS : DIGITS;
		int index;
		int prefLen = stringPrefix.length();
		while(value2 >= radix) {
			if(useInts) {
				int val = value2;
				value2 /= radix;
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = val % radix;
			} else {
				long val = value;
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					value2 = (int) value;
				}
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = (int) (val % radix);
			}
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			appendable.append(dig[index]);
			appendable.append(splitDigitSeparator);
		}
		if(choppedDigits == 0) {
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			appendable.append(dig[value2]);
		}
	}
	private static void appendDigits(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix, 
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		char dig[] = uppercase ? UPPERCASE_DIGITS : DIGITS;
		boolean previousWasFullRange = true;
		boolean useInts = upper <= Integer.MAX_VALUE;
		int upperInt, lowerInt;
		if(useInts) {
			upperInt = (int) upper;
			lowerInt = (int) lower;
		} else {
			upperInt = lowerInt = radix;
		}
		int prefLen = stringPrefix.length();
		while(true) {
			int upperDigit, lowerDigit;
			if(useInts) {
				int ud = upperInt;
				upperDigit = upperInt % radix;
				upperInt /= radix;
				if(ud == lowerInt) {
					lowerInt = upperInt;
					lowerDigit = upperDigit;
				} else {
					lowerDigit = lowerInt % radix;
					lowerInt /= radix;
				}
			} else {
				long ud = upper;
				upperDigit = (int) (upper % radix);
				upper /= radix;
				if(ud == lower) {
					lower = upper;
					lowerDigit = upperDigit;
				} else {
					lowerDigit = (int) (lower % radix);
					lower /= radix;
				}
				if(upper <= Integer.MAX_VALUE) {
					useInts = true;
					upperInt = (int) upper;
					lowerInt = (int) lower;
				}
			}
			if(lowerDigit == upperDigit) {
				previousWasFullRange = false;
				if(reverseSplitDigits) {
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					appendable.append(dig[lowerDigit]);
				} else {
					appendable.append(dig[lowerDigit]);
					for(int k = prefLen - 1; k >= 0; k--) {
						appendable.append(stringPrefix.charAt(k));
					}
				}
			} else {
				if(!previousWasFullRange) {
					throw new IncompatibleAddressException(lower, upper, "ipaddress.error.splitMismatch");
				}
				previousWasFullRange = (lowerDigit == 0) && (upperDigit == radix - 1);
				if(previousWasFullRange && wildcard != null) {
					if(reverseSplitDigits) {
						appendable.append(wildcard);
					} else {
						for(int k = wildcard.length() - 1; k >= 0; k--) {
							appendable.append(wildcard.charAt(k));
						}
					}
				} else {
					if(reverseSplitDigits) {
						if(prefLen > 0) {
							appendable.append(stringPrefix);
						}
						appendable.append(dig[lowerDigit]);
						appendable.append(rangeSeparator);
						appendable.append(dig[upperDigit]);
					} else {
						appendable.append(dig[upperDigit]);
						appendable.append(rangeSeparator);
						appendable.append(dig[lowerDigit]);
						for(int k = prefLen - 1; k >= 0; k--) {
							appendable.append(stringPrefix.charAt(k));
						}
					}
				}
			}
			if(upperInt == 0) {
				break;
			}
			appendable.append(splitDigitSeparator);
		}
	}
	@Override
	protected int getRangeDigitCount(int radix) {
		if(!isMultiple()) {
			return 0;
		} else if(radix == getDefaultTextualRadix()) {
			return getRangeDigitCountImpl();
		} else if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		return calculateRangeDigitCount(radix, getDivisionValue(), getUpperDivisionValue(), getMaxValue());
	}
	protected int getRangeDigitCountImpl() {
		return calculateRangeDigitCount(getDefaultTextualRadix(), getDivisionValue(), getUpperDivisionValue(), getMaxValue());
	}
	private static int calculateRangeDigitCount(int radix, long value, long upperValue, long maxValue) {
		int factor = radix;
		int numDigits = 1;
		while(true) {
			long lowerRemainder = value % factor;
			if(lowerRemainder == 0) {
				long max = (maxValue / factor == upperValue / factor) ? maxValue % factor : factor - 1;
				long upperRemainder = upperValue % factor;
				if(upperRemainder == max) {
					if(upperValue - upperRemainder == value) {
						return numDigits;
					} else {
						numDigits++;
						factor *= radix;
						continue;
					}
				}
			}
			return 0;
		}
	}
	protected static int reverseBits(byte b) {
		int x = b;
		x = ((x & 0xaa) >>> 1) | ((x & 0x55) << 1);
		x = ((x & 0xcc) >>> 2) | ((x & 0x33) << 2);
		x = (0xff & ((x >>> 4) | (x << 4)));
		return x;
	}
	protected static int reverseBits(short b) {
		int x = b;
		x = ((x & 0xaaaa) >>> 1) | ((x & 0x5555) << 1);
		x = ((x & 0xcccc) >>> 2) | ((x & 0x3333) << 2);
		x = ((x & 0xf0f0) >>> 4) | ((x & 0x0f0f) << 4);
		return 0xffff & ((x >>> 8) | (x << 8));
	}
	protected static int reverseBits(int i) {
		int x = i;
		x = ((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1);
		x = ((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2);
		x = ((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4);
		x = ((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8);
		return (x >>> 16) | (x << 16);
	}
	protected static <S extends AddressSegment> int getPrefixValueCount(S segment, int segmentPrefixLength) {
		int shiftAdjustment = segment.getBitCount() - segmentPrefixLength;
		return (segment.getUpperSegmentValue() >>> shiftAdjustment) - (segment.getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected static <S extends AddressSegment> Iterator<S> identityIterator(S original) {
		return new Iterator<S>() {
			boolean done;
			@Override
			public boolean hasNext() {
				return !done;
			}
		   @Override
			public S next() {
		    	if(!hasNext()) {
		    		throw new NoSuchElementException();
		    	}
		    	done = true;
		    	return original;
	    	}
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <S extends AddressSegment> Iterator<S> iterator(
			S original,
			AddressSegmentCreator<S> creator,
			Integer segmentPrefixLength,
			boolean isPrefixIterator,
			boolean isBlockIterator) {
		return iterator(
				original,
				original.getSegmentValue(),
				original.getUpperSegmentValue(),
				original.getBitCount(),
				creator,
				segmentPrefixLength,
				isPrefixIterator,
				isBlockIterator);
	}
	protected static <S extends AddressSegment> Iterator<S> iterator(
			S original,
			int originalLower,
			int originalUpper,
			int bitCount,
			AddressSegmentCreator<S> creator,
			Integer segmentPrefixLength,
			boolean isPrefixIterator,
			boolean isBlockIterator) {
		int shiftAdjustment, shiftMask, upperShiftMask;
		if(isPrefixIterator) {
			shiftAdjustment = bitCount - segmentPrefixLength;
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftAdjustment = shiftMask = upperShiftMask = 0;
		}
		if(original != null && !original.isMultiple()) {
			return new Iterator<S>() {
				boolean done;
				@Override
				public boolean hasNext() {
					return !done;
				}
			   @Override
				public S next() {
			    	if(!hasNext()) {
			    		throw new NoSuchElementException();
			    	}
			    	done = true;
			    	if(isBlockIterator) {
			    		return creator.createSegment(
			    				originalLower & shiftMask,
			    				originalUpper | upperShiftMask,
			    				segmentPrefixLength);
			    	}
			    	return original;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		if(isPrefixIterator) {
			if(isBlockIterator) {
				return new Iterator<S>() {
					private boolean notDone = true;
					private int current = originalLower, last = originalUpper; {
						current >>>= shiftAdjustment;
						last >>>= shiftAdjustment;
					}
					@Override
					public boolean hasNext() {
						return notDone;
					}
				    @Override
					public S next() {
				    	if(!notDone) {
				    		throw new NoSuchElementException();
				    	}
				    	int cur = current;
			    		int blockLow = cur << shiftAdjustment;
			    		S result = creator.createSegment(blockLow, blockLow | upperShiftMask, segmentPrefixLength);
		    			if(++cur > last) {
		    				notDone = false;
		    			} else {
		    				current = cur;
		    			}
				    	return result;
				    }
				    @Override
					public void remove() {
				    	throw new UnsupportedOperationException();
				    }
				};
			}
			return new Iterator<S>() {
				private boolean notDone = true, notFirst;
				private int current = originalLower, last = originalUpper; {
					current >>>= shiftAdjustment;
					last >>>= shiftAdjustment;
				}
				@Override
				public boolean hasNext() {
					return notDone;
				}
			    @Override
				public S next() {
			    	if(!notDone) {
			    		throw new NoSuchElementException();
			    	}
			    	int cur = current;
		    		int blockLow = cur << shiftAdjustment;
		    		int blockHigh = blockLow | upperShiftMask;
		    		current = ++cur;
		    		int low, high;
		    		if(notFirst) {
		    			low = blockLow;
		    		} else {
		    			low = originalLower;
		    			notFirst = true;
		    		}
		    		boolean notDne = cur <= last;
		    		if(notDne) {
		    			high = blockHigh;
		    		} else {
		    			high = originalUpper;
		    			notDone = false;
		    		}
		    		return creator.createSegment(low, high, segmentPrefixLength);
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<S>() {
			private boolean notDone = true;
			private int current = originalLower, last = originalUpper;
			@Override
			public boolean hasNext() {
				return notDone;
			}
		    @Override
			public S next() {
		    	if(!notDone) {
		    		throw new NoSuchElementException();
		    	}
		    	S result = creator.createSegment(current, segmentPrefixLength);
		    	notDone = ++current <= last;
		    	return result;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <S extends AddressSegment> S setPrefixedSegment(
			S original,
			Integer oldSegmentPrefixLength,
			Integer newSegmentPrefixLength,
			boolean zeroed,
			AddressSegmentCreator<S> creator) {
		if(Objects.equals(oldSegmentPrefixLength, newSegmentPrefixLength)) {
			return original;
		}
		int newLower, newUpper;
		if(zeroed) {
			int prefixMask;
			int bitCount = original.getBitCount();
			int allOnes = ~0;
			if(oldSegmentPrefixLength != null) {
				if(newSegmentPrefixLength == null) {
					prefixMask = allOnes << (bitCount - oldSegmentPrefixLength);
				} else if(oldSegmentPrefixLength > newSegmentPrefixLength) {
					prefixMask = allOnes << (bitCount - newSegmentPrefixLength);
					prefixMask |= ~(allOnes << (bitCount - oldSegmentPrefixLength));
				} else {
					prefixMask = allOnes << (bitCount - oldSegmentPrefixLength);
					prefixMask |= ~(allOnes << (bitCount - newSegmentPrefixLength));
				}
			} else {
				prefixMask = allOnes << (bitCount - newSegmentPrefixLength);
			}
			int value = original.getSegmentValue();
			int upperValue = original.getUpperSegmentValue();
			long maxValue = ~(~0L << original.getBitCount());
			Masker masker = maskRange(value, upperValue, prefixMask, maxValue);
			if(!masker.isSequential()) {
				throw new IncompatibleAddressException(original, "ipaddress.error.maskMismatch");
			}
			newLower = (int) masker.getMaskedLower(value, prefixMask);
			newUpper = (int) masker.getMaskedUpper(upperValue, prefixMask);
		} else {
			newLower = original.getSegmentValue();
			newUpper = original.getUpperSegmentValue();
		}
		return creator.createSegment(newLower, newUpper, newSegmentPrefixLength);
	}
	protected static <S extends AddressSegment> boolean isReversibleRangePerByte(S seg) {
		int byteCount = seg.getByteCount();
		int bitCount = seg.getBitCount();
		int val = seg.getSegmentValue();
		int upperVal = seg.getUpperSegmentValue();
		for(int i = 1; i <= byteCount; i++) {
			int bitShift = i << 3;
			int shift = bitCount - bitShift;
			int byteVal = 0xff & (val >> shift);
			int upperByteVal = 0xff & (upperVal >> shift);
			if(byteVal != upperByteVal) {
				if(byteVal > 1 || upperByteVal < 254) {
					return false;
				}
				if(++i <= byteCount) {
					boolean lowerIsZero = byteVal == 1;
					boolean upperIsMax = upperByteVal == 254;
					do {
						bitShift = i<<3;
						shift = bitCount - bitShift;
						byteVal = 0xff & (val >> shift);
						upperByteVal = 0xff & (upperVal >> shift);
						if(lowerIsZero) {
							if(byteVal != 0) {
								return false;
							}
						} else {
							if(byteVal > 1) {
								return false;
							}
							lowerIsZero = byteVal == 1;
						}
						if(upperIsMax) {
							if(upperByteVal != 255) {
								return false;
							}
						} else {
							if(upperByteVal < 254) {
								return false;
							}
							upperIsMax = upperByteVal == 254;
						}
						i++;
					} while(i <= byteCount);
				}
				return true;
			}
		}
		return true;
	}
	protected static <S extends AddressSegment> boolean isReversibleRange(S segment) {
		return segment.getSegmentValue() <= 1 && segment.getUpperSegmentValue() >= segment.getMaxSegmentValue() - 1;
	}
}
package inet.ipaddr.mac;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressDivisionWriter;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection.MACStringCache;
public class MACAddressSegment extends AddressDivision implements AddressSegment, Iterable<MACAddressSegment> {
	private static final long serialVersionUID = 4L;
	public static final int MAX_CHARS = 2;
	private final int value; 
	private final int upperValue; 
	public MACAddressSegment(int value) {
		if(value < 0 || value > MACAddress.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	public MACAddressSegment(int lower, int upper) {
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		if(lower < 0 || upper < 0 || upper > MACAddress.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		this.value = lower;
		this.upperValue = upper;
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		return new byte[] { (byte) (low ? getSegmentValue() : getUpperSegmentValue())};
	}
	protected boolean isPrefixBlock(int segmentPrefixLength) {
		if(segmentPrefixLength < MACAddress.BITS_PER_SEGMENT) {
			int mask = ~0 << (MACAddress.BITS_PER_SEGMENT - segmentPrefixLength);
			int lower = getSegmentValue();
			int newLower = lower & mask;
			if(lower != newLower) {
				return false;
			}
			int upper = getUpperSegmentValue();
			return upper == (upper | ~mask);
		}
		return true;
	}
	protected MACAddressSegment toPrefixBlockSegment(int segmentPrefixLength) {
		if(segmentPrefixLength < MACAddress.BITS_PER_SEGMENT && !isPrefixBlock(segmentPrefixLength)) {
			int lower = getSegmentValue();
			int upper = getUpperSegmentValue();
			int mask = ~0 << (MACAddress.BITS_PER_SEGMENT - segmentPrefixLength);
			lower &= mask;
			upper |= ~mask;
			return getSegmentCreator().createRangeSegment(lower, upper);
		}
		return this;
	}
	protected MACAddressSegment setPrefixedSegment(Integer oldPrefixLength, Integer segmentPrefixLength, boolean zeroed) {
		return setPrefixedSegment(this, oldPrefixLength, segmentPrefixLength, zeroed, getSegmentCreator());
	}
	private MACAddressCreator getSegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public MACAddressNetwork getNetwork() {
		return MACAddress.defaultMACNetwork();
	}
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		return getPrefixValueCount(this, segmentPrefixLength);
	}
	@Override
	public int getBitCount() {
		return MACAddress.BITS_PER_SEGMENT;
	}
	@Override
	public int getByteCount() {
		return MACAddress.BYTES_PER_SEGMENT;
	}
	@Override
	public long getMaxValue() {
		return MACAddress.MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	@Override
	public int getSegmentValue() {
		return value;
	}
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	private MACAddressSegment getLowestOrHighest(boolean lowest) {
		if(!isMultiple()) {
			return this;
		}
		return getSegmentCreator().createSegment(lowest ? getSegmentValue() : getUpperSegmentValue());
	}
	@Override
	public MACAddressSegment getLower() {
		return getLowestOrHighest(true);
	}
	@Override
	public MACAddressSegment getUpper() {
		return getLowestOrHighest(false);
	}
	@Override
	public MACAddressSegment reverseBits(boolean perByte) {
		return reverseBits();
	}
	public MACAddressSegment reverseBits() {
		if(isMultiple()) {
			if(isReversibleRange(this)) {
				return this;
			}
			throw new IncompatibleAddressException(this, "ipaddress.error.reverseRange");
		}
		int oldValue = value;
		int newValue = reverseBits((byte) oldValue);
		if(oldValue == newValue) {
			return this;
		}
		AddressSegmentCreator<MACAddressSegment> creator = getSegmentCreator();
		return creator.createSegment(newValue);
	}
	@Override
	public MACAddressSegment reverseBytes() {
		return this;
	}
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		return other instanceof MACAddressSegment && isSameValues((MACAddressSegment) other);
	}
	protected boolean isSameValues(MACAddressSegment otherSegment) {
		return value == otherSegment.value && upperValue == otherSegment.upperValue;
	}
	@Override
	public int hashCode() {
		return hash(value, upperValue, getBitCount());
	}
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	@Override
	public boolean equals(Object other) {
		return this == other || (other instanceof MACAddressSegment && ((MACAddressSegment) other).isSameValues(this));
	}
	public boolean contains(MACAddressSegment other) {
		return other.value >= value && other.upperValue <= upperValue;
	}
	@Override
	public int getDefaultTextualRadix() {
		return MACAddress.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public int getMaxDigitCount() {
		return MAX_CHARS;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	void setString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedWildcardString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setString(CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = MACAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
	@Override
	public Iterable<MACAddressSegment> getIterable() {
		return this;
	}
	@Override
	public Iterator<MACAddressSegment> iterator() {
		return iterator(this, getSegmentCreator(), null, false, false);
	}
	@Override
	public AddressComponentSpliterator<MACAddressSegment> spliterator() {
		MACAddressCreator creator = getSegmentCreator();
		int bitCount = getBitCount();
		return createSegmentSpliterator(
				this,
				getSegmentValue(),
				getUpperSegmentValue(),
				this::iterator,
				(isLowest, isHighest, value, upperValue) -> iterator(null, value, upperValue, bitCount, creator, null, false, false),
				(value, upperValue) -> creator.createSegment(value, upperValue, null));
	}
	@Override
	public Stream<MACAddressSegment> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	Iterator<MACAddressSegment> prefixBlockIterator(int segmentPrefixLength) {
		return iterator(this, getSegmentCreator(), segmentPrefixLength, true, true);
	}
	Iterator<MACAddressSegment> prefixIterator(int segmentPrefixLength) {
		return iterator(this, getSegmentCreator(), segmentPrefixLength, true, false);
	}
	@Override
	public int getMaxSegmentValue() {
		return MACAddress.MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public boolean prefixEquals(AddressSegment o, int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(segmentPrefixLength);
		}
		if(o instanceof MACAddressSegment) {
			MACAddressSegment other = (MACAddressSegment) o;
			int shift = getBitCount() - segmentPrefixLength;
			if(shift <= 0) {
				return isSameValues(other);
			}
			return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
					(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
		}
		return false;
	}
	@Override
	public boolean overlaps(AddressSegment other) {
		return this == other || (other.getSegmentValue() <= upperValue && other.getUpperSegmentValue() >= value && other instanceof MACAddressSegment);
	}
	@Override
	public boolean contains(AddressSegment other) {
		return other instanceof MACAddressSegment && other.getSegmentValue() >= value && other.getUpperSegmentValue() <= upperValue;
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? MACStringCache.hexPrefixedParams : MACStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(MACStringCache.canonicalParams);
	}
	public String toNormalizedString(StringOptions options) {
		AddressDivisionWriter params =  MACAddressSection.toParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	@Override
	public boolean containsPrefixBlock(int divisionPrefixLen) {
		return isPrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
	@Override
	public boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		return isSinglePrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
}
package inet.ipaddr.format.validate;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionLengthProvider;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionValueProvider;
import inet.ipaddr.ipv6.IPv6Address;
public class ParsedAddressGrouping {
	public static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return (networkPrefixLength - 1) >> 4;
			}
			return (networkPrefixLength - 1) / bitsPerSegment;
		}
		return (networkPrefixLength - 1) >> 3;
	}
	public static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return networkPrefixLength >> 4;
			}
			return networkPrefixLength / bitsPerSegment;
		}
		return networkPrefixLength >> 3;
	}
	public static int getTotalBits(int segmentCount, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment != 1) {
			if(bytesPerSegment == 2) {
				return segmentCount << 4;
			}
			return segmentCount * bitsPerSegment;
		}
		return segmentCount << 3;
	}
	public static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		if(prefixLength != null) {
			return getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
		}
		return null;
	}
	public static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		int decrement = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return getDivisionPrefixLength(bitsPerSegment, prefixLength - decrement);
	}
	public static Integer getDivisionPrefixLength(int divisionBits, int divisionPrefixedBits) {
		if(divisionPrefixedBits <= 0) {
			return cache(0); 
		} else if(divisionPrefixedBits <= divisionBits) {
			return cache(divisionPrefixedBits);
		}
		return null; 
	}
	public static Integer getNetworkPrefixLength(int bitsPerSegment, int segmentPrefixLength, int segmentIndex) {
		int increment = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return cache(increment + segmentPrefixLength);
	}
	public static boolean isPrefixSubnet(
			DivisionValueProvider lowerValueProvider,
			DivisionValueProvider lowerExtendedValueProvider,
			DivisionValueProvider upperValueProvider,
			DivisionValueProvider upperExtendedValueProvider,
			DivisionLengthProvider bitLengthProvider,
			int divisionCount,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		}
		int totalBitLength = 0;
		topLoop:
		for(int i = 0; i < divisionCount; i++) {
			int divBitLength = bitLengthProvider.getLength(i);
			Integer divisionPrefLength = ParsedAddressGrouping.getDivisionPrefixLength(divBitLength, networkPrefixLength - totalBitLength);
			if(divBitLength == 0) {
				continue;
			}
			if(divisionPrefLength == null) {
				totalBitLength += divBitLength;
				continue;
			}
			int divisionPrefixLength = divisionPrefLength;
			int extendedPrefixLength, extendedDivBitLength;
			boolean isExtended, hasExtendedPrefixLength;
			boolean hasPrefLen = divisionPrefixLength != divBitLength;
			if(hasPrefLen) {
				if(isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
					if(hasExtendedPrefixLength = (divisionPrefixLength < extendedDivBitLength)) {
						extendedPrefixLength = divisionPrefixLength;
						divisionPrefixLength = 0;
					} else {
						isExtended = false;
						extendedPrefixLength = extendedDivBitLength;
						divisionPrefixLength -= extendedDivBitLength;
					}
				} else {
					extendedPrefixLength = extendedDivBitLength = 0;
					hasExtendedPrefixLength = false;
				}
			} else {
				extendedPrefixLength = extendedDivBitLength = 0;
				hasExtendedPrefixLength = isExtended = false;
			}
			while(true) {
				if(isExtended) {
					long extendedLower = lowerExtendedValueProvider.getValue(i);
					if(extendedPrefixLength == 0) {
						if(extendedLower != 0) {
							return false;
						}
						long extendedUpper = upperExtendedValueProvider.getValue(i);
						if(fullRangeOnly) {
							long maxVal = ~0L >>> (Long.SIZE - extendedDivBitLength);
							if(extendedUpper != maxVal) {
								return false;
							}
						} else {
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes > 0) {
								if(upperOnes < Long.SIZE && (extendedUpper >>> upperOnes) != 0) {
									return false;
								}
								fullRangeOnly = true;
							} else if(extendedUpper != 0) {
								return false;
							}
						}
					} else if(hasExtendedPrefixLength) {
						int divHostBits = extendedDivBitLength - extendedPrefixLength; 
						if(fullRangeOnly) {
							long hostMask = ~(~0L << divHostBits);
							if((hostMask & extendedLower) != 0) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							if((hostMask & extendedUpper) != hostMask) {
								return false;
							}
						} else {
							int lowerZeros = Long.numberOfTrailingZeros(extendedLower);
							if(lowerZeros < divHostBits) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes < divHostBits) {
								int upperZeros = Long.numberOfTrailingZeros(extendedUpper >>> upperOnes);
								if(upperOnes + upperZeros < divHostBits) {
									return false;
								}
								fullRangeOnly = upperOnes > 0;
							} else {
								fullRangeOnly = true;
							}
						}
					}
				}
				if(divisionPrefixLength == 0) {
					long lower = lowerValueProvider.getValue(i);
					if(lower != 0) {
						return false;
					}
					long upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {	
						long maxVal = ~0L >>> (Long.SIZE - divBitLength);
						if(upper != maxVal) {
							return false;
						}
					} else {
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if(upperOnes < Long.SIZE && (upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(hasPrefLen){
					long lower = lowerValueProvider.getValue(i);
					int divHostBits = divBitLength - divisionPrefixLength; 
					if(fullRangeOnly) {
						long hostMask = ~(~0L << divHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Long.numberOfTrailingZeros(lower);
						if(lowerZeros < divHostBits) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes < divHostBits) {
							int upperZeros = Long.numberOfTrailingZeros(upper >>> upperOnes);
							if(upperOnes + upperZeros < divHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				if(++i == divisionCount) {
					break topLoop;
				}
				divBitLength = bitLengthProvider.getLength(i);
				if(hasExtendedPrefixLength = isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
				} else {
					extendedDivBitLength = 0;
				}
				extendedPrefixLength = divisionPrefixLength = 0;
			} 
		}
		return true;
	}
	public static boolean isPrefixSubnet(
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		} else {
			int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
			if(networkPrefixLength >= totalBitCount) {
				return false;
			}
		}
		if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int prefixedSegment = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int i = prefixedSegment;
		if(i < segmentCount) {
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			do {
				int lower = lowerValueProvider.getValue(i);
				if(segmentPrefixLength == 0) {
					if(lower != 0) {
						return false;
					}
					int upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {
						if(upper != segmentMaxValue) {
							return false;
						}
					} else {
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if((upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(segmentPrefixLength < bitsPerSegment) {
					int segHostBits = bitsPerSegment - segmentPrefixLength;
					if(fullRangeOnly) {
						int hostMask = ~(~0 << segHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Integer.numberOfTrailingZeros(lower);
						if(lowerZeros < segHostBits) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes < segHostBits) {
							int upperZeros = Integer.numberOfTrailingZeros((upper | (~0 << bitsPerSegment)) >>> upperOnes);
							if(upperOnes + upperZeros < segHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				segmentPrefixLength = 0;
			} while(++i < segmentCount);
		}
		return true;
	}
	private static final Integer cache[] = new Integer[Short.MAX_VALUE]; static {
		for(int i = 0; i <= IPv6Address.BIT_COUNT; i++) {
			cache[i] = i;
		}
	}
	public static Integer cache(int i) {
		if(i >= 0 && i < cache.length) {
			Integer result = cache[i];
			if(result == null) {
				result = cache[i] = i;
			}
			return result;
		}
		return i;
	}
}
package inet.ipaddr.mac;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.standard.AddressBitsDivision;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
public class MACAddressSection extends AddressDivisionGrouping implements AddressSection, Iterable<MACAddressSection> {
	private static final long serialVersionUID = 4L;
	private static final long MAX_VALUES_LONG[] = new long[] {
			0,
			MACAddress.MAX_VALUE_PER_SEGMENT,
			0xffff,
			0xffffff,
			0xffffffffL,
			0xffffffffffL,
			0xffffffffffffL,
			0xffffffffffffffL};
	private static final BigInteger MAX_VALUES[] = new BigInteger[] {
			BigInteger.ZERO,
			BigInteger.valueOf(MAX_VALUES_LONG[1]),
			BigInteger.valueOf(MAX_VALUES_LONG[2]),
			BigInteger.valueOf(MAX_VALUES_LONG[3]),
			BigInteger.valueOf(MAX_VALUES_LONG[4]),
			BigInteger.valueOf(MAX_VALUES_LONG[5]),
			BigInteger.valueOf(MAX_VALUES_LONG[6]),
			BigInteger.valueOf(MAX_VALUES_LONG[7]),
			BigInteger.valueOf(1).shiftLeft(64).subtract(BigInteger.ONE),
	};
	protected static class MACStringCache extends StringCache {
		static final StringOptions hexParams;
		static final StringOptions hexPrefixedParams;
		static final StringOptions canonicalParams;
		static final StringOptions compressedParams;
		static final StringOptions normalizedParams;
		static final StringOptions dottedParams;
		static final StringOptions spaceDelimitedParams;
		static {
			hexParams = new MACStringOptions.Builder().setSeparator(null).setExpandedSegments(true).setRadix(16).toOptions();
			hexPrefixedParams = new MACStringOptions.Builder().setSeparator(null).setExpandedSegments(true).setRadix(16).setAddressLabel(MACAddress.HEX_PREFIX).toOptions();
			normalizedParams = new MACStringOptions.Builder().setSeparator(MACAddress.COLON_SEGMENT_SEPARATOR).setExpandedSegments(true).setRadix(MACAddress.DEFAULT_TEXTUAL_RADIX).toOptions();
			canonicalParams = new MACStringOptions.Builder().setSeparator(MACAddress.DASH_SEGMENT_SEPARATOR).setExpandedSegments(true).setRadix(MACAddress.DEFAULT_TEXTUAL_RADIX).setWildcards(new Wildcards(MACAddress.DASHED_SEGMENT_RANGE_SEPARATOR_STR, Address.SEGMENT_WILDCARD_STR, null)).toOptions();
			compressedParams = new MACStringOptions.Builder().setSeparator(MACAddress.COLON_SEGMENT_SEPARATOR).setRadix(MACAddress.DEFAULT_TEXTUAL_RADIX).toOptions();
			dottedParams = new MACStringOptions.Builder().setSeparator(MACAddress.DOTTED_SEGMENT_SEPARATOR).setExpandedSegments(true).setRadix(MACAddress.DEFAULT_TEXTUAL_RADIX).toOptions();
			spaceDelimitedParams = new MACStringOptions.Builder().setSeparator(MACAddress.SPACE_SEGMENT_SEPARATOR).setExpandedSegments(true).setRadix(MACAddress.DEFAULT_TEXTUAL_RADIX).toOptions();
		}
		public String compressedString;
		public String normalizedString;
		public String dottedString;
		public String spaceDelimitedString;
	}
	static class MACAddressCache extends SectionCache<MACAddress> {}
	private static MACAddressCreator creators[][] = new MACAddressCreator[2][MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT];
	private transient MACStringCache stringCache;
	private transient SectionCache<MACAddressSection> sectionCache;
	public final int addressSegmentIndex;
	public final boolean extended;	
	public MACAddressSection(MACAddressSegment segment) {
		super(new MACAddressSegment[] {segment});
		this.addressSegmentIndex = 0;
		this.extended = false;
	}
	public MACAddressSection(MACAddressSegment segment, int startIndex, boolean extended) {
		this(false, new MACAddressSegment[] {segment}, startIndex, extended);
	}
	public MACAddressSection(MACAddressSegment segments[]) {
		this(segments, 0, segments.length > MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT);
	}
	public MACAddressSection(MACAddressSegment segments[], int startIndex, boolean extended) {
		this(true, segments, startIndex, extended);
	}
	protected MACAddressSection(boolean cloneSegments, MACAddressSegment segments[], int startIndex, boolean extended) {
		super(cloneSegments ? segments.clone() : segments);
		addressSegmentIndex = startIndex;
		this.extended = extended;
		if(startIndex < 0 || startIndex > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressPositionException(startIndex);
		} else if(startIndex + segments.length > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(segments.length);
		}
	}
	public MACAddressSection(SegmentValueProvider valueProvider) {
		this(valueProvider, valueProvider, 0, false);
	}
	public MACAddressSection(SegmentValueProvider valueProvider, int startIndex, boolean extended) {
		this(valueProvider, valueProvider, startIndex, extended);
	}
	public MACAddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int startIndex, boolean extended) {
		super(new MACAddressSegment[Math.max(0, (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT) - startIndex)], false);
		createSegments(
				getSegmentsInternal(),
				lowerValueProvider,
				upperValueProvider,
				getBytesPerSegment(),
				getBitsPerSegment(),
				getNetwork(),
				null);
		if(startIndex < 0 || startIndex > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressPositionException(startIndex);
		}
		this.addressSegmentIndex = startIndex;
		this.extended = extended;
	}
	protected MACAddressSection(byte bytes[], int segmentCount, int startIndex, boolean extended, boolean cloneBytes) {
		this(bytes, 0, bytes.length, segmentCount, startIndex, extended, cloneBytes);
	}
	protected MACAddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, int startIndex, boolean extended, boolean cloneBytes) {
		super(new MACAddressSegment[segmentCount >= 0 ? segmentCount : Math.max(0, byteEndIndex - byteStartIndex)], false);
		MACAddressSegment segs[] = getSegmentsInternal();
		toSegments(
				segs,
				bytes,
				byteStartIndex,
				byteEndIndex,
				getBytesPerSegment(),
				getBitsPerSegment(),
				getNetwork(),
				null);
		if(startIndex < 0 || startIndex > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressPositionException(startIndex);
		}
		this.addressSegmentIndex = startIndex;
		this.extended = extended;
		if(bytes.length == segs.length) {
			setBytes(cloneBytes ? bytes.clone() : bytes);
		}
	}
	public MACAddressSection(byte bytes[], int startIndex, boolean extended) {
		this(bytes, 0, bytes.length, -1, startIndex, extended, true);
	}
	public MACAddressSection(byte bytes[]) {
		this(bytes, 0, bytes.length >  MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT);
	}
	public MACAddressSection(long value, int startIndex, boolean extended) {
		super(new MACAddressSegment[extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.MEDIA_ACCESS_CONTROL_SEGMENT_COUNT], false);
		if(startIndex < 0 || startIndex > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressPositionException(startIndex);
		} else if(!extended && (value > 0xffffffffffffL || value < 0L)) {
			throw new AddressValueException(value);
		}
		createSegments(
				getSegmentsInternal(),
				0,
				value,
				getBitsPerSegment(),
				getNetwork(),
				null);
		this.addressSegmentIndex = startIndex;
		this.extended = extended;
	}
	public MACAddressSection(long value) {
		this(value, 0, false);
	}
	@Override
	public MACAddressNetwork getNetwork() {
		return MACAddress.defaultMACNetwork();
	}
	public IPv6AddressNetwork getIPv6Network() {
		return MACAddress.defaultIpv6Network();
	}
	protected MACAddressCreator getAddressCreator(int startIndex, boolean extended) {
		MACAddressCreator creator = null, defaultCreator = getNetwork().getAddressCreator();
		boolean useCached = startIndex < MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT;
		int ext = 0;
		if(useCached) {
			if(extended) {
				ext = 1;
			}
			creator = creators[ext][startIndex];
		}
		if(creator != null) {
			useCached |= creator.getNetwork().equals(getNetwork());
			if(useCached) {
				return creator;
			}
		}
		creator = new MACAddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected MACAddressSection createSectionInternal(MACAddressSegment segments[]) {
				return getNetwork().getAddressCreator().createSectionInternal(segments, startIndex, extended);
			}
		};
		if(useCached) {
			creators[ext][startIndex] = creator;
		}
		return creator;
	}
	MACAddressCreator getAddressCreator() {
		return getAddressCreator(addressSegmentIndex, extended);
	}
	private AddressSegmentCreator<MACAddressSegment> getSegmentCreator() {
		return getAddressCreator(0, false);
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof MACAddressSection && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof MACAddressSection) {
			MACAddressSection other = (MACAddressSection) o;
			return addressSegmentIndex == other.addressSegmentIndex && isExtended() == other.isExtended() && other.isSameGrouping(this);
		}
		return false;
	}
	protected MACStringCache getStringCache() {
		return (MACStringCache) stringCache;
	}
	@Override
	public MACAddressSegment[] getSegments() {
		return (MACAddressSegment[]) getDivisionsInternal().clone();
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSegments(0, getDivisionCount(), segs, 0);
	}
	protected MACAddressSegment[] getSegmentsInternal() {
		return (MACAddressSegment[]) super.getDivisionsInternal();
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int destIndex) {
		System.arraycopy(getSegmentsInternal(), start, segs, destIndex, end - start);
	}
	public boolean isExtended() {
		return extended;
	}
	@Override
	public int getSegmentCount() {
		return getDivisionCount();
	}
	public boolean isEntireAddress(boolean extended) {
		return getSegmentCount() == (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.MEDIA_ACCESS_CONTROL_SEGMENT_COUNT);
	}
	@Override
	public MACAddressSegment getDivision(int index) {
		return (MACAddressSegment) super.getDivision(index);
	}
	@Override
	public MACAddressSegment getSegment(int index) {
		return (MACAddressSegment) super.getDivision(index);
	}
	public void getSegments(Collection<? super MACAddressSegment> segs) {
		getSegments(0, getSegmentCount(), segs);
	}
	public void getSegments(int start, int end, Collection<? super MACAddressSegment> segs) {
		for(int i = start; i < end; i++) {
			segs.add(getSegment(i));
		}
	}
	@Override
	public int getMaxSegmentValue() {
		return MACAddress.MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public int getBitsPerSegment() {
		return MACAddress.BITS_PER_SEGMENT;
	}
	@Override
	public int getBytesPerSegment() {
		return MACAddress.BYTES_PER_SEGMENT;
	}
	@Override
	public int getByteCount() {
		return getSegmentCount(); 
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() << 3;
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int segmentCount = getSegmentCount();
		byte bytes[] = new byte[segmentCount];
		for(int i = 0; i < segmentCount; i++) {
			MACAddressSegment seg = getSegment(i);
			int val = low ? seg.getSegmentValue() : seg.getUpperSegmentValue();
			bytes[i] = (byte) val;
		}
		return bytes;
	}
	@Override
	protected BigInteger getCountImpl() {
		return getCountImpl(getSegmentCount());
	}
	private BigInteger getCountImpl(int segCount) {
		if(!isMultiple()) {
			return BigInteger.ONE;
		}
		long result = getSegment(0).getValueCount();
		int limit = Math.min(segCount, 7);
		for(int i = 1; i < limit; i++) {
			result *= getSegment(i).getValueCount();
		}
		if(segCount == 8) {
			long lastValue = getSegment(7).getValueCount();
			if(lastValue != 1) {
				if(result <= 0x7fffffffffffffL) {
					result *= lastValue;
				} else {
					return BigInteger.valueOf(result).multiply(BigInteger.valueOf(lastValue));
				}
			}
		}
		return BigInteger.valueOf(result);
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		int segCount = getSegmentCount();
		if(segmentCount > segCount) {
			segmentCount = segCount;
		}
		return getCountImpl(segmentCount);
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		checkSubnet(this, prefixLength);
		if(isMultiple()) {
			long result = 1;
			int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			int hostSegmentIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			int i = 0;
			for(; i < hostSegmentIndex; i++) {
				result *= getSegment(i).getValueCount();
			}
			if(i == networkSegmentIndex) {
				long lastValue = getSegment(i).getPrefixValueCount(getSegmentPrefixLength(getBitsPerSegment(), prefixLength, i));
				if(lastValue != 1) {
					if(result <= 0x7fffffffffffffL) {
						result *= lastValue;
					} else {
						return BigInteger.valueOf(result).multiply(BigInteger.valueOf(lastValue));
					}
				}
			}
			return BigInteger.valueOf(result);
		}
		return BigInteger.ONE;
	}
	@Override
	protected BigInteger getPrefixCountImpl() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getCount();
		}
		return getPrefixCount(prefixLength);
	}
	@Override
	public boolean isPrefixed() {
		return getPrefixLength() != null;
	}
	public int getOUISegmentCount() {
		return Math.max(0, MACAddress.ORGANIZATIONAL_UNIQUE_IDENTIFIER_SEGMENT_COUNT - addressSegmentIndex);
	}
	public int getODISegmentCount() {
		return getSegmentCount() - getOUISegmentCount();
	}
	@Override
	public Integer getPrefixLength() {
		Integer ret = cachedPrefixLength;
		if(ret == null) {
			int prefix = getMinPrefixLengthForBlock();
			if(prefix == getBitCount()) {
				cachedPrefixLength = NO_PREFIX_LENGTH;
				return null;
			}
			return cachedPrefixLength = cacheBits(prefix);
		}
		if(ret.intValue() == NO_PREFIX_LENGTH.intValue()) {
			return null;
		}
		return ret;
	}
	protected void assignPrefixLength(Integer prefixLength) {
		if(prefixLength == null) {
			cachedPrefixLength = NO_PREFIX_LENGTH;
			return;
		}
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int max = getBitCount();
		if(prefixLength > max) {
			int maxPrefixLength = extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_BIT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_BIT_COUNT;
			if(prefixLength > maxPrefixLength) {
				throw new PrefixLenException(prefixLength);
			}
			prefixLength = max;
		}
		cachedPrefixLength = prefixLength;
	}
	@Override
	public MACAddressSection getSection() {
		return this;
	}
	@Override
	public MACAddressSection getSection(int index) {
		return getSection(index, getSegmentCount());
	}
	@Override
	public MACAddressSection getSection(int index, int endIndex) {
		MACAddressSection result = getSection(index, endIndex, this, getAddressCreator(addressSegmentIndex + index, extended));
		Integer prefix = getPrefixLength();
		if(prefix != null) {
			if(index > 0) {
				prefix = Math.max(0,  prefix - (index << 3));
			}
			if(prefix > ((endIndex - index) << 3)) {
				prefix = null;
			}
		}
		result.assignPrefixLength(prefix);
		return result;
	}
	public MACAddressSection getOUISection() {
		int segmentCount = getOUISegmentCount();
		MACAddressSection result = getSection(0, segmentCount, this, getAddressCreator());
		Integer prefix = getPrefixLength();
		if(prefix != null) {
			if(prefix > (segmentCount << 3)) {
				prefix = null;
			}
		}
		result.assignPrefixLength(prefix);
		return result;
	}
	public MACAddressSection getODISection() {
		int segmentCount = getOUISegmentCount();
		MACAddressSection result = getSection(segmentCount, getSegmentCount(), this, getAddressCreator(addressSegmentIndex + segmentCount, extended));
		Integer prefix = getPrefixLength();
		if(prefix != null && segmentCount > 0) {
			prefix = Math.max(0,  prefix - (segmentCount << 3));
		}
		result.assignPrefixLength(prefix);
		return result;
	}
	public MACAddressSection toOUIPrefixBlock() {
		int ouiSegmentCount = getOUISegmentCount();
		int segmentCount = getSegmentCount();
		Integer currentPref = getPrefixLength();
		int newPref = ouiSegmentCount << 3;
		boolean createNew;
		if(!(createNew = (currentPref == null || currentPref > newPref))) {
			newPref = currentPref;
			for(int i = ouiSegmentCount; i < segmentCount; i++) {
				MACAddressSegment segment = getSegment(i);
				if(!segment.isFullRange()) {
					createNew = true;
					break;
				}
			}
		}
		if(createNew) {
			MACAddressCreator creator = getAddressCreator();
			MACAddressSegment allRangeSegment = creator.createRangeSegment(0, MACAddress.MAX_VALUE_PER_SEGMENT);
			MACAddressSegment newSegments[] = setPrefixedSegments(
					getNetwork(),
					newPref,
					getSegments(), 
					getBitsPerSegment(),
					getBytesPerSegment(),
					creator, 
					(seg, prefixLength) -> (prefixLength == 0) ? allRangeSegment : seg);			
			MACAddressSection result = creator.createSectionInternal(newSegments);
			result.assignPrefixLength(newPref);
			return result;
		}
		return this;
	}
	public IPv6AddressSection toEUI64IPv6() {
		return getIPv6Network().getAddressCreator().createSection(this);
	}
	public boolean isEUI64(boolean asMAC) {
		return isEUI64(asMAC, false);
	}
	public boolean isEUI64(boolean asMAC, boolean partial) {
		if(isExtended()) {
			int segmentCount = getSegmentCount();
			int endIndex = addressSegmentIndex + segmentCount;
			if(addressSegmentIndex <= 3) {
				if(endIndex > 4) {
					int index3 = 3 - addressSegmentIndex;
					MACAddressSegment seg3 = getSegment(index3);
					MACAddressSegment seg4 = getSegment(index3 + 1);
					return seg4.matches(asMAC ? 0xff : 0xfe) && seg3.matches(0xff);
				} else if(partial && endIndex == 4) {
					MACAddressSegment seg3 = getSegment(3 - addressSegmentIndex);
					return seg3.matches(0xff);
				}
			} else if(partial && addressSegmentIndex == 4 && endIndex > 4) {
				MACAddressSegment seg4 = getSegment(4 - addressSegmentIndex);
				return seg4.matches(asMAC ? 0xff : 0xfe);
			}
			return partial;
		}
		return false;
	}
	public MACAddressSection toEUI64(boolean asMAC) {
		int originalSegmentCount = getSegmentCount();
		if(!isExtended()) {
			MACAddressCreator creator = getAddressCreator(addressSegmentIndex, true);
			if(addressSegmentIndex + originalSegmentCount < 3 || addressSegmentIndex > 3) {
				return this;
			}
			MACAddressSegment segs[] = creator.createSegmentArray(originalSegmentCount + 2);
			int frontCount;
			if(addressSegmentIndex < 3) {
				frontCount = 3 - addressSegmentIndex;
				getSegments(0, frontCount, segs, 0);
			} else {
				frontCount = 0;
			}
			MACAddressSegment ffSegment = creator.createSegment(0xff);
			segs[frontCount] = ffSegment;
			segs[frontCount + 1] = asMAC ? ffSegment : creator.createSegment(0xfe);
			Integer prefLength = getPrefixLength();
			if(originalSegmentCount > frontCount) {
				getSegments(frontCount, originalSegmentCount, segs, frontCount + 2);
				if(prefLength != null && prefLength > frontCount << 3) {
					prefLength += getBitsPerSegment() << 1; 
				}
			}
			MACAddressSection result = creator.createSectionInternal(segs, addressSegmentIndex, true);
			result.assignPrefixLength(prefLength);
			return result;
		}
		int endIndex = addressSegmentIndex + originalSegmentCount;
		if(addressSegmentIndex <= 3) {
			if(endIndex > 4) {
				int index3 = 3 - addressSegmentIndex;
				MACAddressSegment seg3 = getSegment(index3);
				MACAddressSegment seg4 = getSegment(index3 + 1);
				if(!seg4.matches(asMAC ? 0xff : 0xfe) || !seg3.matches(0xff)) {
					throw new IncompatibleAddressException(this, "ipaddress.mac.error.not.eui.convertible");
				}
			} else if(endIndex == 4) {
				MACAddressSegment seg3 = getSegment(3 - addressSegmentIndex);
				if(!seg3.matches(0xff)) {
					throw new IncompatibleAddressException(this, "ipaddress.mac.error.not.eui.convertible");
				}
			}
		} else if(addressSegmentIndex == 4) {
			if(endIndex > 4) {
				MACAddressSegment seg4 = getSegment(4 - addressSegmentIndex);
				if(!seg4.matches(asMAC ? 0xff : 0xfe)) {
					throw new IncompatibleAddressException(this, "ipaddress.mac.error.not.eui.convertible");
				}
			}
		}
		return this;
	}
	public MACAddressSection append(MACAddressSection other) {
		int count = getSegmentCount();
		return replace(count, count, other, 0, other.getSegmentCount());
	}
	public MACAddressSection appendToPrefix(MACAddressSection other) {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null) {
			return append(other);
		}
		MACAddressSection thizz = this;
		int bitsPerSegment = getBitsPerSegment();
		int adjustment = prefixLength % bitsPerSegment;
		if(adjustment != 0) {
			prefixLength += bitsPerSegment - adjustment;
			thizz = setPrefixLength(prefixLength, false, false);
		}
		int index = prefixLength >>> 3;
		if(other.isPrefixed() && other.getPrefixLength() == 0) {
			return insert(index, other); 
		}
		return thizz.replace(index, index, other, 0, other.getSegmentCount(), true);
	}
	public MACAddressSection insert(int index, MACAddressSection other) {
		return replace(index, index, other, 0, other.getSegmentCount());
	}
	public MACAddressSection replace(int index, MACAddressSection replacement) {
		return replace(index, index + replacement.getSegmentCount(), replacement, 0, replacement.getSegmentCount());
	}
	public MACAddressSection replace(int startIndex, int endIndex, MACAddressSection replacement, int replacementStartIndex, int replacementEndIndex) {
		return replace(startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, false);
	}
	private MACAddressSection replace(int startIndex, int endIndex, MACAddressSection replacement, int replacementStartIndex, int replacementEndIndex, boolean appendNetwork) {
		int segmentCount = getSegmentCount();
		int replacedCount = endIndex - startIndex;
		int replacementCount = replacementEndIndex - replacementStartIndex;
		if(replacedCount < 0 || replacementCount < 0 || startIndex < 0 || replacementStartIndex < 0 || replacementEndIndex > replacement.getSegmentCount() || endIndex > segmentCount) {
			throw new IndexOutOfBoundsException();
		}
		int diff = replacementCount - replacedCount;
		int totalSegmentCount = segmentCount + diff;
		if(addressSegmentIndex + totalSegmentCount > MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			throw new AddressValueException(this, replacement, addressSegmentIndex + totalSegmentCount);
		}
		else if(replacementCount == 0) {
			if(isPrefixed()) {
				if(replacement.isPrefixed() && replacement.getPrefixLength() <= replacementEndIndex << 3) {
					if(getPrefixLength() <= startIndex << 3) {
						return this;
					}
				} else {
					return this;
				}
			} else if(!replacement.isPrefixed()) {
				return this;
			}
		}
		if(segmentCount == replacedCount && addressSegmentIndex == replacement.addressSegmentIndex && extended == replacement.extended) {
			if(!isPrefixed() || (replacement.isPrefixed() && replacement.getPrefixLength() == 0)) {
				return replacement;
			}
		}
		MACAddressSection result = replace(this, startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, getAddressCreator(), appendNetwork, true);
		if(isPrefixed()) {
			Integer prefLength = getPrefixLength();
			int startBits = startIndex << 3;
			if(!appendNetwork && prefLength <= startBits) {
				result.assignPrefixLength(prefLength);
			} else if(replacement.isPrefixed() && replacement.getPrefixLength() <= replacementEndIndex << 3) {
				result.assignPrefixLength(Math.max(0, (replacement.getPrefixLength() - (replacementStartIndex << 3))) + startBits);
			} else if(prefLength <= endIndex << 3) {
				result.assignPrefixLength(startBits + (replacementCount << 3));
			} else {
				result.assignPrefixLength(prefLength + (diff << 3));
			}
		} else if(replacement.isPrefixed() && replacement.getPrefixLength() <= replacementEndIndex << 3) {
			result.assignPrefixLength(Math.max(0, (replacement.getPrefixLength() - (replacementStartIndex << 3))) + (startIndex << 3));
		} else {
			result.assignPrefixLength(null);
		}
		return result;
	}
	private MACAddressSection getLowestOrHighestSection(boolean lowest) {
		MACAddressSection result = getSingleLowestOrHighestSection(this);
		if(result == null) {
			if(sectionCache == null || (result = lowest ? sectionCache.lower : sectionCache.upper) == null) {
				synchronized(this) {
					boolean create = (sectionCache == null);
					if(create) {
						sectionCache = new SectionCache<MACAddressSection>();
					} else {
						if(lowest) {
							create = (result = sectionCache.lower) == null;
						} else {
							create = (result = sectionCache.upper) == null;
						}
					}
					if(create) {
						MACAddressCreator creator = getAddressCreator();
						MACAddressSegment segs[] = createSingle(this, creator, i -> lowest ? getSegment(i).getLower() : getSegment(i).getUpper());
						Integer prefLength;
						result = (getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() || (prefLength = getPrefixLength()) == null) ? 
							creator.createSectionInternal(segs) :
							creator.createPrefixedSectionInternal(segs, prefLength, true);
						if(lowest) {
							sectionCache.lower = result;
						} else {
							sectionCache.upper = result;
						}
					}
				}
			}
		}
		return result;
	}
	MACAddress getLowestOrHighest(MACAddress addr, boolean lowest) {
		MACAddressSection sectionResult = getLowestOrHighestSection(lowest);
		if(sectionResult == this) {
			return addr;
		}
		MACAddress result = null;
		MACAddressCache cache = addr.sectionCache;
		if(cache == null || (result = lowest ? cache.lower : cache.upper) == null) {
			synchronized(this) {
				cache = addr.sectionCache;
				boolean create = (cache == null);
				if(create) {
					cache = addr.sectionCache = new MACAddressCache();
				} else {
					if(lowest) {
						create = (result = cache.lower) == null;
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getAddressCreator().createAddress(sectionResult);
					if(lowest) {
						cache.lower = result;
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	@Override
	public MACAddressSection getLower() {
		return getLowestOrHighestSection(true);
	}
	@Override
	public MACAddressSection getUpper() {
		return getLowestOrHighestSection(false);
	}
	public long longValue() {
		return getLongValue(true);
	}
	public long upperLongValue() {
		return getLongValue(false);
	}
	private long getLongValue(boolean lower) {
		int segCount = getSegmentCount();
		long result = 0;
		int bitsPerSeg = getBitsPerSegment();
		for(int i = 0; i < segCount; i++) {
			MACAddressSegment seg = getSegment(i);
			result = (result << bitsPerSeg) | (lower ? seg.getSegmentValue() : seg.getUpperSegmentValue());
		}
		return result;
	}
	@Override
	public MACAddressSection reverseBits(boolean perByte) {
		MACAddressSection result =  reverseBits(perByte, this, getAddressCreator(), i -> getSegment(i).reverseBits(perByte), false);
		result.assignPrefixLength(null);
		return result;
	}
	@Override
	public MACAddressSection reverseBytes() {
		return reverseSegments();
	}
	@Override
	public MACAddressSection reverseBytesPerSegment() {
		return this;
	}
	@Override
	public MACAddressSection reverseSegments() {
		if(getSegmentCount() <= 1) {
			return this;
		}
		MACAddressSection result = reverseSegments(this, getAddressCreator(), this::getSegment, false);
		result.assignPrefixLength(null);
		return result;
	}
	@Override @Deprecated
	public MACAddressSection removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public MACAddressSection withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override  @Deprecated
	public MACAddressSection removePrefixLength(boolean zeroed) {
		if(getPrefixLength() == null) {
			return this;
		}
		return removePrefix(zeroed);
	}
	private MACAddressSection removePrefix(boolean zeroed) {
		MACAddressSegment oldSegs[] = getSegmentsInternal();
		MACAddressSegment newSegs[] = removePrefix(
				this,
				oldSegs,
				getBitsPerSegment(),
				(seg, oldPrefLength, newPrefLength) -> seg.setPrefixedSegment(oldPrefLength, newPrefLength, zeroed)); 
		MACAddressSection result = getAddressCreator().createSectionInternal(newSegs);
		result.assignPrefixLength(null);
		return result;
	}
	@Override
	public MACAddressSection adjustPrefixBySegment(boolean nextSegment) {
		return adjustPrefixBySegment(nextSegment, true);
	}
	@Override
	public MACAddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		Integer existing = getPrefixLength();
		if(existing == null && nextSegment) {
			return this;
		}
		int prefix = getAdjustedPrefix(nextSegment, getBitsPerSegment(), true);
		return setPrefixLength(prefix, zeroed);
	}
	@Override
	public MACAddressSection adjustPrefixLength(int adjustment) {
		return adjustPrefixLength(adjustment, true);
	}
	@Override
	public MACAddressSection adjustPrefixLength(int adjustment, boolean zeroed) {
		if(adjustment == 0) {
			return this;
		}
		int prefix = getAdjustedPrefix(adjustment, true, false);
		if(prefix > getBitCount()) {
			return removePrefix(zeroed);
		}
		return setPrefixLength(prefix, zeroed);
	}
	@Deprecated
	@Override
	public MACAddressSection applyPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true, true);
	}
	@Override
	public MACAddressSection setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true, false);
	}
	@Override
	public MACAddressSection setPrefixLength(int prefixLength, boolean zeroed) {
		return setPrefixLength(prefixLength, zeroed, false);
	}
	private MACAddressSection setPrefixLength(int prefixLength, boolean zeroed, boolean noShrink) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int max = getBitCount();
		if(prefixLength > max) {
			if(prefixLength > (extended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_BIT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_BIT_COUNT)) {
				throw new PrefixLenException(prefixLength);
			}
			prefixLength = max;
		}
		Integer oldPrefix = getPrefixLength();
		boolean prefixShrinking = oldPrefix == null || oldPrefix > prefixLength;
		boolean prefixGrowing;
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(prefixShrinking) {
			prefixGrowing = false;
		} else {
			prefixGrowing = !noShrink && oldPrefix < prefixLength;
			if(!prefixGrowing && !isAllSubnets) {
				return this;
			}
		}
		MACAddressCreator creator = getAddressCreator();
		MACAddressSegment oldSegs[] = getSegmentsInternal();
		MACAddressSegment newSegs[];
		int segmentBitCount = getBitsPerSegment();
		int segmentByteCount = getBytesPerSegment();
		if(isAllSubnets) {
			if(prefixShrinking) {
				newSegs = setPrefixedSegments(getNetwork(), prefixLength, oldSegs.clone(), 
						segmentBitCount, segmentByteCount, creator, MACAddressSegment::toPrefixBlockSegment);
				MACAddressSection result = creator.createSectionInternal(newSegs);
				result.assignPrefixLength(prefixLength);
				return result;
			} else if(!prefixGrowing) {
				return toPrefixBlock();
			}
		}
		newSegs = oldSegs.clone();
		for(int i = 0; i < newSegs.length; i++) {
			Integer newPref = getPrefixedSegmentPrefixLength(getBitsPerSegment(), prefixLength, i);
			Integer oldPref = oldPrefix == null ? null : getPrefixedSegmentPrefixLength(getBitsPerSegment(), oldPrefix, i);
			newSegs[i] = newSegs[i].setPrefixedSegment(oldPref, newPref, zeroed);
			if(isAllSubnets && newPref != null) {
				if(++i < newSegs.length) {
					MACAddressSegment zeroSeg = creator.createRangeSegment(0, MACAddress.MAX_VALUE_PER_SEGMENT);
					Arrays.fill(newSegs, i, newSegs.length, zeroSeg);
					break;
				}
			}
		}
		MACAddressSection result = creator.createSectionInternal(newSegs);
		result.assignPrefixLength(prefixLength);
		return result;
	}
	@Override
	public MACAddressSection toPrefixBlock() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength != null) {
			int segmentBitCount = getBitsPerSegment();
			int segmentByteCount = getBytesPerSegment();
			MACAddressSegment oldSegs[] = getSegmentsInternal();
			for(int i = getHostSegmentIndex(prefixLength, segmentByteCount, segmentBitCount); i < oldSegs.length; i++) {
				Integer pref = getPrefixedSegmentPrefixLength(segmentBitCount, prefixLength, i);
				MACAddressSegment seg = oldSegs[i];
				if(pref != null && !seg.isPrefixBlock(pref)) {
					MACAddressCreator creator = getAddressCreator();
					MACAddressSegment newSegs[] = setPrefixedSegments(getNetwork(), prefixLength, oldSegs.clone(),
							segmentBitCount, segmentByteCount, creator, MACAddressSegment::toPrefixBlockSegment);
					MACAddressSection result = creator.createSectionInternal(newSegs);
					result.assignPrefixLength(prefixLength);
					return result;
				}
			}
		}
		return this;
	}
	@Override
	public Iterable<MACAddressSection> getIterable() {
		return this;
	}
	@Override
	public Iterator<MACAddressSection> iterator() {
		MACAddressCreator creator = getAddressCreator();
		boolean isSingle = !isMultiple();
		return iterator(
				isSingle,
				this,
				creator,
				isSingle ? null : segmentsIterator(),
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength()); 
	}
	@Override
	public Iterator<MACAddressSection> prefixIterator() {
		return prefixIterator(false);
	}
	@Override
	public Iterator<MACAddressSection> prefixBlockIterator() {
		return prefixIterator(true);
	}
	private Iterator<MACAddressSection> prefixIterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator();
		}
		MACAddressCreator creator = getAddressCreator();
		boolean useOriginal = isBlockIterator ? isSinglePrefixBlock() : getPrefixCount().equals(BigInteger.ONE);
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? 
									index -> getSegment(index).prefixBlockIterator(getSegmentPrefixLength(getBitsPerSegment(), prefLength, index)) :
									index -> getSegment(index).prefixIterator(getSegmentPrefixLength(getBitsPerSegment(), prefLength, index))
						),
				prefLength);
	}
	@Override
	public Iterator<MACAddressSegment[]> segmentsIterator() {
		return segmentsIterator(getSegmentCount(), getSegmentCreator(), isMultiple() ? null : () -> getLower().getSegments(), index -> getSegment(index).iterator(), null);
	}
	@Override
	public AddressComponentRangeSpliterator<MACAddressSection, MACAddressSegment[]> segmentsSpliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getPrefixLength();
		MACAddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		MACAddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.segmentsIterator(),
				MACAddressSection::getCount,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<MACAddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	AddressComponentRangeSpliterator<MACAddress, MACAddressSegment[]> segmentsSpliterator(MACAddress address, MACAddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		MACAddress forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = address.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = address;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.segmentsIterator(),
				MACAddress::getCount,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	@Override
	public AddressComponentSpliterator<MACAddressSection> spliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		MACAddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		MACAddressCreator creator = getAddressCreator();
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.iterator(),
				MACAddressSection::getCount,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<MACAddressSection> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	protected AddressComponentSpliterator<MACAddress> spliterator(MACAddress original, MACAddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		MACAddress forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = original;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.iterator(),
				MACAddress::getCount,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	protected Iterator<MACAddress> iterator(MACAddress original, MACAddressCreator creator) {
		boolean isSingle = !isMultiple();
		return iterator(
				isSingle,
				original, 
				creator,
				isSingle ? null : segmentsIterator(),
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength());
	}
	Iterator<MACAddress> prefixIterator(MACAddress original, MACAddressCreator creator, boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator(original, creator);
		}
		boolean useOriginal = isSinglePrefixBlock();
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator,
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, 
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? 
									index -> getSegment(index).prefixBlockIterator(getSegmentPrefixLength(getBitsPerSegment(), prefLength, index)) :
									index -> getSegment(index).prefixIterator(getSegmentPrefixLength(getBitsPerSegment(), prefLength, index))
							),
				prefLength);
	}
	AddressComponentSpliterator<MACAddress> prefixSpliterator(
			MACAddress original,
			MACAddressCreator creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(original, creator);
		}
		int prefixLength = prefLength;
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				original,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, addr) -> addr.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, addr) -> addr.prefixIterator() : 
							((isLowest, isHighest, addr) -> (isLowest || isHighest) ? addr.prefixIterator() : addr.prefixBlockIterator())), 
				MACAddress::getPrefixCount,
				addr -> addr.getPrefixCount().compareTo(LONG_MAX) <= 0,
				addr -> longPrefixCount(addr.getSection(), prefixLength));
	}
	@Override
	public AddressComponentSpliterator<MACAddressSection> prefixSpliterator() {
		return prefixSpliterator(false);
	}
	@Override
	public Stream<MACAddressSection> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public AddressComponentSpliterator<MACAddressSection> prefixBlockSpliterator() {
		return prefixSpliterator(true);
	}
	@Override
	public Stream<MACAddressSection> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	AddressComponentSpliterator<MACAddressSection> prefixSpliterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator();
		}
		int prefixLength = prefLength;
		MACAddressCreator creator = getAddressCreator();
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				this,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, section) -> section.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, section) -> section.prefixIterator() : 
							((isLowest, isHighest, section) -> (isLowest || isHighest) ? section.prefixIterator() : section.prefixBlockIterator())), 
				MACAddressSection::getPrefixCount,
				section -> section.getPrefixCount().compareTo(LONG_MAX) <= 0,
				section -> longPrefixCount(section, prefixLength));
	}
	private static long getMaxValueLong(int segmentCount) {
		return MAX_VALUES_LONG[segmentCount];
	}
	private static BigInteger getMaxValue(int segmentCount) {
		return MAX_VALUES[segmentCount];
	}
	@Override
	public MACAddressSection incrementBoundary(long increment) {
		if(increment <= 0) {
			if(increment == 0) {
				return this;
			}
			return getLower().increment(increment);
		}
		return getUpper().increment(increment);
	}
	@Override
	public MACAddressSection increment(long increment) {
		if(increment == 0 && !isMultiple()) {
			return this;
		}
		if(!isExtended() || getSegmentCount() < 8) {
			checkOverflow(increment, this::longValue, this::upperLongValue, () -> getCount().longValue(), this::isSequential, () -> getMaxValueLong(getSegmentCount()));
			return increment(
					this,
					increment,
					getAddressCreator(),
					() -> getCount().longValue(),
					this::longValue, 
					this::upperLongValue,
					this::getLower,
					this::getUpper,
					getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength());
		}
		BigInteger bigIncrement = BigInteger.valueOf(increment);
		checkOverflow(increment, bigIncrement, this::getValue, this::getUpperValue, this::getCount, this::isSequential, () -> getMaxValue(getSegmentCount()));
		Integer prefixLength = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength();
		MACAddressSection result = fastIncrement(
				this,
				increment,
				getAddressCreator(),
				this::getLower,
				this::getUpper,
				prefixLength);
		if(result != null) {
			return result;
		}
		return increment(
				this,
				increment,
				bigIncrement,
				getAddressCreator(), 
				this::getLower,
				this::getUpper,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength());
	}
	protected boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					stringCache = new MACStringCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			result = toHexString(with0xPrefix, null);
			if(with0xPrefix) {
				stringCache.hexStringPrefixed = result;
			} else {
				stringCache.hexString = result;
			}
		}
		return result;
	}
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			return toNormalizedStringRange(AddressStringParams.toParams(with0xPrefix ? MACStringCache.hexPrefixedParams : MACStringCache.hexParams), getLower(), getUpper(), null);
		}
		return toNormalizedString(with0xPrefix ? MACStringCache.hexPrefixedParams : MACStringCache.hexParams);
	}
	public String toNormalizedString(StringOptions stringOptions) {
		return toNormalizedString(stringOptions, this);
	}
	public static String toNormalizedString(StringOptions opts, AddressDivisionGrouping section) {
		return toParams(opts).toString(section);
	}
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().normalizedString) == null) {
			getStringCache().normalizedString = result = toNormalizedString(MACStringCache.normalizedParams);
		}
		return result;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().canonicalString) == null) {
			getStringCache().canonicalString = result = toNormalizedString(MACStringCache.canonicalParams);
		}
		return result;
	}
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().compressedString) == null) {
			getStringCache().compressedString = result = toNormalizedString(MACStringCache.compressedParams);
		}
		return result;
	}
	public String toDottedString() throws IncompatibleAddressException {
		String result = null;
		if(hasNoStringCache() || (result = getStringCache().dottedString) == null) {
			AddressDivisionGrouping dottedGrouping = getDottedGrouping();
			getStringCache().dottedString = result = toNormalizedString(MACStringCache.dottedParams, dottedGrouping);
		}
		return result;
	}
	public String toSpaceDelimitedString() {
		String result = null;
		if(hasNoStringCache() || (result = getStringCache().spaceDelimitedString) == null) {
			getStringCache().spaceDelimitedString = result = toNormalizedString(MACStringCache.spaceDelimitedParams);
		}
		return result;
	}
	public String toDashedString() {
		return toCanonicalString();
	}
	public String toColonDelimitedString() {
		return toNormalizedString();
	}
	@Override
	public String toString() {
		return toNormalizedString();
	}
	@Override
	public String[] getSegmentStrings() {
		return getDivisionStrings();
	}
	@SuppressWarnings("serial")
	public AddressDivisionGrouping getDottedGrouping() {
		int start = addressSegmentIndex;
		int segmentCount = getSegmentCount();
		AddressDivision newSegs[];
		int newSegmentBitCount = getBitsPerSegment() << 1;
		int segIndex, newSegIndex;
		if((start & 1) == 0) {
			int newSegmentCount = (segmentCount + 1) >>> 1;
			newSegs = new AddressDivision[newSegmentCount];
			newSegIndex = segIndex = 0;
		} else {
			int newSegmentCount = (segmentCount >>> 1) + 1;
			newSegs = new AddressDivision[newSegmentCount];
			MACAddressSegment segment = getSegment(0);
			newSegs[0] = new AddressBitsDivision(segment.getSegmentValue(), segment.getUpperSegmentValue(), newSegmentBitCount, MACAddress.DEFAULT_TEXTUAL_RADIX);
			newSegIndex = segIndex = 1;
		}
		while(segIndex + 1 < segmentCount) {
			MACAddressSegment segment1 = getSegment(segIndex++);
			MACAddressSegment segment2 = getSegment(segIndex++);
			if(segment1.isMultiple() && !segment2.isFullRange()) {
				throw new IncompatibleAddressException(segment1, segIndex - 2, segment2, segIndex - 1, "ipaddress.error.invalid.joined.ranges");
			}
			AddressDivision newSeg = new AddressBitsDivision(
					(segment1.getSegmentValue() << getBitsPerSegment()) | segment2.getSegmentValue(), 
					(segment1.getUpperSegmentValue() << getBitsPerSegment()) | segment2.getUpperSegmentValue(), 
					newSegmentBitCount,
					MACAddress.DEFAULT_TEXTUAL_RADIX);
			newSegs[newSegIndex++] = newSeg;
		}
		if(segIndex < segmentCount) {
			MACAddressSegment segment = getSegment(segIndex);
			newSegs[newSegIndex] = new AddressBitsDivision(
					segment.getSegmentValue() << getBitsPerSegment(),
					segment.getUpperSegmentValue() << getBitsPerSegment(),
					newSegmentBitCount,
					MACAddress.DEFAULT_TEXTUAL_RADIX);
		}
		AddressDivisionGrouping dottedGrouping;
		if(cachedPrefixLength == null) {
			dottedGrouping = new AddressDivisionGrouping(newSegs);
		} else {
			Integer prefLength = cachedPrefixLength;
			dottedGrouping = new AddressDivisionGrouping(newSegs) {{
				cachedPrefixLength = prefLength;
			}};
		}
		return dottedGrouping;
	}
	static String toNormalizedString(IPStringOptions opts, AddressStringDivisionSeries section) {
		return toParams(opts).toString(section);
	}
	@Override
	public boolean overlaps(AddressSection other) {
		return other instanceof MACAddressSection && overlaps((MACAddressSection) other);
	}
	public boolean overlaps(MACAddressSection other) {
		if(addressSegmentIndex != other.addressSegmentIndex || isExtended() != other.isExtended()) {
			return false;
		}
		return overlaps(this, other);
	}
	@Override
	public boolean contains(AddressSection other) {
		return other instanceof MACAddressSection && contains((MACAddressSection) other);
	}
	public boolean contains(MACAddressSection other) {
		if(addressSegmentIndex != other.addressSegmentIndex || isExtended() != other.isExtended() || getSegmentCount() != other.getSegmentCount()) {
			return false;
		}
		for(int i = 0; i < getSegmentCount(); i++) {
			if(!getSegment(i).contains(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	static BigInteger enumerate(MACAddressSection addr, AddressSection other) {
		if(!addr.isExtended()) {
			Long result = enumerateSmall(addr, other);
			if(result != null) {
				return BigInteger.valueOf(result);
			}
			return null;
		}
		return enumerateBig(addr, other);
	}
	@Override
	public BigInteger enumerate(AddressSection other) {
		if(other instanceof MACAddressSection) {
			checkSegmentCount(other);
			MACAddressSection otherSec = (MACAddressSection) other;
			if(addressSegmentIndex != otherSec.addressSegmentIndex) {
				throw new AddressPositionException(this, addressSegmentIndex, otherSec.addressSegmentIndex);
			} else if(!isExtended() || getSegmentCount() <= 7) {
				Long result = enumerateSmall(this, other);
				if(result != null) {
					return BigInteger.valueOf(result);
				}
				return null;
			}
			return enumerateBig(this, other);
		}
		return null;
	}
	@Override
	public boolean prefixEquals(AddressSection o) {
		if(o instanceof MACAddressSection) {
			MACAddressSection other = (MACAddressSection) o;
			if(addressSegmentIndex >= other.addressSegmentIndex) {
				return prefixEquals(this, other, addressSegmentIndex - other.addressSegmentIndex);
			}
		}
		return false;
	}
	protected static AddressStringParams<AddressStringDivisionSeries> toParams(StringOptions opts) {
		return AddressStringParams.toParams(opts);
	}
	public static class MACStringOptions extends StringOptions {
		protected MACStringOptions(
				int base,
				boolean expandSegments,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcards, segmentStrPrefix, separator, label, reverse, splitDigits, uppercase);
		}
		public static class Builder extends StringOptions.Builder {
			public Builder() {
				this(MACAddress.DEFAULT_TEXTUAL_RADIX, MACAddress.COLON_SEGMENT_SEPARATOR);
			}
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			@Override
			public MACStringOptions toOptions() {
				return new MACStringOptions(base, expandSegments, wildcards, segmentStrPrefix, separator, addrLabel, reverse, splitDigits, uppercase);
			}
		}
	}
}
package inet.ipaddr;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.IPAddress.IPAddressValueProvider;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping.RangeList;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
public abstract class IPAddressNetwork<
		T extends IPAddress, 
		R extends IPAddressSection,
		E extends IPAddressSection,
		S extends IPAddressSegment,
		J extends InetAddress> 
	extends AddressNetwork<S> {
	private static final long serialVersionUID = 4L;
	private final T subnetsMasksWithPrefix[];
	private final T subnetMasks[];
	private final T networkAddresses[];
	private final T hostMasks[];
	private final int networkSegmentMasks[];
	private final int hostSegmentMasks[];
	private transient T loopback;
	private transient String loopbackStrings[];
	public static abstract class IPAddressCreator<T extends IPAddress, R extends IPAddressSection, E extends IPAddressSection, S extends IPAddressSegment, J extends InetAddress> extends AddressCreator<T, R, E, S> {
		private static final long serialVersionUID = 4L;
		private IPAddressNetwork<T, R, E, S, J> owner;
		protected IPAddressCreator(IPAddressNetwork<T, R, E, S, J> owner) {
			this.owner = owner;
		}
		@Override
		public IPAddressNetwork<T, R, E, S, J> getNetwork() {
			return owner;
		}
		@Override
		protected S createSegmentInternal(int value, Integer segmentPrefixLength, CharSequence addressStr, int originalVal, boolean isStandardString, int lowerStringStartIndex, int lowerStringEndIndex) {
			S segment = createSegment(value, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			segment.setWildcardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			return segment;
		}
		@Override
		protected S createRangeSegmentInternal(int lower, int upper, Integer segmentPrefixLength, CharSequence addressStr, int originalLower, int originalUpper, boolean isStandardString, boolean isStandardRangeString, int lowerStringStartIndex, int lowerStringEndIndex, int upperStringEndIndex) {
			S segment = createSegment(lower, upper, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString,  isStandardRangeString, lowerStringStartIndex, lowerStringEndIndex, upperStringEndIndex, originalLower, originalUpper);
			segment.setWildcardString(addressStr, isStandardRangeString, lowerStringStartIndex, upperStringEndIndex, originalLower, originalUpper);
			return segment;
		}
		protected abstract R[] createSectionArray(int length);
		@Override
		protected abstract R createSectionInternal(S segments[]);
		protected abstract R createEmbeddedSectionInternal(IPAddressSection encompassingSection, S segments[]);
		@Override
		protected R createPrefixedSectionInternal(S segments[], Integer prefix) {
			return createPrefixedSectionInternal(segments, prefix, false);
		}
		@Override
		protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
		public abstract R createFullSectionInternal(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix);
		public abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix);
		public abstract R createSection(byte bytes[], Integer prefix);
		public abstract R createSection(S segments[], Integer networkPrefixLength);
		public abstract R createSection(S segments[]);
		protected abstract T[] createAddressArray(int length);
		public T createAddress(S segments[]) {
			return createAddress(createSection(segments));
		}
		public T createAddress(S segments[], Integer prefix) {
			return createAddress(createSection(segments, prefix));
		}
		@Override
		protected T createAddressInternal(S segments[]) {
			return createAddress(createSectionInternal(segments));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix, boolean singleOnly) {
			return createAddress(createPrefixedSectionInternal(segments, prefix, singleOnly));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix) {
			return createAddress(createPrefixedSectionInternal(segments, prefix));
		}
		protected T createAddressInternal(S segments[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(segments), zone);
		}
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix) {
			return createAddress(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix));
		}
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix, CharSequence zone) {
			return createAddressInternal(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix), zone);
		}
		protected R createSectionInternal(byte bytes[], int segmentCount, Integer prefix) {
			return createSectionInternal(bytes, segmentCount, prefix, false);
		}
		protected abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix);
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) {
			return createAddress(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix));
		}
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix, CharSequence zone) {
			return createAddressInternal(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix) {
			return createAddress(createSectionInternal(bytes, getAddressSegmentCount(), prefix));
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone);
		}
		@Override
		protected T createAddressInternal(byte bytes[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), null), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone, fromHost);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), fromHost);
		}
		public T createAddress(byte bytes[], Integer prefix) {
			return createAddress(createSection(bytes, prefix));
		}
		public T createAddress(byte bytes[]) {
			return createAddress(createSection(bytes, null));
		}
		@Override
		protected T createAddressInternal(R section, CharSequence zone, HostIdentifierString from) {
			T result = createAddressInternal(section, zone);
			result.cache(from);
			return result;
		}
		@Override
		protected T createAddressInternal(R section, HostIdentifierString from) {
			T result = createAddress(section);
			result.cache(from);
			return result;
		}
		protected abstract T createAddress(J inetAddress);
		protected abstract T createAddress(J inetAddress, Integer networkPrefixLength);
		protected abstract T createAddressInternal(R section, CharSequence zone);
		@Override
		public abstract T createAddress(R section);
		protected abstract int getAddressSegmentCount();
		public T createSequentialBlockAddress(IPAddressSegmentSeries address, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(address, index, lowerVal, upperVal);
			return createAddressInternal(segments);
		}
		public R createSequentialBlockSection(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(series, index, lowerVal, upperVal);
			return createSectionInternal(segments);
		}
		private S[] createSequentialBlockSegments(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S segments[] = createSegmentArray(series.getSegmentCount());
			series.getSegments(0, index, segments, 0);
			segments[index] = createSegment(lowerVal, upperVal, null);
			if(++index < segments.length) {
				S allRangeSegment = createSegment(0, getMaxValuePerSegment(), null);
				do {
					segments[index] = allRangeSegment;
				} while(++index < segments.length);
			}
			return segments;
		}
	}
	private IPAddressCreator<T, R, E, S, J> creator;
	@SuppressWarnings("unchecked")
	protected IPAddressNetwork(Class<T> addressType) {
		IPVersion version = getIPVersion();
		int bitSize = IPAddress.getBitCount(version);
		this.subnetsMasksWithPrefix = (T[]) Array.newInstance(addressType, bitSize + 1);
		this.subnetMasks = this.subnetsMasksWithPrefix.clone();
		this.networkAddresses = this.subnetsMasksWithPrefix.clone();
		this.hostMasks = this.subnetsMasksWithPrefix.clone();
		this.creator = createAddressCreator();
		int segmentBitSize = IPAddressSegment.getBitCount(version);
		int fullMask = ~(~0 << segmentBitSize); 
		networkSegmentMasks = new int[segmentBitSize + 1];
		hostSegmentMasks = networkSegmentMasks.clone();
		for(int i = 0; i <= segmentBitSize; i++) {
			int networkMask = this.networkSegmentMasks[i] = fullMask & (fullMask << (segmentBitSize - i));
			this.hostSegmentMasks[i] = ~networkMask & fullMask;
		}
	}
	@Override
	public void clearCaches() {
		Arrays.fill(subnetsMasksWithPrefix, null);
		Arrays.fill(subnetMasks, null);
		Arrays.fill(networkAddresses, null);
		Arrays.fill(hostMasks, null);
		loopback = null;
		loopbackStrings = null;
		super.clearCaches();
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	protected abstract BiFunction<T, Integer, S> getSegmentProducer();
	protected abstract Function<T, R> getSectionProducer();
	protected abstract IPAddressCreator<T, R, E, S, J> createAddressCreator();
	@Override
	public IPAddressCreator<T, R, E, S, J> getAddressCreator() {
		return creator;
	}
	public T getLoopback() {
		if(loopback == null) {
			synchronized(this) {
				if(loopback == null) {
					loopback = createLoopback();
				}
			}
		}
		return loopback;
	}
	protected abstract T createLoopback();
	public String[] getStandardLoopbackStrings() {
		if(loopbackStrings == null) {
			synchronized(this) {
				if(loopbackStrings == null) {
					loopbackStrings = getLoopback().toStandardStrings();
				}
			}
		}
		return loopbackStrings;
	}
	public int getSegmentNetworkMask(int segmentPrefixLength) {
		return (int) networkSegmentMasks[segmentPrefixLength];
	}
	public int getSegmentHostMask(int segmentPrefixLength) {
		return (int) hostSegmentMasks[segmentPrefixLength];
	}
	public T getNetworkMask(int networkPrefixLength) {
		return getNetworkMask(networkPrefixLength, true);
	}
	public T getNetworkAddress(int networkPrefixLength) {
		return getMask(networkPrefixLength, networkAddresses, true, true, true);
	}
	public T getNetworkMask(int networkPrefixLength, boolean withPrefixLength) {
		return getMask(networkPrefixLength, withPrefixLength ? subnetsMasksWithPrefix : subnetMasks, true, withPrefixLength, false);
	}
	public R getNetworkMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getNetworkMask(networkPrefixLength, true));
	}
	public T getHostMask(int networkPrefixLength) {
		return getMask(networkPrefixLength, hostMasks, false, false, false);
	}
	public R getHostMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getHostMask(networkPrefixLength));
	}
	@SuppressWarnings("unchecked")
	private T getMask(int networkPrefixLength, T cache[], boolean network, boolean withPrefixLength, boolean networkAddress) {
		int bits = networkPrefixLength;
		IPVersion version = getIPVersion();
		int addressBitLength = IPAddress.getBitCount(version);
		if(bits < 0 || bits > addressBitLength) {
			throw new PrefixLenException(bits, version);
		}
		int cacheIndex = bits;
		T subnet = cache[cacheIndex];
		if(subnet == null) {
			int onesSubnetIndex, zerosSubnetIndex;
			if(network) {
				onesSubnetIndex = addressBitLength;
				zerosSubnetIndex = 0;
			} else {
				onesSubnetIndex = 0;
				zerosSubnetIndex = addressBitLength;
			}
			T onesSubnet = cache[onesSubnetIndex];
			T zerosSubnet = cache[zerosSubnetIndex];
			if(onesSubnet == null || zerosSubnet == null) {
				synchronized(cache) {
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					onesSubnet = cache[onesSubnetIndex];
					if(onesSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						int maxSegmentValue = IPAddress.getMaxSegmentValue(version);
						if(network && withPrefixLength) {
							S segment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, addressBitLength)  );
							Arrays.fill(newSegments, 0, newSegments.length - 1, segment);
							S lastSegment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bitsPerSegment)  );
							newSegments[newSegments.length - 1] = lastSegment;
							onesSubnet = creator.createAddressInternal(newSegments, cacheBits(addressBitLength)); 
						} else {
							S segment = creator.createSegment(maxSegmentValue);
							Arrays.fill(newSegments, segment);
							onesSubnet = creator.createAddressInternal(newSegments); 
						}
						initMaskCachedValues(onesSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, onesSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[onesSubnetIndex] = onesSubnet;
					}
					zerosSubnet = cache[zerosSubnetIndex];
					if(zerosSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						S seg;
						if(network && withPrefixLength) {
							seg = creator.createSegment(0, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, 0) );
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments, cacheBits(0)); 
							if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
								zerosSubnet = (T) zerosSubnet.getLower();
							}
						} else {
							seg = creator.createSegment(0);
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments); 
						}
						initMaskCachedValues(zerosSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, zerosSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[zerosSubnetIndex] = zerosSubnet;
					}
				}
			}
			synchronized(cache) {
				subnet = cache[cacheIndex];
				if(subnet == null) {			
					BiFunction<T, Integer, S> segProducer = getSegmentProducer();				
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					int prefix = bits;
					S onesSegment = segProducer.apply(onesSubnet, 0);
					S zerosSegment = segProducer.apply(zerosSubnet, 0);
					IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
					ArrayList<S> segmentList = new ArrayList<S>(segmentCount);
					int i = 0;
					for(; bits > 0; i++, bits -= bitsPerSegment) {
						if(bits <= bitsPerSegment) {
							S segment = null;
							int offset = ((bits - 1) % bitsPerSegment) + 1;
							for(int j = 0, entry = offset; j < segmentCount; j++, entry += bitsPerSegment) {
								if(entry != cacheIndex) { 
									T prev = cache[entry];
									if(prev != null) {
										segment = segProducer.apply(prev, j);
										break;
									}
								}
							}
							if(segment == null) {
								int mask = getSegmentNetworkMask(bits);
								if(network) {
									if(withPrefixLength) {
										segment = creator.createSegment(mask, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bits));
									} else {
										segment = creator.createSegment(mask);
									}
								} else {
									segment = creator.createSegment(getSegmentHostMask(bits));
								}
							}
							segmentList.add(segment);
						} else {
							segmentList.add(network ? onesSegment : zerosSegment);
						}
					}
					for(; i<segmentCount; i++) {
						segmentList.add(network ? zerosSegment : onesSegment);
					}
					S newSegments[] = creator.createSegmentArray(segmentList.size());
					segmentList.toArray(newSegments);
					if(network && withPrefixLength) {
						subnet = creator.createAddressInternal(newSegments, cacheBits(prefix)); 
						if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
							subnet = (T) subnet.getLower();
						}
					} else {
						subnet = creator.createAddressInternal(newSegments); 
					}
					initMaskCachedValues(subnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, prefix, segmentCount, bitsPerSegment, bytesPerSegment);
					cache[cacheIndex] = subnet; 
				} 
			} 
		} 
		return subnet;
	}
	private void initMaskCachedValues(
			IPAddressSection section, 
			boolean network,
			boolean withPrefixLength,
			boolean networkAddress,
			int addressBitLength, 
			int networkPrefixLength,
			int segmentCount, 
			int bitsPerSegment,
			int bytesPerSegment) {
		Integer cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix;
		BigInteger cachedCount;
		RangeList zeroSegments, zeroRanges;
		boolean hasZeroRanges = network ? addressBitLength - networkPrefixLength >= bitsPerSegment : networkPrefixLength >= bitsPerSegment;
		RangeList noZeros = IPAddressSection.getNoZerosRange();
		if(hasZeroRanges) {
			int rangeIndex, rangeLen;
			if(network) {
				int segmentIndex = IPAddressSection.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment) + 1;
				rangeIndex = segmentIndex;
				rangeLen = segmentCount - segmentIndex;
			} else {
				rangeIndex = 0;
				rangeLen = IPAddressSection.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
			}
			zeroRanges = IPAddressSection.getSingleRange(rangeIndex, rangeLen);
			zeroSegments = (network && withPrefixLength && !getPrefixConfiguration().prefixedSubnetsAreExplicit()) ? noZeros : zeroRanges;
		} else {
			zeroSegments = zeroRanges = noZeros;
		}
		Integer npl = cacheBits(networkPrefixLength);
		if(network && withPrefixLength) {
			if(getPrefixConfiguration().prefixedSubnetsAreExplicit() || (getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress)) {
				cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
				cachedNetworkPrefix = npl;
				cachedCount = BigInteger.ONE;
			} else {
				cachedEquivalentPrefix = cachedMinPrefix = cachedNetworkPrefix = npl;
				cachedCount = BigInteger.valueOf(2).pow(addressBitLength - networkPrefixLength);
			}
		} else {
			cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
			cachedNetworkPrefix = null;
			cachedCount = BigInteger.ONE;
		}
		section.initCachedValues(npl, network, cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix, cachedCount, zeroSegments, zeroRanges);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	public static String getPrefixString(int networkPrefixLength) {
		return new StringBuilder(HostIdentifierStringValidator.MAX_PREFIX_CHARS + 1).append(IPAddress.PREFIX_LEN_SEPARATOR).append(networkPrefixLength).toString();
	}
	public static class IPAddressGenerator implements Serializable {
		private static final long serialVersionUID = 4L;
		protected final IPAddressStringParameters options;
		public IPAddressGenerator() {
			this(null);
		}
		public IPAddressGenerator(IPv4AddressNetwork ipv4Network, IPv6AddressNetwork ipv6Network) {
			this(new IPAddressStringParameters.Builder().
						getIPv4AddressParametersBuilder().setNetwork(ipv4Network).
						getParentBuilder().
						getIPv6AddressParametersBuilder().setNetwork(ipv6Network).
							getEmbeddedIPv4AddressParametersBuilder().setNetwork(ipv4Network).
							getEmbeddedIPv4AddressParentBuilder().
						getParentBuilder().
					toParams());
		}
		public IPAddressGenerator(IPAddressStringParameters options) {
			if(options == null) {
				options = IPAddressString.DEFAULT_VALIDATION_OPTIONS;
			}
			this.options = options;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
				return IPv4Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
				return IPv6Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
		public IPAddress from(InetAddress inetAddress) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress);
			}
			return null;
		}
		public IPAddress from(InetAddress inetAddress, Integer prefixLength) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, prefixLength);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, prefixLength);
			}
			return null;
		}
		public IPAddress from(InterfaceAddress interfaceAddress) {
			InetAddress inetAddress = interfaceAddress.getAddress();
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			}
			return null;
		}
		public IPAddress from(byte bytes[]) {
			return from(bytes, 0, bytes.length, null, null);
		}
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex) {
			return from(bytes, byteStartIndex, byteEndIndex, null, null);
		}
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) {
			return from(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
		}
		public IPAddress from(byte bytes[], Integer prefixLength) {
			return from(bytes, 0, bytes.length, prefixLength, null);
		}
		private IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefixLength, CharSequence zone) {
			if(byteEndIndex - byteStartIndex < IPv6Address.BYTE_COUNT) {
				return getIPv4Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength);
			}
			return getIPv6Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength, zone);
		}
		public IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return from(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
		private IPv4AddressCreator getIPv4Creator() {
			IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
			IPv4AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
		private IPv6AddressCreator getIPv6Creator() {
			IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
			IPv6AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
		private IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				return getIPv4Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				return getIPv6Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
	}
	public static abstract class HostIDStringAddressGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		private final IPAddressGenerator addressGenerator;
		protected final Map<String, T> backingMap;
		public HostIDStringAddressGenerator() {
			this(null, null);
		}
		public HostIDStringAddressGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		public HostIDStringAddressGenerator(Map<String, T> backingMap) {
			this(backingMap, null);
		}
		public HostIDStringAddressGenerator(Map<String, T> backingMap, IPAddressStringParameters options) {
			this.backingMap = backingMap;
			this.addressGenerator = new IPAddressGenerator(options);
		}
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			int segmentByteCount = (bytes.length == IPv4Address.BYTE_COUNT) ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return getValueProvider(bytes, segmentByteCount);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[], int segmentByteCount) {
			return segmentIndex -> {	
				int value = 0;
				for(int start = segmentIndex * segmentByteCount, end = start + segmentByteCount; start < end; start++) {
					value = (value << 8) | (0xff & bytes[start]);
				}
				return value;
			};
		}
		public T get(byte bytes[]) {
			IPVersion version = bytes.length == IPv4Address.BYTE_COUNT ? IPVersion.IPV4 : IPVersion.IPV6;
			int segmentByteCount = version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return get(version, getValueProvider(bytes, segmentByteCount), null, null, null);
		}
		public T get(AddressValueProvider addressProvider) {
			if(addressProvider instanceof IPAddressValueProvider) {
				return get((IPAddressValueProvider) addressProvider);
			}
			return get(addressProvider.getSegmentCount() == IPv4Address.SEGMENT_COUNT ? IPVersion.IPV4 : IPVersion.IPV6, 
					addressProvider.getValues(), addressProvider.getUpperValues(), null, null);	
		}
		public T get(IPAddressValueProvider addressProvider) {
			return get(addressProvider.getIPVersion(), addressProvider.getValues(), addressProvider.getUpperValues(), addressProvider.getPrefixLength(), addressProvider.getZone());
		}
		public T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return get(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
		public T get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return get(IPVersion.IPV6, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		private T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(backingMap == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				return create(addr);
			}
			String key = toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
			T result = backingMap.get(key);
			if(result == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				addr.cacheNormalizedString(key);
				result = create(addr);
				T existing = backingMap.putIfAbsent(key, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
				}
			}
			return result;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		protected abstract T create(IPAddress addr);
		protected abstract void cache(T result, IPAddress addr);
		protected abstract void added(T added);
	}
	public static class IPAddressStringGenerator extends HostIdentifierStringGenerator<IPAddressString> {
		private static final long serialVersionUID = 4L;
		private final HostIDStringAddressGenerator<IPAddressString> addressGenerator;
		@SuppressWarnings("serial")
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap, IPAddressStringParameters options) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<IPAddressString>(backingMap, options) {
				@Override
				protected IPAddressString create(IPAddress addr) {
					return addr.toAddressString();
				}
				@Override
				protected void cache(IPAddressString result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(IPAddressString added) {
					IPAddressStringGenerator.this.added(added);
				}
			};
		}
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap) {
			this(backingMap, null);
		}
		public IPAddressStringGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		public IPAddressStringGenerator() {
			this(null, null);
		}
		@Override
		protected IPAddressString create(String addressString) {
			IPAddressStringParameters options = addressGenerator.addressGenerator.options;
			return options == null ? new IPAddressString(addressString) : new IPAddressString(addressString, options);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		@Override
		public IPAddressString get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		public IPAddressString get(IPAddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		@Override
		public IPAddressString get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		public IPAddressString get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		public IPAddressString get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
	public static class HostNameGenerator extends HostIdentifierStringGenerator<HostName> {
		private static final long serialVersionUID = 4L;
		private final HostIDStringAddressGenerator<HostName> addressGenerator;
		private final HostNameParameters options;
		@SuppressWarnings("serial")
		public HostNameGenerator(Map<String, HostName> backingMap, HostNameParameters options, boolean reverseLookup) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<HostName>(backingMap, options.addressOptions) {
				@Override
				protected HostName create(IPAddress addr) {
					if(reverseLookup) {
						return new HostName(addr.toInetAddress().getHostName());
					}
					return new HostName(addr);
				}
				@Override
				protected void cache(HostName result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(HostName added) {
					HostNameGenerator.this.added(added);
				}
			};
			this.options = options;
		}
		public HostNameGenerator(Map<String, HostName> backingMap) {
			this(backingMap, HostName.DEFAULT_VALIDATION_OPTIONS, false);
		}
		public HostNameGenerator(HostNameParameters options) {
			this(null, options, false);
		}
		public HostNameGenerator() {
			this(null, null, false);
		}
		@Override
		protected HostName create(String key) {
			return options == null ? new HostName(key) : new HostName(key, options);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		@Override
		public HostName get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		@Override
		public HostName get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		public HostName get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		public HostName get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
}
package inet.ipaddr.mac;
import java.math.BigInteger;
import java.net.NetworkInterface;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.MACAddressString;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection.MACAddressCache;
public class MACAddress extends Address implements Iterable<MACAddress> {
	private static final long serialVersionUID = 4L;
	public static final char COLON_SEGMENT_SEPARATOR = ':';
	public static final char DASH_SEGMENT_SEPARATOR = '-';
	public static final char SPACE_SEGMENT_SEPARATOR = ' ';
	public static final char DOTTED_SEGMENT_SEPARATOR = '.';
	public static final char DASHED_SEGMENT_RANGE_SEPARATOR = '|';
	public static final String DASHED_SEGMENT_RANGE_SEPARATOR_STR = String.valueOf(DASHED_SEGMENT_RANGE_SEPARATOR);
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int MEDIA_ACCESS_CONTROL_SEGMENT_COUNT = 6;
	public static final int MEDIA_ACCESS_CONTROL_BIT_COUNT = 48;
	public static final int MEDIA_ACCESS_CONTROL_DOTTED_SEGMENT_COUNT = 3;
	public static final int MEDIA_ACCESS_CONTROL_DOTTED_64_SEGMENT_COUNT = 4;
	public static final int MEDIA_ACCESS_CONTROL_DOTTED_BITS_PER_SEGMENT = 16;
	public static final int MEDIA_ACCESS_CONTROL_SINGLE_DASHED_SEGMENT_COUNT = 2;
	public static final int EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT = MEDIA_ACCESS_CONTROL_SEGMENT_COUNT;
	public static final int EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT = 8;
	public static final int EXTENDED_UNIQUE_IDENTIFIER_48_BIT_COUNT = MEDIA_ACCESS_CONTROL_BIT_COUNT;
	public static final int EXTENDED_UNIQUE_IDENTIFIER_64_BIT_COUNT = 64;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE_PER_DOTTED_SEGMENT = 0xffff;
	public static final int ORGANIZATIONAL_UNIQUE_IDENTIFIER_SEGMENT_COUNT = 3;
	public static final int ORGANIZATIONAL_UNIQUE_IDENTIFIER_BIT_COUNT = ORGANIZATIONAL_UNIQUE_IDENTIFIER_SEGMENT_COUNT * BITS_PER_SEGMENT;
	transient MACAddressCache sectionCache;
	public MACAddress(MACAddressSegment[] segments) throws AddressValueException {
		super(thisAddress -> ((MACAddress) thisAddress).getAddressCreator().createSection(segments, segments.length == EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT));
		int segCount = segments.length;
		if(segCount != MEDIA_ACCESS_CONTROL_SEGMENT_COUNT && segCount != EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.mac.invalid.segment.count", segCount);
		}
	}
	public MACAddress(MACAddressSection section) throws AddressValueException {
		super(section);
		int segCount = section.getSegmentCount();
		if(segCount != MEDIA_ACCESS_CONTROL_SEGMENT_COUNT && segCount != EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.mac.invalid.segment.count", segCount);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
	}
	public MACAddress(long address) throws AddressValueException {
		this(address, false);
	}
	public MACAddress(NetworkInterface ni) throws java.net.SocketException {
		this(ni.getHardwareAddress());
	}
	public MACAddress(long address, boolean extended) throws AddressValueException {
		super(thisAddress -> ((MACAddress) thisAddress).getAddressCreator().createSection(address, 0, extended));
	}
	public MACAddress(byte[] bytes) throws AddressValueException {
		super(thisAddress -> createSection((MACAddress) thisAddress, bytes));
	}
	public MACAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, boolean extended) {
		super(thisAddress -> ((MACAddress) thisAddress).getAddressCreator().createSection(lowerValueProvider, upperValueProvider, 0, extended));
	}
	public MACAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, false);
	}
	public MACAddress(SegmentValueProvider valueProvider, boolean extended) throws AddressValueException {
		this(valueProvider, valueProvider, extended);
	}
	public MACAddress(SegmentValueProvider valueProvider) {
		this(valueProvider, false);
	}
	private static MACAddressSection createSection(MACAddress addr, byte[] bytes) {
		int segCount;
		int len = bytes.length;
		if(len < EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			segCount = MEDIA_ACCESS_CONTROL_SEGMENT_COUNT;
			if(len > MEDIA_ACCESS_CONTROL_SEGMENT_COUNT) {
				int i = 0;
				do {
					if(bytes[i++] != 0) {
						segCount = EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT;
						break;
					}
				} while(--len > MEDIA_ACCESS_CONTROL_SEGMENT_COUNT);
			}
		} else {
			segCount = EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT;
		}
		return addr.getAddressCreator().createSection(bytes, 0, segCount, segCount == EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT);
	}
	protected static String getMessage(String key) {
		return Address.getMessage(key);
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof MACAddress) {
			return MACAddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public MACAddressNetwork getNetwork() {
		return defaultMACNetwork();
	}
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	public MACAddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	public boolean isExtended() {
		return getSection().isExtended();
	}
	@Override
	public boolean isMACAddress() {
		return true;
	}
	@Override
	public MACAddress toMACAddress() {
		return this;
	}
	public boolean isAllAddresses() {
		return getSection().isFullRange();
	}
	@Override
	public MACAddressSection getSection() {
		return (MACAddressSection) super.getSection();
	}
	@Override
	public MACAddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public MACAddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public MACAddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public static int maxSegmentValue() {
		return MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public int getMaxSegmentValue() {
		return MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getBytesPerSegment() {
		return BYTES_PER_SEGMENT;
	}
	@Override
	public int getBitsPerSegment() {
		return BITS_PER_SEGMENT;
	}
	@Override
	protected boolean isFromSameString(HostIdentifierString other) {
		if(fromString != null && other instanceof MACAddressString) {
			MACAddressString fromString = (MACAddressString) this.fromString;
			MACAddressString otherString = (MACAddressString) other;
			return (fromString == otherString || 
					(fromString.toString().equals(otherString.toString()) &&
					fromString.getValidationOptions() == otherString.getValidationOptions()));
		}
		return false;
	}
	@Override
	public Iterable<MACAddress> getIterable() {
		return this;
	}
	@Override
	public Iterator<MACAddress> iterator() {
		return getSection().iterator(this, getAddressCreator());
	}
	@Override
	public AddressComponentSpliterator<MACAddress> spliterator() {
		return getSection().spliterator(this, getAddressCreator());
	}
	@Override
	public Stream<MACAddress> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<MACAddress> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<MACAddress> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<MACAddress> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<MACAddress> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<MACAddress> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<MACAddress> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<MACAddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<MACAddress, MACAddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<MACAddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public MACAddress increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public MACAddress incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	@Override
	public MACAddress getLower() {
		return getLowestOrHighest(true);
	}
	@Override
	public MACAddress getUpper() {
		return getLowestOrHighest(false);
	}
	private MACAddress getLowestOrHighest(boolean lowest) {
		return getSection().getLowestOrHighest(this, lowest);
	}
	public long longValue() {
		return getSection().longValue();
	}
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	@Override
	public MACAddress reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	@Override
	public MACAddress reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public MACAddress reverseBytesPerSegment() {
		return this;
	}
	@Override
	public MACAddress reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	private MACAddress checkIdentity(MACAddressSection newSection) {
		MACAddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	@Override @Deprecated
	public MACAddress removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public MACAddress withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public MACAddress removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Deprecated
	@Override
	public MACAddress applyPrefixLength(int prefixLength) {
		return checkIdentity(getSection().applyPrefixLength(prefixLength));
	}
	@Override
	public MACAddress adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public MACAddress adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public MACAddress adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public MACAddress adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public MACAddress setPrefixLength(int prefixLength) {
		return checkIdentity(getSection().setPrefixLength(prefixLength));
	}
	@Override
	public MACAddress setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public MACAddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public MACAddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	public MACAddressSection getODISection() {
		return getSection().getODISection();
	}
	public MACAddressSection getOUISection() {
		return getSection().getOUISection();
	}
	public MACAddress toOUIPrefixBlock() {
		return checkIdentity(getSection().toOUIPrefixBlock());
	}
	@Override
	public MACAddress toPrefixBlock() {
		return checkIdentity(getSection().toPrefixBlock());
	}
	public IPv6Address toLinkLocalIPv6() {
		IPv6AddressNetwork network = getIPv6Network();
		IPv6AddressSection linkLocalPrefix = network.getLinkLocalPrefix();
		IPv6AddressCreator creator = network.getAddressCreator();
		return creator.createAddress(linkLocalPrefix.append(toEUI64IPv6()));
	}
	public IPv6AddressSection toEUI64IPv6() {
		return getIPv6Network().getAddressCreator().createSection(this);
	}
	public boolean isEUI64(boolean asMAC) {
		if(isExtended()) {
			MACAddressSection section = getSection();
			MACAddressSegment seg3 = section.getSegment(3);
			MACAddressSegment seg4 = section.getSegment(4);
			return seg3.matches(0xff) && seg4.matches(asMAC ? 0xff : 0xfe);
		}
		return false;
	}
	public MACAddress toEUI64(boolean asMAC) {
		if(!isExtended()) {
			MACAddressCreator creator = getAddressCreator();
			MACAddressSegment segs[] = creator.createSegmentArray(EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT);
			MACAddressSection section = getSection();
			section.getSegments(0,  3, segs, 0);
			MACAddressSegment ffSegment = creator.createSegment(0xff);
			segs[3] = ffSegment;
			segs[4] = asMAC ? ffSegment : creator.createSegment(0xfe);
			section.getSegments(3,  6, segs, 5);
			Integer prefLength = getPrefixLength();
			if(prefLength != null) {
				MACAddressSection resultSection = creator.createSectionInternal(segs, true);
				if(prefLength >= 24) {
					prefLength += MACAddress.BITS_PER_SEGMENT << 1; 
				}
				resultSection.assignPrefixLength(prefLength);
				return creator.createAddress(resultSection);
			}
			return creator.createAddressInternal(segs);
		} else {
			MACAddressSection section = getSection();
			MACAddressSegment seg3 = section.getSegment(3);
			MACAddressSegment seg4 = section.getSegment(4);
			if(seg3.matches(0xff) && seg4.matches(asMAC ? 0xff : 0xfe)) {
				return this;
			}
		}
		throw new IncompatibleAddressException(this, "ipaddress.mac.error.not.eui.convertible");
	}
	public MACAddress replace(int startIndex, int endIndex, MACAddress replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public MACAddress replace(int startIndex, MACAddressSection replacement) {
		int replacementCount = Math.min(getSegmentCount() - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	public AddressDivisionGrouping getDottedAddress() {
		return getSection().getDottedGrouping();
	}
	void cache(HostIdentifierString string) {
		if(fromString instanceof MACAddressString) {
			fromString = string;
		}
	}
	@Override
	public MACAddressString toAddressString() {
		if(fromString == null) {
			fromString = new MACAddressString(this); 
		}
		return (MACAddressString) fromString;
	}
	public String toNormalizedString(StringOptions stringOptions) {
		return getSection().toNormalizedString(stringOptions);
	}
	public String toDottedString() throws IncompatibleAddressException {
		return getSection().toDottedString();
	}
	public String toDashedString() {
		return toCanonicalString();
	}
	public String toColonDelimitedString() {
		return toNormalizedString();
	}
	public String toSpaceDelimitedString() {
		return getSection().toSpaceDelimitedString();
	}
	@Override
	public String toString() {
		return toNormalizedString();
	}
	public boolean isUnicast() {
		return !isMulticast();
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithMask(1, 0x1);
	}
	public boolean isUniversal() {
		return !isLocal();
	}
	@Override
	public boolean isLocal() {
		return getSegment(0).matchesWithMask(2, 0x2);
	}
}
package inet.ipaddr.format.standard;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.format.AddressDivisionBase;
public class IPAddressBitsDivision extends IPAddressDivision {
	private static final long serialVersionUID = 4L;
	private final int bitCount, defaultRadix, maxDigitCount;
	private final long value, upperValue;
	private final long bitsMask;
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix) {
		this(value, upperValue, bitCount, defaultRadix, null, null);
	}
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix, Integer networkPrefixLength) {
		this(value, upperValue, bitCount, defaultRadix, null, networkPrefixLength);
	}
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer networkPrefixLength) {
		super(networkPrefixLength == null ? null : 
			((bitCount < networkPrefixLength) ? AddressDivisionGrouping.cacheBits(bitCount) : networkPrefixLength));
		this.bitCount = bitCount;
		if(value > upperValue) {
			long tmp = value;
			value = upperValue;
			upperValue = tmp;
		}
		if(value < 0) {
			throw new AddressValueException(value);
		}
		long fullMask = ~0L << bitCount; 
		long max = ~fullMask;
		if(upperValue > max) {
			throw new AddressValueException(upperValue);
		}
		networkPrefixLength = getDivisionPrefixLength();
		if(networkPrefixLength != null && networkPrefixLength < bitCount && network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			long mask = ~0L << (bitCount - networkPrefixLength);
			this.value = value & mask;
			this.upperValue = upperValue | ~mask;
		} else {
			this.value = value;
			this.upperValue = upperValue;
		}
		this.defaultRadix = defaultRadix;
		bitsMask = max;
		maxDigitCount = getMaxDigitCount(defaultRadix, bitCount, max); 
	}
	@Override
	public int getBitCount() {
		return bitCount;
	}
	@Override
	protected long getDivisionNetworkMask(int bits) {
		int bitShift = bitCount - bits;
		return bitsMask & (~0L << bitShift);
	}
	@Override
	protected long getDivisionHostMask(int bits) {
		int bitShift = bitCount - bits;
		return ~(~0L << bitShift);
	}
	@Override
	public long getDivisionValue() {
		return value;
	}
	@Override
	public long getUpperDivisionValue() {
		return upperValue;
	}
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		if(other instanceof IPAddressBitsDivision) {
			return isSameValues((IPAddressBitsDivision) other);
		}
		return false;
	}
	protected boolean isSameValues(IPAddressBitsDivision otherSegment) {
		return  value == otherSegment.value && upperValue == otherSegment.upperValue;
	}
	@Override
	public boolean equals(Object other) {
		if(other == this) {
			return true;
		}
		if(other instanceof IPAddressBitsDivision) {
			IPAddressBitsDivision otherSegments = (IPAddressBitsDivision) other;
			return getBitCount() == otherSegments.getBitCount() && otherSegments.isSameValues(this);
		}
		return false;
	}
	@Override
	public int getDefaultTextualRadix() {
		return defaultRadix;
	}
	@Override
	public int getMaxDigitCount() {
		return maxDigitCount;
	}
}
package inet.ipaddr;
import inet.ipaddr.format.AddressItem;
public class NetworkMismatchException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	private static String errorMessage = getMessage("ipaddress.address.error");
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public NetworkMismatchException(AddressItem one) {
		super(one + ", " + errorMessage + " " + getMessage("ipaddress.error.mixedNetworks"));
	}
	public NetworkMismatchException(AddressItem one, AddressItem two) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.mixedNetworks"));
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.Objects;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.AddressGenericDivision;
import inet.ipaddr.format.AddressItem;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.AddressBitsDivision;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv4.IPv4JoinedSegments;
import inet.ipaddr.ipv4.IPv4AddressSeqRange;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6v4MixedAddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
import inet.ipaddr.ipv6.IPv6AddressSeqRange;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
public abstract class AddressComparator implements Comparator<AddressItem> {
	protected final boolean equalsConsistent;
	AddressComparator(boolean equalsConsistent) {
		this.equalsConsistent = equalsConsistent;
	}
	public int compare(Address one, Address two) {
		if(one == two) {
			return 0;
		}
		int result = compare(one.getSection(), two.getSection());
		if(result == 0 && one instanceof IPv6Address) {
			IPv6Address oneIPv6 = (IPv6Address) one;
			IPv6Address twoIPv6 = (IPv6Address) two;
			result = Objects.compare(oneIPv6.getZone(), twoIPv6.getZone(), Comparator.nullsFirst(String::compareTo));
		}
		return result;
	}
	private static int mapGrouping(AddressDivisionSeries series) {
		if(series instanceof IPv6AddressSection) {
			return 6;
		} else if(series instanceof IPv4AddressSection) {
			return 4;
		} else if(series instanceof IPv6v4MixedAddressSection) {
			return 5;
		} else if(series instanceof MACAddressSection) {
			return 3;
		} else if(series instanceof IPAddressDivisionGrouping) {
			return -1;
		} else if(series instanceof IPAddressLargeDivisionGrouping) {
			return -2;
		} else if(series instanceof AddressDivisionGrouping) {
			return -3;
		}
		return 0;
	}
	private static int mapDivision(AddressGenericDivision div) {
		if(div instanceof IPv6AddressSegment) {
			return 4;
		} else if(div instanceof IPv4AddressSegment) {
			return 3;
		} else if(div instanceof MACAddressSegment) {
			return 1;
		} else if(div instanceof IPv4JoinedSegments) {
			return 2;
		} else if(div instanceof IPAddressLargeDivision) {
			return -1;
		} else if(div instanceof IPAddressBitsDivision) {
			return -2;
		} else if(div instanceof AddressBitsDivision) {
			return -3;
		}
		return 0;
	}
	private static int mapRange(IPAddressSeqRange range) {
		if(range instanceof IPv4AddressSeqRange) {
			return 1;
		} else if(range instanceof IPv6AddressSeqRange) {
			return 2;
		} 
		return 0;
	}
	public int compare(AddressSection one, AddressSection two) {
		if(one == two) {
			return 0;
		}
		if(!one.getClass().equals(two.getClass())) {
			int result = mapGrouping(one) - mapGrouping(two);
			if(result != 0) {
				return result;
			}
		}
		if(one instanceof IPv6AddressSection) {
			IPv6AddressSection o1 = (IPv6AddressSection) one;
			IPv6AddressSection o2 = (IPv6AddressSection) two;
			int result = o2.addressSegmentIndex - o1.addressSegmentIndex;
			if(result != 0) {
				return result;
			}
		} else if(one instanceof MACAddressSection) {
			MACAddressSection o1 = (MACAddressSection) one;
			MACAddressSection o2 = (MACAddressSection) two;
			int result = o2.addressSegmentIndex - o1.addressSegmentIndex;
			if(result != 0) {
				return result;
			}
		}
		return compareParts(one, two);
	}
	@Override
	public int compare(AddressItem one, AddressItem two) {
		if(one instanceof AddressDivisionSeries) {
			if(two instanceof AddressDivisionSeries) {
				return compare((AddressDivisionSeries) one, (AddressDivisionSeries) two);
			} else if (equalsConsistent) {
				return 1;
			} else if(one.isMultiple()) {
				AddressDivisionSeries oneSeries = (AddressDivisionSeries) one;
				if(oneSeries.getDivisionCount() > 0) {
					return 1;
				}
				one = oneSeries.getDivision(0);
			}
		}
		if(one instanceof AddressGenericDivision) {
			if(two instanceof AddressGenericDivision) {
				return compare((AddressGenericDivision) one, (AddressGenericDivision) two);
			} else if (equalsConsistent) {
				return -1;
			}
		} else if(one instanceof IPAddressSeqRange) {
			if(two instanceof IPAddressSeqRange) {
				return compare((IPAddressSeqRange) one, (IPAddressSeqRange) two);
			} else if (equalsConsistent) {
				if(two instanceof AddressDivisionSeries) {
					return -1;
				} 
				return 1;
			}
		}
		if (equalsConsistent) {
			if(two instanceof AddressDivisionSeries) {
				return -1;
			} else if(two instanceof AddressGenericDivision) {
				return 1;
			} else if(two instanceof IPAddressSeqRange) {
				return -1;
			}
		}
		if(one == two) {
			return 0;
		}
		if(equalsConsistent) {
			int bitDiff = one.getBitCount() - two.getBitCount();
			if(bitDiff != 0) {
				return bitDiff;
			}
		}
		if(two instanceof AddressDivisionSeries) {
			AddressDivisionSeries twoSeries = (AddressDivisionSeries) two;
			if(two.isMultiple()) {
				if(twoSeries.getDivisionCount() > 0) {
					return 1;
				}
			}
			if(one instanceof AddressGenericDivision) {
				return compare((AddressGenericDivision) one, twoSeries.getDivision(0));
			}
			two = twoSeries.getDivision(0);
		}
		return compareValues(one.getUpperValue(), one.getValue(), two.getUpperValue(), two.getValue());
	}
	public int compare(AddressDivisionSeries one, AddressDivisionSeries two) {
		if(one instanceof Address) {
			if(two instanceof Address) {
				return compare((Address) one, (Address) two);
			} else {
				if(equalsConsistent) {
					return -1;
				}
				one = ((Address) one).getSection();
			}
		} else if(two instanceof Address) {
			if(equalsConsistent) {
				return 1;
			}
			two = ((Address) two).getSection();
		}
		if(one instanceof AddressSection && two instanceof AddressSection) {
			return compare((AddressSection) one, (AddressSection) two);
		}
		if(one == two) {
			return 0;
		}
		if(!one.getClass().equals(two.getClass())) {
			int result = mapGrouping(one) - mapGrouping(two);
			if(result != 0) {
				return result;
			}
		}
		return compareParts(one, two);
	}
	protected static int compareDivBitCounts(AddressDivisionSeries oneSeries, AddressDivisionSeries twoSeries) {
		int count = oneSeries.getDivisionCount();
		int result = count - twoSeries.getDivisionCount();
		if(result == 0) {
			for(int i = 0; i < count; i++) {
				result = oneSeries.getDivision(i).getBitCount() - twoSeries.getDivision(i).getBitCount();
				if(result != 0) {
					break;
				}
			}
		}
		return result;
	}
	public int compare(AddressSegment one, AddressSegment two) {
		if(one == two) {
			return 0;
		}
		if(!one.getClass().equals(two.getClass())) {
			int result = mapDivision(one) - mapDivision(two);
			if(result != 0) {
				return result;
			}
		}
		return compareValues(one.getUpperSegmentValue(), one.getSegmentValue(), two.getUpperSegmentValue(), two.getSegmentValue());
	}
	public int compare(IPAddressSeqRange one, IPAddressSeqRange two) {
		if(one == two) {
			return 0;
		}
		if(!one.getClass().equals(two.getClass())) {
			int result = mapRange(one) - mapRange(two);
			if(result != 0) {
				return result;
			}
		}
		if(one instanceof IPv4AddressSeqRange && two instanceof IPv4AddressSeqRange) {
			IPv4AddressSeqRange gOne = (IPv4AddressSeqRange) one;
			IPv4AddressSeqRange gTwo = (IPv4AddressSeqRange) two;
			return compareValues(gOne.getUpper().longValue(), gOne.getLower().longValue(), gTwo.getUpper().longValue(), gTwo.getLower().longValue());
		}
		return compareValues(one.getUpperValue(), one.getValue(), two.getUpperValue(), two.getValue());
	}
	public int compare(AddressGenericDivision one, AddressGenericDivision two) {
		if(one instanceof AddressSegment && two instanceof AddressSegment) {
			return compare((AddressSegment) one, (AddressSegment) two);
		}
		if(one == two) {
			return 0;
		}
		if(!one.getClass().equals(two.getClass())) {
			int result = mapDivision(one) - mapDivision(two);
			if(result != 0) {
				return result;
			}
		}
		if(equalsConsistent) {
			int bitDiff = one.getBitCount() - two.getBitCount();
			if(bitDiff != 0) {
				return bitDiff;
			}
		}
		if(one instanceof AddressDivision && two instanceof AddressDivision) {
			AddressDivision gOne = (AddressDivision) one;
			AddressDivision gTwo = (AddressDivision) two;
			return compareValues(gOne.getUpperDivisionValue(), gOne.getDivisionValue(), gTwo.getUpperDivisionValue(), gTwo.getDivisionValue());
		}
		return compareValues(one.getUpperValue(), one.getValue(), two.getUpperValue(), two.getValue());
	}
	protected abstract int compareParts(AddressDivisionSeries one, AddressDivisionSeries two);
	protected abstract int compareParts(AddressSection one, AddressSection two);
	protected abstract int compareValues(BigInteger oneUpper, BigInteger oneLower, BigInteger twoUpper, BigInteger twoLower);
	protected abstract int compareValues(long oneUpper, long oneLower, long twoUpper, long twoLower);
	protected abstract int compareValues(int oneUpper, int oneLower, int twoUpper, int twoLower);
	static int convertResult(long v) {
		return v == 0 ? 0 : (v > 0 ? 1 : -1);
	}
	public static class ValueComparator extends AddressComparator {
		private final boolean compareHighValue, flipSecond;
		public ValueComparator(boolean compareHighValue) {
			this(true, compareHighValue);
		}
		public ValueComparator(boolean equalsConsistent, boolean compareHighValue) {
			this(true, compareHighValue, false);
		}
		public ValueComparator(boolean equalsConsistent, boolean compareHighValue, boolean flipSecond) {
			super(equalsConsistent);
			this.compareHighValue = compareHighValue;
			this.flipSecond = flipSecond;
		}
		@Override
		protected int compareParts(AddressSection one, AddressSection two) {
			int sizeResult = one.getByteCount() - two.getByteCount();
			if(sizeResult != 0) {
				return sizeResult;
			}
			boolean compareHigh = compareHighValue;
			do {
				int result = compareSegmentValues(compareHigh, one, two);
				if(result != 0) {
					if(flipSecond && compareHigh != compareHighValue) {
						return -result;
					}
					return result;
				}
				compareHigh = !compareHigh;
			} while(compareHigh != compareHighValue);
			return 0;
		}
		@Override
		protected int compareParts(AddressDivisionSeries oneSeries, AddressDivisionSeries twoSeries) {
			int sizeResult = oneSeries.getBitCount() - twoSeries.getBitCount();
			if(sizeResult != 0) {
				return sizeResult;
			}
			if(equalsConsistent || oneSeries.isMultiple() || twoSeries.isMultiple()) {
				int result = compareDivBitCounts(oneSeries, twoSeries);
				if(result != 0) {
					return result;
				}
			}
			boolean compareHigh = compareHighValue;
			AddressDivisionGrouping one, two;
			if(oneSeries instanceof AddressDivisionGrouping && twoSeries instanceof AddressDivisionGrouping) {
				one = (AddressDivisionGrouping) oneSeries;
				two = (AddressDivisionGrouping) twoSeries;
			} else {
				one = two = null;
			}
			int oneSeriesByteCount = oneSeries.getByteCount(), twoSeriesByteCount = twoSeries.getByteCount();
			byte oneBytes[] = new byte[oneSeriesByteCount], twoBytes[] = new byte[twoSeriesByteCount];
			do {
				int oneTotalBitCount, twoTotalBitCount, oneByteCount, twoByteCount, oneByteIndex, twoByteIndex;
				oneByteIndex = twoByteIndex = oneByteCount = twoByteCount = oneTotalBitCount = twoTotalBitCount = 0;
				int oneBitCount, twoBitCount, oneIndex, twoIndex;
				oneBitCount = twoBitCount = oneIndex = twoIndex = 0;
				long oneValue, twoValue;
				oneValue = twoValue = 0;
				while(oneIndex < oneSeries.getDivisionCount() || twoIndex < twoSeries.getDivisionCount()) {
					if(one != null) {
						if(oneBitCount == 0) {
							AddressDivision oneCombo = one.getDivision(oneIndex++);
							oneBitCount = oneCombo.getBitCount();
							oneValue = compareHigh ? oneCombo.getUpperDivisionValue() : oneCombo.getDivisionValue();
						}
						if(twoBitCount == 0) {
							AddressDivision twoCombo = two.getDivision(twoIndex++);
							twoBitCount = twoCombo.getBitCount();
							twoValue = compareHigh ? twoCombo.getUpperDivisionValue() : twoCombo.getDivisionValue();
						}
					} else {
						if(oneBitCount == 0) {
							if(oneByteCount == 0) {
								AddressGenericDivision oneCombo = oneSeries.getDivision(oneIndex++);
								oneBytes = compareHigh ? oneCombo.getUpperBytes(oneBytes) : oneCombo.getBytes(oneBytes);
								oneTotalBitCount = oneCombo.getBitCount();
								oneByteCount = oneCombo.getByteCount();
								oneByteIndex = 0;
							}
							int count = Long.BYTES - 1;
							oneValue = 0;
							if(count < oneByteCount) {
								oneBitCount = count << 3;
								oneTotalBitCount -= oneBitCount;
								oneByteCount -= count;
								while(count-- > 0) {
									oneValue = (oneValue << Byte.SIZE) | oneBytes[oneByteIndex++];
								}
							} else {
								int shortCount = oneByteCount - 1;
								int lastBitsCount = oneTotalBitCount - (shortCount << 3);
								while(shortCount-- > 0) {
									oneValue = (oneValue << Byte.SIZE) | oneBytes[oneByteIndex++];
								}
								oneValue = (oneValue << lastBitsCount) | (oneBytes[oneByteIndex++] >>> (Byte.SIZE - lastBitsCount));
								oneBitCount = oneTotalBitCount;
								oneTotalBitCount = oneByteCount = 0;
							}
						}
						if(twoBitCount == 0) {
							if(twoByteCount == 0) {
								AddressGenericDivision twoCombo = twoSeries.getDivision(twoIndex++);
								twoBytes = compareHigh ? twoCombo.getUpperBytes(twoBytes) : twoCombo.getBytes(twoBytes);
								twoTotalBitCount = twoCombo.getBitCount();
								twoByteCount = twoCombo.getByteCount();
								twoByteIndex = 0;
							}
							int count = Long.BYTES - 1;
							twoValue = 0;
							if(count < twoByteCount) {
								twoBitCount = count << 3;
								twoTotalBitCount -= twoBitCount;
								twoByteCount -= count;
								while(count-- > 0) {
									twoValue = (twoValue << Byte.SIZE) | twoBytes[twoByteIndex++];
								}
							} else {
								int shortCount = twoByteCount - 1;
								int lastBitsCount = twoTotalBitCount - (shortCount << 3);
								while(shortCount-- > 0) {
									twoValue = (twoValue << Byte.SIZE) | twoBytes[twoByteIndex++];
								}
								twoValue = (twoValue << lastBitsCount) | (twoBytes[twoByteIndex++] >>> (Byte.SIZE - lastBitsCount));
								twoBitCount = twoTotalBitCount;
								twoTotalBitCount = twoByteCount = 0;
							}
						}
					}
					long oneResultValue = oneValue, twoResultValue = twoValue;
					if(twoBitCount == oneBitCount) {
						oneBitCount = twoBitCount = 0;
					} else {
						int diffBits = twoBitCount - oneBitCount;
						if(diffBits > 0) {
							twoResultValue >>= diffBits;
							twoValue &= ~(~0L << diffBits);
							twoBitCount = diffBits;
							oneBitCount = 0;
						} else {
							diffBits = -diffBits;
							oneResultValue >>= diffBits;
							oneValue &= ~(~0L << diffBits); 
							oneBitCount = diffBits;
							twoBitCount = 0;
						}
					}
					long result = oneResultValue - twoResultValue;
					if(result != 0) {
						if(flipSecond && compareHigh != compareHighValue) {
							result = -result;
						}
						return convertResult(result);
					}
				}
				compareHigh = !compareHigh;
			} while(compareHigh != compareHighValue);
			return 0;
		}
		@Override
		protected int compareValues(BigInteger oneUpper, BigInteger oneLower, BigInteger twoUpper, BigInteger twoLower) {
			int result;
			if(compareHighValue) {
				result = oneUpper.compareTo(twoUpper);
				if(result == 0) {
					result = oneLower.compareTo(twoLower);
					if(flipSecond) {
						result = -result;
					}
				}
			} else {
				result = oneLower.compareTo(twoLower);
				if(result == 0) {
					result = oneUpper.compareTo(twoUpper);
					if(flipSecond) {
						result = -result;
					}
				}
			}
			return convertResult(result);
		}
		@Override
		protected int compareValues(long oneUpper, long oneLower, long twoUpper, long twoLower) {
			long result;
			if(compareHighValue) {
				result = oneUpper - twoUpper;
				if(result == 0) {
					result = oneLower - twoLower;
					if(flipSecond) {
						result = -result;
					}
				}
			} else {
				result = oneLower - twoLower;
				if(result == 0) {
					result = oneUpper - twoUpper;
					if(flipSecond) {
						result = -result;
					}
				}
			}
			return convertResult(result);
		}
		@Override
		protected int compareValues(int oneUpper, int oneLower, int twoUpper, int twoLower) {
			int result;
			if(compareHighValue) {
				result = oneUpper - twoUpper;
				if(result == 0) {
					result = oneLower - twoLower;
					if(flipSecond) {
						result = -result;
					}
				}
			} else {
				result = oneLower - twoLower;
				if(result == 0) {
					result = oneUpper - twoUpper;
					if(flipSecond) {
						result = -result;
					}
				}
			}
			return result;
		}
	}
	public static class CountComparator extends AddressComparator {
		public CountComparator() {
			this(true);
		}
		public CountComparator(boolean equalsConsistent) {
			super(equalsConsistent);
		}
		private static int compareCount(AddressDivisionSeries one, AddressDivisionSeries two) {
			return one.isMore(two);
		}
		@Override
		protected int compareParts(AddressSection one, AddressSection two) {
			int result = one.getBitCount() - two.getBitCount();
			if(result == 0) {
				result = compareCount(one, two);
				if(result == 0) {
					result = compareEqualSizedSections(one, two);
				}
			}
			return result;
		}
		@Override
		protected int compareParts(AddressDivisionSeries one, AddressDivisionSeries two) {
			int result = one.getBitCount() - two.getBitCount();
			if(result == 0) {
				result = compareCount(one, two);
				if(result == 0) {
					result = compareDivisionGroupings(one, two);
				}
			}
			return result;
		}
		private int compareDivisionGroupings(AddressDivisionSeries oneSeries, AddressDivisionSeries twoSeries) {
			AddressDivisionGrouping one, two;
			if(oneSeries instanceof AddressDivisionGrouping && twoSeries instanceof AddressDivisionGrouping) {
				one = (AddressDivisionGrouping) oneSeries;
				two = (AddressDivisionGrouping) twoSeries;
			} else {
				one = two = null;
			}
			if(equalsConsistent || oneSeries.isMultiple() || twoSeries.isMultiple()) {
				int result = compareDivBitCounts(oneSeries, twoSeries);
				if(result != 0) {
					return result;
				}
			}
			int oneSeriesByteCount = oneSeries.getByteCount(), twoSeriesByteCount = twoSeries.getByteCount();
			byte oneUpperBytes[] = new byte[oneSeriesByteCount], oneLowerBytes[] = new byte[oneSeriesByteCount], 
					twoUpperBytes[] = new byte[twoSeriesByteCount], twoLowerBytes[] = new byte[twoSeriesByteCount];
			int oneTotalBitCount, twoTotalBitCount, oneByteCount, twoByteCount, oneByteIndex, twoByteIndex;
			oneByteIndex = twoByteIndex = oneByteCount = twoByteCount = oneTotalBitCount = twoTotalBitCount = 0;
			int oneBitCount, twoBitCount, oneIndex, twoIndex;
			oneBitCount = twoBitCount = oneIndex = twoIndex = 0;
			long oneUpper, oneLower, twoUpper, twoLower;
			oneUpper = oneLower = twoUpper = twoLower = 0;
			while(oneIndex < oneSeries.getDivisionCount() || twoIndex < twoSeries.getDivisionCount()) {
				if(one != null) {
					if(oneBitCount == 0) {
						AddressDivision oneCombo = one.getDivision(oneIndex++);
						oneBitCount = oneCombo.getBitCount();
						oneUpper = oneCombo.getUpperDivisionValue();
						oneLower = oneCombo.getDivisionValue();
					}
					if(twoBitCount == 0) {
						AddressDivision twoCombo = two.getDivision(twoIndex++);
						twoBitCount = twoCombo.getBitCount();
						twoUpper = twoCombo.getUpperDivisionValue();
						twoLower = twoCombo.getDivisionValue();
					}
				} else {
					if(oneBitCount == 0) {
						if(oneByteCount == 0) {
							AddressGenericDivision oneCombo = oneSeries.getDivision(oneIndex++);
							oneUpperBytes = oneCombo.getUpperBytes(oneUpperBytes);
							oneLowerBytes = oneCombo.getBytes(oneLowerBytes);
							oneTotalBitCount = oneCombo.getBitCount();
							oneByteCount = oneCombo.getByteCount();
							oneByteIndex = 0;
						}
						int count = Long.BYTES - 1;
						oneUpper = oneLower = 0;
						if(count < oneByteCount) {
							oneBitCount = count << 3;
							oneTotalBitCount -= oneBitCount;
							oneByteCount -= count;
							while(count-- > 0) {
								byte upperByte = oneUpperBytes[oneByteIndex];
								byte lowerByte = oneLowerBytes[oneByteIndex++];
								oneUpper = (oneUpper << Byte.SIZE) | upperByte;
								oneLower = (oneLower << Byte.SIZE) | lowerByte;
							}
						} else {
							int shortCount = oneByteCount - 1;
							int lastBitsCount = oneTotalBitCount - (shortCount << 3);
							while(shortCount-- > 0) {
								byte upperByte = oneUpperBytes[oneByteIndex];
								byte lowerByte = oneLowerBytes[oneByteIndex++];
								oneUpper = (oneUpper << Byte.SIZE) | upperByte;
								oneLower = (oneLower << Byte.SIZE) | lowerByte;
							}
							byte upperByte = oneUpperBytes[oneByteIndex];
							byte lowerByte = oneLowerBytes[oneByteIndex++];
							oneUpper = (oneUpper << lastBitsCount) | (upperByte >>> (Byte.SIZE - lastBitsCount));
							oneLower = (oneLower << lastBitsCount) | (lowerByte >>> (Byte.SIZE - lastBitsCount));
							oneBitCount = oneTotalBitCount;
							oneTotalBitCount = oneByteCount = 0;
						}
					}
					if(twoBitCount == 0) {
						if(twoByteCount == 0) {
							AddressGenericDivision twoCombo = twoSeries.getDivision(twoIndex++);
							twoUpperBytes = twoCombo.getUpperBytes(twoUpperBytes);
							twoLowerBytes = twoCombo.getBytes(twoLowerBytes);
							twoTotalBitCount = twoCombo.getBitCount();
							twoByteCount = twoCombo.getByteCount();
							twoByteIndex = 0;
						}
						int count = Long.BYTES - 1;
						twoUpper = twoLower = 0;
						if(count < twoByteCount) {
							twoBitCount = count << 3;
							twoTotalBitCount -= twoBitCount;
							twoByteCount -= count;
							while(count-- > 0) {
								byte upperByte = twoUpperBytes[twoByteIndex];
								byte lowerByte = twoLowerBytes[twoByteIndex++];
								twoUpper = (twoUpper << Byte.SIZE) | upperByte;
								twoLower = (twoLower << Byte.SIZE) | lowerByte;
							}
						} else {
							int shortCount = twoByteCount - 1;
							int lastBitsCount = twoTotalBitCount - (shortCount << 3);
							while(shortCount-- > 0) {
								byte upperByte = twoUpperBytes[twoByteIndex];
								byte lowerByte = twoLowerBytes[twoByteIndex++];
								twoUpper = (twoUpper << Byte.SIZE) | upperByte;
								twoLower = (twoLower << Byte.SIZE) | lowerByte;
							}
							byte upperByte = twoUpperBytes[twoByteIndex];
							byte lowerByte = twoLowerBytes[twoByteIndex++];
							twoUpper = (twoUpper << lastBitsCount) | (upperByte >>> (Byte.SIZE - lastBitsCount));
							twoLower = (twoLower << lastBitsCount) | (lowerByte >>> (Byte.SIZE - lastBitsCount));
							twoBitCount = twoTotalBitCount;
							twoTotalBitCount = twoByteCount = 0;
						}
					}
				}
				long oneResultUpper = oneUpper, oneResultLower = oneLower, twoResultUpper = twoUpper, twoResultLower = twoLower;
				if(twoBitCount == oneBitCount) {
					oneBitCount = twoBitCount = 0;
				} else {
					int diffBits = twoBitCount - oneBitCount;
					if(diffBits > 0) {
						twoResultUpper >>>= diffBits;
						twoResultLower >>>= diffBits;
						long mask = ~(~0L << diffBits);
						twoUpper &= mask;
						twoLower &= mask;
						twoBitCount = diffBits;
						oneBitCount = 0;
					} else {
						diffBits = -diffBits;
						oneResultUpper >>>= diffBits;
						oneResultLower >>>= diffBits;
						long mask = ~(~0L << diffBits);
						oneUpper &= mask;
						oneLower &= mask;
						oneBitCount = diffBits;
						twoBitCount = 0;
					}
				}
				int result = compareValues(oneResultUpper, oneResultLower, twoResultUpper, twoResultLower);
				if(result != 0) {
					return result;
				}
			}
			return 0;
		}
		protected int compareEqualSizedSections(AddressSection one, AddressSection two) {
			int segCount = one.getSegmentCount();
			for(int i = 0; i < segCount; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneUpper = segOne.getUpperSegmentValue();
				int twoUpper = segTwo.getUpperSegmentValue();
				int oneLower = segOne.getSegmentValue();
				int twoLower = segTwo.getSegmentValue();
				int result = compareValues(oneUpper, oneLower, twoUpper, twoLower);
				if(result != 0) {
					return result;
				}
			}
			return 0;
		}
		@Override
		protected int compareValues(int oneUpper, int oneLower, int twoUpper, int twoLower) {
			int result = (oneUpper - oneLower) - (twoUpper - twoLower);
			if(result == 0) {
				result = oneLower - twoLower;
			}
			return result;
		}
		@Override
		protected int compareValues(long oneUpper, long oneLower, long twoUpper, long twoLower) {
			long size1 = oneUpper - oneLower;
			long size2 = twoUpper - twoLower;
			if(size1 == size2) {
				if(oneLower == twoLower) {
					return 0;
				} else if(oneLower > twoLower) {
					return 1;
				}
			} else if(size1 > size2) {
				return 1;
			}
			return -1;
		}
		@Override
		protected int compareValues(BigInteger oneUpper, BigInteger oneLower, BigInteger twoUpper, BigInteger twoLower) {
			BigInteger oneCount = oneUpper.subtract(oneLower);
			BigInteger twoCount = twoUpper.subtract(twoLower);
			int result = oneCount.compareTo(twoCount);
			if(result == 0) {
				result = oneLower.compareTo(twoLower);
			}
			return result;
		}
	}
	static int compareSegmentValues(boolean compareUpper, AddressSection one, AddressSection two) {
		int segCount = one.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			AddressSegment segOne = one.getSegment(i);
			AddressSegment segTwo = two.getSegment(i);
			int s1, s2;
			if(compareUpper) {
				s1 = segOne.getUpperSegmentValue();
				s2 = segTwo.getUpperSegmentValue();
			} else {
				s1 = segOne.getSegmentValue();
				s2 = segTwo.getSegmentValue();
			}
			if(s1 != s2) {
				if(s1 > s2) {
					return 1;
				}
				return -1;
			}
		}
		return 0;
	}
}