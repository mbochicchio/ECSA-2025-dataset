package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class ModuleRequestQueue extends ModuleBase implements BaseInfoProvider {
    RequestQueue requestQueueInterface;
    @NonNull String appKey;
    @NonNull String serverURL;
    //app crawlers
    private boolean shouldIgnoreCrawlers = true;//ignore app crawlers by default
    private boolean deviceIsAppCrawler = false;//by default assume that device is not a app crawler
    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")
    private final List<String> appCrawlerNames = new ArrayList<>(Arrays.asList("Calypso AppCrawler"));//List against which device name is checked to determine if device is app crawler
    static final String APP_KEY_KEY = "app_key";
    static final String HOUR_KEY = "hour";
    static final String DOW_KEY = "dow";
    static final String TZ_KEY = "tz";
    static final String SDK_VERSION_KEY = "sdk_version";
    static final String SDK_NAME_KEY = "sdk_name";
    static final String DEVICE_ID_KEY = "device_id";
    static final String OLD_DEVICE_ID_KEY = "old_device_id";
    static final String CHECKSUM_KEY = "checksum";
    static final String CHECKSUM_256_KEY = "checksum256";
    String[] preDefinedKeys = { APP_KEY_KEY, HOUR_KEY, DOW_KEY, TZ_KEY, SDK_VERSION_KEY, SDK_NAME_KEY, DEVICE_ID_KEY, OLD_DEVICE_ID_KEY, CHECKSUM_KEY, CHECKSUM_256_KEY };
    ModuleRequestQueue(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRequestQueue] Initialising");
        config.baseInfoProvider = this;
        baseInfoProvider = this;
        appKey = config.appKey;
        serverURL = config.serverURL;
        //app crawler check
        if (config.shouldIgnoreAppCrawlers) {
            L.d("[ModuleRequestQueue] Ignoring app crawlers");
            shouldIgnoreCrawlers = config.shouldIgnoreAppCrawlers;
        }
        if (config.appCrawlerNames != null) {
            L.d("[ModuleRequestQueue] Adding app crawlers names");
            appCrawlerNames.addAll(Arrays.asList(config.appCrawlerNames));
        }
        checkIfDeviceIsAppCrawler();
        requestQueueInterface = new RequestQueue();
    }
    @Override public @NonNull String getAppKey() {
        return appKey;
    }
    @Override public @NonNull String getServerURL() {
        return serverURL;
    }
    synchronized List<String> requestQueueReplaceWithAppKey(String[] storedRequests, String targetAppKey) {
        try {
            List<String> filteredRequests = new ArrayList<>();
            if (storedRequests == null) {
                //early abort
                L.w("[ModuleRequestQueue] requestQueueReplaceWithAppKey, stopping replacing due to stored requests being 'null'");
                return filteredRequests;
            }
            if (targetAppKey == null || targetAppKey.isEmpty()) {
                //early abort
                L.w("[ModuleRequestQueue] requestQueueReplaceWithAppKey, stopping replacing due to target app key being 'null' or empty string");
                return filteredRequests;
            }
            String replacementPart = "app_key=" + UtilsNetworking.urlEncodeString(targetAppKey);
            for (String storedRequest : storedRequests) {
                if (storedRequest == null) {
                    continue;
                }
                boolean found = false;
                String[] parts = storedRequest.split("&");
                for (int b = 0; b < parts.length; b++) {
                    if (parts[b].contains("app_key=")) {
                        parts[b] = replacementPart;
                        found = true;
                        break;
                    }
                }
                //recombine and add
                StringBuilder stringBuilder = new StringBuilder(storedRequest.length());//todo make the lenght larger to take into account the app key size increase
                for (int c = 0; c < parts.length; c++) {
                    if (c != 0) {
                        stringBuilder.append("&");
                    }
                    stringBuilder.append(parts[c]);
                }
                filteredRequests.add(stringBuilder.toString());
            }
            return filteredRequests;
        } catch (Exception ex) {
            //in case of failure, abort
            L.e("[ModuleRequestQueue] Failed while overwriting appKeys, " + ex.toString());
            return null;
        }
    }
    synchronized List<String> requestQueueRemoveWithoutAppKey(String[] storedRequests, String targetAppKey) {
        List<String> filteredRequests = new ArrayList<>();
        if (storedRequests == null || targetAppKey == null) {
            //early abort
            return filteredRequests;
        }
        String searchablePart = "app_key=" + targetAppKey;
        for (String storedRequest : storedRequests) {
            if (storedRequest == null) {
                continue;
            }
            if (!storedRequest.contains(searchablePart)) {
                L.d("[ModuleRequestQueue] requestQueueEraseAppKeysRequests, Found a entry to remove: [" + storedRequest + "]");
            } else {
                filteredRequests.add(storedRequest);
            }
        }
        return filteredRequests;
    }
    /**
     * Check if events from event queue need to be added to the request queue
     * They will be sent either if the exceed the Threshold size or if their sending is forced
     */
    protected void sendEventsIfNeeded(boolean forceSendingEvents) {
        int eventsInEventQueue = storageProvider.getEventQueueSize();
        L.v("[ModuleRequestQueue] forceSendingEvents, forced:[" + forceSendingEvents + "], event count:[" + eventsInEventQueue + "]");
        if ((forceSendingEvents && eventsInEventQueue > 0) || eventsInEventQueue >= _cly.EVENT_QUEUE_SIZE_THRESHOLD) {
            requestQueueProvider.recordEvents(storageProvider.getEventsForRequestAndEmptyEventQueue());
        }
    }
    boolean isHttpPostForcedInternal() {
        return _cly.isHttpPostForced;
    }
    boolean isDeviceAppCrawlerInternal() {
        return deviceIsAppCrawler;
    }
    boolean ifShouldIgnoreCrawlersInternal() {
        return shouldIgnoreCrawlers;
    }
    private void checkIfDeviceIsAppCrawler() {
        String deviceName = deviceInfo.mp.getDevice();
        for (int a = 0; a < appCrawlerNames.size(); a++) {
            if (deviceName.equals(appCrawlerNames.get(a))) {
                deviceIsAppCrawler = true;
                return;
            }
        }
    }
    public void flushQueuesInternal() {
        CountlyStore store = _cly.countlyStore;
        final String[] storedRequests = store.getRequests();
        store.replaceRequests(new String[] {});
        L.d("[ModuleRequestQueue] flushRequestQueues removed [" + storedRequests.length + "] requests");
    }
    /**
     * Combine all events in event queue into a request and
     * attempt to process stored requests on demand
     */
    public void attemptToSendStoredRequestsInternal() {
        L.i("[ModuleRequestQueue] Calling attemptToSendStoredRequests");
        //combine all available events into a request
        sendEventsIfNeeded(true);
        //save the user profile changes if any
        _cly.moduleUserProfile.saveInternal();
        //trigger the processing of the request queue
        requestQueueProvider.tick();
    }
    /**
     * Go through the request queue and replace the appKey of all requests with the current appKey
     */
    synchronized public void requestQueueOverwriteAppKeysInternal() {
        L.i("[ModuleRequestQueue] Calling requestQueueOverwriteAppKeys");
        List<String> filteredRequests = requestQueueReplaceWithAppKey(storageProvider.getRequests(), baseInfoProvider.getAppKey());
        if (filteredRequests != null) {
            storageProvider.replaceRequestList(filteredRequests);
            attemptToSendStoredRequestsInternal();
        }
    }
    /**
     * Go through the request queue and delete all requests that don't have the current application key
     */
    synchronized public void requestQueueEraseAppKeysRequestsInternal() {
        L.i("[ModuleRequestQueue] Calling requestQueueEraseAppKeysRequests");
        List<String> filteredRequests = requestQueueRemoveWithoutAppKey(storageProvider.getRequests(), baseInfoProvider.getAppKey());
        storageProvider.replaceRequestList(filteredRequests);
        attemptToSendStoredRequestsInternal();
    }
    /**
     * Send request data after removing the predefined keys
     */
    synchronized public void addDirectRequestInternal(@NonNull Map<String, String> requestMap) {
        long pccTsStartAddDirectRequest = 0L;
        if (pcc != null) {
            pccTsStartAddDirectRequest = UtilsTime.getNanoTime();
        }
        L.i("[ModuleRequestQueue] Calling addDirectRequestInternal");
        if (!_cly.isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before adding direct request, returning");
            return;
        }
        if (!consentProvider.anyConsentGiven()) {
            L.e("[ModuleRequestQueue] addDirectRequest, no consent is given, returning");
            return;
        }
        if (requestMap == null || requestMap.isEmpty()) {
            L.e("[ModuleRequestQueue] addDirectRequest, provided requestMap was null or empty, returning");
            return;
        }
        // Filtering and removing predefined/restricted keys
        Map<String, String> filteredRequestMap = new HashMap<>();
        for (Map.Entry<String, String> entry : requestMap.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            boolean isPreDefinedKey = false;
            for (String preDefinedKey : preDefinedKeys) {
                if (preDefinedKey.equals(key)) {
                    //if it's a predefined field
                    isPreDefinedKey = true;
                    L.w("[ModuleRequestQueue] addDirectRequest, removing provided key: [" + key + "] is a restricted key.");
                    break;
                }
            }
            if (!isPreDefinedKey) {
                filteredRequestMap.put(key, value.toString());
            }
        }
        if (filteredRequestMap.isEmpty()) {
            L.e("[ModuleRequestQueue] addDirectRequest, filteredRequestMap was null or empty, returning");
            return;
        }
        int requestDataCount = requestMap.size();
        int filteredDataCount = filteredRequestMap.size();
        int delta = requestDataCount - filteredDataCount;
        if (delta > 0) {
            L.w("[ModuleRequestQueue] addDirectRequest, [" + delta + "] restricted keys are removed");
        }
        requestQueueProvider.sendDirectRequest(filteredRequestMap);
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ModuleRequestQueue_addDirectRequestInternal", UtilsTime.getNanoTime() - pccTsStartAddDirectRequest);
        }
    }
    void esWriteCachesToPersistenceInternal(@Nullable ExplicitStorageCallback callback) {
        L.i("[ModuleRequestQueue] Calling esWriteCachesToPersistenceInternal");
        storageProvider.esWriteCacheToStorage(callback);
    }
    boolean doesBelongToCurrentAppKeyOrDeviceId(@NonNull String request) {
        return request.contains(APP_KEY_KEY + "=" + baseInfoProvider.getAppKey()) && request.contains(DEVICE_ID_KEY + "=" + deviceIdProvider.getDeviceId());
    }
    @Override
    void halt() {
        requestQueueInterface = null;
    }
    public class RequestQueue {
        /**
         * Get the status of the override for HTTP POST
         *
         * @return return "true" if HTTP POST ir forced
         */
        public boolean isHttpPostForced() {
            synchronized (_cly) {
                L.v("[RequestQueue] Calling 'isHttpPostForced'");
                return isHttpPostForcedInternal();
            }
        }
        /**
         * Return if current device is detected as a app crawler
         *
         * @return returns if devices is detected as a app crawler
         */
        public boolean isDeviceAppCrawler() {
            synchronized (_cly) {
                L.v("[RequestQueue] Calling 'isDeviceAppCrawler'");
                return isDeviceAppCrawlerInternal();
            }
        }
        /**
         * Return if the countly sdk should ignore app crawlers
         */
        public boolean ifShouldIgnoreCrawlers() {
            synchronized (_cly) {
                L.v("[RequestQueue] Calling 'ifShouldIgnoreCrawlers'");
                return ifShouldIgnoreCrawlersInternal();
            }
        }
        /**
         * Deletes all stored requests to server.
         * This includes events, crashes, views, sessions, etc
         * Call only if you don't need that information
         */
        public void flushQueues() {
            synchronized (_cly) {
                L.v("[RequestQueue] Calling 'flushQueues'");
                flushQueuesInternal();
            }
        }
        /**
         * Combine all events in event queue into a request and
         * attempt to process stored requests on demand
         */
        public void attemptToSendStoredRequests() {
            synchronized (_cly) {
                L.v("[RequestQueue] Calling 'attemptToSendStoredRequestsInternal'");
                attemptToSendStoredRequestsInternal();
            }
        }
        /**
         * Go through the request queue and replace the appKey of all requests with the current appKey
         */
        public void overwriteAppKeys() {
            synchronized (_cly) {
                L.i("[Countly] Calling overwriteAppKeys");
                requestQueueOverwriteAppKeysInternal();
            }
        }
        /**
         * Go through the request queue and delete all requests that don't have the current application key
         */
        public void eraseWrongAppKeyRequests() {
            synchronized (_cly) {
                L.i("[Countly] Calling eraseWrongAppKeyRequests");
                requestQueueEraseAppKeysRequestsInternal();
            }
        }
        /**
         * This call is for creating custom manual requests that should be sent to the server.
         * The SDK will add base parameters like "device id", "app key", timestamps, checksums etc.
         * It is not possible to override those protected values.
         *
         * The SDK will take the provided request map and add those as key value pairs to the request.
         * The provided pairs will be html encoded before they are added to the request, therefore you
         * have to be sure not to encode them.
         *
         * If consent is being required, this call will check if any consent is given, but will not check further.
         * It is up to this calls user to make sure that they have the required consent to record the things they are trying to record.
         *
         * This call should not be used lightly and should only be used if the SDK misses some specific functionality.
         */
        public void addDirectRequest(@NonNull Map<String, String> requestMap) {
            synchronized (_cly) {
                L.i("[Countly] Calling addDirectRequest");
                addDirectRequestInternal(requestMap);
            }
        }
        /**
         * Call for the explicit storage mode.
         * Writes temporary memory caches to persistent storage.
         * This involves the Request queue and event queue.
         */
        public void esWriteCachesToPersistence() {
            synchronized (_cly) {
                L.i("[Countly] Calling esWriteCachesToStorage");
                esWriteCachesToPersistenceInternal(null);
            }
        }
        public void esWriteCachesToPersistence(@Nullable ExplicitStorageCallback callback) {
            synchronized (_cly) {
                L.i("[Countly] Calling esWriteCachesToStorage");
                esWriteCachesToPersistenceInternal(callback);
            }
        }
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.content.res.Configuration;
import androidx.annotation.NonNull;
import java.util.List;
abstract class ModuleBase {
    final Countly _cly;
    ModuleLog L;
    ConsentProvider consentProvider;
    StorageProvider storageProvider;
    EventProvider eventProvider;
    RequestQueueProvider requestQueueProvider;
    DeviceIdProvider deviceIdProvider;
    BaseInfoProvider baseInfoProvider;
    ViewIdProvider viewIdProvider;
    ConfigurationProvider configProvider;
    HealthTracker healthTracker;
    DeviceInfo deviceInfo;
    PerformanceCounterCollector pcc;
    ModuleBase(@NonNull Countly cly, @NonNull CountlyConfig config) {
        _cly = cly;
        L = cly.L;
        consentProvider = config.consentProvider;
        storageProvider = config.storageProvider;
        eventProvider = config.eventProvider;
        requestQueueProvider = config.requestQueueProvider;
        deviceIdProvider = config.deviceIdProvider;
        baseInfoProvider = config.baseInfoProvider;
        viewIdProvider = config.viewIdProvider;
        configProvider = config.configProvider;
        healthTracker = config.healthTracker;
        deviceInfo = config.deviceInfo;
        pcc = config.pcc;
    }
    void halt() {
        throw new UnsupportedOperationException();
    }
    /**
     * Called manually by a countly call from the developer
     *
     * @param newConfig
     */
    void onConfigurationChanged(Configuration newConfig) {
    }
    /**
     * Called manually by a countly call from the developer
     */
    void onActivityStarted(Activity activity, int updatedActivityCount) {
    }
    /**
     * Called manually by a countly call from the developer
     */
    void onActivityStopped(int updatedActivityCount) {
    }
    //void callbackOnActivityCreated(Activity activity) {
    //}
    //
    //void callbackOnActivityStarted(Activity activity) {
    //}
    //
    void callbackOnActivityResumed(Activity activity) {
    }
    //
    //void callbackOnActivityPaused(Activity activity) {
    //}
    //
    void callbackOnActivityStopped(Activity activity) {
    }
    //
    //void callbackOnActivitySaveInstanceState(Activity activity) {
    //}
    //
    //void callbackOnActivityDestroyed(Activity activity) {
    //}
    //notify the SDK modules that the device ID has changed
    void deviceIdChanged(boolean withoutMerge) {
    }
    //notify the SDK modules that consent was updated
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
    }
    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {
    }
    //notify the SDK modules that internal configuration was updated
    void sdkConfigurationChanged() {
    }
    void initFinished(@NonNull CountlyConfig config) {
    }
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Application;
import android.content.ComponentCallbacks;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.lifecycle.Lifecycle;
import androidx.lifecycle.ProcessLifecycleOwner;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
/**
 * This class is the public API for the Countly Android SDK.
 * Get more details <a href="https://github.com/Countly/countly-sdk-android">here</a>.
 */
public class Countly {
    private final String DEFAULT_COUNTLY_SDK_VERSION_STRING = "24.7.8";
    /**
     * Used as request meta data on every request
     */
    private final String DEFAULT_COUNTLY_SDK_NAME = "java-native-android";
    /**
     * Current version of the Count.ly Android SDK as a displayable string.
     */
    public String COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
    /**
     * Used as request meta data on every request
     */
    public String COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
    /**
     * Default string used in the begin session metrics if the
     * app version cannot be found.
     */
    protected static final String DEFAULT_APP_VERSION = "1.0";
    /**
     * Tag used in all logging in the Count.ly SDK.
     */
    public static final String TAG = "Countly";
    /**
     * Countly internal logger
     * Should not be used outside of the SDK
     * No guarantees of not breaking functionality
     * Exposed only for the SDK push implementation
     */
    public ModuleLog L = new ModuleLog();
    /**
     * Broadcast sent when consent set is changed
     */
    public static final String CONSENT_BROADCAST = "ly.count.android.sdk.Countly.CONSENT_BROADCAST";
    /**
     * Determines how many custom events can be queued locally before
     * an attempt is made to submit them to a Count.ly server.
     */
    int EVENT_QUEUE_SIZE_THRESHOLD = 100;
    /**
     * How often onTimer() is called. This is the default value.
     */
    private static final long TIMER_DELAY_IN_SECONDS = 60;
    protected static String[] publicKeyPinCertificates;
    protected static String[] certificatePinCertificates;
    interface LifecycleObserver {
        boolean LifeCycleAtleastStarted();
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * app installation it is. Later (in Countly Dashboard or when calling Countly API method),
     * you'll be able to choose whether you want to send a message to test devices,
     * or to production ones.
     */
    public enum CountlyMessagingMode {
        TEST,
        PRODUCTION,
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * messaging provider is in use in current app installation.
     */
    public enum CountlyMessagingProvider {
        FCM,    // Firebase
        HMS,    // Huawei
    }
    //SDK limit defaults
    final int maxKeyLengthDefault = 128;
    final int maxValueSizeDefault = 256;
    final int maxSegmentationValuesDefault = 100;
    final int maxBreadcrumbCountDefault = 100;
    final int maxStackTraceLinesPerThreadDefault = 30;
    final int maxStackTraceLineLengthDefault = 200;
    final int maxStackTraceThreadCountDefault = 50;
    // see http://stackoverflow.com/questions/7048198/thread-safe-singletons-in-java
    private static class SingletonHolder {
        @SuppressLint("StaticFieldLeak")
        static final Countly instance = new Countly();
    }
    ConnectionQueue connectionQueue_;
    private ScheduledExecutorService timerService_;
    private ScheduledFuture<?> timerFuture = null;
    private int activityCount_;
    boolean disableUpdateSessionRequests_ = false;//todo, move to module after 'setDisableUpdateSessionRequests' is removed
    boolean sdkIsInitialised = false;
    BaseInfoProvider baseInfoProvider;
    RequestQueueProvider requestQueueProvider;
    //w - warnings
    //e - errors
    //i - user accessible calls and important SDK internals
    //d - regular SDK internals
    //v - spammy SDK internals
    private boolean enableLogging_;
    Context context_;
    //Internal modules for functionality grouping
    List<ModuleBase> modules = new ArrayList<>();
    ModuleCrash moduleCrash = null;
    ModuleEvents moduleEvents = null;
    ModuleViews moduleViews = null;
    ModuleRatings moduleRatings = null;
    ModuleSessions moduleSessions = null;
    ModuleRemoteConfig moduleRemoteConfig = null;
    ModuleAPM moduleAPM = null;
    ModuleConsent moduleConsent = null;
    ModuleDeviceId moduleDeviceId = null;
    ModuleLocation moduleLocation = null;
    ModuleFeedback moduleFeedback = null;
    ModuleRequestQueue moduleRequestQueue = null;
    ModuleAttribution moduleAttribution = null;
    ModuleUserProfile moduleUserProfile = null;
    ModuleConfiguration moduleConfiguration = null;
    ModuleHealthCheck moduleHealthCheck = null;
    ModuleContent moduleContent = null;
    //reference to countly store
    CountlyStore countlyStore;
    //overrides
    boolean isHttpPostForced = false;//when true, all data sent to the server will be sent using HTTP POST
    //push related
    private boolean addMetadataToPushIntents = false;// a flag that indicates if metadata should be added to push notification intents
    //internal flags
    private boolean calledAtLeastOnceOnStart = false;//flag for if the onStart function has been called at least once
    protected boolean isBeginSessionSent = false;
    //custom request header fields
    Map<String, String> requestHeaderCustomValues;
    static long applicationStart = System.currentTimeMillis();
    String[] locationFallback;//temporary used until location can't be set before init
    protected CountlyConfig config_ = null;
    //fields for tracking push token debounce
    final static long lastRegistrationCallDebounceDuration = 60 * 1000;//60seconds
    long lastRegistrationCallTs = 0;
    String lastRegistrationCallID = null;
    CountlyMessagingProvider lastRegistrationCallProvider = null;
    boolean applicationClassProvided = false;
    public static class CountlyFeatureNames {
        public static final String sessions = "sessions";
        public static final String events = "events";
        public static final String views = "views";
        public static final String scrolls = "scrolls";
        public static final String clicks = "clicks";
        //public static final String forms = "forms";
        public static final String location = "location";
        public static final String crashes = "crashes";
        public static final String attribution = "attribution";
        public static final String users = "users";
        public static final String push = "push";
        public static final String starRating = "star-rating";
        public static final String apm = "apm";
        public static final String feedback = "feedback";
        public static final String remoteConfig = "remote-config";
        public static final String content = "content";
        //public static final String accessoryDevices = "accessory-devices";
    }
    /**
     * Returns the Countly singleton.
     */
    public static Countly sharedInstance() {
        return SingletonHolder.instance;
    }
    /**
     * Constructs a Countly object.
     * Creates a new ConnectionQueue and initializes the session timer.
     */
    Countly() {
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    private void startTimerService(ScheduledExecutorService service, ScheduledFuture<?> previousTimer, long timerDelay) {
        if (previousTimer != null && !previousTimer.isCancelled()) {
            previousTimer.cancel(false);
        }
        //minimum delay of 1 second
        if (timerDelay < 1) {
            timerDelay = 1;
        }
        timerFuture = service.scheduleWithFixedDelay(this::onTimer, timerDelay, timerDelay, TimeUnit.SECONDS);
    }
    /**
     * Must be called before other SDK methods can be used.
     * To initialise the SDK, you must pass a CountlyConfig object that contains
     * all the necessary information for setting up the SDK
     * Please prefer to use this on Application's onCreate method
     *
     * @param config contains all needed information to init SDK
     */
    public synchronized Countly init(CountlyConfig config) {
        if (config == null) {
            throw new IllegalArgumentException("Can't init SDK with 'null' config");
        }
        //enable logging
        if (config.loggingEnabled) {
            //enable logging before any potential logging calls
            setLoggingEnabled(true);
        }
        L.SetListener(config.providedLogCallback);
        if (COUNTLY_SDK_NAME.equals(DEFAULT_COUNTLY_SDK_NAME) && COUNTLY_SDK_VERSION_STRING.equals(DEFAULT_COUNTLY_SDK_VERSION_STRING)) {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "]");
        } else {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "] default name[" + DEFAULT_COUNTLY_SDK_NAME + "] default version[" + DEFAULT_COUNTLY_SDK_VERSION_STRING + "]");
        }
        if (config.context == null) {
            if (config.application != null) {
                L.d("[Init] No explicit context provided. Using context from the provided application class");
                config.context = config.application;
            } else {
                throw new IllegalArgumentException("valid context is required in Countly init, but was provided 'null'");
            }
        } else {
            L.d("[Init] Using explicitly provided context");
        }
        if (!UtilsNetworking.isValidURL(config.serverURL)) {
            throw new IllegalArgumentException("valid serverURL is required");
        }
        if (config.serverURL.charAt(config.serverURL.length() - 1) == '/') {
            L.v("[Init] Removing trailing '/' from provided server url");
            config.serverURL = config.serverURL.substring(0, config.serverURL.length() - 1);//removing trailing '/' from server url
        }
        if (config.appKey == null || config.appKey.isEmpty()) {
            throw new IllegalArgumentException("valid appKey is required, but was provided either 'null' or empty String");
        }
        if (config.application == null) {
            L.w("[Init] Initialising the SDK without providing the application class. Some functionality will not work.");
        }
        applicationClassProvided = config.application != null;
        if (config.deviceID != null && config.deviceID.isEmpty()) {
            //device ID is provided but it's a empty string
            L.w("[Countly] init, Provided device ID is an empty string. It will be ignored. And a new one will be generated by the SDK.");
            // setting device id as null to trigger SDK device id generation
            config.setDeviceId(null);
        }
        L.d("[Init] SDK initialised with the URL:[" + config.serverURL + "] and the appKey:[" + config.appKey + "]");
        if (L.logEnabled()) {
            L.i("[Init] Checking init parameters");
            // Context class hierarchy
            // Context
            //|- ContextWrapper
            //|- - Application
            //|- - ContextThemeWrapper
            //|- - - - Activity
            //|- - Service
            //|- - - IntentService
            Class contextClass = config.context.getClass();
            Class contextSuperClass = contextClass.getSuperclass();
            String contextText = "[Init] Provided Context [" + config.context.getClass().getSimpleName() + "]";
            if (contextSuperClass != null) {
                contextText += ", it's superclass: [" + contextSuperClass.getSimpleName() + "]";
            }
            L.i(contextText);
        }
        //set internal context, it's allowed to be changed on the second init call
        context_ = config.context.getApplicationContext();
        // if we get here and eventQueue_ != null, init is being called again with the same values,
        // so there is nothing to do, because we are already initialized with those values
        if (!sdkIsInitialised) {
            L.d("[Init] About to init internal systems");
            config_ = config;
            // Have a look at the SDK limit values
            if (config.sdkInternalLimits.maxKeyLength != null) {
                if (config.sdkInternalLimits.maxKeyLength < 1) {
                    config.sdkInternalLimits.maxKeyLength = 1;
                    L.w("[Init] provided 'maxKeyLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxKeyLength' override:[" + config.sdkInternalLimits.maxKeyLength + "]");
            } else {
                config.sdkInternalLimits.maxKeyLength = maxKeyLengthDefault;
            }
            if (config.sdkInternalLimits.maxValueSize != null) {
                if (config.sdkInternalLimits.maxValueSize < 1) {
                    config.sdkInternalLimits.maxValueSize = 1;
                    L.w("[Init] provided 'maxValueSize' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxValueSize' override:[" + config.sdkInternalLimits.maxValueSize + "]");
            } else {
                config.sdkInternalLimits.maxValueSize = maxValueSizeDefault;
            }
            if (config.sdkInternalLimits.maxSegmentationValues != null) {
                if (config.sdkInternalLimits.maxSegmentationValues < 1) {
                    config.sdkInternalLimits.maxSegmentationValues = 1;
                    L.w("[Init] provided 'maxSegmentationValues' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxSegmentationValues' override:[" + config.sdkInternalLimits.maxSegmentationValues + "]");
            } else {
                config.sdkInternalLimits.maxSegmentationValues = maxSegmentationValuesDefault;
            }
            if (config.sdkInternalLimits.maxBreadcrumbCount != null) {
                if (config.sdkInternalLimits.maxBreadcrumbCount < 1) {
                    config.sdkInternalLimits.maxBreadcrumbCount = 1;
                    L.w("[Init] provided 'maxBreadcrumbCount' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxBreadcrumbCount' override:[" + config.sdkInternalLimits.maxBreadcrumbCount + "]");
            } else {
                config.sdkInternalLimits.maxBreadcrumbCount = maxBreadcrumbCountDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLinesPerThread != null) {
                if (config.sdkInternalLimits.maxStackTraceLinesPerThread < 1) {
                    config.sdkInternalLimits.maxStackTraceLinesPerThread = 1;
                    L.w("[Init] provided 'maxStackTraceLinesPerThread' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLinesPerThread' override:[" + config.sdkInternalLimits.maxStackTraceLinesPerThread + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLinesPerThread = maxStackTraceLinesPerThreadDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLineLength != null) {
                if (config.sdkInternalLimits.maxStackTraceLineLength < 1) {
                    config.sdkInternalLimits.maxStackTraceLineLength = 1;
                    L.w("[Init] provided 'maxStackTraceLineLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLineLength' override:[" + config.sdkInternalLimits.maxStackTraceLineLength + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLineLength = maxStackTraceLineLengthDefault;
            }
            long timerDelay = TIMER_DELAY_IN_SECONDS;
            if (config.sessionUpdateTimerDelay != null) {
                //if we need to change the timer delay, do that first
                L.d("[Init] Setting custom session update timer delay, [" + config.sessionUpdateTimerDelay + "]");
                timerDelay = config.sessionUpdateTimerDelay;
            }
            startTimerService(timerService_, timerFuture, timerDelay);
            if (config.explicitStorageModeEnabled) {
                L.i("[Init] Explicit storage mode is being enabled");
            }
            //set or create the CountlyStore
            if (config.countlyStore != null) {
                //we are running a test and using a mock object
                countlyStore = config.countlyStore;
            } else {
                countlyStore = new CountlyStore(config.context, L, config.explicitStorageModeEnabled);
                config.setCountlyStore(countlyStore);
            }
            if (config.pcc != null) {
                L.i("[Init] Attaching a performance counter collector");
                countlyStore.pcc = config.pcc;
            }
            if (config.maxRequestQueueSize < 1) {
                L.e("[Init] provided request queue size is less than 1. Replacing it with 1.");
                config.maxRequestQueueSize = 1;
            }
            L.d("[Init] request queue size set to [" + config.maxRequestQueueSize + "]");
            countlyStore.setLimits(config.maxRequestQueueSize);
            if (config.storageProvider == null) {
                // outside of tests this should be null
                config.storageProvider = config.countlyStore;
            } else {
                L.d("[Init] Custom event storage provider was provided");
            }
            if (config.eventQueueProvider == null) {
                config.eventQueueProvider = countlyStore;
            } else {
                L.d("[Init] Custom event queue provider was provided");
            }
            if (config.requestQueueProvider == null) {
                config.requestQueueProvider = connectionQueue_;
            } else {
                L.d("[Init] Custom request queue provider was provided");
            }
            if (config.safeViewIDGenerator == null) {
                //if we didn't override this for a test
                config.safeViewIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.safeEventIDGenerator == null) {
                //if we didn't override this for a test
                config.safeEventIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.immediateRequestGenerator == null) {
                config.immediateRequestGenerator = new ImmediateRequestGenerator() {
                    @Override public ImmediateRequestI CreateImmediateRequestMaker() {
                        return (new ImmediateRequestMaker());
                    }
                };
            }
            if (config.lifecycleObserver == null) {
                config.lifecycleObserver = new LifecycleObserver() {
                    @Override public boolean LifeCycleAtleastStarted() {
                        return lifecycleStateAtLeastStartedInternal();
                    }
                };
            }
            if (config.metricProviderOverride != null) {
                L.d("[Init] Custom metric provider was provided");
            }
            config.deviceInfo = new DeviceInfo(config.metricProviderOverride);
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Parameter tampering protection salt set");
            }
            if (config.dropAgeHours < 0) {
                config.dropAgeHours = 0;
                L.d("[Init] Drop older requests threshold can not be negative. No threshold will be set.");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Drop older requests threshold set to:[" + config.dropAgeHours + "] hours");
            }
            if (connectionQueue_ == null) {
                L.e("[Init] SDK failed to initialize because the connection queue failed to be created");
                return this;
            }
            //check legacy access methods
            if (locationFallback != null && config.locationCountyCode == null && config.locationCity == null && config.locationLocation == null && config.locationIpAddress == null) {
                //if the fallback was set and config did not contain any location, use the fallback info
                // { country_code, city, gpsCoordinates, ipAddress };
                config.locationCountyCode = locationFallback[0];
                config.locationCity = locationFallback[1];
                config.locationLocation = locationFallback[2];
                config.locationIpAddress = locationFallback[3];
            }
            //perform data migration if needed
            try {
                Map<String, Object> migrationParams = new HashMap<>();
                migrationParams.put(MigrationHelper.key_from_0_to_1_custom_id_set, config.deviceID != null);
                MigrationHelper mHelper = new MigrationHelper(config.storageProvider, L, context_);
                mHelper.doWork(migrationParams);
            } catch (Exception ex) {
                L.e("[Init] SDK failed while performing data migration. SDK is not capable to initialize.");
                return this;
            }
            //initialise modules
            moduleHealthCheck = new ModuleHealthCheck(this, config);
            moduleConfiguration = new ModuleConfiguration(this, config);
            moduleRequestQueue = new ModuleRequestQueue(this, config);
            moduleConsent = new ModuleConsent(this, config);
            moduleDeviceId = new ModuleDeviceId(this, config);
            moduleCrash = new ModuleCrash(this, config);
            moduleEvents = new ModuleEvents(this, config);
            moduleUserProfile = new ModuleUserProfile(this, config);//this has to be set before the session module so that we can update remote config before sending anything session related
            moduleViews = new ModuleViews(this, config);
            moduleRatings = new ModuleRatings(this, config);
            moduleSessions = new ModuleSessions(this, config);
            moduleRemoteConfig = new ModuleRemoteConfig(this, config);
            moduleAPM = new ModuleAPM(this, config);
            moduleLocation = new ModuleLocation(this, config);
            moduleFeedback = new ModuleFeedback(this, config);
            moduleAttribution = new ModuleAttribution(this, config);
            moduleContent = new ModuleContent(this, config);
            modules.clear();
            modules.add(moduleConfiguration);
            modules.add(moduleRequestQueue);
            modules.add(moduleConsent);
            modules.add(moduleDeviceId);
            modules.add(moduleCrash);
            modules.add(moduleEvents);
            modules.add(moduleUserProfile);//this has to be set before the session module so that we can update remote config before sending anything session related
            modules.add(moduleViews);
            modules.add(moduleRatings);
            modules.add(moduleSessions);
            modules.add(moduleRemoteConfig);
            modules.add(moduleAPM);
            modules.add(moduleLocation);
            modules.add(moduleFeedback);
            modules.add(moduleAttribution);
            modules.add(moduleContent);
            modules.add(moduleHealthCheck);//set this at the end to detect any health issues with other modules before sending the report
            if (config.testModuleListener != null) {
                modules.add(config.testModuleListener);
            }
            //add missing providers
            moduleConfiguration.consentProvider = config.consentProvider;
            moduleRequestQueue.consentProvider = config.consentProvider;
            moduleHealthCheck.consentProvider = config.consentProvider;
            moduleRequestQueue.deviceIdProvider = config.deviceIdProvider;
            moduleConsent.eventProvider = config.eventProvider;
            moduleConsent.deviceIdProvider = config.deviceIdProvider;
            moduleDeviceId.eventProvider = config.eventProvider;
            moduleCrash.eventProvider = config.eventProvider;
            moduleEvents.viewIdProvider = config.viewIdProvider;
            baseInfoProvider = config.baseInfoProvider;
            requestQueueProvider = config.requestQueueProvider;
            L.setHealthChecker(config.healthTracker);
            L.i("[Init] Finished initialising modules");
            if (config.customNetworkRequestHeaders != null) {
                L.i("[Countly] Calling addCustomNetworkRequestHeaders");
                requestHeaderCustomValues = config.customNetworkRequestHeaders;
                connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            }
            if (config.httpPostForced) {
                L.d("[Init] Setting HTTP POST to be forced");
                isHttpPostForced = config.httpPostForced;
            }
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Enabling tamper protection");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Enabling drop older request threshold");
                countlyStore.setRequestAgeLimit(config.dropAgeHours);
            }
            if (config.pushIntentAddMetadata) {
                L.d("[Init] Enabling push intent metadata");
                addMetadataToPushIntents = config.pushIntentAddMetadata;
            }
            if (config.eventQueueSizeThreshold != null) {
                L.d("[Init] Setting event queue size: [" + config.eventQueueSizeThreshold + "]");
                if (config.eventQueueSizeThreshold < 1) {
                    L.d("[Init] queue size can't be less than zero");
                    config.eventQueueSizeThreshold = 1;
                }
                EVENT_QUEUE_SIZE_THRESHOLD = config.eventQueueSizeThreshold;
            }
            if (config.publicKeyPinningCertificates != null) {
                sharedInstance().L.i("[Init] Enabling public key pinning");
                publicKeyPinCertificates = config.publicKeyPinningCertificates;
            }
            if (config.certificatePinningCertificates != null) {
                Countly.sharedInstance().L.i("[Init] Enabling certificate pinning");
                certificatePinCertificates = config.certificatePinningCertificates;
            }
            //initialize networking queues
            connectionQueue_.L = L;
            connectionQueue_.healthTracker = config.healthTracker;
            connectionQueue_.configProvider = config.configProvider;
            connectionQueue_.consentProvider = moduleConsent;
            connectionQueue_.moduleRequestQueue = moduleRequestQueue;
            connectionQueue_.deviceInfo = config.deviceInfo;
            connectionQueue_.pcc = config.pcc;
            connectionQueue_.setStorageProvider(config.storageProvider);
            connectionQueue_.setupSSLContext();
            connectionQueue_.setBaseInfoProvider(config.baseInfoProvider);
            connectionQueue_.setDeviceId(config.deviceIdProvider);
            connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            connectionQueue_.setMetricOverride(config.metricOverride);
            connectionQueue_.setContext(context_);
            connectionQueue_.requestInfoProvider = new RequestInfoProvider() {
                @Override public boolean isHttpPostForced() {
                    return requestQueue().isHttpPostForced();
                }
                @Override public boolean isDeviceAppCrawler() {
                    return requestQueue().isDeviceAppCrawler();
                }
                @Override public boolean ifShouldIgnoreCrawlers() {
                    return requestQueue().ifShouldIgnoreCrawlers();
                }
                @Override public int getRequestDropAgeHours() {
                    return config.dropAgeHours;
                }
                @Override public String getRequestSalt() {
                    return config.tamperingProtectionSalt;
                }
            };
            sdkIsInitialised = true;
            //AFTER THIS POINT THE SDK IS COUNTED AS INITIALISED
            //set global application listeners
            if (config.application != null) {
                L.d("[Countly] Calling registerActivityLifecycleCallbacks");
                config.application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
                    @Override
                    public void onActivityCreated(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityCreated, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityCreated(activity);
                        //}
                    }
                    @Override
                    public void onActivityStarted(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStarted, " + activity.getClass().getSimpleName());
                        }
                        onStartInternal(activity);
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityStarted(activity);
                        //}
                    }
                    @Override
                    public void onActivityResumed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityResumed, " + activity.getClass().getSimpleName());
                        }
                        //for star rating
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityResumed(activity);
                        }
                    }
                    @Override
                    public void onActivityPaused(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityPaused, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityPaused(activity);
                        //}
                    }
                    @Override
                    public void onActivityStopped(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStopped, " + activity.getClass().getSimpleName());
                        }
                        onStopInternal();
                        //for APM
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityStopped(activity);
                        }
                    }
                    @Override
                    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivitySaveInstanceState, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivitySaveInstanceState(activity);
                        //}
                    }
                    @Override
                    public void onActivityDestroyed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityDestroyed, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityDestroyed(activity);
                        //}
                    }
                });
                config.application.registerComponentCallbacks(new ComponentCallbacks() {
                    @Override
                    public void onConfigurationChanged(Configuration configuration) {
                        L.d("[Countly] ComponentCallbacks, onConfigurationChanged");
                        onConfigurationChangedInternal(configuration);
                    }
                    @Override
                    public void onLowMemory() {
                        L.d("[Countly] ComponentCallbacks, onLowMemory");
                    }
                });
            } else {
                L.d("[Countly] Global activity listeners not registred due to no Application class");
            }
            if (config_.lifecycleObserver.LifeCycleAtleastStarted()) {
                L.d("[Countly] SDK detects that the app is in the foreground. Increasing the activity counter and setting the foreground state.");
                activityCount_++;
                config.deviceInfo.inForeground();
            }
            L.i("[Init] About to call module 'initFinished'");
            for (ModuleBase module : modules) {
                module.initFinished(config);
            }
            L.i("[Init] Finished initialising SDK");
        } else {
            //if this is not the first time we are calling init
            L.i("[Init] Getting in the 'else' block");
            // context is allowed to be changed on the second init call
            connectionQueue_.setContext(context_);
        }
        return this;
    }
    /**
     * Checks whether Countly.init has been already called.
     *
     * @return true if Countly is ready to use
     */
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isInitialized() {
        return sdkIsInitialised;
    }
    boolean lifecycleStateAtLeastStartedInternal() {
        return ProcessLifecycleOwner.get().getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED);
    }
    private void stopTimer() {
        L.i("[Countly] stopTimer, Stopping global timer");
        if (timerService_ != null) {
            try {
                timerService_.shutdown();
                if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                    timerService_.shutdownNow();
                    if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                        L.e("[Countly] stopTimer, Global timer must be locked");
                    }
                }
            } catch (Throwable t) {
                L.e("[Countly] stopTimer, Error while stopping global timer " + t);
            }
        }
    }
    /**
     * Immediately disables session and event tracking and clears any stored session and event data.
     * Testing Purposes Only!
     *
     * This will destroy all stored data
     */
    public synchronized void halt() {
        L.i("Halting Countly!");
        sdkIsInitialised = false;
        L.SetListener(null);
        stopTimer();
        if (connectionQueue_ != null) {
            if (countlyStore != null) {
                countlyStore.clear();
            }
            connectionQueue_.setContext(null);
            connectionQueue_ = null;
        }
        activityCount_ = 0;
        for (ModuleBase module : modules) {
            module.halt();
        }
        modules.clear();
        moduleCrash = null;
        moduleViews = null;
        moduleEvents = null;
        moduleRatings = null;
        moduleSessions = null;
        moduleRemoteConfig = null;
        moduleConsent = null;
        moduleAPM = null;
        moduleDeviceId = null;
        moduleLocation = null;
        moduleFeedback = null;
        moduleRequestQueue = null;
        moduleConfiguration = null;
        moduleHealthCheck = null;
        moduleContent = null;
        COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
        COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    synchronized void notifyDeviceIdChange(boolean withoutMerge) {
        L.d("Notifying modules that device ID changed");
        for (ModuleBase module : modules) {
            module.deviceIdChanged(withoutMerge);
        }
    }
    void onStartInternal(Activity activity) {
        if (L.logEnabled()) {
            String activityName = "NULL ACTIVITY PROVIDED";
            if (activity != null) {
                activityName = activity.getClass().getSimpleName();
            }
            L.d("Countly onStartInternal called, name:[" + activityName + "], [" + activityCount_ + "] -> [" + (activityCount_ + 1) + "] activities now open");
        }
        ++activityCount_;
        if (activityCount_ == 1 && !moduleSessions.manualSessionControlEnabled) {
            //if we open the first activity
            //and we are not using manual session control,
            //begin a session
            moduleSessions.beginSessionInternal();
        }
        config_.deviceInfo.inForeground();
        for (ModuleBase module : modules) {
            module.onActivityStarted(activity, activityCount_);
        }
        calledAtLeastOnceOnStart = true;
    }
    void onStopInternal() {
        L.d("Countly onStopInternal called, [" + activityCount_ + "] -> [" + (activityCount_ - 1) + "] activities now open");
        if (activityCount_ == 0) {
            L.e("must call onStart before onStop");
            return;
        }
        --activityCount_;
        if (activityCount_ == 0 && !moduleSessions.manualSessionControlEnabled) {
            // if we don't use manual session control
            // Called when final Activity is stopped.
            // Sends an end session event to the server, also sends any unsent custom events.
            moduleSessions.endSessionInternal();
        }
        config_.deviceInfo.inBackground();
        for (ModuleBase module : modules) {
            module.onActivityStopped(activityCount_);
        }
    }
    public synchronized void onConfigurationChangedInternal(Configuration newConfig) {
        L.i("Calling [onConfigurationChangedInternal]");
        for (ModuleBase module : modules) {
            module.onConfigurationChanged(newConfig);
        }
    }
    /**
     * Tells the Countly SDK that an Activity has started. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStart methods for accurate application
     * session tracking.
     */
    public synchronized void onStart(Activity activity) {
        if (!isInitialized()) {
            L.e("init must be called before onStart");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStartInternal(activity);
    }
    /**
     * Tells the Countly SDK that an Activity has stopped. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStop methods for accurate application
     * session tracking.
     * unbalanced calls to onStart/onStop are detected
     */
    public synchronized void onStop() {
        if (!isInitialized()) {
            L.e("init must be called before onStop");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStopInternal();
    }
    public synchronized void onConfigurationChanged(Configuration newConfig) {
        if (!isInitialized()) {
            L.e("init must be called before onConfigurationChanged");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onConfigurationChanged' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onConfigurationChangedInternal(newConfig);
    }
    /**
     * Called every 60 seconds to send a session heartbeat to the server. Does nothing if there
     * is not an active application session.
     */
    synchronized void onTimer() {
        L.v("[onTimer] Calling heartbeat, Activity count:[" + activityCount_ + "]");
        if (isInitialized()) {
            final boolean appIsInForeground = activityCount_ > 0;
            if (appIsInForeground && !moduleSessions.manualSessionControlEnabled) {
                //if we have automatic session control and we are in the foreground, record an update
                moduleSessions.updateSessionInternal();
            } else if (moduleSessions.manualSessionControlEnabled && moduleSessions.manualSessionControlHybridModeEnabled && moduleSessions.sessionIsRunning()) {
                // if we are in manual session control mode with hybrid sessions enabled (SDK takes care of update requests) and there is a session running,
                // let's create the update request
                moduleSessions.updateSessionInternal();
            }
            //on every timer tick we collect all events and attempt to send requests
            moduleRequestQueue.sendEventsIfNeeded(true);
            //on every timer tick we save the user profile if it was changed
            moduleUserProfile.saveInternal();
            requestQueueProvider.tick();
        }
    }
    /**
     * DON'T USE THIS!!!!
     */
    public void onRegistrationId(String registrationId, CountlyMessagingProvider provider) {
        //if this call is done by CountlyPush, it is assumed that the SDK is already initialised
        if (!config_.consentProvider.getConsent(CountlyFeatureNames.push)) {
            return;
        }
        if (!isInitialized()) {
            L.w("[onRegistrationId] Calling this before the SDK is initialized.");
        }
        //debouncing the call
        long currentTs = UtilsTime.currentTimestampMs();
        long timeDelta = currentTs - lastRegistrationCallTs;
        if (lastRegistrationCallID != null && lastRegistrationCallID.equals(registrationId) &&
            lastRegistrationCallProvider != null && lastRegistrationCallProvider == provider &&
            timeDelta < lastRegistrationCallDebounceDuration) {
            // if the values match and we are trying to resend them withing the debounce duration, ignore them
            L.w("[onRegistrationId] Calling this with the same values within the debounce interval. elapsedT:[" + timeDelta + "] ms");
            return;
        }
        lastRegistrationCallTs = currentTs;
        lastRegistrationCallID = registrationId;
        lastRegistrationCallProvider = provider;
        connectionQueue_.tokenSession(registrationId, provider);
    }
    public void setLoggingEnabled(final boolean enableLogging) {
        enableLogging_ = enableLogging;
        L.d("Enabling logging");
    }
    /**
     * Check if logging has been enabled internally in the SDK
     *
     * @return true means "yes"
     */
    public boolean isLoggingEnabled() {
        return enableLogging_;
    }
    /**
     * Returns if the countly sdk onStart function has been called at least once
     *
     * @return true - yes, it has, false - no it has not
     * @deprecated This will be removed
     */
    public boolean hasBeenCalledOnStart() {
        return calledAtLeastOnceOnStart;
    }
    public ModuleCrash.Crashes crashes() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing crashes");
            return null;
        }
        return moduleCrash.crashesInterface;
    }
    public ModuleEvents.Events events() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing events");
            return null;
        }
        return moduleEvents.eventsInterface;
    }
    public ModuleViews.Views views() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing views");
            return null;
        }
        return moduleViews.viewsInterface;
    }
    public ModuleRatings.Ratings ratings() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing ratings");
            return null;
        }
        return moduleRatings.ratingsInterface;
    }
    public ModuleSessions.Sessions sessions() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing sessions");
            return null;
        }
        return moduleSessions.sessionInterface;
    }
    public ModuleRemoteConfig.RemoteConfig remoteConfig() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing remote config");
            return null;
        }
        return moduleRemoteConfig.remoteConfigInterface;
    }
    public ModuleAPM.Apm apm() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing apm");
            return null;
        }
        return moduleAPM.apmInterface;
    }
    public ModuleConsent.Consent consent() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing consent");
            return null;
        }
        return moduleConsent.consentInterface;
    }
    public ModuleLocation.Location location() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing location");
            return null;
        }
        return moduleLocation.locationInterface;
    }
    public ModuleFeedback.Feedback feedback() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing feedback");
            return null;
        }
        return moduleFeedback.feedbackInterface;
    }
    public ModuleRequestQueue.RequestQueue requestQueue() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing request queue");
            return null;
        }
        return moduleRequestQueue.requestQueueInterface;
    }
    public ModuleAttribution.Attribution attribution() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing attribution");
            return null;
        }
        return moduleAttribution.attributionInterface;
    }
    public ModuleDeviceId.DeviceId deviceId() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing deviceId");
            return null;
        }
        return moduleDeviceId.deviceIdInterface;
    }
    public ModuleUserProfile.UserProfile userProfile() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing user profile");
            return null;
        }
        return moduleUserProfile.userProfileInterface;
    }
    /**
     * Content feature interface
     *
     * @return content module
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public ModuleContent.Content contents() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing content");
            return null;
        }
        return moduleContent.contentInterface;
    }
    public static void applicationOnCreate() {
    }
    // for unit testing
    ConnectionQueue getConnectionQueue() {
        return connectionQueue_;
    }
    ExecutorService getTimerService() {
        return timerService_;
    }
    long getPrevSessionDurationStartTime() {
        return moduleSessions.prevSessionDurationStartTime_;
    }
    void setPrevSessionDurationStartTime(final long prevSessionDurationStartTime) {
        moduleSessions.prevSessionDurationStartTime_ = prevSessionDurationStartTime;
    }
    int getActivityCount() {
        return activityCount_;
    }
    synchronized boolean getDisableUpdateSessionRequests() {
        return disableUpdateSessionRequests_;
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.View;
import android.webkit.WebResourceRequest;
import android.webkit.WebResourceResponse;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.RatingBar;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleRatings extends ModuleBase {
    //star rating
    StarRatingCallback starRatingCallback_;// saved callback that is used for automatic star rating
    boolean showStarRatingDialogOnFirstActivity = false;
    final Ratings ratingsInterface;
    ModuleRatings(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRatings] Initialising");
        starRatingCallback_ = config.starRatingCallback;
        setStarRatingInitConfig(config.starRatingSessionLimit, config.starRatingTextTitle, config.starRatingTextMessage, config.starRatingTextDismiss);
        setIfRatingDialogIsCancellableInternal(config.starRatingDialogIsCancellable);
        setShowDialogAutomatically(config.starRatingShownAutomatically);
        setStarRatingDisableAskingForEachAppVersion(config.starRatingDisableAskingForEachAppVersion);
        ratingsInterface = new Ratings();
    }
    void recordManualRatingInternal(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
        L.d("[ModuleRatings] Calling recordManualRatingInternal");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            return;
        }
        if (widgetId == null) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is null, returning");
            return;
        }
        if (widgetId.isEmpty()) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is empty, returning");
            return;
        }
        if (rating < 1) {
            rating = 1;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too low, defaulting to 1");
        }
        if (rating > 5) {
            rating = 5;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too high, defaulting to 5");
        }
        String truncatedEmail = UtilsInternalLimits.truncateValueSize(email, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        String truncatedComment = UtilsInternalLimits.truncateValueSize(comment, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", deviceInfo.mp.getAppVersion(_cly.context_));
        segm.put("rating", "" + rating);
        segm.put("widget_id", widgetId);
        segm.put("contactMe", userCanBeContacted);
        if (truncatedEmail != null && !truncatedEmail.isEmpty()) {
            segm.put("email", truncatedEmail);
        }
        if (truncatedComment != null && !truncatedComment.isEmpty()) {
            segm.put("comment", truncatedComment);
        }
        eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    /**
     * Save the star rating preferences object
     *
     * @param srp
     */
    private void saveStarRatingPreferences(final StarRatingPreferences srp) {
        storageProvider.setStarRatingPreferences(srp.toJSON().toString());
    }
    /**
     * Setting things that would be provided during initial config
     *
     * @param limit limit for automatic rating
     * @param starRatingTextTitle provided title
     * @param starRatingTextMessage provided message
     * @param starRatingTextDismiss provided dismiss text
     */
    void setStarRatingInitConfig(final int limit, final String starRatingTextTitle, final String starRatingTextMessage, final String starRatingTextDismiss) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        if (limit >= 0) {
            srp.sessionLimit = limit;
        }
        if (starRatingTextTitle != null) {
            srp.dialogTextTitle = starRatingTextTitle;
        }
        if (starRatingTextMessage != null) {
            srp.dialogTextMessage = starRatingTextMessage;
        }
        if (starRatingTextDismiss != null) {
            srp.dialogTextDismiss = starRatingTextDismiss;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog should be shown automatically
     *
     * @param shouldShow
     */
    void setShowDialogAutomatically(final boolean shouldShow) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.automaticRatingShouldBeShown = shouldShow;
        saveStarRatingPreferences(srp);
    }
    boolean getIfStarRatingShouldBeShownAutomatically() {
        StarRatingPreferences srp = loadStarRatingPreferences(_cly.countlyStore);
        return srp.automaticRatingShouldBeShown;
    }
    /**
     * Set if automatic star rating should be disabled for each new version.
     * By default automatic star rating will be shown for every new app version.
     * If this is set to true, star rating will be shown only once over apps lifetime
     *
     * @param disableAsking if set true, will not show star rating for every new app version
     */
    void setStarRatingDisableAskingForEachAppVersion(final boolean disableAsking) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.disabledAutomaticForNewVersions = disableAsking;
        saveStarRatingPreferences(srp);
    }
    /**
     * Register that a apps session has transpired. Will increase session counter and show automatic star rating if needed.
     *
     * @param context android context
     * @param starRatingCallback
     */
    void registerAppSession(final Context context, final StarRatingCallback starRatingCallback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        String currentAppVersion = deviceInfo.mp.getAppVersion(context);
        //a new app version is released, reset all counters
        //if we show the rating once per apps lifetime, don't reset the counters
        if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {
            srp.appVersion = currentAppVersion;
            srp.isShownForCurrentVersion = false;
            srp.sessionAmount = 0;
        }
        srp.sessionAmount++;
        if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {
            showStarRatingDialogOnFirstActivity = true;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Returns the session limit set for automatic star rating
     */
    static int getAutomaticStarRatingSessionLimitInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionLimit;
    }
    /**
     * Returns how many sessions has star rating counted internally
     *
     * @return
     */
    int getCurrentVersionsSessionCountInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionAmount;
    }
    /**
     * Set the automatic star rating session count back to 0
     */
    void clearAutomaticStarRatingSessionCountInternal() {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.sessionAmount = 0;
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog is cancellable
     *
     * @param isCancellable
     */
    void setIfRatingDialogIsCancellableInternal(final boolean isCancellable) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.isDialogCancellable = isCancellable;
        saveStarRatingPreferences(srp);
    }
    /**
     * Class that handles star rating internal state
     */
    static class StarRatingPreferences {
        String appVersion = ""; //the name of the current version that we keep track of
        int sessionLimit = 5; //session limit for the automatic star rating
        int sessionAmount = 0; //session amount for the current version
        boolean isShownForCurrentVersion = false; //if automatic star rating has been shown for the current version
        boolean automaticRatingShouldBeShown = false; //if the automatic star rating should be shown
        boolean disabledAutomaticForNewVersions = false; //if the automatic star star should not be shown for every new apps version
        boolean automaticHasBeenShown = false; //if automatic star rating has been shown for any app's version
        boolean isDialogCancellable = true; //if star rating dialog is cancellable
        String dialogTextTitle = "App rating";
        String dialogTextMessage = "Please rate this app";
        String dialogTextDismiss = "Cancel";
        private static final String KEY_APP_VERSION = "sr_app_version";
        private static final String KEY_SESSION_LIMIT = "sr_session_limit";
        private static final String KEY_SESSION_AMOUNT = "sr_session_amount";
        private static final String KEY_IS_SHOWN_FOR_CURRENT = "sr_is_shown";
        private static final String KEY_AUTOMATIC_RATING_IS_SHOWN = "sr_is_automatic_shown";
        private static final String KEY_DISABLE_AUTOMATIC_NEW_VERSIONS = "sr_is_disable_automatic_new";
        private static final String KEY_AUTOMATIC_HAS_BEEN_SHOWN = "sr_automatic_has_been_shown";
        private static final String KEY_DIALOG_IS_CANCELLABLE = "sr_automatic_dialog_is_cancellable";
        private static final String KEY_DIALOG_TEXT_TITLE = "sr_text_title";
        private static final String KEY_DIALOG_TEXT_MESSAGE = "sr_text_message";
        private static final String KEY_DIALOG_TEXT_DISMISS = "sr_text_dismiss";
        /**
         * Create a JSONObject from the current state
         *
         * @return
         */
        JSONObject toJSON() {
            final JSONObject json = new JSONObject();
            try {
                json.put(KEY_APP_VERSION, appVersion);
                json.put(KEY_SESSION_LIMIT, sessionLimit);
                json.put(KEY_SESSION_AMOUNT, sessionAmount);
                json.put(KEY_IS_SHOWN_FOR_CURRENT, isShownForCurrentVersion);
                json.put(KEY_AUTOMATIC_RATING_IS_SHOWN, automaticRatingShouldBeShown);
                json.put(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, disabledAutomaticForNewVersions);
                json.put(KEY_AUTOMATIC_HAS_BEEN_SHOWN, automaticHasBeenShown);
                json.put(KEY_DIALOG_IS_CANCELLABLE, isDialogCancellable);
                json.put(KEY_DIALOG_TEXT_TITLE, dialogTextTitle);
                json.put(KEY_DIALOG_TEXT_MESSAGE, dialogTextMessage);
                json.put(KEY_DIALOG_TEXT_DISMISS, dialogTextDismiss);
            } catch (JSONException e) {
                Countly.sharedInstance().L.w("Got exception converting an StarRatingPreferences to JSON", e);
            }
            return json;
        }
        /**
         * Load the preference state from a JSONObject
         *
         * @param json
         * @return
         */
        static StarRatingPreferences fromJSON(final JSONObject json) {
            StarRatingPreferences srp = new StarRatingPreferences();
            if (json != null) {
                try {
                    srp.appVersion = json.getString(KEY_APP_VERSION);
                    srp.sessionLimit = json.optInt(KEY_SESSION_LIMIT, 5);
                    srp.sessionAmount = json.optInt(KEY_SESSION_AMOUNT, 0);
                    srp.isShownForCurrentVersion = json.optBoolean(KEY_IS_SHOWN_FOR_CURRENT, false);
                    srp.automaticRatingShouldBeShown = json.optBoolean(KEY_AUTOMATIC_RATING_IS_SHOWN, true);
                    srp.disabledAutomaticForNewVersions = json.optBoolean(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, false);
                    srp.automaticHasBeenShown = json.optBoolean(KEY_AUTOMATIC_HAS_BEEN_SHOWN, false);
                    srp.isDialogCancellable = json.optBoolean(KEY_DIALOG_IS_CANCELLABLE, true);
                    if (!json.isNull(KEY_DIALOG_TEXT_TITLE)) {
                        srp.dialogTextTitle = json.getString(KEY_DIALOG_TEXT_TITLE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_MESSAGE)) {
                        srp.dialogTextMessage = json.getString(KEY_DIALOG_TEXT_MESSAGE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_DISMISS)) {
                        srp.dialogTextDismiss = json.getString(KEY_DIALOG_TEXT_DISMISS);
                    }
                } catch (JSONException e) {
                    Countly.sharedInstance().L.w("Got exception converting JSON to a StarRatingPreferences", e);
                }
            }
            return srp;
        }
    }
    /**
     * Call to manually show star rating dialog
     *
     * @param context android context
     * @param callback
     */
    void showStarRatingInternal(final Context context, final StarRatingCallback callback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        showStarRatingCustom(context, srp.dialogTextTitle, srp.dialogTextMessage, srp.dialogTextDismiss, srp.isDialogCancellable, callback);
    }
    /**
     * Returns a object with the loaded preferences
     * TODO make this non static
     *
     * @return
     */
    static StarRatingPreferences loadStarRatingPreferences(final StorageProvider sp) {
        String srpString = sp.getStarRatingPreferences();
        StarRatingPreferences srp;
        if (!srpString.equals("")) {
            JSONObject srJSON;
            try {
                srJSON = new JSONObject(srpString);
                srp = StarRatingPreferences.fromJSON(srJSON);
            } catch (JSONException e) {
                e.printStackTrace();
                srp = new StarRatingPreferences();
            }
        } else {
            srp = new StarRatingPreferences();
        }
        return srp;
    }
    /**
     * Method that created the star rating dialog
     *
     * @param context android context
     * @param title
     * @param message
     * @param cancelText
     * @param isCancellable
     * @param callback
     */
    void showStarRatingCustom(@NonNull final Context context, final String title, final String message, final String cancelText, final boolean isCancellable, @Nullable final StarRatingCallback callback) {
        if (!(context instanceof Activity)) {
            L.e("[ModuleRatings] Can't show star rating dialog, the provided context is not based off a activity");
            return;
        }
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View dialogLayout = inflater.inflate(R.layout.star_rating_layout, null);
        RatingBar ratingBar = dialogLayout.findViewById(R.id.ratingBar);
        final AlertDialog.Builder builder = new AlertDialog.Builder(context)
            .setTitle(title)
            .setMessage(message)
            .setCancelable(isCancellable)
            .setView(dialogLayout)
            .setOnCancelListener(new DialogInterface.OnCancelListener() {
                @Override
                public void onCancel(DialogInterface dialogInterface) {
                    if (callback != null) {
                        //call the dismiss callback ir the user clicks the back button or clicks outside the dialog
                        callback.onDismiss();
                    }
                }
            })
            .setPositiveButton(cancelText, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialogInterface, int i) {
                    if (callback != null) {
                        //call the dismiss callback if the user clicks the "dismiss" button
                        callback.onDismiss();
                    }
                }
            });
        final AlertDialog dialog = builder.show();
        ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {
            @Override
            public void onRatingChanged(RatingBar ratingBar, float v, boolean b) {
                int rating = (int) v;
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    Map<String, Object> segm = new HashMap<>();
                    segm.put("platform", "android");
                    segm.put("app_version", deviceInfo.mp.getAppVersion(context));
                    segm.put("rating", "" + rating);
                    eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
                }
                dialog.dismiss();
                if (callback != null) {
                    callback.onRate(rating);
                }
            }
        });
    }
    /// Countly webDialog user rating
    synchronized void showFeedbackPopupInternal(@Nullable final String widgetId, @Nullable final String closeButtonText, @Nullable final Activity activity, @Nullable final FeedbackRatingCallback devCallback) {
        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
        if (widgetId == null || widgetId.isEmpty()) {
            if (devCallback != null) {
                devCallback.callback("Countly widgetId cannot be null or empty");
            }
            L.e("[ModuleRatings] Countly widgetId cannot be null or empty");
            return;
        }
        if (activity == null) {
            if (devCallback != null) {
                devCallback.callback("When showing feedback popup, Activity can't be null");
            }
            L.e("[ModuleRatings] When showing feedback popup, Activity can't be null");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            if (devCallback != null) {
                devCallback.callback("Consent is not granted");
            }
            return;
        }
        //check the device type
        final boolean deviceIsPhone;
        final boolean deviceIsTablet;
        final boolean deviceIsTv;
        deviceIsTv = Utils.isDeviceTv(activity);
        if (!deviceIsTv) {
            deviceIsPhone = !Utils.isDeviceTablet(activity);
            deviceIsTablet = Utils.isDeviceTablet(activity);
        } else {
            deviceIsTablet = false;
            deviceIsPhone = false;
        }
        String requestData = requestQueueProvider.prepareRatingWidgetRequest(widgetId);
        final String ratingWidgetUrl = baseInfoProvider.getServerURL() + "/feedback?widget_id=" + widgetId +
            "&device_id=" + UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()) +
            "&app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey());
        L.d("[ModuleRatings] rating widget url :[" + ratingWidgetUrl + "]");
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/feedback/widget", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override
            public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably a lack of connection to the server");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably no internet connection or wrong widget id");
                    }
                    return;
                }
                if (!checkResponse.has("target_devices")) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably using a widget_id not intended for the rating widget");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably using a widget_id not intended for the rating widget");
                    }
                    return;
                }
                try {
                    JSONObject jDevices = checkResponse.getJSONObject("target_devices");
                    boolean showOnTv = jDevices.optBoolean("desktop", false);
                    boolean showOnPhone = jDevices.optBoolean("phone", false);
                    boolean showOnTablet = jDevices.optBoolean("tablet", false);
                    if ((deviceIsPhone && showOnPhone) || (deviceIsTablet && showOnTablet) || (deviceIsTv && showOnTv)) {
                        //it's possible to show the rating window on this device
                        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
                        Handler handler = new Handler(Looper.getMainLooper());
                        handler.post(new Runnable() {
                            public void run() {
                                L.d("[ModuleRatings] Calling on main thread");
                                RatingDialogWebView webView = new RatingDialogWebView(activity);
                                webView.clearCache(true);
                                webView.clearHistory();
                                webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                                webView.getSettings().setJavaScriptEnabled(true);
                                webView.loadUrl(ratingWidgetUrl);
                                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                                builder.setView(webView);
                                if (closeButtonText != null && !closeButtonText.isEmpty()) {
                                    builder.setNeutralButton(closeButtonText, new DialogInterface.OnClickListener() {
                                        @Override public void onClick(DialogInterface dialog, int which) {
                                            L.d("[ModuleRatings] Calling callback from 'close' button");
                                            if (devCallback != null) {
                                                devCallback.callback(null);
                                            }
                                        }
                                    });
                                }
                                builder.show();
                            }
                        });
                    } else {
                        if (devCallback != null) {
                            devCallback.callback("Rating dialog is not meant for this form factor");
                        }
                    }
                } catch (JSONException e) {
                    L.e("[ModuleRatings] Encountered a issue while trying to parse the results of the widget config", e);
                }
            }
        }, L);
    }
    static class RatingDialogWebView extends WebView {
        public RatingDialogWebView(Context context) {
            super(context);
        }
        /**
         * Without this override, the keyboard is not showing
         */
        @Override
        public boolean onCheckIsTextEditor() {
            return true;
        }
    }
    static class FeedbackDialogWebViewClient extends WebViewClient {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
            String url = request.getUrl().toString();
            // Filter out outgoing calls
            if (url.endsWith("cly_x_int=1")) {
                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
                view.getContext().startActivity(intent);
                return true;
            }
            return false;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + url);
            return null;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + request.getUrl());
            return null;
        }
    }
    @Override
    void callbackOnActivityResumed(Activity activity) {
        if (showStarRatingDialogOnFirstActivity) {
            StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
            srp.isShownForCurrentVersion = true;
            srp.automaticHasBeenShown = true;
            showStarRatingInternal(activity, starRatingCallback_);
            saveStarRatingPreferences(srp);
            showStarRatingDialogOnFirstActivity = false;
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //do star rating related things
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            registerAppSession(config.context, starRatingCallback_);
        }
    }
    @Override
    void halt() {
    }
    public class Ratings {
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         * @deprecated use 'recordRatingWidgetWithID' in place of this call
         */
        public void recordManualRating(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            L.i("[Ratings] Calling recordManualRating");
            recordRatingWidgetWithID(widgetId, rating, email, comment, userCanBeContacted);
        }
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         */
        public void recordRatingWidgetWithID(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            synchronized (_cly) {
                L.i("[Ratings] Calling recordRatingWidgetWithID");
                if (widgetId == null || widgetId.isEmpty()) {
                    throw new IllegalStateException("A valid widgetID must be provided. The current one is either null or empty");
                }
                recordManualRatingInternal(widgetId, rating, email, comment, userCanBeContacted);
            }
        }
        /**
         * Show the rating dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         * @deprecated use 'presentRatingWidgetWithID' in place of this call
         */
        public void showFeedbackPopup(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            L.i("[Ratings] Calling showFeedbackPopup");
            presentRatingWidgetWithID(widgetId, closeButtonText, activity, callback);
        }
        /**
         * Show the rating widget dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         */
        public void presentRatingWidgetWithID(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling presentRatingWidgetWithID");
                showFeedbackPopupInternal(widgetId, closeButtonText, activity, callback);
            }
        }
        /**
         * Shows the star rating dialog
         *
         * @param activity the activity that will own the dialog
         * @param callback callback for the star rating dialog "rate" and "dismiss" events
         */
        public void showStarRating(Activity activity, StarRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling showStarRating");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    return;
                }
                showStarRatingInternal(activity, callback);
            }
        }
        /**
         * Returns how many sessions has star rating counted internally for the current apps version
         *
         * @return
         */
        public int getCurrentVersionsSessionCount() {
            synchronized (_cly) {
                int sessionCount = getCurrentVersionsSessionCountInternal(_cly.countlyStore);
                L.i("[Ratings] Getting star rating current version session count: [" + sessionCount + "]");
                return sessionCount;
            }
        }
        /**
         * Set the automatic star rating session count back to 0
         */
        public void clearAutomaticStarRatingSessionCount() {
            synchronized (_cly) {
                L.i("[Ratings] Clearing star rating session count");
                clearAutomaticStarRatingSessionCountInternal();
            }
        }
        /**
         * Returns the session limit set for automatic star rating
         */
        public int getAutomaticStarRatingSessionLimit() {
            synchronized (_cly) {
                int sessionLimit = ModuleRatings.getAutomaticStarRatingSessionLimitInternal(_cly.countlyStore);
                L.i("[Ratings] Getting automatic star rating session limit: [" + sessionLimit + "]");
                return sessionLimit;
            }
        }
    }
}
package ly.count.android.sdk;
import android.util.Log;
public class ModuleLog {
    public interface LogCallback {
        void LogHappened(String logMessage, ModuleLog.LogLevel logLevel);
    }
    public enum LogLevel {Verbose, Debug, Info, Warning, Error}
    LogCallback logListener = null;
    HealthTracker healthTracker;
    int countWarnings = 0;
    int countErrors = 0;
    void SetListener(LogCallback logListener) {
        this.logListener = logListener;
    }
    void trackWarning() {
        if (healthTracker == null) {
            countWarnings++;
        } else {
            healthTracker.logWarning();
        }
    }
    void trackError() {
        if (healthTracker == null) {
            countErrors++;
        } else {
            healthTracker.logError();
        }
    }
    void setHealthChecker(HealthTracker healthTracker) {
        v("[ModuleLog] Setting healthTracker W:" + countWarnings + " E:" + countErrors);
        this.healthTracker = healthTracker;
        if (healthTracker == null) {
            return;
        }
        for (int a = 0; a < countErrors; a++) {
            healthTracker.logError();
        }
        for (int a = 0; a < countWarnings; a++) {
            healthTracker.logWarning();
        }
        countWarnings = 0;
        countErrors = 0;
    }
    public void v(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.v(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Verbose);
    }
    public void d(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.d(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Debug);
    }
    public void i(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.i(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Info);
    }
    public void w(String msg) {
        w(msg, null);
    }
    public void w(String msg, Throwable t) {
        trackWarning();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.w(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Warning);
    }
    public void e(String msg) {
        e(msg, null);
    }
    public void e(String msg, Throwable t) {
        trackError();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.e(Countly.TAG, msg, t);
        }
        informListener(msg, t, LogLevel.Error);
    }
    public boolean logEnabled() {
        return logListener != null || Countly.sharedInstance().isLoggingEnabled();
    }
    private void informListener(String msg, final Throwable t, final LogLevel level) {
        try {
            if (msg == null) {
                msg = "";
            }
            if (t != null) {
                msg += Log.getStackTraceString(t);
            }
            if (logListener != null) {
                logListener.LogHappened(msg, level);
            }
        } catch (Exception ex) {
            Log.e(Countly.TAG, "[ModuleLog] Failed to inform listener [" + ex.toString() + "]");
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Map;
interface RequestQueueProvider {
    void beginSession(boolean locationDisabled, @Nullable String locationCountryCode, @Nullable String locationCity, @Nullable String locationGpsCoordinates, @Nullable String locationIpAddress, @NonNull String preparedMetrics);
    void updateSession(final int duration);
    void changeDeviceId(String deviceId, String oldDeviceId);
    void tokenSession(String token, Countly.CountlyMessagingProvider provider);
    void endSession(final int duration);
    void sendLocation(boolean locationDisabled, String locationCountryCode, String locationCity, String locationGpsCoordinates, String locationIpAddress);
    void sendUserData(String userdata);
    void sendIndirectAttribution(@NonNull String attributionObj);
    void sendDirectAttributionLegacy(@NonNull String campaignID, @Nullable String userID);
    void sendDirectAttributionTest(@NonNull String attributionData);
    void sendCrashReport(@NonNull final String crashData, final boolean nonFatalCrash);
    void recordEvents(final String events);
    void sendConsentChanges(String formattedConsentChanges);
    void sendAPMCustomTrace(String key, Long durationMs, Long startMs, Long endMs, String customMetrics);
    void sendAPMNetworkTrace(String networkTraceKey, Long responseTimeMs, int responseCode, int requestPayloadSize, int responsePayloadSize, Long startMs, Long endMs);
    void sendAPMAppStart(long durationMs, Long startMs, Long endMs);
    void sendAPMScreenTime(boolean recordForegroundTime, long durationMs, Long startMs, Long endMs);
    void sendDirectRequest(@NonNull final Map<String, String> requestData);
    void enrollToKeys(@NonNull String[] keys);
    void exitForKeys(@NonNull String[] keys);
    //todo these should be moved or replaced in the future
    boolean queueContainsTemporaryIdItems();
    void tick();
    ConnectionProcessor createConnectionProcessor();
    String prepareRemoteConfigRequestLegacy(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics);
    String prepareRemoteConfigRequest(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics, boolean autoEnroll);
    String prepareFetchAllVariants(); // for fetching all A/B test variants
    String prepareFetchAllExperiments(); // for fetching all A/B test information (like with exp ID, definition etc, including variants)
    String prepareEnrollVariant(String key, String Variant); // for enrolling to an A/B test variant
    String prepareRatingWidgetRequest(String widgetId);
    String prepareFeedbackListRequest();
    String prepareServerConfigRequest();
    String prepareHealthCheckRequest(String preparedMetrics);
    String prepareFetchContents(int portraitWidth, int portraitHeight, int landscapeWidth, int landscapeHeight, String[] categories, String language);
}
package ly.count.android.sdk;
interface DeviceIdProvider {
    String getDeviceId();
    DeviceId getDeviceIdInstance();
    boolean isTemporaryIdEnabled();
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.media.AudioManager;
import android.net.ConnectivityManager;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Environment;
import android.os.StatFs;
import android.telephony.TelephonyManager;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.WindowManager;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.json.JSONObject;
/**
 * This class provides several static methods to retrieve information about
 * the current device and operating environment.
 */
class DeviceInfo {
    private final static int startTime = UtilsTime.currentTimestampSeconds();
    private boolean inBackground = true;
    private static long totalMemory = 0;
    MetricProvider mp;
    public DeviceInfo(MetricProvider mpOverride) {
        mp = mpOverride;
        if (mp == null) {
            mp = new MetricProvider() {
                /**
                 * Returns the display name of the current operating system.
                 */
                @NonNull
                @Override public String getOS() {
                    return "Android";
                }
                /**
                 * Returns the current operating system version as a displayable string.
                 */
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getOSVersion() {
                    return android.os.Build.VERSION.RELEASE;
                }
                /**
                 * Returns the current device model.
                 */
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getDevice() {
                    return android.os.Build.MODEL;
                }
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getManufacturer() {
                    return Build.MANUFACTURER;
                }
                /**
                 * Returns the non-scaled pixel resolution of the current default display being used by the
                 * WindowManager in the specified context.
                 *
                 * @param context context to use to retrieve the current WindowManager
                 * @return a string in the format "WxH", or the empty string "" if resolution cannot be determined
                 */
                @NonNull
                @Override
                public String getResolution(@NonNull final Context context) {
                    // user reported NPE in this method; that means either getSystemService or getDefaultDisplay
                    // were returning null, even though the documentation doesn't say they should do so; so now
                    // we catch Throwable and return empty string if that happens
                    String resolution = "";
                    try {
                        final DisplayMetrics metrics = getDisplayMetrics(context);
                        resolution = metrics.widthPixels + "x" + metrics.heightPixels;
                    } catch (Throwable t) {
                        Countly.sharedInstance().L.i("[DeviceInfo] Device resolution cannot be determined");
                    }
                    return resolution;
                }
                /**
                 * Return the display metrics collected from the WindowManager in the specified context.
                 * @param context context to use to retrieve the current WindowManager
                 * @return the display metrics of the current default display
                 */
                @NonNull
                @Override
                public DisplayMetrics getDisplayMetrics(@NonNull final Context context) {
                    final WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                    final Display display = wm.getDefaultDisplay();
                    final DisplayMetrics metrics = new DisplayMetrics();
                    display.getMetrics(metrics);
                    return metrics;
                }
                /**
                 * Maps the current display density to a string constant.
                 *
                 * @param context context to use to retrieve the current display metrics
                 * @return a string constant representing the current display density, or the
                 * empty string if the density is unknown
                 */
                @NonNull
                @Override
                public String getDensity(@NonNull final Context context) {
                    String densityStr;
                    final int density = context.getResources().getDisplayMetrics().densityDpi;
                    switch (density) {
                        case DisplayMetrics.DENSITY_LOW:
                            densityStr = "LDPI";
                            break;
                        case DisplayMetrics.DENSITY_MEDIUM:
                            densityStr = "MDPI";
                            break;
                        case DisplayMetrics.DENSITY_TV:
                            densityStr = "TVDPI";
                            break;
                        case DisplayMetrics.DENSITY_HIGH:
                            densityStr = "HDPI";
                            break;
                        case DisplayMetrics.DENSITY_260:
                        case DisplayMetrics.DENSITY_280:
                        case DisplayMetrics.DENSITY_300:
                        case DisplayMetrics.DENSITY_XHIGH:
                            densityStr = "XHDPI";
                            break;
                        case DisplayMetrics.DENSITY_340:
                        case DisplayMetrics.DENSITY_360:
                        case DisplayMetrics.DENSITY_400:
                        case DisplayMetrics.DENSITY_420:
                        case DisplayMetrics.DENSITY_XXHIGH:
                            densityStr = "XXHDPI";
                            break;
                        case DisplayMetrics.DENSITY_560:
                        case DisplayMetrics.DENSITY_XXXHIGH:
                            densityStr = "XXXHDPI";
                            break;
                        default:
                            densityStr = "other";
                            break;
                    }
                    return densityStr;
                }
                /**
                 * Returns the display name of the current network operator from the
                 * TelephonyManager from the specified context.
                 *
                 * @param context context to use to retrieve the TelephonyManager from
                 * @return the display name of the current network operator, or the empty
                 * string if it cannot be accessed or determined
                 */
                @NonNull
                @Override
                public String getCarrier(@NonNull final Context context) {
                    String carrier = "";
                    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
                    if (manager != null) {
                        carrier = manager.getNetworkOperatorName();
                    }
                    if (carrier == null || carrier.length() == 0) {
                        carrier = "";
                        Countly.sharedInstance().L.i("[DeviceInfo] No carrier found");
                    }
                    if (carrier.equals("--")) {
                        //if for some reason the carrier is returned as "--", just clear it and set to empty string
                        carrier = "";
                    }
                    return carrier;
                }
                @Override
                public int getTimezoneOffset() {
                    return TimeZone.getDefault().getOffset(new Date().getTime()) / 60_000;
                }
                /**
                 * Returns the current locale (ex. "en_US").
                 */
                @NonNull
                @Override
                public String getLocale() {
                    final Locale locale = Locale.getDefault();
                    return locale.getLanguage() + "_" + locale.getCountry();
                }
                /**
                 * Returns the application version string stored in the specified
                 * context's package info versionName field, or "1.0" if versionName
                 * is not present.
                 */
                @NonNull
                @Override
                public String getAppVersion(@NonNull final Context context) {
                    String result = Countly.DEFAULT_APP_VERSION;
                    try {
                        String tmpVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
                        if (tmpVersion != null) {
                            result = tmpVersion;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Countly.sharedInstance().L.i("[DeviceInfo] No app version found");
                    }
                    return result;
                }
                /**
                 * Returns the package name of the app that installed this app
                 */
                @NonNull
                @Override
                public String getStore(@NonNull final Context context) {
                    String result = "";
                    try {
                        result = context.getPackageManager().getInstallerPackageName(context.getPackageName());
                    } catch (Exception e) {
                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] Can't get Installer package ");
                    }
                    if (result == null || result.length() == 0) {
                        result = "";
                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] No store found");
                    }
                    return result;
                }
                /**
                 * Returns what kind of device this is. The potential values are:
                 * ["console", "mobile", "tablet", "smarttv", "wearable", "embedded", "desktop"]
                 * Currently the Android SDK differentiates between ["mobile", "tablet", "smarttv"]
                 */
                @NonNull
                @Override
                public String getDeviceType(@NonNull final Context context) {
                    if (Utils.isDeviceTv(context)) {
                        return "smarttv";
                    }
                    if (Utils.isDeviceTablet(context)) {
                        return "tablet";
                    }
                    return "mobile";
                }
                // Crash related calls
                @Override
                public long getTotalRAM() {
                    if (totalMemory == 0) {
                        RandomAccessFile reader = null;
                        String load;
                        try {
                            reader = new RandomAccessFile("/proc/meminfo", "r");
                            load = reader.readLine();
                            // Get the Number value from the string
                            Pattern p = Pattern.compile("(\\d+)");
                            Matcher m = p.matcher(load);
                            String value = "";
                            while (m.find()) {
                                value = m.group(1);
                            }
                            try {
                                if (value != null) {
                                    totalMemory = Long.parseLong(value) / 1024;
                                } else {
                                    totalMemory = 0;
                                }
                            } catch (NumberFormatException ex) {
                                totalMemory = 0;
                            }
                        } catch (IOException ex) {
                            try {
                                if (reader != null) {
                                    reader.close();
                                }
                            } catch (IOException exc) {
                                exc.printStackTrace();
                            }
                            ex.printStackTrace();
                        } finally {
                            try {
                                if (reader != null) {
                                    reader.close();
                                }
                            } catch (IOException exc) {
                                exc.printStackTrace();
                            }
                        }
                    }
                    return totalMemory;
                }
                /**
                 * Returns the current device RAM amount.
                 */
                @NonNull
                @Override
                public String getRamCurrent(Context context) {
                    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
                    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
                    activityManager.getMemoryInfo(mi);
                    return Long.toString(getTotalRAM() - (mi.availMem / 1_048_576L));
                }
                /**
                 * Returns the total device RAM amount.
                 */
                @NonNull
                @Override
                public String getRamTotal() {
                    return Long.toString(getTotalRAM());
                }
                /**
                 * Returns the current device cpu.
                 */
                @NonNull
                @Override
                public String getCpu() {
                    return Build.SUPPORTED_ABIS[0];
                }
                /**
                 * Returns the current device openGL version.
                 */
                @NonNull
                @Override
                public String getOpenGL(Context context) {
                    PackageManager packageManager = context.getPackageManager();
                    FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
                    if (featureInfos != null && featureInfos.length > 0) {
                        for (FeatureInfo featureInfo : featureInfos) {
                            // Null feature name means this feature is the open gl es version feature.
                            if (featureInfo.name == null) {
                                if (featureInfo.reqGlEsVersion != FeatureInfo.GL_ES_VERSION_UNDEFINED) {
                                    return Integer.toString((featureInfo.reqGlEsVersion & 0xffff0000) >> 16);
                                } else {
                                    return "1"; // Lack of property means OpenGL ES version 1
                                }
                            }
                        }
                    }
                    return "1";
                }
                /**
                 * Returns the current device disk space.
                 */
                @TargetApi(18)
                @NonNull
                @Override
                public String getDiskCurrent() {
                    if (android.os.Build.VERSION.SDK_INT < 18) {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();
                        long free = (long) statFs.getAvailableBlocks() * (long) statFs.getBlockSize();
                        return Long.toString((total - free) / 1_048_576L);
                    } else {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();
                        long free = statFs.getAvailableBlocksLong() * statFs.getBlockSizeLong();
                        return Long.toString((total - free) / 1048576L);
                    }
                }
                /**
                 * Returns the current device disk space.
                 */
                @TargetApi(18)
                @NonNull
                @Override
                public String getDiskTotal() {
                    if (android.os.Build.VERSION.SDK_INT < 18) {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();
                        return Long.toString(total / 1048576L);
                    } else {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();
                        return Long.toString(total / 1048576L);
                    }
                }
                /**
                 * Returns the current device battery level.
                 */
                @Nullable
                @Override
                public String getBatteryLevel(Context context) {
                    try {
                        Intent batteryIntent;
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED), null, null, Context.RECEIVER_NOT_EXPORTED);
                        } else {
                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
                        }
                        if (batteryIntent != null) {
                            int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
                            int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
                            // Error checking that probably isn't needed but I added just in case.
                            if (level > -1 && scale > 0) {
                                return Float.toString(((float) level / (float) scale) * 100.0f);
                            }
                        }
                    } catch (Exception e) {
                        Countly.sharedInstance().L.i("Can't get battery level");
                    }
                    return null;
                }
                /**
                 * Returns the current device orientation.
                 */
                @Nullable
                @Override
                public String getOrientation(Context context) {
                    int orientation = context.getResources().getConfiguration().orientation;
                    switch (orientation) {
                        case Configuration.ORIENTATION_LANDSCAPE:
                            return "Landscape";
                        case Configuration.ORIENTATION_PORTRAIT:
                            return "Portrait";
                        case Configuration.ORIENTATION_SQUARE:
                            return "Square";
                        case Configuration.ORIENTATION_UNDEFINED:
                            return "Unknown";
                        default:
                            return null;
                    }
                }
                /**
                 * Checks if device is rooted.
                 */
                @NonNull
                @Override
                public String isRooted() {
                    String[] paths = {
                        "/sbin/su", "/system/bin/su", "/system/xbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su",
                        "/system/bin/failsafe/su", "/data/local/su"
                    };
                    for (String path : paths) {
                        if (new File(path).exists()) return "true";
                    }
                    return "false";
                }
                /**
                 * Checks if device is online.
                 */
                @SuppressLint("MissingPermission")
                @Nullable
                @Override
                public String isOnline(Context context) {
                    try {
                        ConnectivityManager conMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                        if (conMgr != null && conMgr.getActiveNetworkInfo() != null
                            && conMgr.getActiveNetworkInfo().isAvailable()
                            && conMgr.getActiveNetworkInfo().isConnected()) {
                            return "true";
                        }
                        return "false";
                    } catch (Exception e) {
                        Countly.sharedInstance().L.w("isOnline, Got exception determining netwprl connectivity", e);
                    }
                    return null;
                }
                /**
                 * Checks if device is muted.
                 */
                @NonNull
                @Override
                public String isMuted(Context context) {
                    try {
                        AudioManager audio = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
                        switch (audio.getRingerMode()) {
                            case AudioManager.RINGER_MODE_SILENT:
                                // Fall-through
                            case AudioManager.RINGER_MODE_VIBRATE:
                                return "true";
                            default:
                                return "false";
                        }
                    } catch (Throwable thr) {
                        return "false";
                    }
                }
                /**
                 * Check if device is foldable
                 * requires API level 30
                 *
                 * @param context to use
                 * @return true if device is foldable
                 */
                @Override
                public String hasHinge(Context context) {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_SENSOR_HINGE_ANGLE) + "";
                    }
                    return "false";
                }
                /**
                 * Get app's running time before crashing.
                 */
                @Override public String getRunningTime() {
                    return Integer.toString(UtilsTime.currentTimestampSeconds() - startTime);
                }
            };
        }
    }
    /**
     * Returns the common metrics that would be shared with session, remote config and crash metrics
     * If metric override is provided, it will check for specific keys and override them
     *
     * @param context
     * @param metricOverride
     * @return
     */
    @NonNull
    Map<String, Object> getCommonMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        final Map<String, Object> map = new ConcurrentHashMap<>();
        putIfNotNullAndNotEmpty(map, "_device", mp.getDevice());
        putIfNotNullAndNotEmpty(map, "_os", mp.getOS());
        putIfNotNullAndNotEmpty(map, "_os_version", mp.getOSVersion());
        putIfNotNullAndNotEmpty(map, "_resolution", mp.getResolution(context));
        putIfNotNullAndNotEmpty(map, "_app_version", mp.getAppVersion(context));
        putIfNotNullAndNotEmpty(map, "_manufacturer", mp.getManufacturer());
        putIfNotNullAndNotEmpty(map, "_has_hinge", mp.hasHinge(context));
        if (metricOverride != null) {
            try {
                if (metricOverride.containsKey("_device")) {
                    map.put("_device", metricOverride.get("_device"));
                }
                if (metricOverride.containsKey("_os")) {
                    map.put("_os", metricOverride.get("_os"));
                }
                if (metricOverride.containsKey("_os_version")) {
                    map.put("_os_version", metricOverride.get("_os_version"));
                }
                if (metricOverride.containsKey("_resolution")) {
                    map.put("_resolution", metricOverride.get("_resolution"));
                }
                if (metricOverride.containsKey("_app_version")) {
                    map.put("_app_version", metricOverride.get("_app_version"));
                }
                if (metricOverride.containsKey("_manufacturer")) {
                    map.put("_manufacturer", metricOverride.get("_manufacturer"));
                }
                if (metricOverride.containsKey("_has_hinge")) {
                    map.put("_has_hinge", metricOverride.get("_has_hinge"));
                }
            } catch (Exception e) {
                L.e("[DeviceInfo] getCommonMetrics, SDK encountered failure while trying to apply metric override, " + e);
            }
        }
        return map;
    }
    private void putIfNotNullAndNotEmpty(@NonNull Map<String, Object> metrics, String key, String value) {
        if (value != null && !value.isEmpty()) {
            metrics.put(key, value);
        }
    }
    /**
     * Returns url encoded metrics that would be used for "begin_session" requests and remote config
     *
     * @param context
     * @param metricOverride
     * @return
     */
    @NonNull
    String getMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        //we set the override to null because all of the entries will be overwritten anyway
        Map<String, Object> metrics = getCommonMetrics(context, null, L);
        putIfNotNullAndNotEmpty(metrics, "_carrier", mp.getCarrier(context));
        putIfNotNullAndNotEmpty(metrics, "_density", mp.getDensity(context));
        putIfNotNullAndNotEmpty(metrics, "_locale", mp.getLocale());
        putIfNotNullAndNotEmpty(metrics, "_store", mp.getStore(context));
        putIfNotNullAndNotEmpty(metrics, "_device_type", mp.getDeviceType(context));
        if (metricOverride != null) {
            for (String k : metricOverride.keySet()) {
                if (k == null || k.isEmpty()) {
                    L.w("[DeviceInfo] getMetrics, Provided metric override key can't be null or empty");
                    continue;
                }
                String overrideValue = metricOverride.get(k);
                if (overrideValue == null) {
                    L.w("[DeviceInfo] getMetrics, Provided metric override value can't be null, key:[" + k + "]");
                    continue;
                }
                metrics.put(k, overrideValue);
            }
        }
        String result = new JSONObject(metrics).toString();
        try {
            result = java.net.URLEncoder.encode(result, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            // should never happen because Android guarantees UTF-8 support
            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");
        }
        return result;
    }
    @NonNull
    String getMetricsHealthCheck(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {
        Map<String, Object> metrics = new ConcurrentHashMap<>();
        String appVersion = mp.getAppVersion(context);
        if (metricOverride != null) {
            if (metricOverride.containsKey("_app_version")) {
                appVersion = metricOverride.get("_app_version");
            }
        }
        metrics.put("_app_version", appVersion);
        String result = new JSONObject(metrics).toString();
        try {
            result = java.net.URLEncoder.encode(result, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            // should never happen because Android guarantees UTF-8 support
            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");
        }
        return result;
    }
    /**
     * Returns a JSON object containing the device crash report
     */
    @NonNull
    JSONObject getCrashDataJSON(@NonNull CrashData crashData, final boolean isNativeCrash) {
        Map<String, Object> crashDataMap = crashData.getCrashMetrics();
        //setting this first so the followup are not picked up as "dev changes" in the change field
        crashDataMap.put("_ob", crashData.getChangedFieldsAsInt());
        putIfNotNullAndNotEmpty(crashDataMap, "_error", crashData.getStackTrace());
        putIfNotNullAndNotEmpty(crashDataMap, "_nonfatal", Boolean.toString(!crashData.getFatal()));
        if (!isNativeCrash) {
            String breadcrumbs = crashData.getBreadcrumbsAsString();
            if (!breadcrumbs.isEmpty()) {
                crashDataMap.put("_logs", breadcrumbs);
            }
        }
        if (!crashData.getCrashSegmentation().isEmpty()) {
            crashDataMap.put("_custom", crashData.getCrashSegmentation());
        }
        return new JSONObject(crashDataMap);
    }
    @NonNull
    Map<String, Object> getCrashMetrics(@NonNull final Context context, boolean isNativeCrash, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        Map<String, Object> metrics = getCommonMetrics(context, metricOverride, L);
        putIfNotNullAndNotEmpty(metrics, "_cpu", mp.getCpu());
        putIfNotNullAndNotEmpty(metrics, "_opengl", mp.getOpenGL(context));
        putIfNotNullAndNotEmpty(metrics, "_root", mp.isRooted());
        putIfNotNullAndNotEmpty(metrics, "_ram_total", mp.getRamTotal());
        putIfNotNullAndNotEmpty(metrics, "_disk_total", mp.getDiskTotal());
        if (!isNativeCrash) {
            //if is not a native crash
            putIfNotNullAndNotEmpty(metrics, "_ram_current", mp.getRamCurrent(context));
            putIfNotNullAndNotEmpty(metrics, "_disk_current", mp.getDiskCurrent());
            putIfNotNullAndNotEmpty(metrics, "_bat", mp.getBatteryLevel(context));
            putIfNotNullAndNotEmpty(metrics, "_run", mp.getRunningTime());
            putIfNotNullAndNotEmpty(metrics, "_orientation", mp.getOrientation(context));
            putIfNotNullAndNotEmpty(metrics, "_online", mp.isOnline(context));
            putIfNotNullAndNotEmpty(metrics, "_muted", mp.isMuted(context));
            putIfNotNullAndNotEmpty(metrics, "_background", isInBackground());
        } else {
            //if is a native crash
            metrics.put("_native_cpp", true);
        }
        return metrics;
    }
    @NonNull
    public String getAppVersionWithOverride(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {
        String appVersion = mp.getAppVersion(context);
        if (metricOverride != null && metricOverride.containsKey("_app_version")) {
            String overrideVersion = metricOverride.get("_app_version");
            if (overrideVersion != null) {
                appVersion = overrideVersion;
            }
        }
        return appVersion;
    }
    /**
     * Notify when app is in foreground
     */
    void inForeground() {
        inBackground = false;
    }
    /**
     * Notify when app is in background
     */
    void inBackground() {
        inBackground = true;
    }
    /**
     * Returns app background state
     */
    String isInBackground() {
        return Boolean.toString(inBackground);
    }
}
package ly.count.android.sdk;
import android.app.Application;
import android.content.Context;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
public class CountlyConfig {
    /**
     * Internal fields and fields for testing
     */
    protected CountlyStore countlyStore = null;
    /**
     * Used to pass the consent provider to all modules and features
     */
    protected ConsentProvider consentProvider = null;
    /**
     * Used to pass the storage provider to all modules and features
     */
    protected StorageProvider storageProvider = null;
    protected EventProvider eventProvider = null;
    protected EventQueueProvider eventQueueProvider = null;
    protected RequestQueueProvider requestQueueProvider = null;
    protected DeviceIdProvider deviceIdProvider = null;
    protected ViewIdProvider viewIdProvider = null;
    protected BaseInfoProvider baseInfoProvider = null;
    protected ConfigurationProvider configProvider = null;
    protected SafeIDGenerator safeViewIDGenerator = null;
    protected SafeIDGenerator safeEventIDGenerator = null;
    protected ImmediateRequestGenerator immediateRequestGenerator = null;
    protected HealthTracker healthTracker;
    protected MetricProvider metricProviderOverride = null;
    protected DeviceInfo deviceInfo = null;
    protected ModuleBase testModuleListener = null;
    protected Map<String, Object> providedUserProperties = null;
    protected Countly.LifecycleObserver lifecycleObserver = null;
    //used to deliver this object to connection queue
    //protected DeviceId deviceIdInstance = null;
    // Fields used for SDK configuration during init
    /**
     * Android context.
     * Mandatory field.
     */
    protected Context context = null;
    /**
     * URL of the Countly server to submit data to.
     * Mandatory field.
     */
    protected String serverURL = null;
    /**
     * app key for the application being tracked; find in the Countly Dashboard under Management &gt; Applications.
     * Mandatory field.
     */
    protected String appKey = null;
    /**
     * unique ID for the device the app is running on; note that null in deviceID means that Countly will fall back to OpenUDID, then, if it's not available, to Google Advertising ID.
     */
    protected String deviceID = null;
    /**
     * sets the limit after how many sessions, for each apps version, the automatic star rating dialog is shown.
     */
    protected int starRatingSessionLimit = 5;
    /**
     * the callback function that will be called from the automatic star rating dialog.
     */
    protected StarRatingCallback starRatingCallback = null;
    /**
     * the shown title text for the star rating dialogs.
     */
    protected String starRatingTextTitle = null;
    /**
     * the shown message text for the star rating dialogs.
     */
    protected String starRatingTextMessage = null;
    /**
     * the shown dismiss button text for the shown star rating dialogs.
     */
    protected String starRatingTextDismiss = null;
    protected boolean loggingEnabled = false;
    protected boolean enableAutomaticViewTracking = false;
    protected boolean autoTrackingUseShortName = false;
    protected Class[] automaticViewTrackingExceptions = null;
    protected Map<String, Object> globalViewSegmentation = null;
    protected Map<String, String> customNetworkRequestHeaders = null;
    protected boolean pushIntentAddMetadata = false;
    protected boolean enableRemoteConfigAutomaticDownloadTriggers = false;
    protected boolean enableAutoEnrollFlag = false;
    boolean enableRemoteConfigValueCaching = false;
    protected RemoteConfigCallback remoteConfigCallbackLegacy = null;
    protected List<RCDownloadCallback> remoteConfigGlobalCallbackList = new ArrayList<>(2);
    protected boolean shouldRequireConsent = false;
    protected boolean enableAllConsents = false;
    protected String[] enabledFeatureNames = null;
    protected boolean httpPostForced = false;
    protected boolean temporaryDeviceIdEnabled = false;
    protected String tamperingProtectionSalt = null;
    protected Integer eventQueueSizeThreshold = null;
    protected boolean trackOrientationChange = true;
    protected boolean manualSessionControlEnabled = false;
    protected boolean manualSessionControlHybridModeEnabled = false;
    protected boolean disableUpdateSessionRequests = false;
    protected boolean shouldIgnoreAppCrawlers = false;
    protected String[] appCrawlerNames = null;
    protected String[] publicKeyPinningCertificates = null;
    protected String[] certificatePinningCertificates = null;
    protected Integer sessionUpdateTimerDelay = null;
    /**
     * @deprecated This is deprecated, will be removed in the future
     */
    protected CrashFilterCallback crashFilterCallback;
    protected boolean starRatingDialogIsCancellable = false;
    protected boolean starRatingShownAutomatically = false;
    protected boolean starRatingDisableAskingForEachAppVersion = false;
    protected Application application = null;
    boolean disableLocation = false;
    String locationCountyCode = null;
    String locationCity = null;
    String locationLocation = null;
    String locationIpAddress = null;
    Map<String, String> metricOverride = null;
    int maxRequestQueueSize = 1000;
    ModuleLog.LogCallback providedLogCallback;
    String daCampaignType = null;
    String daCampaignData = null;
    Map<String, String> iaAttributionValues = null;
    boolean explicitStorageModeEnabled = false;
    boolean serverConfigurationEnabled = false;
    boolean healthCheckEnabled = true;
    // Requests older than this value in hours would be dropped (0 means this feature is disabled)
    int dropAgeHours = 0;
    /**
     * THIS VARIABLE SHOULD NOT BE USED
     * IT IS ONLY FOR INTERNAL TESTING
     * BREAKING CHANGES WILL BE DONE WITHOUT WARNING
     */
    public PerformanceCounterCollector pcc;
    /**
     * Sets how many segmentation values can be recorded when recording an event or view.
     * Values exceeding this count will be ignored.
     *
     * @param maxSegmentationValues to set
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>sdkInternalLimits.setMaxSegmentationValues(int)</pre> instead
     */
    public synchronized CountlyConfig setMaxSegmentationValues(int maxSegmentationValues) {
        sdkInternalLimits.setMaxSegmentationValues(maxSegmentationValues);
        return this;
    }
    /**
     * Set the maximum amount of breadcrumbs that can be recorded.
     * After exceeding the limit, the oldest values will be removed.
     *
     * @param maxBreadcrumbCount to set
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>sdkInternalLimits.setMaxBreadcrumbCount(int)</pre> instead
     */
    public synchronized CountlyConfig setMaxBreadcrumbCount(int maxBreadcrumbCount) {
        sdkInternalLimits.setMaxBreadcrumbCount(maxBreadcrumbCount);
        return this;
    }
    public CountlyConfig() {
    }
    /**
     * @param context
     * @param appKey
     * @param serverURL
     */
    public CountlyConfig(Context context, String appKey, String serverURL) {
        setContext(context);
        setAppKey(appKey);
        setServerURL(serverURL);
    }
    public CountlyConfig(Application application, String appKey, String serverURL) {
        setAppKey(appKey);
        setServerURL(serverURL);
        setApplication(application);
    }
    /**
     * Android context.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setContext(Context context) {
        this.context = context;
        return this;
    }
    /**
     * URL of the Countly server to submit data to.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setServerURL(String serverURL) {
        this.serverURL = serverURL;
        return this;
    }
    /**
     * app key for the application being tracked; find in the Countly Dashboard under Management &gt; Applications.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAppKey(String appKey) {
        this.appKey = appKey;
        return this;
    }
    /**
     * unique ID for the device the app is running on; note that null in deviceID means that Countly will fall back to OpenUDID, then, if it's not available, to Google Advertising ID.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDeviceId(String deviceID) {
        this.deviceID = deviceID;
        return this;
    }
    /**
     * enum value specifying which device ID generation strategy Countly should use: OpenUDID or Google Advertising ID.
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call should not be used anymore as it does not have any purpose anymore
     */
    public synchronized CountlyConfig setIdMode(DeviceIdType idMode) {
        return this;
    }
    /**
     * sets the limit after how many sessions, for each apps version, the automatic star rating dialog is shown.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingSessionLimit(int starRatingLimit) {
        this.starRatingSessionLimit = starRatingLimit;
        return this;
    }
    /**
     * the callback function that will be called from the automatic star rating dialog.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingCallback(StarRatingCallback starRatingCallback) {
        this.starRatingCallback = starRatingCallback;
        return this;
    }
    /**
     * the shown title text for the star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextTitle(String starRatingTextTitle) {
        this.starRatingTextTitle = starRatingTextTitle;
        return this;
    }
    /**
     * the shown message text for the star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextMessage(String starRatingTextMessage) {
        this.starRatingTextMessage = starRatingTextMessage;
        return this;
    }
    /**
     * the shown dismiss button text for the shown star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextDismiss(String starRatingTextDismiss) {
        this.starRatingTextDismiss = starRatingTextDismiss;
        return this;
    }
    /**
     * Set to true of you want to enable countly internal debugging logs
     * Those logs will be printed to the console
     *
     * @param enabled Set to true of you want to enable countly internal debugging logs
     */
    public synchronized CountlyConfig setLoggingEnabled(boolean enabled) {
        this.loggingEnabled = enabled;
        return this;
    }
    /**
     * Call to enable uncaught crash reporting
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.enableCrashReporting()</pre> instead
     */
    public synchronized CountlyConfig enableCrashReporting() {
        crashes.enableCrashReporting();
        return this;
    }
    /**
     * Set if automatic view tracking should be enabled
     *
     * @param enable
     * @return Returns the same config object for convenient linking
     * @deprecated Use "enableAutomaticViewTracking()"
     */
    public synchronized CountlyConfig setViewTracking(boolean enable) {
        this.enableAutomaticViewTracking = enable;
        return this;
    }
    /**
     * Enable automatic view tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableAutomaticViewTracking() {
        this.enableAutomaticViewTracking = true;
        return this;
    }
    /**
     * Enable short names for automatic view tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableAutomaticViewShortNames() {
        this.autoTrackingUseShortName = true;
        return this;
    }
    /**
     * Set if automatic activity tracking should use short names
     *
     * @param enable set true if you want short names
     * @return Returns the same config object for convenient linking
     * @deprecated use "enableAutomaticViewShortNames()"
     */
    public synchronized CountlyConfig setAutoTrackingUseShortName(boolean enable) {
        this.autoTrackingUseShortName = enable;
        return this;
    }
    /**
     * @param segmentation segmentation values that will be added for all recorded views (manual and automatic)
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setGlobalViewSegmentation(Map<String, Object> segmentation) {
        globalViewSegmentation = segmentation;
        return this;
    }
    /**
     * @param segmentation
     * @return Returns the same config object for convenient linking
     * @deprecated please use "setGlobalViewSegmentation(Map<String, Object>)"
     */
    public synchronized CountlyConfig setAutomaticViewSegmentation(Map<String, Object> segmentation) {
        globalViewSegmentation = segmentation;
        return this;
    }
    /**
     * Set which activities should be excluded from automatic view tracking
     *
     * @param exclusions activities which should be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAutomaticViewTrackingExclusions(Class[] exclusions) {
        if (exclusions != null) {
            for (Class exception : exclusions) {
                if (exception == null) {
                    throw new IllegalArgumentException("setAutomaticViewTrackingExclusions(...) does not accept 'null' activities");
                }
            }
        }
        automaticViewTrackingExceptions = exclusions;
        return this;
    }
    /**
     * Set which activities should be excluded from automatic view tracking
     *
     * @param exceptions activities which should be ignored
     * @return Returns the same config object for convenient linking
     * @deprecated Use "setAutomaticViewTrackingExclusions(Class[])"
     */
    public synchronized CountlyConfig setAutoTrackingExceptions(Class[] exceptions) {
        return setAutomaticViewTrackingExclusions(exceptions);
    }
    /**
     * Allows you to add custom header key/value pairs to each request
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig addCustomNetworkRequestHeaders(Map<String, String> customHeaderValues) {
        this.customNetworkRequestHeaders = customHeaderValues;
        return this;
    }
    /**
     * @param enable
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setPushIntentAddMetadata(boolean enable) {
        pushIntentAddMetadata = enable;
        return this;
    }
    /**
     * If enable, will automatically download newest remote config values.
     *
     * @param enabled set true for enabling it
     * @param callback callback called after the update was done
     * @return Returns the same config object for convenient linking
     * @deprecated use "enableRemoteConfigAutomaticTriggers" and "RemoteConfigRegisterGlobalCallback" in it's place
     */
    public synchronized CountlyConfig setRemoteConfigAutomaticDownload(boolean enabled, RemoteConfigCallback callback) {
        enableRemoteConfigAutomaticDownloadTriggers = enabled;
        remoteConfigCallbackLegacy = callback;
        return this;
    }
    /**
     * Calling this would enable automatic download triggers for remote config.
     * This way the SDK would automatically initiate remote config download at specific points.
     * For example, those include: the SDK finished initializing, device ID is changed, consent is given
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableRemoteConfigAutomaticTriggers() {
        enableRemoteConfigAutomaticDownloadTriggers = true;
        return this;
    }
    /**
     * Calling this would enable automatic enrollment of the user to the available experiments when RC is downloaded.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enrollABOnRCDownload() {
        enableAutoEnrollFlag = true;
        return this;
    }
    /**
     * This would set a time frame in which the requests older than the given hours would be dropped while sending a request
     * Ex: Setting this to 10 would mean any requests created more than 10 hours ago would be dropped if they were in the queue
     *
     * @param dropAgeHours A positive integer. Requests older than the 'dropAgeHours' (with respect to now) would be dropped
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setRequestDropAgeHours(int dropAgeHours) {
        this.dropAgeHours = dropAgeHours;
        return this;
    }
    /**
     * If this option is not enabled then when the device ID is changed without merging, remote config values are cleared
     * If this option is enabled then the previous values are not cleared but they are marked as not from the current user.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableRemoteConfigValueCaching() {
        enableRemoteConfigValueCaching = true;
        return this;
    }
    /**
     * Calling this adds global listeners for remote config download callbacks.
     * Calling this multiple times would add multiple listeners
     *
     * @param callback The callback that needs to be registered
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig RemoteConfigRegisterGlobalCallback(RCDownloadCallback callback) {
        remoteConfigGlobalCallbackList.add(callback);
        return this;
    }
    /**
     * Set if consent should be required
     *
     * @param shouldRequireConsent if set to "true" then the SDK will require consent to be used. If consent for features is not given, they would not function
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setRequiresConsent(boolean shouldRequireConsent) {
        this.shouldRequireConsent = shouldRequireConsent;
        return this;
    }
    /**
     * Sets which features are enabled in case consent is required
     *
     * @param featureNames
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setConsentEnabled(String[] featureNames) {
        enabledFeatureNames = featureNames;
        return this;
    }
    /**
     * Give consent to all features
     *
     * @return
     */
    public synchronized CountlyConfig giveAllConsents() {
        enableAllConsents = true;
        return this;
    }
    /**
     * Set the override for forcing to use HTTP POST for all connections to the server
     *
     * @param isForced the flag for the new status, set "true" if you want it to be forced
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setHttpPostForced(boolean isForced) {
        httpPostForced = isForced;
        return this;
    }
    /**
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableTemporaryDeviceIdMode() {
        temporaryDeviceIdEnabled = true;
        return this;
    }
    /**
     * @param callback
     * @return Returns the same config object for convenient linking
     * @deprecated This call is deprecated, please use <pre>crashes.setGlobalCrashFilterCallback(GlobalCrashFilterCallback)</pre> instead
     */
    public synchronized CountlyConfig setCrashFilterCallback(CrashFilterCallback callback) {
        crashFilterCallback = callback;
        return this;
    }
    /**
     * @param salt
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setParameterTamperingProtectionSalt(String salt) {
        tamperingProtectionSalt = salt;
        return this;
    }
    /**
     * @param shouldTrackOrientation
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setTrackOrientationChanges(boolean shouldTrackOrientation) {
        trackOrientationChange = shouldTrackOrientation;
        return this;
    }
    /**
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.enableRecordAllThreadsWithCrash()</pre> instead
     */
    public synchronized CountlyConfig setRecordAllThreadsWithCrash() {
        crashes.enableRecordAllThreadsWithCrash();
        return this;
    }
    /**
     * Set if attribution should be enabled
     *
     * @param enableAttribution set true if you want to enable it, set false if you want to disable it
     * @return Returns the same config object for convenient linking
     * @deprecated This call will not do anything anymore. Use 'setDirectAttribution' or 'setIndirectAttribution' for attribution purposes
     */
    public synchronized CountlyConfig setEnableAttribution(boolean enableAttribution) {
        return this;
    }
    /**
     * Allows public key pinning.
     * Supply list of SSL certificates (base64-encoded strings between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----" without end-of-line)
     * along with server URL starting with "https://". Countly will only accept connections to the server
     * if public key of SSL certificate provided by the server matches one provided to this method.
     *
     * @param certificates List of SSL public keys
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enablePublicKeyPinning(String[] certificates) {
        publicKeyPinningCertificates = certificates;
        return this;
    }
    /**
     * Allows certificate pinning.
     * Supply list of SSL certificates (base64-encoded strings between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----" without end-of-line)
     * along with server URL starting with "https://". Countly will only accept connections to the server
     * if certificate provided by the server matches one provided to this method.
     *
     * @param certificates List of SSL certificates
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableCertificatePinning(String[] certificates) {
        certificatePinningCertificates = certificates;
        return this;
    }
    /**
     * Set if Countly SDK should ignore app crawlers
     *
     * @param shouldIgnore if crawlers should be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setShouldIgnoreAppCrawlers(boolean shouldIgnore) {
        shouldIgnoreAppCrawlers = shouldIgnore;
        return this;
    }
    /**
     * List of app crawler names that should be ignored
     *
     * @param appCrawlerNames the names to be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAppCrawlerNames(String[] appCrawlerNames) {
        this.appCrawlerNames = appCrawlerNames;
        return this;
    }
    /**
     * Set the threshold for event grouping. Event count that is bellow the
     * threshold will be sent on update ticks.
     *
     * @param threshold
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setEventQueueSizeToSend(int threshold) {
        eventQueueSizeThreshold = threshold;
        return this;
    }
    public synchronized CountlyConfig enableManualSessionControl() {
        manualSessionControlEnabled = true;
        return this;
    }
    public synchronized CountlyConfig enableManualSessionControlHybridMode() {
        manualSessionControlHybridModeEnabled = true;
        return this;
    }
    /**
     * Set custom crash segmentation which will be added to all recorded crashes
     *
     * @param crashSegment segmentation information. Accepted values are "Integer", "String", "Double", "Boolean"
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.setCustomCrashSegmentation(Map<String, Object>)</pre> instead
     */
    public synchronized CountlyConfig setCustomCrashSegment(Map<String, Object> crashSegment) {
        crashes.setCustomCrashSegmentation(crashSegment);
        return this;
    }
    /**
     * For use during testing
     *
     * @param checkForDumps whether to check for native crash dumps
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated and will always be enabled
     */
    protected synchronized CountlyConfig checkForNativeCrashDumps(boolean checkForDumps) {
        return this;
    }
    /**
     * Sets the interval for the automatic session update calls
     * min value 1 (1 second)
     *
     * @param delay in seconds
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setUpdateSessionTimerDelay(int delay) {
        sessionUpdateTimerDelay = delay;
        return this;
    }
    /**
     * For use during testing
     *
     * @param store
     * @return Returns the same config object for convenient linking
     */
    protected synchronized CountlyConfig setCountlyStore(CountlyStore store) {
        countlyStore = store;
        return this;
    }
    /**
     * Disable periodic session time updates.
     * By default, Countly will send a request to the server each 60 seconds with a small update
     * containing session duration time. This method allows you to disable such behavior.
     * Note that event updates will still be sent every 100 events or 60 seconds after event recording.
     *
     * @param disable whether or not to disable session time updates
     * @return Returns the same config object for convenient linking
     */
    protected synchronized CountlyConfig setDisableUpdateSessionRequests(boolean disable) {
        disableUpdateSessionRequests = disable;
        return this;
    }
    /**
     * Set if the star rating dialog is cancellable
     *
     * @param isCancellable set this true if it should be cancellable
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIfStarRatingDialogIsCancellable(boolean isCancellable) {
        starRatingDialogIsCancellable = isCancellable;
        return this;
    }
    /**
     * Set if the star rating should be shown automatically
     *
     * @param isShownAutomatically set it true if you want to show the app star rating dialog automatically for each new version after the specified session amount
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIfStarRatingShownAutomatically(boolean isShownAutomatically) {
        starRatingShownAutomatically = isShownAutomatically;
        return this;
    }
    /**
     * Set if the star rating is shown only once per app lifetime
     *
     * @param disableAsking set true if you want to disable asking the app rating for each new app version (show it only once per apps lifetime)
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingDisableAskingForEachAppVersion(boolean disableAsking) {
        starRatingDisableAskingForEachAppVersion = disableAsking;
        return this;
    }
    /**
     * Set the link to the application class
     *
     * @param application
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setApplication(Application application) {
        this.application = application;
        return this;
    }
    /**
     * Enable the recording of the app start time
     *
     * @param recordAppStartTime set true if you want to enable the recording of the app start time
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.enableAppStartTracking()</pre> instead
     */
    public synchronized CountlyConfig setRecordAppStartTime(boolean recordAppStartTime) {
        apm.trackAppStartTime = recordAppStartTime;
        return this;
    }
    /**
     * Disable location tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDisableLocation() {
        disableLocation = true;
        return this;
    }
    /**
     * Set location parameters.
     * This will be ignored if set together with `setDisableLocation`
     *
     * @param country_code ISO Country code for the user's country
     * @param city Name of the user's city
     * @param gpsCoordinates comma separate lat and lng values. For example, "56.42345,123.45325"
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setLocation(String country_code, String city, String gpsCoordinates, String ipAddress) {
        locationCountyCode = country_code;
        locationCity = city;
        locationLocation = gpsCoordinates;
        locationIpAddress = ipAddress;
        return this;
    }
    /**
     * Set the metrics you want to override or additional custom metrics you want to provide
     *
     * @param providedMetricOverride
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setMetricOverride(Map<String, String> providedMetricOverride) {
        metricOverride = providedMetricOverride;
        return this;
    }
    /**
     * Override the app start timestamp in case you have a more precise way to measure it
     *
     * @param appStartTimestampOverride The timestamp to use as the app start timestamp
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.setAppStartTimestampOverride()</pre> instead
     */
    public synchronized CountlyConfig setAppStartTimestampOverride(long appStartTimestampOverride) {
        apm.setAppStartTimestampOverride(appStartTimestampOverride);
        return this;
    }
    /**
     * Set to manually trigger the moment when the app has finished loading
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.enableManualAppLoadedTrigger()</pre> instead
     */
    public synchronized CountlyConfig enableManualAppLoadedTrigger() {
        apm.enableManualAppLoadedTrigger();
        return this;
    }
    /**
     * Set this in case you want to control these triggers manually
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated and will be removed in the future
     */
    public synchronized CountlyConfig enableManualForegroundBackgroundTriggerAPM() {
        apm.manualForegroundBackgroundTrigger = true;
        return this;
    }
    /**
     * Add a log callback that will duplicate all logs done by the SDK.
     * For each message you will receive the message string and it's targeted log level.
     *
     * @param logCallback
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setLogListener(ModuleLog.LogCallback logCallback) {
        providedLogCallback = logCallback;
        return this;
    }
    /**
     * Set's the new maximum size for the request queue.
     *
     * @param newMaxSize Minimum value is "1".
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setMaxRequestQueueSize(int newMaxSize) {
        maxRequestQueueSize = newMaxSize;
        return this;
    }
    /**
     * Report direct user attribution
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDirectAttribution(String campaignType, String campaignData) {
        daCampaignType = campaignType;
        daCampaignData = campaignData;
        return this;
    }
    /**
     * Report indirect user attribution
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIndirectAttribution(Map<String, String> attributionValues) {
        iaAttributionValues = attributionValues;
        return this;
    }
    /**
     * Used to provide user properties that would be sent as soon as possible
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setUserProperties(Map<String, Object> userProperties) {
        providedUserProperties = userProperties;
        return this;
    }
    /**
     * If this mode is enabled then the SDK not write the request and event queues to disk
     * until the explicit write signal is given.
     *
     * The explicit write signal is given with:
     * 'Countly.sharedInstance().requestQueue().esWriteCachesToPersistence();'
     *
     * If not used properly, this mode will lead to data loss or data duplication.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableExplicitStorageMode() {
        explicitStorageModeEnabled = true;
        return this;
    }
    /**
     * This is an experimental feature and it can have breaking changes
     *
     * With this mode enable, the SDK will acquire additional configuration from it's Countly server
     *
     * @return Returns the same config object for convenient linking
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public synchronized CountlyConfig enableServerConfiguration() {
        serverConfigurationEnabled = true;
        return this;
    }
    protected synchronized CountlyConfig disableHealthCheck() {
        healthCheckEnabled = false;
        return this;
    }
    /**
     * APM configuration interface to be used with CountlyConfig
     */
    public final ConfigApm apm = new ConfigApm();
    /**
     * SDK Internal Limits configuration interface to be used with CountlyConfig
     */
    public final ConfigSdkInternalLimits sdkInternalLimits = new ConfigSdkInternalLimits();
    /**
     * Crash Reporting configuration interface to be used with CountlyConfig
     */
    public final ConfigCrashes crashes = new ConfigCrashes();
    /**
     * Content configuration interface to be used with CountlyConfig
     *
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public final ConfigContent content = new ConfigContent();
    /**
     * Experimental configuration interface to be used with CountlyConfig
     *
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public final ConfigExperimental experimental = new ConfigExperimental();
}
package ly.count.android.sdk;
import android.content.Intent;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class ModuleConsent extends ModuleBase implements ConsentProvider {
    Consent consentInterface = null;
    //a list of valid feature names that are used for checking
    protected static final String[] validFeatureNames = {
        Countly.CountlyFeatureNames.sessions,
        Countly.CountlyFeatureNames.events,
        Countly.CountlyFeatureNames.views,
        Countly.CountlyFeatureNames.location,
        Countly.CountlyFeatureNames.crashes,
        Countly.CountlyFeatureNames.attribution,
        Countly.CountlyFeatureNames.users,
        Countly.CountlyFeatureNames.push,
        Countly.CountlyFeatureNames.starRating,
        Countly.CountlyFeatureNames.remoteConfig,
        Countly.CountlyFeatureNames.apm,
        Countly.CountlyFeatureNames.feedback,
        Countly.CountlyFeatureNames.clicks,
        Countly.CountlyFeatureNames.scrolls,
        Countly.CountlyFeatureNames.content,
    };
    public enum ConsentChangeSource {ChangeConsentCall, DeviceIDChangedNotMerged}
    protected boolean requiresConsent = false;
    final Map<String, Boolean> featureConsentValues = new HashMap<>();
    private final Map<String, String[]> groupedFeatures = new HashMap<>();
    ModuleConsent(@NonNull final Countly cly, @NonNull final CountlyConfig config) {
        super(cly, config);
        consentProvider = this;
        config.consentProvider = this;
        L.v("[ModuleConsent] constructor, Initialising");
        L.i("[ModuleConsent] Is consent required? [" + config.shouldRequireConsent + "]");
        //setup initial consent data structure
        //initialize all features to "false"
        for (String featureName : validFeatureNames) {
            featureConsentValues.put(featureName, false);
        }
        //react to given consent during init
        if (config.shouldRequireConsent) {
            requiresConsent = config.shouldRequireConsent;
            if (config.enabledFeatureNames == null && !config.enableAllConsents) {
                L.i("[ModuleConsent] constructor, Consent has been required but no consent was given during init");
            } else {
                if (config.enableAllConsents) {
                    //set all consent values to "true"
                    L.i("[ModuleConsent] constructor, Giving consent for all features");
                    for (String featureName : validFeatureNames) {
                        featureConsentValues.put(featureName, true);
                    }
                } else {
                    //set provided consent values
                    L.i("[ModuleConsent] constructor, Giving consent for features named: [" + Arrays.toString(config.enabledFeatureNames) + "]");
                    for (String providedFeature : config.enabledFeatureNames) {
                        featureConsentValues.put(providedFeature, true);
                    }
                }
            }
        }
        consentInterface = new Consent();
    }
    public boolean getConsent(@NonNull final String featureName) {
        return getConsentInternal(featureName);
    }
    public boolean anyConsentGiven() {
        if (!requiresConsent) {
            //no consent required - all consent given
            return true;
        }
        for (String key : featureConsentValues.keySet()) {
            if (getConsentTrue(key)) {
                return true;
            }
        }
        return false;
    }
    boolean getConsentInternal(@Nullable final String featureName) {
        if (featureName == null) {
            L.e("[ModuleConsent] getConsentInternal, Can't call this with a 'null' feature name!");
            return false;
        }
        if (!requiresConsent) {
            //return true silently
            return true;
        }
        boolean returnValue = getConsentTrue(featureName);
        L.v("[ModuleConsent] getConsentInternal, Returning consent for feature named: [" + featureName + "] [" + returnValue + "]");
        return returnValue;
    }
    /**
     * Returns the true internally set value
     *
     * @param featureName
     */
    private boolean getConsentTrue(@NonNull final String featureName) {
        Boolean returnValue = featureConsentValues.get(featureName);
        if (returnValue == null) {
            returnValue = false;
        }
        return returnValue;
    }
    /**
     * Print the consent values of all features
     */
    public void checkAllConsentInternal() {
        L.d("[ModuleConsent] checkAllConsentInternal, consentRequired: [" + requiresConsent + "]");
        //make sure push consent has been added to the feature map
        getConsent(Countly.CountlyFeatureNames.push);
        StringBuilder sb = new StringBuilder();
        for (String key : featureConsentValues.keySet()) {
            sb.append("Feature named [").append(key).append("], consent value: [").append(featureConsentValues.get(key)).append("]\n");
        }
        L.d("[ModuleConsent] checkAllConsentInternal, Current consent state: [" + sb + "]");
    }
    /**
     * Special things needed to be done during setting push consent
     *
     * @param consentValue The value of push consent
     */
    void doPushConsentSpecialAction(final boolean consentValue) {
        L.d("[ModuleConsent] doPushConsentSpecialAction, consentValue: [" + consentValue + "]");
        _cly.countlyStore.setConsentPush(consentValue);
        _cly.context_.sendBroadcast(new Intent(Countly.CONSENT_BROADCAST));
    }
    /**
     * Check if the given name is a valid feature name
     *
     * @param name the name of the feature to be tested if it is valid
     * @return returns true if value is contained in feature name array
     */
    private boolean isValidFeatureName(@Nullable final String name) {
        for (String fName : validFeatureNames) {
            if (fName.equals(name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Prepare the current feature state into a json format
     *
     * @param features the names of features that are about to be changed
     * @return provided consent changes in json format
     */
    private @NonNull String formatConsentState(@NonNull final Map<String, Boolean> features) {
        StringBuilder preparedConsent = new StringBuilder();
        preparedConsent.append("{");
        boolean commaAdded = false;
        for (Map.Entry<String, Boolean> entry : features.entrySet()) {
            if (commaAdded) {
                preparedConsent.append(",");
            } else {
                commaAdded = true;
            }
            preparedConsent.append('"');
            preparedConsent.append(entry.getKey());
            preparedConsent.append('"');
            preparedConsent.append(':');
            preparedConsent.append(entry.getValue());
        }
        preparedConsent.append("}");
        return preparedConsent.toString();
    }
    void setConsentInternal(@Nullable final String[] featureNames, final boolean isConsentGiven, final ConsentChangeSource changeSource) {
        L.d("[ModuleConsent] setConsentInternal, featureNames: [" + Arrays.toString(featureNames) + "] to value: [" + isConsentGiven + "], changeSource: [" + changeSource + "]");
        if (!requiresConsent) {
            L.i("[ModuleConsent] setConsentInternal, Consent is not required, ignoring the call");
            return;
        }
        if (featureNames == null) {
            L.w("[ModuleConsent] setConsentInternal, Calling setConsent with null featureNames!");
            return;
        }
        List<String> consentThatWillChange = new ArrayList<>(featureNames.length);
        Map<String, Boolean> consentUpdateMap = new ConcurrentHashMap<>();
        for (String featureName : featureNames) {
            if (!isValidFeatureName(featureName)) {
                L.w("[ModuleConsent] setConsentInternal, Given feature: [" + featureName + "] is not a valid name, ignoring it");
                continue;
            }
            if (getConsentTrue(featureName) != isConsentGiven) {
                //if the current consent does not match the one give, add it to the list
                consentThatWillChange.add(featureName);
                //set new consent values later because some modules need to do operation before changing consent
                consentUpdateMap.put(featureName, isConsentGiven);
            }
        }
        for (ModuleBase module : _cly.modules) {
            module.consentWillChange(consentThatWillChange, isConsentGiven);
        }
        featureConsentValues.putAll(consentUpdateMap);
        for (ModuleBase module : _cly.modules) {
            module.onConsentChanged(consentThatWillChange, isConsentGiven, changeSource);
        }
        if (isConsentGiven || !changeSource.equals(ConsentChangeSource.DeviceIDChangedNotMerged)) {
            //send consent changes
            String formattedConsentState = formatConsentState(featureConsentValues);
            L.v("[ModuleConsent] setConsentInternal, Sending consent changes: [" + formattedConsentState + "]");
            requestQueueProvider.sendConsentChanges(formattedConsentState);
        }
    }
    /**
     * Remove the consent of a feature
     *
     * @param featureNames the names of features for which consent should be removed
     */
    public void removeConsentInternal(@Nullable final String[] featureNames, final ConsentChangeSource changeSource) {
        L.d("[ModuleConsent] removeConsentInternal, featureNames: [" + Arrays.toString(featureNames) + "], changeSource: [" + changeSource + "]");
        setConsentInternal(featureNames, false, changeSource);
    }
    /**
     * Remove consent for all features
     */
    public void removeConsentAllInternal(final ConsentChangeSource changeSource) {
        L.d("[ModuleConsent] removeConsentAllInternal, changeSource: [" + changeSource + "]");
        removeConsentInternal(validFeatureNames, changeSource);
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        L.d("[ModuleConsent] initFinished, requiresConsent: [" + requiresConsent + "]");
        if (requiresConsent) {
            //do appropriate action regarding the current consent state
            //remove persistent push flag if no push consent was set
            doPushConsentSpecialAction(getConsentTrue(Countly.CountlyFeatureNames.push));
            //send 'after init' consent state
            String formattedConsentState = formatConsentState(featureConsentValues);
            L.d("[ModuleConsent] initFinished, Sending consent changes after init: [" + formattedConsentState + "]");
            requestQueueProvider.sendConsentChanges(formattedConsentState);
            if (L.logEnabled()) {
                checkAllConsentInternal();
            }
        }
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        L.d("[ModuleConsent] onConsentChanged, consentChangeDelta: [" + consentChangeDelta + "], newConsent: [" + newConsent + "], changeSource: [" + changeSource + "]");
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.push)) {
            //handle push consent changes
            doPushConsentSpecialAction(newConsent);
        }
    }
    @Override
    void halt() {
        consentInterface = null;
    }
    public class Consent {
        /**
         * Print the consent values of all features
         */
        public void checkAllConsent() {
            L.i("[Countly] checkAllConsent");
            synchronized (_cly) {
                L.i("[Consent] calling checkAllConsent");
                checkAllConsentInternal();
            }
        }
        /**
         * Get the current consent state of a feature
         *
         * @param featureName the name of a feature for which consent should be checked
         * @return the consent value
         */
        public boolean getConsent(@Nullable final String featureName) {
            L.i("[Countly] getConsent, featureName: [" + featureName + "]");
            synchronized (_cly) {
                return getConsentInternal(featureName);
            }
        }
        /**
         * Remove consent for all features
         */
        public void removeConsentAll() {
            L.i("[Countly] removeConsentAll");
            synchronized (_cly) {
                removeConsentAllInternal(ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Remove the consent of a feature
         *
         * @param featureNames the names of features for which consent should be removed
         */
        public void removeConsent(@Nullable final String[] featureNames) {
            L.i("[Countly] removeConsent");
            synchronized (_cly) {
                removeConsentInternal(featureNames, ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Gives consent for all features
         */
        public void giveConsentAll() {
            synchronized (_cly) {
                L.i("[Consent] Giving consent for all features");
                setConsentInternal(validFeatureNames, true, ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Give the consent to a feature
         *
         * @param featureNames the names of features for which consent should be given
         */
        public void giveConsent(@Nullable final String[] featureNames) {
            L.i("[Countly] giveConsent");
            synchronized (_cly) {
                setConsentInternal(featureNames, true, ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Set the consent of a feature
         *
         * @param featureNames feature names for which consent should be changed
         * @param isConsentGiven the consent value that should be set
         */
        public void setConsent(@Nullable final String[] featureNames, final boolean isConsentGiven) {
            L.i("[Countly] setConsent");
            synchronized (_cly) {
                setConsentInternal(featureNames, isConsentGiven, ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Set the consent of a feature group
         *
         * @param groupName name of the consent group
         * @param isConsentGiven the value that should be set for this consent group
         */
        public void setConsentFeatureGroup(@Nullable final String groupName, final boolean isConsentGiven) {
            L.i("[Countly] setConsentFeatureGroup, groupName: [" + groupName + "], isConsentGiven: [" + isConsentGiven + "]");
            synchronized (_cly) {
                if (!groupedFeatures.containsKey(groupName)) {
                    L.d("[Countly] setConsentFeatureGroup, Trying to set consent for a unknown feature group: [" + groupName + "]");
                    return;
                }
                setConsentInternal(groupedFeatures.get(groupName), isConsentGiven, ConsentChangeSource.ChangeConsentCall);
            }
        }
        /**
         * Group multiple features into a feature group
         *
         * @param groupName name of the consent group
         * @param features array of feature to be added to the consent group
         */
        public void createFeatureGroup(@Nullable final String groupName, @Nullable final String[] features) {
            L.i("[Countly] createFeatureGroup, groupName: [" + groupName + "], features: [" + Arrays.toString(features) + "]");
            synchronized (_cly) {
                groupedFeatures.put(groupName, features);
            }
        }
    }
}
package ly.count.android.sdk;
import android.text.TextUtils;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import ly.count.android.sdk.internal.RemoteConfigHelper;
import ly.count.android.sdk.internal.RemoteConfigValueStore;
import org.json.JSONException;
import org.json.JSONObject;
import static ly.count.android.sdk.ModuleConsent.ConsentChangeSource.ChangeConsentCall;
public class ModuleRemoteConfig extends ModuleBase {
    ImmediateRequestGenerator iRGenerator;
    boolean updateRemoteConfigAfterIdChange = false;
    Map<String, String[]> variantContainer = new HashMap<>(); // Stores the fetched A/B test variants
    Map<String, ExperimentInformation> experimentContainer = new HashMap<>(); // Stores the fetched A/B test information (includes exp ID, description etc.)
    RemoteConfig remoteConfigInterface = null;
    //if set to true, it will automatically download remote configs on module startup
    boolean automaticDownloadTriggersEnabled;
    // if set to true we should add 'oi=1' to our RC download call
    boolean autoEnrollEnabled;
    boolean remoteConfigValuesShouldBeCached = false;
    List<RCDownloadCallback> downloadCallbacks = new ArrayList<>(2);
    public final static String variantObjectNameKey = "name";
    @Nullable
    Map<String, String> metricOverride = null;
    ModuleRemoteConfig(Countly cly, final CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRemoteConfig] Initialising");
        metricOverride = config.metricOverride;
        iRGenerator = config.immediateRequestGenerator;
        L.d("[ModuleRemoteConfig] Setting if remote config Automatic triggers enabled, " + config.enableRemoteConfigAutomaticDownloadTriggers + ", caching enabled: " + config.enableRemoteConfigValueCaching + ", auto enroll enabled: " + config.enableAutoEnrollFlag);
        automaticDownloadTriggersEnabled = config.enableRemoteConfigAutomaticDownloadTriggers;
        remoteConfigValuesShouldBeCached = config.enableRemoteConfigValueCaching;
        autoEnrollEnabled = config.enableAutoEnrollFlag;
        downloadCallbacks.addAll(config.remoteConfigGlobalCallbackList);
        if (config.remoteConfigCallbackLegacy != null) {
            downloadCallbacks.add((downloadResult, error, fullValueUpdate, downloadedValues) -> config.remoteConfigCallbackLegacy.callback(error));
        }
        remoteConfigInterface = new RemoteConfig();
    }
    /**
     * Internal call for updating remote config keys
     *
     * @param keysOnly set if these are the only keys to update
     * @param keysExcept set if these keys should be ignored from the update
     * @param devProvidedCallback dev provided callback that is called after the update is done
     */
    void updateRemoteConfigValues(@Nullable final String[] keysOnly, @Nullable final String[] keysExcept, final boolean useLegacyAPI, @Nullable final RCDownloadCallback devProvidedCallback) {
        L.d("[ModuleRemoteConfig] Updating remote config values, legacyAPI:[" + useLegacyAPI + "]");
        String[] preparedKeys = RemoteConfigHelper.prepareKeysIncludeExclude(keysOnly, keysExcept, L);
        boolean fullUpdate = (preparedKeys[0] == null || preparedKeys[0].length() == 0) && (preparedKeys[1] == null || preparedKeys[1].length() == 0);
        try {
            // checks
            if (deviceIdProvider.getDeviceId() == null) {
                //device ID is null, abort
                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, deviceID is null");
                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, device ID is null", fullUpdate, null);
                return;
            }
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {
                //temporary id mode enabled, abort
                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, temporary device ID mode is set");
                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, temporary device ID is set", fullUpdate, null);
                return;
            }
            //prepare metrics and request data
            String preparedMetrics = deviceInfo.getMetrics(_cly.context_, metricOverride, L);
            String requestData;
            if (useLegacyAPI) {
                requestData = requestQueueProvider.prepareRemoteConfigRequestLegacy(preparedKeys[0], preparedKeys[1], preparedMetrics);
            } else {
                requestData = requestQueueProvider.prepareRemoteConfigRequest(preparedKeys[0], preparedKeys[1], preparedMetrics, autoEnrollEnabled);
            }
            L.d("[ModuleRemoteConfig] RemoteConfig requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing remote config received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered problem while trying to reach the server, possibly no internet connection", fullUpdate, null);
                    return;
                }
                String error = null;
                Map<String, RCData> newRC = RemoteConfigHelper.DownloadedValuesIntoMap(checkResponse);
                try {
                    boolean clearOldValues = keysExcept == null && keysOnly == null;
                    mergeCheckResponseIntoCurrentValues(clearOldValues, newRC);
                } catch (Exception ex) {
                    L.e("[ModuleRemoteConfig] updateRemoteConfigValues - execute, Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]");
                    error = "Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]";
                }
                NotifyDownloadCallbacks(devProvidedCallback, error == null ? RequestResult.Success : RequestResult.Error, error, fullUpdate, newRC);
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to perform a remote config update. " + ex.toString());
            NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered internal error while trying to perform a remote config update", fullUpdate, null);
        }
    }
    /**
     * Internal function to form and send a request to enroll user for given keys
     *
     * @param keys
     */
    void enrollIntoABTestsForKeysInternal(@NonNull String[] keys) {
        L.d("[ModuleRemoteConfig] Enrolling user for the given keys:" + keys);
        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
            L.d("[ModuleRemoteConfig] Enrolling user was aborted, temporary device ID mode is set or device ID is null.");
            return;
        }
        requestQueueProvider.enrollToKeys(keys);
    }
    /**
     * Internal function to form and send the request to remove user from A/B testes for given keys
     *
     * @param keys
     */
    void exitABTestsForKeysInternal(@NonNull String[] keys) {
        L.d("[ModuleRemoteConfig] Removing user for the tests with given keys:" + keys);
        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
            L.d("[ModuleRemoteConfig] Removing user from tests was aborted, temporary device ID mode is set or device ID is null.");
            return;
        }
        requestQueueProvider.exitForKeys(keys);
    }
    /**
     * Internal call for fetching all variants of A/B test experiments
     * There are 2 endpoints that can be used:
     *
     * @param callback called after the fetch is done
     * @param shouldFetchExperimentInfo if true this call would fetch experiment information including the variants
     */
    void testingFetchVariantInformationInternal(@NonNull final RCVariantCallback callback, final boolean shouldFetchExperimentInfo) {
        try {
            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info");
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
                L.d("[ModuleRemoteConfig] Fetching all A/B test variants was aborted, temporary device ID mode is set or device ID is null.");
                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");
                return;
            }
            // prepare request data
            String requestData = shouldFetchExperimentInfo ? requestQueueProvider.prepareFetchAllExperiments() : requestQueueProvider.prepareFetchAllVariants();
            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants/info received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");
                    return;
                }
                if (shouldFetchExperimentInfo) {
                    experimentContainer = RemoteConfigHelper.convertExperimentInfoJsonToMap(checkResponse, L);
                } else {
                    variantContainer = RemoteConfigHelper.convertVariantsJsonToMap(checkResponse, L);
                }
                callback.callback(RequestResult.Success, null);
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to fetch all A/B test variants/info. " + ex.toString());
            callback.callback(RequestResult.Error, "Encountered internal error while trying to fetch all A/B test variants/info.");
        }
    }
    void testingEnrollIntoVariantInternal(@NonNull final String key, @NonNull final String variant, @NonNull final RCVariantCallback callback) {
        try {
            L.d("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pairs:[" + key + "][" + variant + "]");
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
                L.d("[ModuleRemoteConfig] Enrolling A/B test variants was aborted, temporary device ID mode is set or device ID is null.");
                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");
                return;
            }
            // check Key and Variant
            if (TextUtils.isEmpty(key) || TextUtils.isEmpty(variant)) {
                L.w("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pair is invalid. Aborting.");
                callback.callback(RequestResult.Error, "Provided key/variant pair is invalid.");
                return;
            }
            // prepare request data
            String requestData = requestQueueProvider.prepareEnrollVariant(key, variant);
            L.d("[ModuleRemoteConfig] Enrolling A/B test variants requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/i", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");
                    return;
                }
                try {
                    if (!isResponseValid(checkResponse)) {
                        callback.callback(RequestResult.NetworkIssue, "Bad response from the server:" + checkResponse.toString());
                        return;
                    }
                    RCAutomaticDownloadTrigger(true);//todo afterwards cache only that one key
                    callback.callback(RequestResult.Success, null);
                } catch (Exception ex) {
                    L.e("[ModuleRemoteConfig] testingEnrollIntoVariantInternal - execute, Encountered internal issue while trying to enroll to the variant, [" + ex.toString() + "]");
                    callback.callback(RequestResult.Error, "Encountered internal error while trying to take care of the A/B test variant enrolment.");
                }
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to enroll A/B test variants. " + ex.toString());
            callback.callback(RequestResult.Error, "Encountered internal error while trying to enroll A/B test variants.");
        }
    }
    /**
     * Merge the values acquired from the server into the current values.
     * Clear if needed.
     *
     * @throws Exception it throws an exception so that it is escalated upwards
     */
    void mergeCheckResponseIntoCurrentValues(boolean clearOldValues, @NonNull Map<String, RCData> newRC) {
        //todo iterate over all response values and print a summary of the returned keys + ideally a summary of their payload.
        //merge the new values into the current ones
        RemoteConfigValueStore rcvs = loadConfig();
        rcvs.mergeValues(newRC, clearOldValues);
        L.d("[ModuleRemoteConfig] Finished remote config processing, starting saving");
        saveConfig(rcvs);
        L.d("[ModuleRemoteConfig] Finished remote config saving");
    }
    /**
     * Checks and evaluates the response from the server
     *
     * @param responseJson - JSONObject response
     * @return
     */
    boolean isResponseValid(@NonNull JSONObject responseJson) {
        boolean result = false;
        try {
            if (responseJson.get("result").equals("Success")) {
                result = true;
            }
        } catch (JSONException e) {
            L.e("[ModuleRemoteConfig] isResponseValid, encountered issue, " + e);
            return false;
        }
        return result;
    }
    RCData getRCValue(@NonNull String key) {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getValue(key);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] getValue, Call failed:[" + ex.toString() + "]");
            return new RCData(null, true);
        }
    }
    Object getRCValueLegacy(@NonNull String key) {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getValueLegacy(key);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] getValueLegacy, Call failed:[" + ex.toString() + "]");
            return null;
        }
    }
    void saveConfig(@NonNull RemoteConfigValueStore rcvs) {
        storageProvider.setRemoteConfigValues(rcvs.dataToString());
    }
    /**
     * @return
     * @throws Exception For some reason this might be throwing an exception
     */
    @NonNull RemoteConfigValueStore loadConfig() {
        String rcvsString = storageProvider.getRemoteConfigValues();
        //noinspection UnnecessaryLocalVariable
        RemoteConfigValueStore rcvs = RemoteConfigValueStore.dataFromString(rcvsString, remoteConfigValuesShouldBeCached);
        return rcvs;
    }
    void clearValueStoreInternal() {
        storageProvider.setRemoteConfigValues("");
    }
    @NonNull Map<String, Object> getAllRemoteConfigValuesInternalLegacy() {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getAllValuesLegacy();
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");
            return new HashMap<>();
        }
    }
    @NonNull Map<String, RCData> getAllRemoteConfigValuesInternal() {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getAllValues();
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");
            return new HashMap<>();
        }
    }
    /**
     * Gets all AB testing variants stored in the memory
     *
     * @return
     */
    @NonNull Map<String, String[]> testingGetAllVariantsInternal() {
        return variantContainer;
    }
    /**
     * Get all variants for a given key if exists. Else returns an empty array.
     *
     * @param key
     * @return
     */
    @Nullable String[] testingGetVariantsForKeyInternal(@NonNull String key) {
        String[] variantResponse = null;
        if (variantContainer.containsKey(key)) {
            variantResponse = variantContainer.get(key);
        }
        return variantResponse;
    }
    void clearAndDownloadAfterIdChange() {
        L.v("[RemoteConfig] Clearing remote config values and preparing to download after ID update");
        CacheOrClearRCValuesIfNeeded();
        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            updateRemoteConfigAfterIdChange = true;
        }
    }
    void CacheOrClearRCValuesIfNeeded() {
        L.v("[RemoteConfig] CacheOrClearRCValuesIfNeeded, cacheclearing values");
        RemoteConfigValueStore rc = loadConfig();
        rc.cacheClearValues();
        saveConfig(rc);
    }
    void NotifyDownloadCallbacks(RCDownloadCallback devProvidedCallback, RequestResult requestResult, String message, boolean fullUpdate, Map<String, RCData> downloadedValues) {
        for (RCDownloadCallback callback : downloadCallbacks) {
            callback.callback(requestResult, message, fullUpdate, downloadedValues);
        }
        if (devProvidedCallback != null) {
            devProvidedCallback.callback(requestResult, message, fullUpdate, downloadedValues);
        }
    }
    void RCAutomaticDownloadTrigger(boolean cacheClearOldValues) {
        if (cacheClearOldValues) {
            CacheOrClearRCValuesIfNeeded();
        }
        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            L.d("[RemoteConfig] Automatically updating remote config values");
            updateRemoteConfigValues(null, null, false, null);
        } else {
            L.v("[RemoteConfig] Automatic RC update trigger skipped");
        }
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.remoteConfig) && changeSource == ChangeConsentCall) {
            if (newConsent) {
                L.d("[RemoteConfig] onConsentChanged, Consent given, will update RC values");
                //if consent was just given trigger automatic RC download if needed
                RCAutomaticDownloadTrigger(false);
            }
        }
    }
    @Override
    void deviceIdChanged(boolean withoutMerge) {
        L.v("[RemoteConfig] Device ID changed will update values: [" + updateRemoteConfigAfterIdChange + "]");
        if (updateRemoteConfigAfterIdChange) {
            updateRemoteConfigAfterIdChange = false;
            RCAutomaticDownloadTrigger(true);
        }
    }
    @Override
    public void initFinished(@NonNull CountlyConfig config) {
        //update remote config_ values if automatic update is enabled and we are not in temporary id mode
        if (!deviceIdProvider.isTemporaryIdEnabled()) {
            RCAutomaticDownloadTrigger(false);
        }
    }
    @Override
    public void halt() {
        remoteConfigInterface = null;
    }
    // ==================================================================
    // ==================================================================
    // INTERFACE
    // ==================================================================
    // ==================================================================
    public class RemoteConfig {
        /**
         * Clear all stored remote config_ values
         *
         * @deprecated Use "clearAll"
         */
        public void clearStoredValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] clearStoredValues");
                clearValueStoreInternal();
            }
        }
        /**
         * @return
         * @deprecated You should use "getValues"
         */
        public Map<String, Object> getAllValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getAllValues");
                return getAllRemoteConfigValuesInternalLegacy();
            }
        }
        /**
         * Get the stored value for the provided remote config_ key
         *
         * @param key
         * @return
         * @deprecated You should use "getValue"
         */
        public Object getValueForKey(String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] remoteConfigValueForKey, " + key);
                return getRCValueLegacy(key);
            }
        }
        /**
         * Manual remote config update call. Will update all keys except the ones provided
         *
         * @param keysToExclude
         * @param callback
         * @deprecated You should use "downloadOmittingKeys"
         */
        public void updateExceptKeys(String[] keysToExclude, RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] updateExceptKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                if (keysToExclude == null) {
                    L.w("[RemoteConfig] updateExceptKeys passed 'keys to ignore' array is null");
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(null, keysToExclude, true, innerCall);
            }
        }
        /**
         * Manual remote config update call. Will only update the keys provided.
         *
         * @param keysToInclude
         * @param callback
         * @deprecated You should use "downloadSpecificKeys"
         */
        public void updateForKeysOnly(String[] keysToInclude, RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] updateForKeysOnly");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                if (keysToInclude == null) {
                    L.w("[RemoteConfig] updateForKeysOnly passed 'keys to include' array is null");
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(keysToInclude, null, true, innerCall);
            }
        }
        /**
         * Manually update remote config values
         *
         * @param callback
         * @deprecated You should use "downloadAllKeys"
         */
        public void update(RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] update");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(null, null, true, innerCall);
            }
        }
        /**
         * Manual remote config call that will initiate a download of all except the given remote config keys.
         * If no keys are provided then it will download all available RC values
         *
         * @param keysToOmit A list of keys that need to be downloaded
         * @param callback This is called when the operation concludes
         */
        public void downloadOmittingKeys(@Nullable String[] keysToOmit, @Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadOmittingKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, false, null);
                    }
                    return;
                }
                if (keysToOmit == null) {
                    L.w("[RemoteConfig] downloadOmittingKeys passed 'keys to ignore' array is null");
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(null, keysToOmit, false, callback);
            }
        }
        /**
         * Manual remote config call that will initiate a download of only the given remote config keys.
         * If no keys are provided then it will download all available RC values
         *
         * @param keysToInclude Keys for which the RC should be initialized
         * @param callback This is called when the operation concludes
         */
        public void downloadSpecificKeys(@Nullable String[] keysToInclude, @Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadSpecificKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, false, null);
                    }
                    return;
                }
                if (keysToInclude == null) {
                    L.w("[RemoteConfig] downloadSpecificKeys passed 'keys to include' array is null");
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(keysToInclude, null, false, callback);
            }
        }
        /**
         * Manual remote config call that will initiate a download of all available remote config keys.
         *
         * @param callback This is called when the operation concludes
         */
        public void downloadAllKeys(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadAllKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, true, null);
                    }
                    return;
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(null, null, false, callback);
            }
        }
        /**
         * Returns all available remote config values
         *
         * @return The available RC values
         */
        public @NonNull Map<String, RCData> getValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValues");
                return getAllRemoteConfigValuesInternal();
            }
        }
        /**
         * Returns all available remote config values and enrolls to A/B tests for those values
         *
         * @return The available RC values
         */
        public @NonNull Map<String, RCData> getAllValuesAndEnroll() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getAllValuesAndEnroll");
                Map<String, RCData> values = getAllRemoteConfigValuesInternal();
                if (values.isEmpty()) {
                    L.i("[RemoteConfig] getAllValuesAndEnroll, No value to enroll");
                } else {
                    // assuming the values is not empty enroll for the keys
                    Set<String> setOfKeys = values.keySet();
                    String[] arrayOfKeys = new String[setOfKeys.size()];
                    // set to array
                    int i = 0;
                    for (String key : setOfKeys) {
                        arrayOfKeys[i++] = key;
                    }
                    // enroll
                    enrollIntoABTestsForKeys(arrayOfKeys);
                }
                return values;
            }
        }
        /**
         * Return the remote config value for a specific key
         *
         * @param key Key for which the remote config value needs to be returned
         * @return The returned value. If no value existed for the key then the inner object (value) will be returned as "null"
         */
        public @NonNull RCData getValue(final @Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValue, key:[" + key + "]");
                if (key == null || key.equals("")) {
                    L.i("[RemoteConfig] getValue, A valid key should be provided to get its value.");
                    return new RCData(null, true);
                }
                return getRCValue(key);
            }
        }
        /**
         * Returns the remote config value for a specific key and enrolls to A/B tests for it
         *
         * @param key Key for which the remote config value needs to be returned
         * @return The returned value. If no value existed for the key then the inner object will be returned as "null"
         */
        public @NonNull RCData getValueAndEnroll(@Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValueAndEnroll, key:[" + key + "]");
                if (key == null || key.equals("")) {
                    L.i("[RemoteConfig] getValueAndEnroll, A valid key should be provided to get its value.");
                    return new RCData(null, true);
                }
                RCData data = getRCValue(key);
                if (data.value == null) {
                    L.i("[RemoteConfig] getValueAndEnroll, No value to enroll");
                } else {
                    // assuming value is not null enroll to key
                    String[] arrayOfKeys = { key };
                    enrollIntoABTestsForKeys(arrayOfKeys);
                }
                return data;
            }
        }
        /**
         * Enrolls user to AB tests of the given keys.
         *
         * @param keys - String array of keys (parameters)
         */
        public void enrollIntoABTestsForKeys(@Nullable String[] keys) {
            synchronized (_cly) {
                L.i("[RemoteConfig] enrollIntoABTestsForKeys");
                if (keys == null || keys.length == 0) {
                    L.w("[RemoteConfig] enrollIntoABTestsForKeys, A key should be provided to enroll the user.");
                    return;
                }
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                enrollIntoABTestsForKeysInternal(keys);
            }
        }
        /**
         * Removes user from A/B tests for the given keys. If no key provided would remove the user from all tests.
         *
         * @param keys - String array of keys (parameters)
         */
        public void exitABTestsForKeys(@Nullable String[] keys) {
            synchronized (_cly) {
                L.i("[RemoteConfig] exitABTestsForKeys");
                if (keys == null) {
                    keys = new String[0];
                }
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                exitABTestsForKeysInternal(keys);
            }
        }
        /**
         * Register a global callback for when download operations have finished
         *
         * @param callback The callback that should be added
         */
        public void registerDownloadCallback(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] registerDownloadCallback");
                downloadCallbacks.add(callback);
            }
        }
        /**
         * Unregister a global download callback
         *
         * @param callback The callback that should be removed
         */
        public void removeDownloadCallback(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] removeDownloadCallback");
                downloadCallbacks.remove(callback);
            }
        }
        /**
         * Clear all stored remote config values.
         */
        public void clearAll() {
            synchronized (_cly) {
                L.i("[RemoteConfig] clearAll");
                clearStoredValues();
            }
        }
        /**
         * Returns all variant information as a Map<String, String[]>
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @return Return the information of all available variants
         */
        public @NonNull Map<String, String[]> testingGetAllVariants() {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetAllVariants");
                return testingGetAllVariantsInternal();
            }
        }
        /**
         * Returns all experiment information as a Map<String, ExperimentInformation>
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @return Return the information of all available variants
         */
        public @NonNull Map<String, ExperimentInformation> testingGetAllExperimentInfo() {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetAllExperimentInfo");
                return experimentContainer;
            }
        }
        /**
         * Returns variant information for a key as a String[]
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param key - key value to get variant information for
         * @return If returns the stored variants for the given key. Returns "null" if there are no variants for that key.
         */
        public @Nullable String[] testingGetVariantsForKey(@Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetVariantsForKey");
                if (key == null) {
                    L.i("[RemoteConfig] testingGetVariantsForKey, provided variant key can not be null");
                    return null;
                }
                return testingGetVariantsForKeyInternal(key);
            }
        }
        /**
         * Download all variants of A/B testing experiments
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param completionCallback this callback will be called when the network request finished
         */
        public void testingDownloadVariantInformation(@Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingFetchVariantInformation");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingFetchVariantInformationInternal(completionCallback, false);
            }
        }
        /**
         * Download all A/B testing experiments information
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param completionCallback this callback will be called when the network request finished
         */
        public void testingDownloadExperimentInformation(@Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingDownloadExperimentInformation");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingFetchVariantInformationInternal(completionCallback, true);
            }
        }
        /**
         * Enrolls user for a specific variant of A/B testing experiment
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param keyName - key value retrieved from the fetched variants
         * @param variantName - name of the variant for the key to enroll
         * @param completionCallback
         */
        public void testingEnrollIntoVariant(@Nullable String keyName, String variantName, @Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingEnrollIntoVariant");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (keyName == null || variantName == null) {
                    L.w("[RemoteConfig] testEnrollIntoVariant, passed key or variant is null. Aborting.");
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingEnrollIntoVariantInternal(keyName, variantName, completionCallback);
            }
        }
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class ModuleAPM extends ModuleBase {
    final static String[] reservedKeys = { "response_time", "response_payload_size", "response_code", "request_payload_size", "duration", "slow_rendering_frames", "frozen_frames" };
    Apm apmInterface = null;
    Map<String, Long> codeTraces;
    Map<String, Long> networkTraces;
    //used to determine app start time
    boolean hasFirstOnResumeHappened = false;
    long lastScreenSwitchTime = -1;// timestamp of when the app last changed from foreground to background
    int activitiesOpen;
    boolean useManualAppLoadedTrigger;
    long appStartTimestamp;
    boolean manualForegroundBackgroundTriggers;
    boolean trackForegroundBackground;
    boolean manualOverrideInForeground = false;//app starts in background
    boolean appStartRecorded = false;
    ModuleAPM(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleAPM] Initialising");
        codeTraces = new HashMap<>();
        networkTraces = new HashMap<>();
        activitiesOpen = 0;
        useManualAppLoadedTrigger = config.apm.appLoadedManualTrigger;
        if (config.apm.appStartTimestampOverride != null) {
            //if there is a app start time override, use it
            appStartTimestamp = config.apm.appStartTimestampOverride;
            L.d("[ModuleAPM] Using app start timestamp override");
        } else {
            //otherwise use the statically generated timestamp
            appStartTimestamp = Countly.applicationStart;
        }
        if (config.apm.appLoadedManualTrigger) {
            L.d("[ModuleAPM] Using manual app finished loading trigger for app start");
        }
        manualForegroundBackgroundTriggers = config.apm.manualForegroundBackgroundTrigger;
        if (manualForegroundBackgroundTriggers) {
            L.d("[ModuleAPM] Using manual foreground/background triggers");
        }
        trackForegroundBackground = config.apm.trackForegroundBackground;
        if (trackForegroundBackground) {
            L.d("[ModuleAPM] tracking foreground/background is enabled");
        }
        apmInterface = new Apm();
    }
    void startTraceInternal(String traceKey) {
        L.d("[ModuleAPM] Calling 'startTraceInternal' with key:[" + traceKey + "]");
        if (traceKey == null || traceKey.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid trace key");
            return;
        }
        Long currentTimestamp = UtilsTime.currentTimestampMs();
        codeTraces.put(traceKey, currentTimestamp);
    }
    void endTraceInternal(@NonNull String traceKey, @NonNull Map<String, Integer> customMetrics) {
        //end time counting as fast as possible
        Long currentTimestamp = UtilsTime.currentTimestampMs();
        assert traceKey != null && !traceKey.isEmpty();
        assert customMetrics != null;
        L.d("[ModuleAPM] Calling 'endTraceInternal' with key:[" + traceKey + "]");
        if (codeTraces.containsKey(traceKey)) {
            Long startTimestamp = codeTraces.remove(traceKey);
            if (startTimestamp == null) {
                L.e("[ModuleAPM] endTraceInternal, retrieved 'startTimestamp' is null, dropping trace");
            } else {
                Long durationMs = currentTimestamp - startTimestamp;
                if (!customMetrics.isEmpty()) {
                    //custom metrics provided
                    //remove reserved keys
                    removeReservedInvalidKeys(customMetrics);
                    UtilsInternalLimits.truncateSegmentationKeys(customMetrics, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] endTraceInternal");
                    UtilsInternalLimits.truncateSegmentationValues(customMetrics, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleAPM] endTraceInternal", L);
                }
                String metricString = customMetricsToString(customMetrics);
                String truncatedTraceKey = UtilsInternalLimits.truncateKeyLength(traceKey, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] endTraceInternal");
                String modifiedTraceKey = validateAndModifyTraceKey(truncatedTraceKey);
                requestQueueProvider.sendAPMCustomTrace(modifiedTraceKey, durationMs, startTimestamp, currentTimestamp, metricString);
            }
        } else {
            L.w("[ModuleAPM] endTraceInternal, trying to end trace which was not started");
        }
    }
    void cancelTraceInternal(String traceKey) {
        L.d("[ModuleAPM] Calling 'cancelTraceInternal' with key:[" + traceKey + "]");
        if (traceKey == null || traceKey.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid trace key");
            return;
        }
        if (!codeTraces.containsKey(traceKey)) {
            L.w("[ModuleAPM] no trace with key [" + traceKey + "] found");
            return;
        }
        codeTraces.remove(traceKey);
    }
    void cancelAllTracesInternal() {
        L.d("[ModuleAPM] Calling 'cancelAllTracesInternal'");
        codeTraces.clear();
    }
    static String customMetricsToString(@NonNull Map<String, Integer> customMetrics) {
        assert customMetrics != null;
        StringBuilder ret = new StringBuilder();
        for (Map.Entry<String, Integer> entry : customMetrics.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            ret.append(",\"");
            ret.append(key);
            ret.append("\":");
            ret.append(value);
        }
        return ret.toString();
    }
    void removeReservedInvalidKeys(Map<String, Integer> customMetrics) {
        if (customMetrics == null) {
            return;
        }
        //remove reserved keys
        for (String rKey : ModuleAPM.reservedKeys) {
            customMetrics.remove(rKey);
        }
        for (Iterator<Map.Entry<String, Integer>> it = customMetrics.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry<String, Integer> entry = it.next();
            String key = entry.getKey();
            Integer value = entry.getValue();
            //remove invalid values
            if (key == null || key.isEmpty() || value == null) {
                it.remove();
                L.w("[ModuleAPM] custom metrics can't contain null or empty key/value");
                continue;
            }
            //remove invalid keys
            //regex for valid keys serverside
            // /^[a-zA-Z][a-zA-Z0-9_]*$/
            int keyLength = key.length();
            if (keyLength > 32) {
                //remove key longer than 32 characters
                it.remove();
                L.w("[ModuleAPM] custom metric key can't be longer than 32 characters, skipping entry, [" + key + "]");
                continue;
            }
            if (key.charAt(0) == '$') {
                L.w("[ModuleAPM] custom metric key can't start with '$', it will be removed server side, [" + key + "]");
            }
            if (key.contains(".")) {
                L.w("[ModuleAPM] custom metric key can't contain '.', those will be removed server side, [" + key + "]");
            }
        }
    }
    String validateAndModifyTraceKey(String traceKey) {
        if (traceKey.charAt(0) == '$') {
            L.w("[ModuleAPM] validateAndModifyTraceKey, trace keys can't start with '$', it will be removed server side");
        }
        if (traceKey.length() > 2048) {
            traceKey = traceKey.substring(0, 2047);
            L.w("[ModuleAPM] validateAndModifyTraceKey, trace keys can't be longer than 2048 characters, it will be trimmed down");
        }
        return traceKey;
    }
    /**
     * Begin the tracking of a network request
     *
     * @param networkTraceKey key that identifies the network trace
     * @param uniqueId this is important in cases where multiple requests in parallel are done
     * for the same trace. This helps to distinguish them
     */
    void startNetworkRequestInternal(String networkTraceKey, String uniqueId) {
        L.d("[ModuleAPM] Calling 'startNetworkRequestInternal' with key:[" + networkTraceKey + "]");
        if (networkTraceKey == null || networkTraceKey.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid trace key");
            return;
        }
        if (uniqueId == null || uniqueId.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid uniqueId");
            return;
        }
        String internalTraceKey = networkTraceKey + "|" + uniqueId;
        Long currentTimestamp = UtilsTime.currentTimestampMs();
        networkTraces.put(internalTraceKey, currentTimestamp);
    }
    /**
     * Mark that a network request has ended
     *
     * @param networkTraceKey key that identifies the network trace
     * @param uniqueId this is important in cases where multiple requests in parallel are done
     * for the same trace. This helps to distinguish them.
     * @param responseCode returned response code
     * @param requestPayloadSize sent request payload size in bytes
     * @param responsePayloadSize received response payload size in bytes
     */
    void endNetworkRequestInternal(String networkTraceKey, String uniqueId, int responseCode, int requestPayloadSize, int responsePayloadSize) {
        //end time counting as fast as possible
        long currentTimestamp = UtilsTime.currentTimestampMs();
        L.d("[ModuleAPM] Calling 'endNetworkRequestInternal' with key:[" + networkTraceKey + "]");
        if (networkTraceKey == null || networkTraceKey.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid trace key");
            return;
        }
        if (uniqueId == null || uniqueId.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid uniqueId");
            return;
        }
        String internalTraceKey = networkTraceKey + "|" + uniqueId;
        if (networkTraces.containsKey(internalTraceKey)) {
            Long startTimestamp = networkTraces.remove(internalTraceKey);
            if (startTimestamp == null) {
                L.e("[ModuleAPM] endNetworkRequestInternal, retrieved 'startTimestamp' is null");
            } else {
                recordNetworkRequestInternal(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, startTimestamp, currentTimestamp);
            }
        } else {
            L.w("[ModuleAPM] endNetworkRequestInternal, trying to end trace which was not started");
        }
    }
    /**
     * Record network trace
     *
     * @param networkTraceKey key that identifies the network trace
     * @param responseCode returned response code
     * @param requestPayloadSize sent request payload size in bytes
     * @param responsePayloadSize received response payload size in bytes
     * @param startTimestamp timestamp in milliseconds of when the request was started
     * @param endTimestamp timestamp in milliseconds of when the request was ended
     */
    void recordNetworkRequestInternal(String networkTraceKey, int responseCode, int requestPayloadSize, int responsePayloadSize, long startTimestamp, long endTimestamp) {
        L.v("[ModuleAPM] Calling 'recordNetworkRequestInternal' with key:[" + networkTraceKey + "]");
        if (networkTraceKey == null || networkTraceKey.isEmpty()) {
            L.e("[ModuleAPM] Provided a invalid trace key, aborting request");
            return;
        }
        if (!(responseCode >= 100 && responseCode < 600)) {
            L.e("[ModuleAPM] Invalid response code was provided, setting to '0'");
            responseCode = 0;
        }
        if (requestPayloadSize < 0) {
            L.e("[ModuleAPM] Invalid request payload size was provided, setting to '0'");
            requestPayloadSize = 0;
        }
        if (responsePayloadSize < 0) {
            L.e("[ModuleAPM] Invalid response payload size was provided, setting to '0'");
            responsePayloadSize = 0;
        }
        if (startTimestamp > endTimestamp) {
            L.e("[ModuleAPM] End timestamp is smaller than start timestamp, switching values");
            long tmp = startTimestamp;
            startTimestamp = endTimestamp;
            endTimestamp = tmp;
        }
        //validate trace key
        networkTraceKey = UtilsInternalLimits.truncateKeyLength(networkTraceKey, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] recordNetworkRequestInternal");
        networkTraceKey = validateAndModifyTraceKey(networkTraceKey);
        Long responseTimeMs = endTimestamp - startTimestamp;
        requestQueueProvider.sendAPMNetworkTrace(networkTraceKey, responseTimeMs, responseCode, requestPayloadSize, responsePayloadSize, startTimestamp, endTimestamp);
    }
    void clearNetworkTraces() {
        L.v("[ModuleAPM] Calling 'clearNetworkTraces'");
        networkTraces.clear();
    }
    void recordAppStart(long appLoadedTimestamp) {
        if (!_cly.config_.apm.trackAppStartTime) {
            L.d("[ModuleAPM] Calling 'recordAppStart', call will be ignored due to app start tracking not being enabled");
            return;
        }
        if (appStartRecorded) {
            L.w("[ModuleAPM] Calling 'recordAppStart', call will be ignored due to it already being registered before");
            return;
        }
        L.d("[ModuleAPM] Calling 'recordAppStart' [" + appLoadedTimestamp + "] [" + appStartTimestamp + "]");
        long durationMs = appLoadedTimestamp - appStartTimestamp;
        if (durationMs <= 0) {
            L.e("[ModuleAPM] Encountered negative app start duration:[" + durationMs + "] dropping app start duration request");
            return;
        }
        requestQueueProvider.sendAPMAppStart(durationMs, appStartTimestamp, appLoadedTimestamp);
        appStartRecorded = true;
    }
    void calculateAppRunningTimes(int previousCount, int newCount) {
        boolean goingToBackground = previousCount == 1 && newCount == 0;
        boolean goingToForeground = previousCount == 0 && newCount == 1;
        L.v("[ModuleAPM] calculateAppRunningTimes, going toBG[" + goingToBackground + "] going toFG[" + goingToForeground + "] | [" + previousCount + "][" + newCount + "]");
        doForegroundBackgroundCalculations(goingToBackground, goingToForeground);
    }
    void doForegroundBackgroundCalculations(boolean goingToBackground, boolean goingToForeground) {
        L.d("[ModuleAPM] Calling 'doForegroundBackgroundCalculations', [" + goingToBackground + "] [" + goingToForeground + "]");
        if (goingToBackground || goingToForeground) {
            long currentTimeMs = UtilsTime.currentTimestampMs();
            if (lastScreenSwitchTime != -1) {
                // if it was '-1' then it just started, todo might be a issue with halt where it is only reset on first screen change
                long durationMs = currentTimeMs - lastScreenSwitchTime;
                if (goingToForeground) {
                    // coming from a background mode to the foreground
                    requestQueueProvider.sendAPMScreenTime(false, durationMs, lastScreenSwitchTime, currentTimeMs);
                } else if (goingToBackground) {
                    // going form the foreground to the background
                    requestQueueProvider.sendAPMScreenTime(true, durationMs, lastScreenSwitchTime, currentTimeMs);
                }
            } else {
                L.d("[ModuleAPM] 'doForegroundBackgroundCalculations' last screen switch time was '-1', doing nothing");
            }
            lastScreenSwitchTime = currentTimeMs;
        } else {
            L.d("[ModuleAPM] Calling 'doForegroundBackgroundCalculations', just changing screens, ignoring request");
            // changing screens normally
        }
    }
    void goToForeground() {
        L.d("[ModuleAPM] Calling 'goToForeground'");
        if (manualOverrideInForeground) {
            //if we already are in foreground, do nothing
            return;
        }
        manualOverrideInForeground = true;
        doForegroundBackgroundCalculations(false, true);
    }
    void goToBackground() {
        L.d("[ModuleAPM] Calling 'goToBackground'");
        if (!manualOverrideInForeground) {
            //if we already are in background, do nothing
            return;
        }
        manualOverrideInForeground = false;
        doForegroundBackgroundCalculations(true, false);
    }
    @Override
    void halt() {
        codeTraces = null;
        networkTraces = null;
    }
    /**
     * used for background / foreground time recording
     *
     * @param activity
     */
    @Override
    void callbackOnActivityResumed(Activity activity) {
        L.d("[Apm] Calling 'callbackOnActivityResumed'");
    }
    @Override
    void onActivityStarted(Activity activity, int updatedActivityCount) {
        L.d("[Apm] Calling 'onActivityStarted', [" + activitiesOpen + "] -> [" + (activitiesOpen + 1) + "]");
        long currentTimestamp = System.currentTimeMillis();
        if (trackForegroundBackground && !manualForegroundBackgroundTriggers) {
            calculateAppRunningTimes(activitiesOpen, activitiesOpen + 1);
        }
        activitiesOpen++;
        if (!hasFirstOnResumeHappened) {
            hasFirstOnResumeHappened = true;
            if (!useManualAppLoadedTrigger) {
                recordAppStart(currentTimestamp);
            }
        }
    }
    /**
     * used for background / foreground time recording
     *
     * @param activity
     */
    @Override
    void callbackOnActivityStopped(Activity activity) {
        L.d("[Apm] Calling 'callbackOnActivityStopped', [" + activitiesOpen + "] -> [" + (activitiesOpen - 1) + "]");
        if (trackForegroundBackground & !manualForegroundBackgroundTriggers) {
            calculateAppRunningTimes(activitiesOpen, activitiesOpen - 1);
        }
        activitiesOpen--;
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.apm)) {
            if (!newConsent) {
                //in case APM consent is removed, clear custom and network traces
                _cly.moduleAPM.clearNetworkTraces();
                _cly.moduleAPM.cancelAllTracesInternal();
            }
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        if (_cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Increasing the activity counter.");
            activitiesOpen++;
        }
        // we only do this adjustment if we track it automatically
        if (trackForegroundBackground && !manualForegroundBackgroundTriggers && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Starting to track foreground time");
            calculateAppRunningTimes(activitiesOpen - 1, activitiesOpen);
        }
        if (config.apm.trackAppStartTime && !config.apm.appLoadedManualTrigger && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Recording automatic app start duration");
            long currentTimestamp = System.currentTimeMillis();
            recordAppStart(currentTimestamp);
        }
    }
    public class Apm {
        /**
         * Start a trace of a action you want to track
         *
         * @param traceKey key by which this action is identified
         */
        public void startTrace(String traceKey) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'startTrace' with key:[" + traceKey + "]");
                startTraceInternal(traceKey);
            }
        }
        /**
         * End a trace of a action you want to track
         *
         * @param traceKey key by which this action is identified
         */
        public void endTrace(@Nullable String traceKey, @Nullable Map<String, Integer> customMetrics) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'endTrace' with key:[" + traceKey + "]");
                if (traceKey == null || traceKey.isEmpty()) {
                    L.e("[Apm] Calling 'endTrace' with invalid traceKey");
                    return;
                }
                Map<String, Integer> customMetricsInternal;
                if (customMetrics == null) {
                    customMetricsInternal = new ConcurrentHashMap<>();
                } else {
                    customMetricsInternal = customMetrics;
                }
                endTraceInternal(traceKey, customMetricsInternal);
            }
        }
        public void cancelTrace(String traceKey) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'cancelTrace' with key:[" + traceKey + "]");
                cancelTraceInternal(traceKey);
            }
        }
        public void cancelAllTraces() {
            synchronized (_cly) {
                L.i("[Apm] Calling 'cancelAllTraces'");
                cancelAllTracesInternal();
                clearNetworkTraces();
            }
        }
        /**
         * Begin the tracking of a network request
         *
         * @param networkTraceKey key that identifies the network trace
         * @param uniqueId this is important in cases where multiple requests in parallel are done
         * for the same trace. This helps to distinguish them.
         */
        public void startNetworkRequest(String networkTraceKey, String uniqueId) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'startNetworkRequest' with key:[" + networkTraceKey + "], uniqueID:[" + uniqueId + "]");
                startNetworkRequestInternal(networkTraceKey, uniqueId);
            }
        }
        /**
         * Mark that a network request has ended
         *
         * @param networkTraceKey key that identifies the network trace
         * @param uniqueId this is important in cases where multiple requests in parallel are done
         * for the same trace. This helps to distinguish them.
         * @param responseCode returned response code
         * @param requestPayloadSize sent request payload size in bytes
         * @param responsePayloadSize received response payload size in bytes
         */
        public void endNetworkRequest(String networkTraceKey, String uniqueId, int responseCode, int requestPayloadSize, int responsePayloadSize) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'endNetworkRequest' with key:[" + networkTraceKey + "], uniqueID:[" + uniqueId + "]");
                endNetworkRequestInternal(networkTraceKey, uniqueId, responseCode, requestPayloadSize, responsePayloadSize);
            }
        }
        /**
         * Mark that a network request has ended
         *
         * @param networkTraceKey key that identifies the network trace
         * @param responseCode returned response code
         * @param requestPayloadSize sent request payload size in bytes
         * @param responsePayloadSize received response payload size in bytes
         * @param requestStartTimestampMs network request start timestamp in milliseconds
         * @param requestEndTimestampMs network request end timestamp in milliseconds
         */
        public void recordNetworkTrace(String networkTraceKey, int responseCode, int requestPayloadSize, int responsePayloadSize, long requestStartTimestampMs, long requestEndTimestampMs) {
            synchronized (_cly) {
                L.i("[Apm] Calling 'recordNetworkTrace' with key:[" + networkTraceKey + "]");
                recordNetworkRequestInternal(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, requestStartTimestampMs, requestEndTimestampMs);
            }
        }
        /**
         * Manually set that the app is loaded so that the app load duration can be recorded.
         * Should only be used if manual app loading trigger is enabled
         */
        public void setAppIsLoaded() {
            synchronized (_cly) {
                L.i("[Apm] Calling 'setAppIsLoaded'");
                long timestamp = System.currentTimeMillis();
                if (!useManualAppLoadedTrigger) {
                    L.w("[Apm] trying to record that app has finished loading without enabling manual trigger");
                    return;
                }
                recordAppStart(timestamp);
            }
        }
        /**
         * Manually trigger that the app has gone to the foreground
         *
         * @deprecated this call is deprecated and will be removed in the future
         */
        public void triggerForeground() {
            synchronized (_cly) {
                L.i("[Apm] Calling 'triggerForeground'");
                if (!trackForegroundBackground) {
                    L.w("[Apm] triggerForeground, tracking foreground is disabled");
                    return;
                }
                if (!manualForegroundBackgroundTriggers) {
                    L.w("[Apm] trying to use manual foreground triggers without enabling them");
                    return;
                }
                goToForeground();
            }
        }
        /**
         * Manually trigger that the app has gone to the background
         *
         * @deprecated this call is deprecated and will be removed in the future
         */
        public void triggerBackground() {
            synchronized (_cly) {
                L.i("[Apm] Calling 'triggerBackground'");
                if (!trackForegroundBackground) {
                    L.w("[Apm] triggerBackground, tracking background is disabled");
                    return;
                }
                if (!manualForegroundBackgroundTriggers) {
                    L.w("[Apm] triggerBackground, trying to use manual background triggers without enabling them");
                    return;
                }
                goToBackground();
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.List;
import java.util.Map;
public class ModuleSessions extends ModuleBase {
    boolean manualSessionControlEnabled = false;
    boolean manualSessionControlHybridModeEnabled = false;
    long prevSessionDurationStartTime_ = System.currentTimeMillis();
    boolean sessionRunning = false;
    final Sessions sessionInterface;
    @Nullable
    Map<String, String> metricOverride = null;
    ModuleSessions(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleSessions] Initialising");
        metricOverride = config.metricOverride;
        manualSessionControlEnabled = config.manualSessionControlEnabled;
        if (manualSessionControlEnabled) {
            L.d("[ModuleSessions] Enabling manual session control");
        }
        manualSessionControlHybridModeEnabled = config.manualSessionControlHybridModeEnabled;
        if (manualSessionControlHybridModeEnabled) {
            L.d("[ModuleSessions] Enabling manual session control hybrid mode");
        }
        if (config.disableUpdateSessionRequests) {
            L.d("[ModuleSessions] Disabling periodic session time updates");
            _cly.disableUpdateSessionRequests_ = config.disableUpdateSessionRequests;
        }
        sessionInterface = new Sessions();
    }
    void beginSessionInternal() {
        L.d("[ModuleSessions] 'beginSessionInternal'");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            return;
        }
        if (sessionIsRunning()) {
            L.w("[ModuleSessions] A session is already running, this 'beginSessionInternal' will be ignored");
            healthTracker.logSessionStartedWhileRunning();
            return;
        }
        //prepare metrics
        String preparedMetrics = deviceInfo.getMetrics(_cly.context_, metricOverride, L);
        sessionRunning = true;
        prevSessionDurationStartTime_ = System.currentTimeMillis();
        requestQueueProvider.beginSession(_cly.moduleLocation.locationDisabled, _cly.moduleLocation.locationCountryCode, _cly.moduleLocation.locationCity, _cly.moduleLocation.locationGpsCoordinates, _cly.moduleLocation.locationIpAddress, preparedMetrics);
        if (_cly.moduleViews.trackOrientationChanges) {
            _cly.moduleViews.updateOrientation(_cly.context_.getResources().getConfiguration().orientation, true);
        }
    }
    void updateSessionInternal() {
        L.d("[ModuleSessions] 'updateSessionInternal'");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            return;
        }
        if (!sessionIsRunning()) {
            L.w("[ModuleSessions] No session is running, this 'updateSessionInternal' will be ignored");
            healthTracker.logSessionUpdatedWhileNotRunning();
            return;
        }
        if (!_cly.disableUpdateSessionRequests_) {
            requestQueueProvider.updateSession(roundedSecondsSinceLastSessionDurationUpdate());
        }
    }
    void endSessionInternal(boolean checkConsent) {
        L.d("[ModuleSessions] endSessionInternal, checkConsent:[" + checkConsent + "]");
        if (checkConsent && !consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            return;
        }
        if (!sessionIsRunning()) {
            L.w("[ModuleSessions] No session is running, this 'endSessionInternal' will be ignored");
            healthTracker.logSessionEndedWhileNotRunning();
            return;
        }
        _cly.moduleRequestQueue.sendEventsIfNeeded(true);
        _cly.moduleUserProfile.saveInternal();
        requestQueueProvider.endSession(roundedSecondsSinceLastSessionDurationUpdate());
        sessionRunning = false;
        _cly.moduleViews.resetFirstView();//todo these scenarios need to be tested and validated
    }
    void endSessionInternal() {
        endSessionInternal(true);
    }
    /**
     * If a session has been started and is still running
     *
     * @return
     */
    public boolean sessionIsRunning() {
        //if the start timestamp is set then assume that the session is running
        return sessionRunning;
    }
    /**
     * Calculates the unsent session duration in seconds, rounded to the nearest int.
     */
    int roundedSecondsSinceLastSessionDurationUpdate() {
        if (prevSessionDurationStartTime_ < 1) {
            L.e("[ModuleSessions] roundedSecondsSinceLastSessionDurationUpdate, called with prevSessionDurationStartTime_ being less than 1, returning 0, values was:[" + prevSessionDurationStartTime_ + "]");
            return 0;
        }
        final long currentTimestampInMilliseconds = System.currentTimeMillis();
        final long unsentSessionLengthInMilliseconds = currentTimestampInMilliseconds - prevSessionDurationStartTime_;
        prevSessionDurationStartTime_ = currentTimestampInMilliseconds;
        int seconds = (int) Math.round(unsentSessionLengthInMilliseconds / 1_000.0d);
        L.d("[ModuleSessions] roundedSecondsSinceLastSessionDurationUpdate, psds_:[" + prevSessionDurationStartTime_ + "], ctim:[" + currentTimestampInMilliseconds + "], uslim:[" + unsentSessionLengthInMilliseconds + "], uslim_s:[" + seconds + "]");
        return seconds;
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        L.d("[ModuleSessions] onConsentChanged, consentChangeDelta:[" + consentChangeDelta + "], newConsent:[" + newConsent + "], changeSource:[" + changeSource + "]");
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.sessions)) {
            if (newConsent) {
                //if consent was just given and manual sessions sessions are not enabled, start a session if we are in the foreground
                if (!manualSessionControlEnabled && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
                    beginSessionInternal();
                }
            } else {
                L.d("[ModuleSessions] Ending session due to consent change");
                if (!_cly.isBeginSessionSent) {
                    //if session consent was removed and first begins session was not sent
                    //that means that we might not have sent the initially given location information
                    _cly.moduleLocation.sendCurrentLocationIfValid();
                }
                if (sessionIsRunning()) {
                    endSessionInternal(false);
                } else {
                    _cly.moduleViews.resetFirstView();
                }
            }
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        if (!manualSessionControlEnabled && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
            //start a session if we initialized in the foreground
            beginSessionInternal();
        }
    }
    @Override
    void halt() {
        prevSessionDurationStartTime_ = 0;
        sessionRunning = false;
    }
    @Override
    void deviceIdChanged(boolean withoutMerge) {
        if (!manualSessionControlEnabled && withoutMerge && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {
            L.d("[ModuleSessions] deviceIdChanged, automatic session control enabled and device id changed without merge, starting a new session");
            beginSessionInternal();
        }
    }
    public class Sessions {
        public void beginSession() {
            synchronized (_cly) {
                L.i("[Sessions] Calling 'beginSession', manual session control enabled:[" + manualSessionControlEnabled + "]");
                if (!manualSessionControlEnabled) {
                    L.w("[Sessions] 'beginSession' will be ignored since manual session control is not enabled");
                    return;
                }
                beginSessionInternal();
            }
        }
        public void updateSession() {
            synchronized (_cly) {
                L.i("[Sessions] Calling 'updateSession', manual session control enabled:[" + manualSessionControlEnabled + "]");
                if (!manualSessionControlEnabled) {
                    L.w("[Sessions] 'updateSession' will be ignored since manual session control is not enabled");
                    return;
                }
                if (manualSessionControlHybridModeEnabled) {
                    L.w("[Sessions] 'updateSession' will be ignored since manual session control hybrid mode is enabled");
                    return;
                }
                updateSessionInternal();
            }
        }
        public void endSession() {
            synchronized (_cly) {
                L.i("[Sessions] Calling 'endSession', manual session control enabled:[" + manualSessionControlEnabled + "]");
                if (!manualSessionControlEnabled) {
                    L.w("[Sessions] 'endSession' will be ignored since manual session control is not enabled");
                    return;
                }
                endSessionInternal();
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
class ModuleHealthCheck extends ModuleBase {
    ImmediateRequestGenerator immediateRequestGenerator;
    HealthCheckCounter hCounter;
    boolean healthCheckEnabled = true;
    boolean healthCheckSent = false;
    ModuleHealthCheck(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleHealthCheck] Initialising, enabled: " + healthCheckEnabled);
        hCounter = new HealthCheckCounter(config.storageProvider, L);
        config.healthTracker = hCounter;
        immediateRequestGenerator = config.immediateRequestGenerator;
        healthCheckEnabled = config.healthCheckEnabled;
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (healthCheckEnabled) {
            sendHealthCheck();
        }
    }
    @Override
    void halt() {
        hCounter = null;
        immediateRequestGenerator = null;
    }
    @Override
    void onActivityStopped(int updatedActivityCount) {
        hCounter.saveState();
    }
    void sendHealthCheck() {
        L.v("[ModuleHealthCheck] sendHealthCheck, attempting to send health information");
        if (!healthCheckEnabled) {
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check is disabled");
            return;
        }
        // why _cly? because module health is created last. So device id provider
        // call order to module device id is before module health check and device id provider is module device id
        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {
            //temporary id mode enabled, abort
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, temporary device ID mode is set");
            return;
        }
        if (healthCheckSent) {
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check already sent");
            return;
        }
        healthCheckSent = true;
        String preparedMetrics = deviceInfo.getMetricsHealthCheck(_cly.context_, _cly.config_.metricOverride);
        StringBuilder requestData = new StringBuilder(requestQueueProvider.prepareHealthCheckRequest(preparedMetrics));
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        requestData.append(hCounter.createRequestParam());
        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData.toString(), "/i", cp, false, networkingIsEnabled, checkResponse -> {
            if (checkResponse == null) {
                L.w("[ModuleHealthCheck] No response for sending health check Probably due to lack of connection to the server");
                //sending failed, keep counters
                return;
            }
            L.d("[ModuleHealthCheck] Retrieved request response: [" + checkResponse.toString() + "]");
            if (!checkResponse.has("result")) {
                L.d("[ModuleHealthCheck] Retrieved request response does not match expected pattern");
                return;
            }
            //at this point we can expect that the request succeed and we can clear the counters
            L.d("[ModuleHealthCheck] sendHealthCheck, SDK health information sent successfully");
            hCounter.clearAndSave();
        }, L);
    }
}
package ly.count.android.sdk;
import android.content.Intent;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.util.DisplayMetrics;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.json.JSONArray;
import org.json.JSONObject;
public class ModuleContent extends ModuleBase {
    private final ImmediateRequestGenerator iRGenerator;
    Content contentInterface;
    CountlyTimer countlyTimer;
    private boolean shouldFetchContents = false;
    private final int zoneTimerInterval;
    private final ContentCallback globalContentCallback;
    static int waitForDelay = 0;
    ModuleContent(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleContent] Initialising");
        iRGenerator = config.immediateRequestGenerator;
        contentInterface = new Content();
        countlyTimer = new CountlyTimer();
        zoneTimerInterval = config.content.zoneTimerInterval;
        globalContentCallback = config.content.globalContentCallback;
    }
    void fetchContentsInternal(@NonNull String[] categories) {
        L.d("[ModuleContent] fetchContentsInternal, shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(categories) + "]");
        DisplayMetrics displayMetrics = deviceInfo.mp.getDisplayMetrics(_cly.context_);
        String requestData = prepareContentFetchRequest(displayMetrics, categories);
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk/content", cp, false, networkingIsEnabled, checkResponse -> {
            L.d("[ModuleContent] fetchContentsInternal, processing fetched contents, received response is :[" + checkResponse + "]");
            if (checkResponse == null) {
                return;
            }
            try {
                if (validateResponse(checkResponse)) {
                    L.d("[ModuleContent] fetchContentsInternal, got new content data, showing it");
                    Map<Integer, TransparentActivityConfig> placementCoordinates = parseContent(checkResponse, displayMetrics);
                    if (placementCoordinates.isEmpty()) {
                        L.d("[ModuleContent] fetchContentsInternal, placement coordinates are empty, skipping");
                        return;
                    }
                    Intent intent = new Intent(_cly.context_, TransparentActivity.class);
                    intent.putExtra(TransparentActivity.CONFIGURATION_LANDSCAPE, placementCoordinates.get(Configuration.ORIENTATION_LANDSCAPE));
                    intent.putExtra(TransparentActivity.CONFIGURATION_PORTRAIT, placementCoordinates.get(Configuration.ORIENTATION_PORTRAIT));
                    intent.putExtra(TransparentActivity.ORIENTATION, _cly.context_.getResources().getConfiguration().orientation);
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    _cly.context_.startActivity(intent);
                    shouldFetchContents = false; // disable fetching contents until the next time, this will disable the timer fetching
                } else {
                    L.w("[ModuleContent] fetchContentsInternal, response is not valid, skipping");
                }
            } catch (Exception ex) {
                L.e("[ModuleContent] fetchContentsInternal, Encountered internal issue while trying to fetch contents, [" + ex + "]");
            }
        }, L);
    }
    void registerForContentUpdates(@Nullable String[] categories) {
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.w("[ModuleContent] registerForContentUpdates, temporary device ID is enabled, skipping");
            return;
        }
        String[] validCategories;
        if (categories == null) {
            L.w("[ModuleContent] registerForContentUpdates, categories is null, providing empty array");
            validCategories = new String[] {};
        } else {
            validCategories = categories;
        }
        countlyTimer.startTimer(zoneTimerInterval, () -> {
            L.d("[ModuleContent] registerForContentUpdates, waitForDelay: [" + waitForDelay + "], shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(validCategories) + "]");
            if (waitForDelay > 0) {
                waitForDelay--;
                return;
            }
            if (!shouldFetchContents) {
                L.w("[ModuleContent] registerForContentUpdates, shouldFetchContents is false, skipping");
                return;
            }
            fetchContentsInternal(validCategories);
        }, L);
    }
    @NonNull
    private String prepareContentFetchRequest(@NonNull DisplayMetrics displayMetrics, @NonNull String[] categories) {
        Resources resources = _cly.context_.getResources();
        int currentOrientation = resources.getConfiguration().orientation;
        boolean portrait = currentOrientation == Configuration.ORIENTATION_PORTRAIT;
        int scaledWidth = (int) Math.ceil(displayMetrics.widthPixels / displayMetrics.density);
        int scaledHeight = (int) Math.ceil(displayMetrics.heightPixels / displayMetrics.density);
        // this calculation needs improvement for status bar and navigation bar
        int portraitWidth = portrait ? scaledWidth : scaledHeight;
        int portraitHeight = portrait ? scaledHeight : scaledWidth;
        int landscapeWidth = portrait ? scaledHeight : scaledWidth;
        int landscapeHeight = portrait ? scaledWidth : scaledHeight;
        String language = Locale.getDefault().getLanguage().toLowerCase();
        return requestQueueProvider.prepareFetchContents(portraitWidth, portraitHeight, landscapeWidth, landscapeHeight, categories, language);
    }
    boolean validateResponse(@NonNull JSONObject response) {
        return response.has("geo");
        //boolean success = response.optString("result", "error").equals("success");
        //JSONArray content = response.optJSONArray("content");
        //return success && content != null && content.length() > 0;
    }
    @NonNull
    Map<Integer, TransparentActivityConfig> parseContent(@NonNull JSONObject response, @NonNull DisplayMetrics displayMetrics) {
        Map<Integer, TransparentActivityConfig> placementCoordinates = new ConcurrentHashMap<>();
        JSONArray contents = response.optJSONArray("content");
        //assert contents != null; TODO enable later
        JSONObject contentObj = response; //contents.optJSONObject(0); TODO this will be changed
        assert contentObj != null;
        String content = contentObj.optString("html");
        JSONObject coordinates = contentObj.optJSONObject("geo");
        assert coordinates != null;
        placementCoordinates.put(Configuration.ORIENTATION_PORTRAIT, extractOrientationPlacements(coordinates, displayMetrics.density, "p", content));
        placementCoordinates.put(Configuration.ORIENTATION_LANDSCAPE, extractOrientationPlacements(coordinates, displayMetrics.density, "l", content));
        return placementCoordinates;
    }
    private TransparentActivityConfig extractOrientationPlacements(@NonNull JSONObject placements, float density, @NonNull String orientation, @NonNull String content) {
        if (placements.has(orientation)) {
            JSONObject orientationPlacements = placements.optJSONObject(orientation);
            assert orientationPlacements != null;
            int x = orientationPlacements.optInt("x");
            int y = orientationPlacements.optInt("y");
            int w = orientationPlacements.optInt("w");
            int h = orientationPlacements.optInt("h");
            L.d("[ModuleContent] extractOrientationPlacements, orientation: [" + orientation + "], x: [" + x + "], y: [" + y + "], w: [" + w + "], h: [" + h + "]");
            TransparentActivityConfig config = new TransparentActivityConfig((int) Math.ceil(x * density), (int) Math.ceil(y * density), (int) Math.ceil(w * density), (int) Math.ceil(h * density));
            config.url = content;
            // TODO, passing callback with an intent is impossible, need to find a way to pass it
            // Currently, the callback is set as a static variable in TransparentActivity
            TransparentActivity.globalContentCallback = globalContentCallback;
            return config;
        }
        return null;
    }
    @Override
    void halt() {
        contentInterface = null;
        countlyTimer.stopTimer(L);
        countlyTimer = null;
    }
    private void optOutFromContent() {
        exitContentZoneInternal();
        shouldFetchContents = false;
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        L.d("[ModuleContent] onConsentChanged, consentChangeDelta: [" + consentChangeDelta + "], newConsent: [" + newConsent + "], changeSource: [" + changeSource + "]");
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.content) && !newConsent) {
            optOutFromContent();
        }
    }
    @Override
    void deviceIdChanged(boolean withoutMerge) {
        L.d("[ModuleContent] deviceIdChanged, withoutMerge: [" + withoutMerge + "]");
        if (withoutMerge) {
            optOutFromContent();
        }
    }
    protected void exitContentZoneInternal() {
        shouldFetchContents = false;
        countlyTimer.stopTimer(L);
    }
    public class Content {
        /**
         * Opt in user for the content fetching and updates
         *
         * @param categories categories for the content
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        private void enterContentZone(@Nullable String... categories) {
            L.d("[ModuleContent] openForContent, categories: [" + Arrays.toString(categories) + "]");
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] openForContent, Consent is not granted, skipping");
                return;
            }
            shouldFetchContents = true;
            registerForContentUpdates(categories);
        }
        /**
         * Opt in user for the content fetching and updates
         *
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        public void enterContentZone() {
            enterContentZone(new String[] {});
        }
        /**
         * Opt out user from the content fetching and updates
         *
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        public void exitContentZone() {
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] exitFromContent, Consent is not granted, skipping");
                return;
            }
            exitContentZoneInternal();
        }
        /**
         * Change the content that is being shown
         *
         * @param categories categories for the content
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        private void changeContent(@Nullable String... categories) {
            L.d("[ModuleContent] changeContent, categories: [" + Arrays.toString(categories) + "]");
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] changeContent, Consent is not granted, skipping");
                return;
            }
            registerForContentUpdates(categories);
        }
    }
}
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.Mockito.mock;
@RunWith(AndroidJUnit4.class)
public class ModuleBaseTests {
    Countly mCountly;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        mCountly = new Countly();
        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting());
    }
    @After
    public void tearDown() {
    }
    //making sure all needed modules are added
    @Test
    public void checkup() {
        Assert.assertEquals(17, mCountly.modules.size());
    }
    //just making sure nothing throws exceptions
    @Test
    public void onConfigurationChanged() {
        mCountly.onConfigurationChanged(null);
    }
    //just making sure nothing throws exceptions
    @Test
    public void onActivityStartStop() {
        mCountly.onStart(null);
        mCountly.onStop();
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.app.Application;
import android.content.Context;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.core.app.ApplicationProvider;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Assert;
import org.mockito.ArgumentCaptor;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
public class TestUtils {
    //Useful call:
    //mockingDetails(mockObj).printInvocations()
    //
    //
    //convenience arrays for referencing during tests
    public static final String[] eKeys = { "eventKey1", "eventKey2", "eventKey3", "eventKey4", "eventKey5", "eventKey6", "eventKey7" };
    public static final String[] vNames = { "vienName1", "vienName2", "vienName3", "vienName4", "vienName5", "vienName6", "vienName7" };
    public static final String[] requestEntries = { "blah", "blah1", "blah2", "123", "456", "678", "890" };
    public static final String[] tooOldRequestEntries = { "&timestamp=1664273584000", "&timestamp=1664273554000", "&timestamp=1664272584000" };
    public static final String[] viewIDVals = { "idv1", "idv2", "idv3", "idv4", "idv5", "idv6", "idv7", "idv8", "idv9", "idv10" };
    public static final String[] eventIDVals = { "ide1", "ide2", "ide3", "ide4", "ide5", "ide6", "ide7", "ide8", "ide9", "ide10" };
    //common values used for SDK init during tests
    public final static String commonURL = "http://test.count.ly";
    public final static String commonAppKey = "appkey";
    public final static String commonDeviceId = "1234";
    public final static String SDK_NAME = "java-native-android";
    public final static String SDK_VERSION = "24.7.8";
    public static final int MAX_THREAD_COUNT_PER_STACK_TRACE = 50;
    public static class Activity2 extends Activity {
    }
    public static class Activity3 extends Activity {
    }
    public static CountlyConfig createConfigurationConfig(boolean enableServerConfig, ImmediateRequestGenerator irGen) {
        CountlyConfig cc = createBaseConfig();
        cc.immediateRequestGenerator = irGen;
        if (enableServerConfig) {
            cc.enableServerConfiguration();
        }
        return cc;
    }
    public static CountlyConfig createVariantConfig(ImmediateRequestGenerator irGen) {
        CountlyConfig cc = createBaseConfig();
        cc.immediateRequestGenerator = irGen;
        return cc;
    }
    public static CountlyConfig createConsentCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener, RequestQueueProvider rqp) {
        CountlyConfig cc = createBaseConfig();
        cc.setRequiresConsent(requiresConsent)
            .setConsentEnabled(givenConsent)
            .disableHealthCheck();//mocked tests fail without disabling this
        cc.testModuleListener = testModuleListener;
        cc.requestQueueProvider = rqp;
        return cc;
    }
    public static CountlyConfig createConsentCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener) {
        return createConsentCountlyConfig(requiresConsent, givenConsent, testModuleListener, null);
    }
    public static CountlyConfig createAttributionCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener, RequestQueueProvider rqp, String daType, String daValue, Map<String, String> iaValues) {
        CountlyConfig cc = createBaseConfig();
        cc.setDirectAttribution(daType, daValue)
            .setIndirectAttribution(iaValues)
            .setRequiresConsent(requiresConsent)
            .setConsentEnabled(givenConsent)
            .disableHealthCheck();//mocked tests fail without disabling this
        cc.testModuleListener = testModuleListener;
        cc.requestQueueProvider = rqp;
        return cc;
    }
    public static CountlyConfig createViewCountlyConfig(boolean orientationTracking, boolean useShortNames, boolean automaticViewTracking, SafeIDGenerator safeViewIDGenerator, Map<String, Object> globalViewSegms) {
        CountlyConfig cc = createBaseConfig();
        cc.setTrackOrientationChanges(orientationTracking);
        if (useShortNames) {
            cc.enableAutomaticViewShortNames();
        }
        cc.safeViewIDGenerator = safeViewIDGenerator;
        cc.setGlobalViewSegmentation(globalViewSegms);
        if (automaticViewTracking) {
            cc.enableAutomaticViewTracking();
        }
        return cc;
    }
    public static CountlyConfig createScenarioEventIDConfig(SafeIDGenerator safeViewIDGenerator, SafeIDGenerator safeEventIDGenerator) {
        CountlyConfig cc = createBaseConfig();
        cc.enableAutomaticViewShortNames();
        cc.safeViewIDGenerator = safeViewIDGenerator;
        cc.safeEventIDGenerator = safeEventIDGenerator;
        return cc;
    }
    public static CountlyConfig createBaseConfig() {
        return createBaseConfig(commonDeviceId);
    }
    public static CountlyConfig createBaseConfig(String deviceId) {
        CountlyConfig cc = new CountlyConfig(getApplication(), commonAppKey, commonURL)
            .setDeviceId(deviceId)
            .setLoggingEnabled(true)
            .enableCrashReporting();
        return cc;
    }
    public static CountlyConfig createBaseConfig(Context context) {
        CountlyConfig cc = new CountlyConfig(context, commonAppKey, commonURL)
            .setDeviceId(commonDeviceId)
            .setLoggingEnabled(true)
            .enableCrashReporting();
        return cc;
    }
    public static String[] createStringArray(int count) {
        String[] sArr = new String[count];
        Random rnd = new Random();
        for (int a = 0; a < sArr.length; a++) {
            sArr[a] = "" + rnd.nextInt();
        }
        return sArr;
    }
    public static Map<String, Object> createMapString(int count) {
        Map<String, Object> mRes = new HashMap<>(count);
        Random rnd = new Random();
        for (int a = 0; a < count; a++) {
            mRes.put("" + rnd.nextInt(), "" + rnd.nextInt());
        }
        return mRes;
    }
    public static StorageProvider setStorageProviderToMock(Countly countly, StorageProvider sp) {
        for (ModuleBase module : countly.modules) {
            module.storageProvider = sp;
        }
        countly.config_.storageProvider = sp;
        return sp;
    }
    public static EventProvider setEventProviderToMock(Countly countly, EventProvider ep) {
        for (ModuleBase module : countly.modules) {
            module.eventProvider = ep;
        }
        countly.config_.eventProvider = ep;
        return ep;
    }
    public static EventQueueProvider setCreateEventQueueProviderMock(Countly countly) {
        return setEventQueueProviderToMock(countly, mock(EventQueueProvider.class));
    }
    public static EventQueueProvider setEventQueueProviderToMock(Countly countly, EventQueueProvider eqp) {
        countly.moduleEvents.eventQueueProvider = eqp;
        countly.config_.eventQueueProvider = eqp;
        return eqp;
    }
    public static RequestQueueProvider setRequestQueueProviderToMock(Countly countly, RequestQueueProvider rqp) {
        for (ModuleBase module : countly.modules) {
            module.requestQueueProvider = rqp;
        }
        countly.config_.requestQueueProvider = rqp;
        countly.requestQueueProvider = rqp;
        return rqp;
    }
    @SuppressWarnings("InfiniteRecursion")
    public static void stackOverflow() {
        stackOverflow();
    }
    @SuppressWarnings("ConstantConditions")
    public static Countly crashTest(int crashNumber) {
        if (crashNumber == 1) {
            stackOverflow();
        } else if (crashNumber == 2) {
            // noinspection divzero
            @SuppressWarnings("NumericOverflow") int test = 10 / 0;
        } else if (crashNumber == 3) {
            throw new RuntimeException("This is a crash");
        } else {
            String test = null;
            //noinspection ResultOfMethodCallIgnored
            test.charAt(1);
        }
        return Countly.sharedInstance();
    }
    public static void bothJSONObjEqual(@NonNull JSONObject jA, @NonNull JSONObject jB) throws JSONException {
        Assert.assertNotNull(jA);
        Assert.assertNotNull(jB);
        Assert.assertEquals(jA.length(), jB.length());
        Iterator<String> iter = jA.keys();
        while (iter.hasNext()) {
            String key = iter.next();
            Assert.assertEquals(jA.get(key), jB.get(key));
        }
    }
    public static List<String> getRequestsWithParam(String[] requests, String param) {
        List<String> filteredRequests = new ArrayList<>();
        String targetParamValue = "&" + param + "=";
        for (String entry : requests) {
            if (entry.contains(targetParamValue)) {
                filteredRequests.add(entry);
            }
        }
        return filteredRequests;
    }
    public static String getParamValueFromRequest(String request, String param) {
        String[] params = request.split("&");
        for (String entry : params) {
            String[] pair = entry.split("=");
            if (pair[0].equals(param)) {
                return pair[1];
            }
        }
        return null;
    }
    public static void validateThatRQContainsCorrectEntry(CountlyStore store, String param, String targetValue, int entryCount) {
        List<String> filteredVals = TestUtils.getRequestsWithParam(store.getRequests(), param);
        Assert.assertEquals(entryCount, filteredVals.size());
        if (entryCount != 0) {
            String paramValue = TestUtils.getParamValueFromRequest(filteredVals.get(0), param);
            Assert.assertEquals(targetValue, paramValue);
        }
    }
    public static String[] subtractConsentFromArray(String[] input, String[] subtraction) {
        ArrayList<String> res = new ArrayList<>();
        for (String v : input) {
            boolean contains = false;
            for (String sv : subtraction) {
                if (sv.equals(v)) {
                    contains = true;
                    break;
                }
            }
            if (!contains) {
                res.add(v);
            }
        }
        return res.toArray(new String[0]);
    }
    public static String[] getReminderConsent(String[] subtraction) {
        return subtractConsentFromArray(ModuleConsentTests.usedFeatureNames, subtraction);
    }
    public static void verifyLocationValuesInRQMockDisabled(RequestQueueProvider rqp) {
        verifyLocationValuesInRQMock(1, true, null, null, null, null, rqp);
    }
    public static void verifyLocationValuesInRQMockNotGiven(RequestQueueProvider rqp) {
        verifyLocationValuesInRQMock(0, true, null, null, null, null, rqp);
    }
    public static void verifyLocationValuesInRQMockValues(String countryCode, String city, String location, String ip, RequestQueueProvider rqp) {
        verifyLocationValuesInRQMock(1, false, countryCode, city, location, ip, rqp);
    }
    public static void verifyLocationValuesInRQMock(int count, Boolean enabled, String countryCode, String city, String location, String ip, RequestQueueProvider rqp) {
        ArgumentCaptor<Boolean> acLocationDisabled = ArgumentCaptor.forClass(Boolean.class);
        ArgumentCaptor<String> acCountryCode = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> acCity = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> acGps = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> acIp = ArgumentCaptor.forClass(String.class);
        verify(rqp, times(count)).sendLocation(acLocationDisabled.capture(), acCountryCode.capture(), acCity.capture(), acGps.capture(), acIp.capture());
        if (count == 0) {
            return;
        }
        Assert.assertEquals(enabled, acLocationDisabled.getValue());
        Assert.assertEquals(countryCode, acCountryCode.getValue());
        Assert.assertEquals(city, acCity.getValue());
        Assert.assertEquals(location, acGps.getValue());
        Assert.assertEquals(ip, acIp.getValue());
    }
    public static void verifyConsentValuesInRQMock(int count, String[] valuesTrue, String[] valuesFalse, RequestQueueProvider rqp) throws JSONException {
        ArgumentCaptor<String> consentChanges = ArgumentCaptor.forClass(String.class);
        verify(rqp, times(count)).sendConsentChanges(consentChanges.capture());
        String changes = consentChanges.getValue();
        Assert.assertNotNull(changes);
        JSONObject jObj = new JSONObject(changes);
        Assert.assertEquals(ModuleConsentTests.usedFeatureNames.length, jObj.length());
        Assert.assertEquals(ModuleConsentTests.usedFeatureNames.length, valuesTrue.length + valuesFalse.length);
        for (String v : valuesTrue) {
            Assert.assertTrue((Boolean) jObj.get(v));
        }
        for (String v : valuesFalse) {
            Assert.assertFalse((Boolean) jObj.get(v));
        }
    }
    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation, Integer count, Double sum, Double duration, UtilsTime.Instant instant, String idOverride) {
        validateRecordEventInternalMock(ep, eventKey, segmentation, count, sum, duration, instant, idOverride, 0, 1);
    }
    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey) {
        validateRecordEventInternalMock(ep, eventKey, null, null, null, null, null, null, 0, 1);
    }
    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation) {
        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, 0.0, null, null, 0, 1);
    }
    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation, String idOverride, int index, Integer interactionCount) {
        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, 0.0, null, idOverride, index, interactionCount);
    }
    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, double duration, Map<String, Object> segmentation, String idOverride, int index, Integer interactionCount) {
        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, duration, null, idOverride, index, interactionCount);
    }
    public static void validateRecordEventInternalMockInteractions(EventProvider ep, int interactionCount) {
        ArgumentCaptor<String> arg1 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<Map> arg2 = ArgumentCaptor.forClass(Map.class);
        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> arg4 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Double> arg5 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<UtilsTime.Instant> arg6 = ArgumentCaptor.forClass(UtilsTime.Instant.class);
        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);
        verify(ep, times(interactionCount)).recordEventInternal(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture());
    }
    public static void validateRecordEventInternalMock(final @NonNull EventProvider ep, final @NonNull String eventKey, final @Nullable Map<String, Object> segmentation, final @Nullable Integer count, final @Nullable Double sum, final @Nullable Double duration,
        final @Nullable UtilsTime.Instant instant, final @Nullable String idOverride, int index, int interactionCount) {
        ArgumentCaptor<String> arg1 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<Map> arg2 = ArgumentCaptor.forClass(Map.class);
        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> arg4 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Double> arg5 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<UtilsTime.Instant> arg6 = ArgumentCaptor.forClass(UtilsTime.Instant.class);
        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);
        verify(ep, times(interactionCount)).recordEventInternal(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture());
        //verify(ep).recordEventInternal(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture());
        if (interactionCount == 0) {
            return;
        }
        String cEventKey = arg1.getAllValues().get(index);
        Map cSegment = arg2.getAllValues().get(index);
        Integer cCount = arg3.getAllValues().get(index);
        Double cSum = arg4.getAllValues().get(index);
        Double cDuration = arg5.getAllValues().get(index);
        UtilsTime.Instant cInstant = arg6.getAllValues().get(index);
        String cIdOverride = arg7.getAllValues().get(index);
        Assert.assertNotNull(cEventKey);
        Assert.assertEquals(eventKey, cEventKey);
        if (segmentation != null) {
            Assert.assertEquals(segmentation, cSegment);
        }
        Assert.assertTrue(cCount > 0);
        if (count != null) {
            Assert.assertEquals(count, cCount);
        }
        if (sum != null) {
            Assert.assertEquals(sum, cSum);
        }
        Assert.assertTrue(cDuration >= 0);
        if (duration != null) {
            Assert.assertEquals(duration, cDuration);
        }
        if (instant != null) {
            Assert.assertTrue(cInstant.timestampMs > 0);
            Assert.assertEquals(instant.timestampMs, cInstant.timestampMs);
            Assert.assertEquals(instant.hour, cInstant.hour);
            Assert.assertEquals(instant.dow, cInstant.dow);
        }
        if (cIdOverride != null) {
            Assert.assertTrue(cIdOverride.length() > 0);
        }
        if (idOverride != null) {
            Assert.assertEquals(idOverride, cIdOverride);
        }
    }
    public static void verifyBeginSessionNotCalled(RequestQueueProvider requestQueueProvider) {
        verifyBeginSessionTimes(requestQueueProvider, 0);
    }
    public static void verifyBeginSessionTimes(RequestQueueProvider requestQueueProvider, int count) {
        ArgumentCaptor<Boolean> arg1 = ArgumentCaptor.forClass(Boolean.class);
        ArgumentCaptor<String> arg2 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg3 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg4 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg5 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg6 = ArgumentCaptor.forClass(String.class);
        verify(requestQueueProvider, count == 0 ? never() : times(count)).beginSession(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture());
    }
    public static void verifyBeginSessionValues(RequestQueueProvider requestQueueProvider, Boolean v1, String v2, String v3, String v4, String v5) {
        ArgumentCaptor<Boolean> arg1 = ArgumentCaptor.forClass(Boolean.class);
        ArgumentCaptor<String> arg2 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg3 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg4 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg5 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg6 = ArgumentCaptor.forClass(String.class);
        verify(requestQueueProvider, times(1)).beginSession(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture());
        Assert.assertEquals(v1, arg1.getAllValues().get(0));
        Assert.assertEquals(v2, arg2.getAllValues().get(0));
        Assert.assertEquals(v3, arg3.getAllValues().get(0));
        Assert.assertEquals(v4, arg4.getAllValues().get(0));
        Assert.assertEquals(v5, arg5.getAllValues().get(0));
    }
    public static void verifyCurrentPreviousViewID(ModuleViews mv, String current, String previous) {
        Assert.assertEquals(current, mv.getCurrentViewId());
        Assert.assertEquals(previous, mv.getPreviousViewId());
    }
    protected static CountlyStore getCountyStore() {
        return new CountlyStore(getContext(), mock(ModuleLog.class), false);
    }
    /**
     * Get current request queue from target folder
     *
     * @return array of request params
     */
    protected static @NonNull Map<String, String>[] getCurrentRQ() {
        return getCurrentRQ("");
    }
    /**
     * Get current request queue from target folder
     *
     * @param filter Filter by given string
     * @return array of request params
     */
    protected static @NonNull Map<String, String>[] getCurrentRQ(String filter) {
        //get all request files from target folder
        String[] requests = getCountyStore().getRequests();
        //create array of request params
        Map<String, String>[] resultMapArray = new ConcurrentHashMap[requests.length];
        for (int i = 0; i < requests.length; i++) {
            if (!requests[i].contains(filter)) {
                continue;
            }
            String[] params = requests[i].split("&");
            Map<String, String> paramMap = new ConcurrentHashMap<>();
            for (String param : params) {
                String[] pair = param.split("=");
                paramMap.put(UtilsNetworking.urlDecodeString(pair[0]), pair.length == 1 ? "" : UtilsNetworking.urlDecodeString(pair[1]));
            }
            resultMapArray[i] = paramMap;
        }
        return resultMapArray;
    }
    protected static void removeRequestContains(String search) {
        for (String request : getCountyStore().getRequests()) {
            if (request.contains(search)) {
                getCountyStore().removeRequest(request);
            }
        }
    }
    protected static Map<String, Object> map(Object... args) {
        Map<String, Object> map = new ConcurrentHashMap<>();
        if (args.length < 1) {
            return map;
        }
        if (args.length % 2 != 0) {
            return map;
        }
        for (int a = 0; a < args.length; a += 2) {
            if (args[a] != null && args[a + 1] != null) {
                map.put(args[a].toString(), args[a + 1]);
            }
        }
        return map;
    }
    protected static JSONObject json(Object... args) {
        return new JSONObject(TestUtils.map(args));
    }
    public static Context getContext() {
        return ApplicationProvider.getApplicationContext();
    }
    public static Application getApplication() {
        return (Application) getContext();
    }
    /**
     * Validate sdk identity params which are sdk version and name
     *
     * @param params params to validate
     */
    public static void validateSdkIdentityParams(Map<String, String> params) {
        Assert.assertEquals(SDK_VERSION, params.get("sdk_version"));
        Assert.assertEquals(SDK_NAME, params.get("sdk_name"));
    }
    public static void validateRequiredParams(@NonNull Map<String, String> params) {
        validateRequiredParams(params, commonDeviceId);
    }
    public static void validateRequiredParams(Map<String, String> params, String deviceId) {
        int hour = Integer.parseInt(params.get("hour"));
        int dow = Integer.parseInt(params.get("dow"));
        int tz = Integer.parseInt(params.get("tz"));
        validateSdkIdentityParams(params);
        Assert.assertEquals(deviceId, params.get("device_id"));
        Assert.assertEquals(commonAppKey, params.get("app_key"));
        Assert.assertEquals(Countly.DEFAULT_APP_VERSION, params.get("av"));
        Assert.assertTrue(Long.parseLong(params.get("timestamp")) > 0);
        Assert.assertTrue(hour >= 0 && hour < 24);
        Assert.assertTrue(dow >= 0 && dow < 7);
        Assert.assertTrue(tz >= -720 && tz <= 840);
    }
    /**
     * Ignore JSONException thrown by JSONObject.put
     *
     * @param json target json object
     * @param key key to put
     * @param value value to put
     */
    protected static void put(JSONObject json, String key, Object value) {
        try {
            json.put(key, value);
        } catch (JSONException ignored) {
        }
    }
    public static void assertQueueSizes(int rqSize, int eqSize, CountlyStore cs) {
        Assert.assertEquals(rqSize, cs.getRequests().length);
        Assert.assertEquals(eqSize, cs.getEventQueueSize());
    }
    protected static String generateRandomString(int length) {
        byte[] array = new byte[length];
        new Random().nextBytes(array);
        return new String(array, java.nio.charset.StandardCharsets.UTF_8);
    }
    protected static void validateRequest(String deviceId, Map<String, Object> expectedExtras, int idx) {
        Map<String, String> request = getCurrentRQ()[idx];
        validateRequiredParams(getCurrentRQ()[idx], deviceId);
        for (Map.Entry<String, Object> entry : expectedExtras.entrySet()) {
            if (entry.getValue() instanceof Map) {
                assertEqualsMap((Map<String, Object>) entry.getValue(), parseMap(request.get(entry.getKey())));
            } else {
                Assert.assertEquals(entry.getValue(), request.get(entry.getKey()));
            }
        }
    }
    private static Map<String, Object> parseMap(String mapCandidate) {
        Map<String, Object> map = new ConcurrentHashMap<>();
        try {
            JSONObject json = new JSONObject(mapCandidate);
            Iterator<String> keys = json.keys();
            while (keys.hasNext()) {
                String key = keys.next();
                map.put(key, json.get(key));
            }
        } catch (JSONException e) {
            Assert.fail(e.getMessage());
        }
        return map;
    }
    protected static void assertArraysEquals(Object arr1, Object arr2) {
        // Check if both are arrays
        if (!arr1.getClass().isArray() || !arr2.getClass().isArray()) {
            Assert.fail("Both parameters must be arrays.");
        }
        // Handle primitive arrays
        if (arr1 instanceof int[] && arr2 instanceof int[]) {
            Assert.assertTrue(Arrays.equals((int[]) arr1, (int[]) arr2));
        } else if (arr1 instanceof long[] && arr2 instanceof long[]) {
            Assert.assertTrue(Arrays.equals((long[]) arr1, (long[]) arr2));
        } else if (arr1 instanceof double[] && arr2 instanceof double[]) {
            Assert.assertTrue(Arrays.equals((double[]) arr1, (double[]) arr2));
        } else if (arr1 instanceof float[] && arr2 instanceof float[]) {
            Assert.assertTrue(Arrays.equals((float[]) arr1, (float[]) arr2));
        } else if (arr1 instanceof char[] && arr2 instanceof char[]) {
            Assert.assertTrue(Arrays.equals((char[]) arr1, (char[]) arr2));
        } else if (arr1 instanceof byte[] && arr2 instanceof byte[]) {
            Assert.assertTrue(Arrays.equals((byte[]) arr1, (byte[]) arr2));
        } else if (arr1 instanceof short[] && arr2 instanceof short[]) {
            Assert.assertTrue(Arrays.equals((short[]) arr1, (short[]) arr2));
        } else if (arr1 instanceof boolean[] && arr2 instanceof boolean[]) {
            Assert.assertTrue(Arrays.equals((boolean[]) arr1, (boolean[]) arr2));
        }
        // Handle reference type arrays (like String[], Object[])
        else if (arr1 instanceof Object[] && arr2 instanceof Object[]) {
            Assert.assertTrue(Arrays.equals((Object[]) arr1, (Object[]) arr2));
        }
        // If the arrays are of different types
        else {
            Assert.fail("Array types do not match.");
        }
    }
    protected static void assertEqualsMap(Map<String, Object> map1, Map<String, Object> map2) {
        Assert.assertEquals(map1.size(), map2.size());
        for (Map.Entry<String, Object> entry : map1.entrySet()) {
            if (entry.getValue().getClass().isArray()) {
                assertArraysEquals(entry.getValue(), map2.get(entry.getKey()));
            } else {
                Assert.assertEquals(entry.getValue(), map2.get(entry.getKey()));
            }
        }
    }
    protected static void assertRQSize(int size) {
        Assert.assertEquals(size, getCurrentRQ().length);
    }
    static SafeIDGenerator incrementalViewIdGenerator() {
        AtomicInteger counter = new AtomicInteger(0);
        return () -> "idv" + counter.incrementAndGet();
    }
    static SafeIDGenerator incrementalEventIdGenerator() {
        AtomicInteger counter = new AtomicInteger(0);
        return () -> "ide" + counter.incrementAndGet();
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.content.res.Configuration;
import android.content.res.Resources;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class ModuleViews extends ModuleBase implements ViewIdProvider {
    private String currentViewID = null;
    private String previousViewID = null;
    String previousViewName = "";
    String currentViewName = "";
    private boolean firstView = true;
    boolean autoViewTracker = false;
    boolean automaticTrackingShouldUseShortName = false;
    //track orientation changes
    boolean trackOrientationChanges;
    int currentOrientation = -1;
    final static String ORIENTATION_EVENT_KEY = "[CLY]_orientation";
    final static String VIEW_EVENT_KEY = "[CLY]_view";
    Class[] autoTrackingActivityExceptions = null;//excluded activities from automatic view tracking
    Map<String, Object> automaticViewSegmentation = new HashMap<>();//automatic view segmentation
    final Map<String, ViewData> viewDataMap = new ConcurrentHashMap<>(); // map viewIDs to its viewData
    SafeIDGenerator safeViewIDGenerator;
    String[] reservedSegmentationKeysViews = { "name", "visit", "start", "segment" };
    public @NonNull String getCurrentViewId() {
        return currentViewID == null ? "" : currentViewID;
    }
    public @NonNull String getPreviousViewId() {
        return previousViewID == null ? "" : previousViewID;
    }
    static class ViewData {
        String viewID;
        long viewStartTimeSeconds; // if this is 0 then the view is not started yet or was paused
        String viewName;
        boolean isAutoStoppedView = false;//views started with "startAutoStoppedView" would have this as "true". If set to "true" views should be automatically closed when another one is started.
        Map<String, Object> viewSegmentation = null; // segmentation that can be updated while a view is on
        boolean willStartAgain = false; // if this is true, the view will be started again when the app comes back to the foreground
    }
    //interface for SDK users
    final Views viewsInterface;
    /**
     * Checks the Countly config Object. Turns on/off the flags for view tracking accordingly.
     * And initiates the Views interface for the developer to interact with the SDK/ModuleViews.
     */
    ModuleViews(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleViews] Initializing");
        if (config.enableAutomaticViewTracking) {
            L.d("[ModuleViews] Enabling automatic view tracking");
            autoViewTracker = config.enableAutomaticViewTracking;
        }
        if (config.autoTrackingUseShortName) {
            L.d("[ModuleViews] Enabling automatic view tracking short names");
            automaticTrackingShouldUseShortName = config.autoTrackingUseShortName;
        }
        config.viewIdProvider = this;
        safeViewIDGenerator = config.safeViewIDGenerator;
        setGlobalViewSegmentationInternal(config.globalViewSegmentation);
        autoTrackingActivityExceptions = config.automaticViewTrackingExceptions;
        trackOrientationChanges = config.trackOrientationChange;
        viewsInterface = new Views();
    }
    /**
     * Checks the provided Segmentation by the user. Sanitizes it
     * and transfers the data into an internal Segmentation Object.
     */
    void setGlobalViewSegmentationInternal(@Nullable Map<String, Object> segmentation) {
        L.d("[ModuleViews] Calling setGlobalViewSegmentationInternal with[" + (segmentation == null ? "null" : segmentation.size()) + "] entries");
        automaticViewSegmentation.clear();
        applyLimitsToViewSegmentation(segmentation, "setGlobalViewSegmentationInternal", automaticViewSegmentation);
    }
    public void updateGlobalViewSegmentationInternal(@NonNull Map<String, Object> segmentation) {
        applyLimitsToViewSegmentation(segmentation, "updateGlobalViewSegmentationInternal", automaticViewSegmentation);
    }
    /**
     * Checks if the current Activity is in the Activity Exception list
     *
     * @return boolean - true if in the list, false else
     */
    boolean isActivityInExceptionList(Activity act) {
        if (autoTrackingActivityExceptions == null) {
            return false;
        }
        for (Class autoTrackingActivityException : autoTrackingActivityExceptions) {
            if (act.getClass().equals(autoTrackingActivityException)) {
                return true;
            }
        }
        return false;
    }
    /**
     * This should be called in case a new session starts so that we could identify the new "first view"
     */
    public void resetFirstView() {
        firstView = true;
    }
    Map<String, Object> CreateViewEventSegmentation(@NonNull ViewData vd, boolean firstView, boolean visit, @NonNull Map<String, Object> customViewSegmentation) {
        Map<String, Object> viewSegmentation = new ConcurrentHashMap<>(customViewSegmentation);
        String truncatedViewName = UtilsInternalLimits.truncateKeyLength(vd.viewName, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleViews] CreateViewEventSegmentation");
        viewSegmentation.put("name", truncatedViewName);
        if (visit) {
            viewSegmentation.put("visit", "1");
        }
        if (firstView) {
            viewSegmentation.put("start", "1");
        }
        viewSegmentation.put("segment", "Android");
        return viewSegmentation;
    }
    void autoCloseRequiredViews(boolean closeAllViews, @Nullable Map<String, Object> customViewSegmentation) {
        L.d("[ModuleViews] autoCloseRequiredViews");
        List<ViewData> viewsToRemove = new ArrayList<>(1);
        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {
            ViewData vd = entry.getValue();
            if (closeAllViews || (!vd.willStartAgain && vd.isAutoStoppedView)) {
                viewsToRemove.add(vd);
            }
        }
        if (!viewsToRemove.isEmpty()) {
            L.d("[ModuleViews] autoCloseRequiredViews, about to close [" + viewsToRemove.size() + "] views");
        }
        for (int a = 0; a < viewsToRemove.size(); a++) {
            ViewData vd = viewsToRemove.get(a);
            if (!vd.willStartAgain) {
                stopViewWithIDInternal(vd.viewID, customViewSegmentation);
            } else if (closeAllViews) {
                //if we are closing all views, we should remove the view from the cache
                viewDataMap.remove(vd.viewID);
            }
        }
    }
    /**
     * Record a view manually, without automatic tracking
     * or tracks a view that is not automatically tracked
     * like a fragment, Message box or a transparent Activity
     * with segmentation if provided. (This is the internal function)
     *
     * @param viewName String - name of the view
     * @param customViewSegmentation Map<String, Object> - segmentation that will be added to the view, set 'null' if none should be added
     * @return Returns link to Countly for call chaining
     */
    @Nullable String startViewInternal(@Nullable String viewName, @Nullable Map<String, Object> customViewSegmentation, boolean viewShouldBeAutomaticallyStopped) {
        if (!_cly.isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before startViewInternal");
            return null;
        }
        if (viewName == null || viewName.isEmpty()) {
            L.e("[ModuleViews] startViewInternal, Trying to record view with null or empty view name, ignoring request");
            return null;
        }
        if (L.logEnabled()) {
            int segmCount = 0;
            if (customViewSegmentation != null) {
                segmCount = customViewSegmentation.size();
            }
            L.d("[ModuleViews] Recording view with name: [" + viewName + "], previous view ID:[" + currentViewID + "] custom view segment count:[" + segmCount + "], first:[" + firstView + "], autoStop:[" + viewShouldBeAutomaticallyStopped + "]");
        }
        //stop views that should be automatically stopped
        //no segmentation should be used in this case
        autoCloseRequiredViews(false, null);
        ViewData currentViewData = new ViewData();
        currentViewData.viewID = safeViewIDGenerator.GenerateValue();
        currentViewData.viewName = viewName;
        currentViewData.viewStartTimeSeconds = UtilsTime.currentTimestampSeconds();
        currentViewData.isAutoStoppedView = viewShouldBeAutomaticallyStopped;
        viewDataMap.put(currentViewData.viewID, currentViewData);
        previousViewID = currentViewID;
        previousViewName = currentViewName;
        currentViewID = currentViewData.viewID;
        currentViewName = viewName;
        Map<String, Object> accumulatedEventSegm = new HashMap<>(automaticViewSegmentation);
        applyLimitsToViewSegmentation(customViewSegmentation, "startViewInternal", accumulatedEventSegm);
        boolean firstViewInSession = firstView && _cly.moduleSessions.sessionIsRunning();
        Map<String, Object> viewSegmentation = CreateViewEventSegmentation(currentViewData, firstViewInSession, true, accumulatedEventSegm);
        if (firstViewInSession) {
            L.d("[ModuleViews] Recording view as the first one in the session. [" + viewName + "]");
            firstView = false;
        }
        eventProvider.recordEventInternal(VIEW_EVENT_KEY, viewSegmentation, 1, 0, 0, null, currentViewData.viewID);
        return currentViewData.viewID;
    }
    void stopViewWithNameInternal(@Nullable String viewName, @Nullable Map<String, Object> customViewSegmentation) {
        if (viewName == null || viewName.isEmpty()) {
            L.e("[ModuleViews] stopViewWithNameInternal, Trying to record view with null or empty view name, ignoring request");
            return;
        }
        String viewID = null;
        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {
            ViewData vd = entry.getValue();
            if (vd != null && viewName.equals(vd.viewName)) {
                viewID = entry.getKey();
            }
        }
        if (viewID == null) {
            L.e("[ModuleViews] stopViewWithNameInternal, No view entry found with the provided name :[" + viewName + "]");
            return;
        }
        stopViewWithIDInternal(viewID, customViewSegmentation);
    }
    void stopViewWithIDInternal(@Nullable String viewID, @Nullable Map<String, Object> customViewSegmentation) {
        if (viewID == null || viewID.isEmpty()) {
            L.e("[ModuleViews] stopViewWithNameInternal, Trying to record view with null or empty view ID, ignoring request");
            return;
        }
        //todo extract common checks
        if (!viewDataMap.containsKey(viewID)) {
            L.w("[ModuleViews] stopViewWithIDInternal, there is no view with the provided view id to close");
            return;
        }
        ViewData vd = viewDataMap.get(viewID);
        if (vd == null) {
            L.e("[ModuleViews] stopViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");
            return;
        }
        L.d("[ModuleViews] View [" + vd.viewName + "], id:[" + vd.viewID + "] is getting closed, reporting duration: [" + (UtilsTime.currentTimestampSeconds() - vd.viewStartTimeSeconds) + "] s, current timestamp: [" + UtilsTime.currentTimestampSeconds() + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {
            L.w("[ModuleViews] stopViewWithIDInternal, no consent given for views, ignoring call");
            return;
        }
        recordViewEndEvent(vd, customViewSegmentation, "stopViewWithIDInternal");
        if (!vd.willStartAgain) {
            viewDataMap.remove(vd.viewID);
        }
    }
    void recordViewEndEvent(ViewData vd, @Nullable Map<String, Object> customViewSegmentation, String viewRecordingSource) {
        long lastElapsedDurationSeconds = 0;
        //we sanity check the time component and print error in case of problem
        if (vd.viewStartTimeSeconds < 0) {
            L.e("[ModuleViews] " + viewRecordingSource + ", view start time value is not normal: [" + vd.viewStartTimeSeconds + "], ignoring that duration");
        } else if (vd.viewStartTimeSeconds == 0) {
            L.i("[ModuleViews] " + viewRecordingSource + ", view is either paused or didn't run, ignoring start timestamp");
        } else {
            lastElapsedDurationSeconds = UtilsTime.currentTimestampSeconds() - vd.viewStartTimeSeconds;
        }
        //only record view if the view name is not null
        if (vd.viewName == null) {
            L.e("[ModuleViews] recordViewEndEvent, view has no internal name, ignoring it");
            return;
        }
        Map<String, Object> accumulatedEventSegm = new HashMap<>(automaticViewSegmentation);
        if (vd.viewSegmentation != null) {
            accumulatedEventSegm.putAll(vd.viewSegmentation);
        }
        applyLimitsToViewSegmentation(customViewSegmentation, "recordViewEndEvent", accumulatedEventSegm);
        UtilsInternalLimits.truncateSegmentationValues(accumulatedEventSegm, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleViews] recordViewEndEvent", L);
        long viewDurationSeconds = lastElapsedDurationSeconds;
        Map<String, Object> segments = CreateViewEventSegmentation(vd, false, false, accumulatedEventSegm);
        eventProvider.recordEventInternal(VIEW_EVENT_KEY, segments, 1, 0, viewDurationSeconds, null, vd.viewID);
    }
    void pauseViewWithIDInternal(String viewID) {
        if (viewID == null || viewID.isEmpty()) {
            L.e("[ModuleViews] pauseViewWithIDInternal, Trying to record view with null or empty view ID, ignoring request");
            return;
        }
        if (!viewDataMap.containsKey(viewID)) {
            L.w("[ModuleViews] pauseViewWithIDInternal, there is no view with the provided view id to close");
            return;
        }
        ViewData vd = viewDataMap.get(viewID);
        if (vd == null) {
            L.e("[ModuleViews] pauseViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {
            return;
        }
        L.d("[ModuleViews] pauseViewWithIDInternal, pausing view for ID:[" + viewID + "], name:[" + vd.viewName + "]");
        if (vd.viewStartTimeSeconds == 0) {
            L.w("[ModuleViews] pauseViewWithIDInternal, pausing a view that is already paused. ID:[" + viewID + "], name:[" + vd.viewName + "]");
            return;
        }
        recordViewEndEvent(vd, null, "pauseViewWithIDInternal");
        vd.viewStartTimeSeconds = 0;
    }
    void resumeViewWithIDInternal(String viewID) {
        if (viewID == null || viewID.isEmpty()) {
            L.e("[ModuleViews] resumeViewWithIDInternal, Trying to record view with null or empty view ID, ignoring request");
            return;
        }
        if (!viewDataMap.containsKey(viewID)) {
            L.w("[ModuleViews] resumeViewWithIDInternal, there is no view with the provided view id to close");
            return;
        }
        ViewData vd = viewDataMap.get(viewID);
        if (vd == null) {
            L.e("[ModuleViews] resumeViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {
            return;
        }
        L.d("[ModuleViews] resumeViewWithIDInternal, resuming view for ID:[" + viewID + "], name:[" + vd.viewName + "]");
        if (vd.viewStartTimeSeconds > 0) {
            L.w("[ModuleViews] resumeViewWithIDInternal, resuming a view that is already running. ID:[" + viewID + "], name:[" + vd.viewName + "]");
            return;
        }
        vd.viewStartTimeSeconds = UtilsTime.currentTimestampSeconds();
    }
    public void addSegmentationToViewWithIDInternal(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {
        if (viewID == null || viewSegmentation == null || viewID.isEmpty() || viewSegmentation.isEmpty()) {
            L.e("[Views] addSegmentationToViewWithID, null or empty parameters provided");
            return;
        }
        if (!viewDataMap.containsKey(viewID)) {
            L.w("[ModuleViews] addSegmentationToViewWithID, there is no view with the provided view id");
            return;
        }
        ViewData vd = viewDataMap.get(viewID);
        if (vd == null) {
            L.e("[ModuleViews] addSegmentationToViewWithID, view id:[" + viewID + "] has a 'null' view data. This should not be happening");
            return;
        }
        if (vd.viewSegmentation == null) {
            vd.viewSegmentation = new HashMap<>();
        }
        applyLimitsToViewSegmentation(viewSegmentation, "addSegmentationToViewWithIDInternal", vd.viewSegmentation);
    }
    private void applyLimitsToViewSegmentation(@Nullable Map<String, Object> viewSegmentation, @NonNull String function, @NonNull Map<String, Object> source) {
        if (viewSegmentation == null) {
            viewSegmentation = new HashMap<>();
        }
        assert viewSegmentation != null;
        assert source != null;
        assert function != null;
        UtilsInternalLimits.removeReservedKeysFromSegmentation(viewSegmentation, reservedSegmentationKeysViews, "[ModuleViews] " + function + ", ", L);
        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(viewSegmentation, _cly.config_.sdkInternalLimits, L, "[ModuleViews] " + function);
        source.putAll(viewSegmentation);
        UtilsInternalLimits.truncateSegmentationValues(source, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleViews] " + function, L);
    }
    public void addSegmentationToViewWithNameInternal(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
        String viewID = null;
        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {
            ViewData vd = entry.getValue();
            if (vd != null && viewName != null && viewName.equals(vd.viewName)) {
                viewID = entry.getKey();
            }
        }
        if (viewID == null) {
            L.e("[ModuleViews] addSegmentationToViewWithName, No view entry found with the provided name :[" + viewName + "]");
            return;
        }
        L.i("[ModuleViews] Will add segmentation for view: [" + viewName + "] with ID:[" + viewID + "]");
        addSegmentationToViewWithIDInternal(viewID, viewSegmentation);
    }
    void stopAllViewsInternal(Map<String, Object> viewSegmentation) {
        L.d("[ModuleViews] stopAllViewsInternal");
        autoCloseRequiredViews(true, viewSegmentation);
    }
    void updateOrientation(int newOrientation, boolean forceSend) {
        L.d("[ModuleViews] updateOrientation,  forceSend: [" + forceSend + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {
            L.d("[ModuleViews] updateOrientation, no consent given for users, skipping orientation tracking");
            return;
        }
        if (!forceSend && currentOrientation == newOrientation) {
            L.d("[ModuleViews] updateOrientation, orientation did not change, skipping");
            return;
        }
        L.i("[ModuleViews] updateOrientation, new orientation:[" + newOrientation + "], current orientation:[" + currentOrientation + "], landscape:[" + Configuration.ORIENTATION_LANDSCAPE + "], portrait:[" + Configuration.ORIENTATION_PORTRAIT + "]");
        currentOrientation = newOrientation;
        Map<String, Object> segm = new HashMap<>();
        if (currentOrientation == Configuration.ORIENTATION_PORTRAIT) {
            segm.put("mode", "portrait");
        } else {
            segm.put("mode", "landscape");
        }
        eventProvider.recordEventInternal(ORIENTATION_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    void updateOrientation(int newOrientation) {
        updateOrientation(newOrientation, false);
    }
    void stopRunningViewsAndSend() {
        L.d("[ModuleViews] stopRunningViewsAndSend, going to the background and stopping views");
        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {
            ViewData vd = entry.getValue();
            vd.willStartAgain = true;
            stopViewWithIDInternal(vd.viewID, null);
        }
    }
    void startStoppedViews() {
        L.d("[ModuleViews] startStoppedViews, app is coming back to the foreground, starting views that were stopped");
        Iterator<Map.Entry<String, ViewData>> iterator = viewDataMap.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, ViewData> value = iterator.next();
            ViewData vd = value.getValue();
            if (vd.willStartAgain) {
                //if the view is auto-stopped, start it again and remove from the cache
                iterator.remove();
                startViewInternal(vd.viewName, vd.viewSegmentation, vd.isAutoStoppedView);
            }
        }
    }
    @Override
    void onConfigurationChanged(Configuration newConfig) {
        if (trackOrientationChanges) {
            Integer orient = getOrientationFromConfiguration(newConfig);
            if (orient != null) {
                updateOrientation(orient);
            }
        }
    }
    @Override
    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {
        if (consentThatWillChange.contains(Countly.CountlyFeatureNames.views) && !isConsentGiven) {
            stopAllViewsInternal(null);
        }
    }
    @Override
    void onActivityStopped(int updatedActivityCount) {
        if (autoViewTracker) {
            //main purpose of this is handling transitions when the app is getting closed/minimised
            //for cases when going from one view to another we would report the duration there
            if (updatedActivityCount <= 0) {
                //try to close the last open view with the current view ID
                stopViewWithIDInternal(currentViewID, null);
            }
        }
        if (updatedActivityCount <= 0) {
            //if we go to the background, stop all running views
            stopRunningViewsAndSend();
        }
    }
    @Override
    void onActivityStarted(Activity activity, int updatedActivityCount) {
        //automatic view tracking
        if (autoViewTracker) {
            if (!isActivityInExceptionList(activity)) {
                String usedActivityName = "NULL ACTIVITY";
                if (activity != null) {
                    if (automaticTrackingShouldUseShortName) {
                        usedActivityName = activity.getClass().getSimpleName();
                    } else {
                        usedActivityName = activity.getClass().getName();
                    }
                }
                startViewInternal(usedActivityName, automaticViewSegmentation, true);
            } else {
                L.d("[ModuleViews] [onStart] Ignoring activity because it's in the exception list");
            }
        }
        //orientation tracking
        if (trackOrientationChanges) {
            Integer orient = getOrientationFromActivity(activity);
            if (orient != null) {
                updateOrientation(orient);
            }
        }
        if (updatedActivityCount == 1) {
            //if we go to the background, stop all running views
            startStoppedViews();
        }
    }
    /**
     * Needed for mocking test result
     *
     * @param conf
     * @return
     */
    Integer getOrientationFromConfiguration(@Nullable Configuration conf) {
        if (conf == null) {
            return null;
        }
        return conf.orientation;
    }
    /**
     * Needed for mocking test result
     *
     * @param act
     * @return
     */
    Integer getOrientationFromActivity(Activity act) {
        if (act == null) {
            return null;
        }
        Resources resources = act.getResources();
        if (resources != null) {
            return resources.getConfiguration().orientation;
        } else {
            return null;
        }
    }
    @Override
    void halt() {
        if (automaticViewSegmentation != null) {
            automaticViewSegmentation.clear();
            automaticViewSegmentation = null;
        }
        autoTrackingActivityExceptions = null;
    }
    public class Views {
        /**
         * Check state of automatic view tracking
         *
         * @return boolean - true if enabled, false if disabled
         * @deprecated this call will be removed. There is no replacement
         */
        public boolean isAutomaticViewTrackingEnabled() {
            synchronized (_cly) {
                L.i("[Views] Calling isAutomaticViewTrackingEnabled");
                return autoViewTracker;
            }
        }
        /**
         * Record a view manually, without automatic tracking
         * or tracks a view that is not automatically tracked
         * like a fragment, Message box or a transparent Activity
         *
         * @param viewName String - name of the view
         * @return Returns link to Countly for call chaining
         * @deprecated Use "Countly.sharedInstance().views().startAutoStoppedView(...)" in place of this
         */
        public Countly recordView(@Nullable String viewName) {
            synchronized (_cly) {
                // call the general function that has two parameters
                return recordView(viewName, null);
            }
        }
        /**
         * Record a view manually, without automatic tracking
         * or tracks a view that is not automatically tracked
         * like a fragment, Message box or a transparent Activity
         * with segmentation. (This is the main function that is used)
         *
         * @param viewName String - name of the view
         * @param viewSegmentation Map<String, Object> - segmentation that will be added to the view, set 'null' if none should be added
         * @deprecated Use "Countly.sharedInstance().views().startAutoStoppedView(...)" in place of this
         */
        public Countly recordView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling recordView [" + viewName + "]");
                if (autoViewTracker) {
                    L.e("[Views] recordView, manual view call will be ignored since automatic tracking is enabled.");
                    return _cly;
                }
                startViewInternal(viewName, viewSegmentation, true);
                return _cly;
            }
        }
        /**
         * Record a view manually, without automatic tracking
         * or tracks a view that is not automatically tracked
         * like a fragment, Message box or a transparent Activity
         *
         * @param viewName String - name of the view
         * @return Returns View ID
         */
        public String startAutoStoppedView(@Nullable String viewName) {
            synchronized (_cly) {
                // call the general function that has two parameters
                return startAutoStoppedView(viewName, null);
            }
        }
        /**
         * Record a view manually, without automatic tracking
         * or tracks a view that is not automatically tracked
         * like a fragment, Message box or a transparent Activity
         * with segmentation. (This is the main function that is used)
         *
         * @param viewName String - name of the view
         * @param viewSegmentation Map<String, Object> - segmentation that will be added to the view, set 'null' if none should be added
         * @return String - view ID
         */
        public String startAutoStoppedView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling startAutoStoppedView [" + viewName + "]");
                if (autoViewTracker) {
                    L.e("[Views] startAutoStoppedView, manual view call will be ignored since automatic tracking is enabled.");
                    return null;
                }
                return startViewInternal(viewName, viewSegmentation, true);
            }
        }
        /**
         * Updates the segmentation of a view
         *
         * @param viewID String - View ID of the view
         * @param viewSegmentation Map<String, Object> - New segmentation to update the segmentation of a view in memory
         */
        public void addSegmentationToViewWithID(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling addSegmentationToViewWithID for view ID: [" + viewID + "]");
                if (autoViewTracker) {
                    L.e("[Views] addSegmentationToViewWithID, manual view call will be ignored since automatic tracking is enabled.");
                    return;
                }
                addSegmentationToViewWithIDInternal(viewID, viewSegmentation);
            }
        }
        /**
         * Updates the segmentation of a view
         *
         * @param viewName String - Name of the view
         * @param viewSegmentation Map<String, Object> - New segmentation to update the segmentation of a view in memory
         */
        public void addSegmentationToViewWithName(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling addSegmentationToViewWithName for Name: [" + viewName + "]");
                if (autoViewTracker) {
                    L.e("[Views] addSegmentationToViewWithName, manual view call will be ignored since automatic tracking is enabled.");
                    return;
                }
                addSegmentationToViewWithNameInternal(viewName, viewSegmentation);
            }
        }
        /**
         * Starts a view which would not close automatically (For multi view tracking)
         *
         * @param viewName - String
         * @return String - View ID
         */
        public @Nullable String startView(@Nullable String viewName) {
            synchronized (_cly) {
                L.i("[Views] Calling startView vn[" + viewName + "]");
                if (autoViewTracker) {
                    L.e("[Views] startView, manual view call will be ignored since automatic tracking is enabled.");
                    return null;
                }
                return startViewInternal(viewName, null, false);
            }
        }
        /**
         * Starts a view which would not close automatically (For multi view tracking)
         *
         * @param viewName String - name of the view
         * @param viewSegmentation Map<String, Object> - segmentation that will be added to the view, set 'null' if none should be added
         * @return String - View ID
         */
        public @Nullable String startView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling startView vn[" + viewName + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");
                if (autoViewTracker) {
                    L.e("[Views] startView, manual view call will be ignored since automatic tracking is enabled.");
                    return null;
                }
                return startViewInternal(viewName, viewSegmentation, false);
            }
        }
        /**
         * Stops a view with the given name if it was open
         *
         * @param viewName String - view name
         */
        public void stopViewWithName(@Nullable String viewName) {
            synchronized (_cly) {
                L.i("[Views] Calling stopViewWithName vn[" + viewName + "]");
                stopViewWithNameInternal(viewName, null);
            }
        }
        /**
         * Stops a view with the given name if it was open
         *
         * @param viewName String - view name
         * @param viewSegmentation Map<String, Object> - view segmentation
         */
        public void stopViewWithName(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling stopViewWithName vn[" + viewName + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");
                stopViewWithNameInternal(viewName, viewSegmentation);
            }
        }
        /**
         * Stops a view with the given ID if it was open
         *
         * @param viewID String - view ID
         */
        public void stopViewWithID(@Nullable String viewID) {
            synchronized (_cly) {
                L.i("[Views] Calling stopViewWithID vi[" + viewID + "]");
                stopViewWithIDInternal(viewID, null);
            }
        }
        /**
         * Stops a view with the given ID if it was open
         *
         * @param viewID String - view ID
         * @param viewSegmentation Map<String, Object> - view segmentation
         */
        public void stopViewWithID(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling stopViewWithName vi[" + viewID + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");
                stopViewWithIDInternal(viewID, viewSegmentation);
            }
        }
        /**
         * Pauses a view with the given ID
         *
         * @param viewID String - view ID
         */
        public void pauseViewWithID(@Nullable String viewID) {
            synchronized (_cly) {
                L.i("[Views] Calling pauseViewWithID vi[" + viewID + "]");
                pauseViewWithIDInternal(viewID);
            }
        }
        /**
         * Resumes a view with the given ID
         *
         * @param viewID String - view ID
         */
        public void resumeViewWithID(@Nullable String viewID) {
            synchronized (_cly) {
                L.i("[Views] Calling resumeViewWithID vi[" + viewID + "]");
                resumeViewWithIDInternal(viewID);
            }
        }
        /**
         * Set a segmentation to be recorded with all views
         *
         * @param segmentation Map<String, Object> - global view segmentation
         */
        public void setGlobalViewSegmentation(@Nullable Map<String, Object> segmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling setGlobalViewSegmentation sg[" + (segmentation == null ? segmentation : segmentation.size()) + "]");
                setGlobalViewSegmentationInternal(segmentation);
            }
        }
        /**
         * Updates the global segmentation for views
         *
         * @param segmentation Map<String, Object> - global view segmentation
         */
        public void updateGlobalViewSegmentation(@Nullable Map<String, Object> segmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling updateGlobalViewSegmentation sg[" + (segmentation == null ? segmentation : segmentation.size()) + "]");
                if (segmentation == null) {
                    L.w("[View] When updating segmentation values, they can't be 'null'.");
                    return;
                }
                updateGlobalViewSegmentationInternal(segmentation);
            }
        }
        /**
         * Stops all views and records a segmentation if set
         *
         * @param viewSegmentation Map<String, Object> - view segmentation
         */
        public void stopAllViews(@Nullable Map<String, Object> viewSegmentation) {
            synchronized (_cly) {
                L.i("[Views] Calling stopAllViews sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");
                stopAllViewsInternal(viewSegmentation);
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.List;
public class ModuleLocation extends ModuleBase {
    boolean locationDisabled = false;
    String locationCountryCode = null;
    String locationCity = null;
    String locationGpsCoordinates = null;
    String locationIpAddress = null;
    Location locationInterface = null;
    ModuleLocation(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleLocation] Initialising");
        locationInterface = new Location();
    }
    void resetLocationValues() {
        locationCity = null;
        locationCountryCode = null;
        locationGpsCoordinates = null;
        locationIpAddress = null;
    }
    void sendCurrentLocationIfValid() {
        L.d("[ModuleLocation] Calling 'sendCurrentLocationIfValid'");
        if (locationDisabled) {
            return;
        }
        if (locationCountryCode != null || locationCity != null || locationIpAddress != null || locationGpsCoordinates != null) {
            requestQueueProvider.sendLocation(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);
        }
    }
    void disableLocationInternal() {
        L.d("[ModuleLocation] Calling 'disableLocationInternal'");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {
            //can't send disable location request if no consent given
            return;
        }
        locationDisabled = true;
        performLocationErasure();
    }
    void performLocationErasure() {
        resetLocationValues();
        requestQueueProvider.sendLocation(true, null, null, null, null);
    }
    void setLocationInternal(@Nullable String country_code, @Nullable String city, @Nullable String gpsCoordinates, @Nullable String ipAddress) {
        L.d("[ModuleLocation] Calling 'setLocationInternal'");
        L.d("[ModuleLocation] Setting location parameters, cc[" + country_code + "] cy[" + city + "] gps[" + gpsCoordinates + "] ip[" + ipAddress + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {
            return;
        }
        locationCountryCode = country_code;
        locationCity = city;
        locationGpsCoordinates = gpsCoordinates;
        locationIpAddress = ipAddress;
        if ((country_code == null && city != null) || (city == null && country_code != null)) {
            L.w("[ModuleLocation] In \"setLocation\" both city and country code need to be set at the same time to be sent");
        }
        if (country_code != null || city != null || gpsCoordinates != null || ipAddress != null) {
            locationDisabled = false;
        }
        if (_cly.isBeginSessionSent || !consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            //send as a separate request if either begin session was already send and we missed our first opportunity
            //or if consent for sessions is not given and our only option to send this is as a separate request
            requestQueueProvider.sendLocation(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);
        } else {
            //will be sent a part of begin session
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //check first if consent is even given
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {
            //if no consent is given, perform location erasure
            performLocationErasure();
        } else {
            //if consent is given, check if location isn't disabled
            if (config.disableLocation) {
                //disable location if needed
                disableLocationInternal();
            } else {
                //if we are not disabling location, check for other set values
                if (config.locationIpAddress != null || config.locationLocation != null || config.locationCity != null || config.locationCountyCode != null) {
                    setLocationInternal(config.locationCountyCode, config.locationCity, config.locationLocation, config.locationIpAddress);
                }
            }
        }
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.location)) {
            if (!newConsent) {
                //if consent is about to be removed
                performLocationErasure();
            }
        }
    }
    @Override
    void halt() {
        locationInterface = null;
    }
    public class Location {
        /**
         * Disable sending of location data. Erases server side saved location information
         */
        public void disableLocation() {
            synchronized (_cly) {
                L.i("[Location] Calling 'disableLocation'");
                disableLocationInternal();
            }
        }
        /**
         * Set location parameters. If they are set before begin_session, they will be sent as part of it.
         * If they are set after, then they will be sent as a separate request.
         * If this is called after disabling location, it will enable it.
         *
         * @param countryCode ISO Country code for the user's country
         * @param city Name of the user's city
         * @param gpsCoordinates comma separate lat and lng values. For example, "56.42345,123.45325"
         * @param ipAddress ipAddress like "192.168.88.33"
         */
        public void setLocation(@Nullable String countryCode, @Nullable String city, @Nullable String gpsCoordinates, @Nullable String ipAddress) {
            synchronized (_cly) {
                L.i("[Location] Calling 'setLocation'");
                setLocationInternal(countryCode, city, gpsCoordinates, ipAddress);
            }
        }
    }
}package ly.count.android.sdk;
import android.content.Context;
import android.util.Base64;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
public class ModuleCrash extends ModuleBase {
    //native crash
    private static final String countlyFolderName = "Countly";
    private static final String countlyNativeCrashFolderName = "CrashDumps";
    //crash filtering
    GlobalCrashFilterCallback globalCrashFilterCallback;
    //Deprecated, will be removed in the future
    CrashFilterCallback crashFilterCallback;
    boolean recordAllThreads = false;
    @Nullable
    Map<String, Object> customCrashSegments = null;
    //interface for SDK users
    final Crashes crashesInterface;
    @Nullable
    Map<String, String> metricOverride = null;
    BreadcrumbHelper breadcrumbHelper;
    ModuleCrash(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleCrash] Initialising");
        globalCrashFilterCallback = config.crashes.globalCrashFilterCallback;
        crashFilterCallback = config.crashFilterCallback;
        recordAllThreads = config.crashes.recordAllThreadsWithCrash;
        setCustomCrashSegmentsInternal(config.crashes.customCrashSegment);
        metricOverride = config.metricOverride;
        crashesInterface = new Crashes();
        breadcrumbHelper = new BreadcrumbHelper(config.sdkInternalLimits.maxBreadcrumbCount, L);
        assert breadcrumbHelper != null;
    }
    /**
     * Called during init to check if there are any crash dumps saved
     *
     * @param context android context
     */
    void checkForNativeCrashDumps(@NonNull Context context) {
        assert context != null;
        L.d("[ModuleCrash] Checking for native crash dumps");
        String basePath = context.getCacheDir().getAbsolutePath();
        String finalPath = basePath + File.separator + countlyFolderName + File.separator + countlyNativeCrashFolderName;
        File folder = new File(finalPath);
        if (folder.exists()) {
            L.d("[ModuleCrash] Native crash folder exists, checking for dumps");
            File[] dumpFiles = folder.listFiles();
            int dumpFileCount = -1;
            if (dumpFiles != null) {
                dumpFileCount = dumpFiles.length;
            }
            L.d("[ModuleCrash] Crash dump folder contains [" + dumpFileCount + "] files");
            if (dumpFiles != null) {
                for (File dumpFile : dumpFiles) {
                    //record crash
                    recordNativeException(dumpFile);
                    //delete dump file
                    dumpFile.delete();
                }
            }
        } else {
            L.d("[ModuleCrash] Native crash folder does not exist");
        }
    }
    private void recordNativeException(@NonNull File dumpFile) {
        assert dumpFile != null;
        L.d("[ModuleCrash] Recording native crash dump: [" + dumpFile.getName() + "]");
        //check for consent
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
            return;
        }
        //read bytes
        int size = (int) dumpFile.length();
        byte[] bytes = new byte[size];
        try {
            BufferedInputStream buf = new BufferedInputStream(new FileInputStream(dumpFile));
            buf.read(bytes, 0, bytes.length);
            buf.close();
        } catch (Exception e) {
            L.e("[ModuleCrash] Failed to read dump file bytes");
            e.printStackTrace();
            return;
        }
        //convert to base64
        String dumpString = Base64.encodeToString(bytes, Base64.NO_WRAP);
        CrashData crashData = prepareCrashData(dumpString, false, true, null);
        if (!crashFilterCheck(crashData)) {
            sendCrashReportToQueue(crashData, true);
        }
    }
    private CrashData prepareCrashData(@NonNull String error, final boolean handled, final boolean isNativeCrash, @Nullable Map<String, Object> customSegmentation) {
        assert error != null;
        if (!isNativeCrash) {
            error = error.substring(0, Math.min(20_000, error.length()));
        }
        Map<String, Object> combinedSegmentationValues = new HashMap<>();
        if (customCrashSegments != null) {
            combinedSegmentationValues.putAll(customCrashSegments);
        }
        if (customSegmentation != null) {
            UtilsInternalLimits.applySdkInternalLimitsToSegmentation(customSegmentation, _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");
            combinedSegmentationValues.putAll(customSegmentation);
        }
        UtilsInternalLimits.truncateSegmentationValues(combinedSegmentationValues, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleCrash] prepareCrashData", L);
        return new CrashData(error, combinedSegmentationValues, breadcrumbHelper.getBreadcrumbs(), deviceInfo.getCrashMetrics(_cly.context_, isNativeCrash, metricOverride, L), !handled);
    }
    private String prepareStackTrace(Throwable e) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        if (recordAllThreads) {
            addAllThreadInformationToCrash(pw, _cly.config_.sdkInternalLimits);
        }
        String truncatedStackTrace = UtilsInternalLimits.applyInternalLimitsToStackTraces(sw.toString(), _cly.config_.sdkInternalLimits.maxStackTraceLineLength, "[ModuleCrash] prepareStackTrace", L);
        return truncatedStackTrace;
    }
    public void sendCrashReportToQueue(@NonNull CrashData crashData, final boolean isNativeCrash) {
        assert crashData != null;
        L.d("[ModuleCrash] sendCrashReportToQueue");
        String crashDataString = deviceInfo.getCrashDataJSON(crashData, isNativeCrash).toString();
        requestQueueProvider.sendCrashReport(crashDataString, !crashData.getFatal());
    }
    /**
     * Sets custom segments to be reported with crash reports
     * In custom segments you can provide any string key values to segments crashes by
     *
     * @param segments Map&lt;String, Object&gt; key segments and their values
     */
    void setCustomCrashSegmentsInternal(@Nullable Map<String, Object> segments) {
        L.d("[ModuleCrash] Calling setCustomCrashSegmentsInternal");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
            return;
        }
        Map<String, Object> customSegments;
        if (segments == null) {
            customSegments = new HashMap<>();
        } else {
            customSegments = segments;
        }
        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(customSegments, _cly.config_.sdkInternalLimits, L, "[ModuleCrash] setCustomCrashSegmentsInternal");
        customCrashSegments = customSegments;
    }
    void enableCrashReporting() {
        L.d("[ModuleCrash] Enabling unhandled crash reporting");
        //get default handler
        final Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) {
                L.d("[ModuleCrash] Uncaught crash handler triggered");
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
                    String stackTrace = prepareStackTrace(e);
                    CrashData crashData = prepareCrashData(stackTrace, false, false, null);
                    if (!crashFilterCheck(crashData)) {
                        sendCrashReportToQueue(crashData, false);
                    }
                }
                //if there was another handler before
                if (oldHandler != null) {
                    //notify it also
                    oldHandler.uncaughtException(t, e);
                }
            }
        };
        Thread.setDefaultUncaughtExceptionHandler(handler);
    }
    /**
     * Call to check if crash matches one of the filters
     * If it does, the crash should be ignored
     *
     * @param crashData CrashData object to check
     * @return true if a match was found
     */
    boolean crashFilterCheck(@NonNull CrashData crashData) {
        assert crashData != null;
        L.d("[ModuleCrash] Calling crashFilterCheck");
        if (crashFilterCallback != null) {
            return crashFilterCallback.filterCrash(crashData.getStackTrace());
        }
        if (globalCrashFilterCallback == null) {
            return false;
        }
        if (globalCrashFilterCallback.filterCrash(crashData)) {
            L.d("[ModuleCrash] crashFilterCheck, Global Crash filter found a match, exception will be ignored, [" + crashData.getStackTrace().substring(0, Math.min(crashData.getStackTrace().length(), 60)) + "]");
            return true;
        }
        crashData.calculateChangedFields();
        UtilsInternalLimits.applyInternalLimitsToBreadcrumbs(crashData.getBreadcrumbs(), _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");
        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(crashData.getCrashSegmentation(), _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");
        String truncatedStackTrace = UtilsInternalLimits.applyInternalLimitsToStackTraces(crashData.getStackTrace(), _cly.config_.sdkInternalLimits.maxStackTraceLineLength, "[ModuleCrash] sendCrashReportToQueue", L);
        crashData.setStackTrace(truncatedStackTrace);
        UtilsInternalLimits.removeUnsupportedDataTypes(crashData.getCrashSegmentation(), L);
        UtilsInternalLimits.removeUnsupportedDataTypes(crashData.getCrashMetrics(), L);
        return false;
    }
    void addAllThreadInformationToCrash(@NonNull PrintWriter pw, @NonNull ConfigSdkInternalLimits sdkInternalLimits) {
        assert pw != null;
        assert sdkInternalLimits != null;
        Map<Thread, StackTraceElement[]> allThreads = Thread.getAllStackTraces();
        int threadCount = 0;
        for (Map.Entry<Thread, StackTraceElement[]> entry : allThreads.entrySet()) {
            if (threadCount >= sdkInternalLimits.maxStackTraceThreadCount) {
                break;
            }
            StackTraceElement[] val = entry.getValue();
            Thread thread = entry.getKey();
            if (val == null || thread == null) {
                continue;
            }
            pw.println();
            pw.println("Thread " + thread.getName());
            for (int i = 0; i < Math.min(val.length, sdkInternalLimits.maxStackTraceLinesPerThread); i++) {
                pw.println(val[i].toString());
            }
            threadCount++;
        }
    }
    /**
     * Common call for handling exceptions
     *
     * @param exception Exception to log
     * @param itIsHandled If the exception is handled or not (fatal)
     * @return Returns link to Countly for call chaining
     */
    Countly recordExceptionInternal(@Nullable final Throwable exception, final boolean itIsHandled, final Map<String, Object> customSegmentation) {
        L.i("[ModuleCrash] Logging exception, handled:[" + itIsHandled + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
            return _cly;
        }
        if (exception == null) {
            L.d("[ModuleCrash] recordException, provided exception was null, returning");
            return _cly;
        }
        String exceptionString = prepareStackTrace(exception);
        CrashData crashData = prepareCrashData(exceptionString, itIsHandled, false, customSegmentation);
        if (crashFilterCheck(crashData)) {
            L.d("[ModuleCrash] Crash filter found a match, exception will be ignored, [" + exceptionString.substring(0, Math.min(exceptionString.length(), 60)) + "]");
        } else {
            sendCrashReportToQueue(crashData, false);
        }
        return _cly;
    }
    Countly addBreadcrumbInternal(@Nullable String breadcrumb) {
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
            return _cly;
        }
        if (breadcrumb == null || breadcrumb.isEmpty()) {
            L.w("[ModuleCrash] addBreadcrumbInternal, Can't add a null or empty crash breadcrumb");
            return _cly;
        }
        breadcrumbHelper.addBreadcrumb(breadcrumb, _cly.config_.sdkInternalLimits.maxValueSize);
        return _cly;
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //enable unhandled crash reporting
        if (config.crashes.enableUnhandledCrashReporting) {
            enableCrashReporting();
        }
        //check for previous native crash dumps
        if (config.crashes.checkForNativeCrashDumps) {
            //flag so that this can be turned off during testing
            _cly.moduleCrash.checkForNativeCrashDumps(config.context);
        }
    }
    @Override
    void halt() {
    }
    public class Crashes {
        /**
         * Add crash breadcrumb like log record to the log that will be send together with crash report
         *
         * @param record String a bread crumb for the crash report
         * @return Returns link to Countly for call chaining
         */
        public Countly addCrashBreadcrumb(String record) {
            synchronized (_cly) {
                L.i("[Crashes] Adding crash breadcrumb");
                return addBreadcrumbInternal(record);
            }
        }
        /**
         * Log handled exception to report it to server as non fatal crash
         *
         * @param exception Exception to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordHandledException(Exception exception) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, true, null);
            }
        }
        /**
         * Log handled exception to report it to server as non fatal crash
         *
         * @param exception Throwable to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordHandledException(Throwable exception) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, true, null);
            }
        }
        /**
         * Log unhandled exception to report it to server as fatal crash
         *
         * @param exception Exception to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordUnhandledException(Exception exception) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, false, null);
            }
        }
        /**
         * Log unhandled exception to report it to server as fatal crash
         *
         * @param exception Throwable to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordUnhandledException(Throwable exception) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, false, null);
            }
        }
        /**
         * Log handled exception to report it to server as non fatal crash
         *
         * @param exception Throwable to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordHandledException(final Throwable exception, final Map<String, Object> customSegmentation) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, true, customSegmentation);
            }
        }
        /**
         * Log unhandled exception to report it to server as fatal crash
         *
         * @param exception Throwable to log
         * @return Returns link to Countly for call chaining
         */
        public Countly recordUnhandledException(final Throwable exception, final Map<String, Object> customSegmentation) {
            synchronized (_cly) {
                return recordExceptionInternal(exception, false, customSegmentation);
            }
        }
    }
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static androidx.test.InstrumentationRegistry.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.anyInt;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
@RunWith(AndroidJUnit4.class)
public class CountlyTests {
    Countly mUninitedCountly;
    Countly mCountly;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        mUninitedCountly = new Countly();
        mCountly = new Countly();
        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting());
    }
    @After
    public void tearDown() {
    }
    @Test
    public void testConstructor() {
        assertNotNull(mUninitedCountly.getConnectionQueue());
        assertNull(mUninitedCountly.getConnectionQueue().getContext());
        assertNull(mUninitedCountly.getConnectionQueue().baseInfoProvider);
        assertNull(mUninitedCountly.getConnectionQueue().getStorageProvider());
        assertNotNull(mUninitedCountly.getTimerService());
        assertEquals(0, mUninitedCountly.getActivityCount());
        assertNull(mUninitedCountly.moduleSessions);
        assertFalse(mUninitedCountly.getDisableUpdateSessionRequests());
        assertFalse(mUninitedCountly.isLoggingEnabled());
        assertTrue(mCountly.isInitialized());
    }
    @Test
    public void testSharedInstance() {
        Countly sharedCountly = Countly.sharedInstance();
        assertNotNull(sharedCountly);
        assertSame(sharedCountly, Countly.sharedInstance());
    }
    @Test
    public void testInitWithNoDeviceID() {
        mUninitedCountly = spy(mUninitedCountly);
        CountlyConfig cc = new CountlyConfig(getContext(), "appkey", "http://test.count.ly");
        mUninitedCountly.init(cc);
        verify(mUninitedCountly).init(cc);
    }
    @Test
    public void testInit_nullContext() {
        try {
            mUninitedCountly.init(new CountlyConfig(null, "appkey", "http://test.count.ly"));
            fail("expected null context to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_nullServerURL() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", null).setDeviceId("1234"));
            fail("expected null server URL to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_emptyServerURL() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "").setDeviceId("1234"));
            fail("expected empty server URL to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_invalidServerURL() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "not-a-valid-server-url").setDeviceId("1234"));
            fail("expected invalid server URL to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_nullAppKey() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), null, "http://test.count.ly").setDeviceId("1234"));
            fail("expected null app key to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_emptyAppKey() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "", "http://test.count.ly").setDeviceId("1234"));
            fail("expected empty app key to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_nullDeviceID() {
        // null device ID is okay because it tells Countly to use OpenUDID
        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test.count.ly").setDeviceId(null));
    }
    /**
     * This test not fail anymore because we are now not throwing an exception when device ID is empty.
     */
    @Test(expected = AssertionError.class)
    public void testInit_emptyDeviceID() {
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test.count.ly").setDeviceId(""));
            fail("expected empty device ID to throw IllegalArgumentException");
        } catch (IllegalArgumentException ignored) {
            // success!
        }
    }
    @Test
    public void testInit_emptyDeviceID_sdkGenerated() {
        mCountly.halt(); // to reset the state
        mUninitedCountly.init(TestUtils.createBaseConfig().setDeviceId(""));
        // this should be an SDK generated device ID
        Assert.assertEquals(DeviceIdType.OPEN_UDID, mUninitedCountly.deviceId().getType());
    }
    @Test
    public void testInit_twiceWithSameParams() {
        final String deviceID = "1234";
        final String appKey = "appkey";
        final String serverURL = "http://test.count.ly";
        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));
        final ConnectionQueue expectedConnectionQueue = mUninitedCountly.getConnectionQueue();
        final StorageProvider expectedCountlyStore = expectedConnectionQueue.getStorageProvider();
        Assert.assertTrue(mCountly.isInitialized());
        assertNotNull(expectedConnectionQueue);
        assertNotNull(expectedCountlyStore);
        // second call with same params should succeed, no exception thrown
        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));
        Assert.assertTrue(mCountly.isInitialized());
        assertSame(expectedConnectionQueue, mUninitedCountly.getConnectionQueue());
        assertSame(expectedCountlyStore, mUninitedCountly.getConnectionQueue().getStorageProvider());
        assertSame(getContext().getApplicationContext(), mUninitedCountly.getConnectionQueue().getContext());
        assertEquals(serverURL, mUninitedCountly.getConnectionQueue().baseInfoProvider.getServerURL());
        assertEquals(appKey, mUninitedCountly.getConnectionQueue().baseInfoProvider.getAppKey());
        assertSame(mUninitedCountly.getConnectionQueue().getStorageProvider(), mUninitedCountly.countlyStore);
    }
    @Test
    public void testInit_twiceWithDifferentContext() {
        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test.count.ly"));
        // changing context is okay since SharedPrefs are global singletons
        Context mContext = mock(Context.class);
        when(mContext.getCacheDir()).thenReturn(getContext().getCacheDir());
        mUninitedCountly.init(new CountlyConfig(mContext, "appkey", "http://test.count.ly"));
    }
    @Test
    public void testInit_twiceWithDifferentServerURL() {
        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test1.count.ly").setDeviceId("1234"));
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test2.count.ly").setDeviceId("1234"));
            // success!
            // should not throw a exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected IllegalStateException to be thrown when calling init a second time with different serverURL");
        }
    }
    @Test
    public void testInit_twiceWithDifferentAppKey() {
        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey1", "http://test.count.ly").setDeviceId("1234"));
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey2", "http://test.count.ly").setDeviceId("1234"));
            // success!
            // should not throw a exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected IllegalStateException to be thrown when calling init a second time with different app key");
        }
    }
    @Test
    public void testInit_twiceWithDifferentDeviceID() {
        mUninitedCountly.init((new CountlyConfig(getContext(), "appkey", "http://test.count.ly")).setDeviceId("1234"));
        try {
            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http://test.count.ly").setDeviceId("4321"));
            // success!
            // should not throw a exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected IllegalStateException to be thrown when calling init a second time with different device ID");
        }
    }
    @Test
    public void testInit_normal() {
        final String deviceID = "1234";
        final String appKey = "appkey";
        final String serverURL = "http://test.count.ly";
        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));
        assertSame(getContext().getApplicationContext(), mUninitedCountly.getConnectionQueue().getContext());
        assertEquals(serverURL, mUninitedCountly.getConnectionQueue().baseInfoProvider.getServerURL());
        assertEquals(appKey, mUninitedCountly.getConnectionQueue().baseInfoProvider.getAppKey());
        assertNotNull(mUninitedCountly.getConnectionQueue().getStorageProvider());
        assertTrue(mCountly.isInitialized());
        assertSame(mUninitedCountly.getConnectionQueue().getStorageProvider(), mUninitedCountly.countlyStore);
    }
    @Test
    public void testHalt_notInitialized() {
        mUninitedCountly.halt();
        assertNotNull(mUninitedCountly.getConnectionQueue());
        assertNull(mUninitedCountly.getConnectionQueue().getContext());
        assertNull(mUninitedCountly.getConnectionQueue().baseInfoProvider);
        assertNull(mUninitedCountly.getConnectionQueue().getStorageProvider());
        assertNotNull(mUninitedCountly.getTimerService());
        assertTrue(mCountly.isInitialized());
        assertEquals(0, mUninitedCountly.getActivityCount());
        assertNull(mUninitedCountly.moduleSessions);
    }
    //@Test
    //public void testHalt() {
    //    CountlyStore mockCountlyStore = mock(CountlyStore.class);
    //
    //    when(mockCountlyStore.getCachedAdvertisingId()).thenReturn("");
    //
    //    mCountly.getConnectionQueue().setStorageProvider(mockCountlyStore);
    //    mCountly.onStart(null);
    //    assertTrue(0 != mCountly.getPrevSessionDurationStartTime());
    //    assertTrue(0 != mCountly.getActivityCount());
    //    Assert.assertTrue(mCountly.isInitialized());
    //    assertNotNull(mCountly.getConnectionQueue().getContext());
    //    assertNotNull(mCountly.getConnectionQueue().baseInfoProvider.getServerURL());
    //    assertNotNull(mCountly.getConnectionQueue().baseInfoProvider.getAppKey());
    //    assertNotNull(mCountly.getConnectionQueue().getContext());
    //
    //    assertNotEquals(0, mCountly.modules.size());
    //
    //    assertNotNull(mCountly.moduleSessions);
    //    assertNotNull(mCountly.moduleCrash);
    //    assertNotNull(mCountly.moduleEvents);
    //    assertNotNull(mCountly.moduleRatings);
    //    assertNotNull(mCountly.moduleViews);
    //
    //    for (ModuleBase module : mCountly.modules) {
    //        assertNotNull(module);
    //    }
    //
    //    mCountly.halt();
    //
    //    verify(mockCountlyStore).clear();
    //    assertNotNull(mCountly.getConnectionQueue());
    //    assertNull(mCountly.getConnectionQueue().getContext());
    //    assertNull(mCountly.getConnectionQueue().baseInfoProvider);
    //    assertNull(mCountly.getConnectionQueue().getStorageProvider());
    //    assertNotNull(mCountly.getTimerService());
    //    Assert.assertFalse(mCountly.isInitialized());
    //    assertEquals(0, mCountly.getActivityCount());
    //
    //    assertNull(mCountly.moduleSessions);
    //    assertNull(mCountly.moduleCrash);
    //    assertNull(mCountly.moduleEvents);
    //    assertNull(mCountly.moduleRatings);
    //    assertNull(mCountly.moduleViews);
    //    assertEquals(0, mCountly.modules.size());
    //}
    @Test
    public void testOnStart_initNotCalled() {
        try {
            mUninitedCountly.onStart(null);
            // success!
            // should not throw a exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected calling onStart before init to throw IllegalStateException");
        }
    }
    @Test
    public void testOnStart_firstCall() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.onStart(null);
        assertEquals(1, mCountly.getActivityCount());
        final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();
        assertTrue(prevSessionDurationStartTime > 0);
        assertTrue(prevSessionDurationStartTime <= System.currentTimeMillis());
        TestUtils.verifyBeginSessionValues(requestQueueProvider, false, null, null, null, null);
    }
    @Test
    public void testOnStart_subsequentCall() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.onStart(null); // first call to onStart
        final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();
        mCountly.onStart(null); // second call to onStart
        assertEquals(2, mCountly.getActivityCount());
        assertEquals(prevSessionDurationStartTime, mCountly.getPrevSessionDurationStartTime());
        TestUtils.verifyBeginSessionValues(requestQueueProvider, false, null, null, null, null);
    }
    @Test
    public void testOnStop_initNotCalled() {
        try {
            mUninitedCountly.onStop();
            // success!
            // call should not throw exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected calling onStop before init to throw IllegalStateException");
        }
    }
    @Test
    public void testOnStop_unbalanced() {
        try {
            mCountly.onStop();
            // success!
            // call should not throw exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected calling onStop before init to throw IllegalStateException");
        }
    }
    @Test
    public void testOnStop_reallyStopping_emptyEventQueue() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.onStart(null);
        mCountly.onStop();
        assertEquals(0, mCountly.getActivityCount());
        assertTrue(mCountly.getPrevSessionDurationStartTime() > 0);
        verify(requestQueueProvider).endSession(0);
        verify(requestQueueProvider, times(1)).recordEvents(anyString()); // not 0 anymore, it will send orientation event
    }
    /**
     * Start and stop an activity.
     * Make sure that the session is stopped correctly.
     * Verify that the stored events are added to the request queue
     */
    @Test
    public void testOnStop_reallyStopping_nonEmptyEventQueue() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);
        StorageProvider sp = mock(StorageProvider.class);
        TestUtils.setStorageProviderToMock(mCountly, sp);
        when(sp.getEventQueueSize()).thenReturn(1);
        final String eventStr = "blahblahblahblah";
        when(sp.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventStr);
        mCountly.onStart(null);
        mCountly.onStop();
        assertEquals(0, mCountly.getActivityCount());
        assertTrue(mCountly.getPrevSessionDurationStartTime() > 0);
        verify(requestQueueProvider).endSession(0);
        verify(requestQueueProvider).recordEvents(eventStr);
    }
    @Test
    public void testOnStop_notStopping() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.onStart(null);
        mCountly.onStart(null);
        final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();
        mCountly.onStop();
        assertEquals(1, mCountly.getActivityCount());
        assertEquals(prevSessionDurationStartTime, mCountly.getPrevSessionDurationStartTime());
        verify(requestQueueProvider, times(0)).endSession(anyInt());
        verify(requestQueueProvider, times(0)).recordEvents(anyString());
    }
    /**
     * There are no events in the event queue.
     * Make sure that no event requests is created when 'sendEventsIfNeeded' is called.
     */
    @Test
    public void testSendEventsIfNeeded_emptyQueue() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.moduleEvents.storageProvider = mock(StorageProvider.class);
        when(mCountly.moduleEvents.storageProvider.getEventQueueSize()).thenReturn(0);
        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);
        verify(mCountly.moduleEvents.storageProvider, times(0)).getEventsForRequestAndEmptyEventQueue();
        verifyZeroInteractions(requestQueueProvider);
    }
    /**
     * There are some events in the event queue, but they are less than the threshold.
     * Make sure that no event requests is created when 'sendEventsIfNeeded' is called.
     */
    @Test
    public void testSendEventsIfNeeded_lessThanThreshold() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.moduleEvents.storageProvider = mock(StorageProvider.class);
        when(mCountly.moduleEvents.storageProvider.getEventQueueSize()).thenReturn(9);
        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);
        verify(mCountly.moduleEvents.storageProvider, times(0)).getEventsForRequestAndEmptyEventQueue();
        verifyZeroInteractions(requestQueueProvider);
    }
    @Test
    public void testSendEventsIfNeeded_equalToThreshold() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(100);
        final String eventData = "blahblahblah";
        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);
        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);
        verify(mCountly.config_.storageProvider, times(1)).getEventsForRequestAndEmptyEventQueue();
        verify(requestQueueProvider, times(1)).recordEvents(eventData);
    }
    @Test
    public void testSendEventsIfNeeded_moreThanThreshold() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(120);
        final String eventData = "blahblahblah";
        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);
        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);
        verify(mCountly.config_.storageProvider, times(1)).getEventsForRequestAndEmptyEventQueue();
        verify(requestQueueProvider, times(1)).recordEvents(eventData);
    }
    @Test
    public void testOnTimer_noActiveSession() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);
        mCountly.onTimer();
        verify(requestQueueProvider).tick();
    }
    @Test
    public void testOnTimer_activeSession_emptyEventQueue() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(0);
        mCountly.onStart(null);
        mCountly.onTimer();
        verify(requestQueueProvider).updateSession(0);
        verify(requestQueueProvider, times(1)).recordEvents(anyString()); // not 0 anymore, it will send orientation event
    }
    @Test
    public void testOnTimer_activeSession_nonEmptyEventQueue() {
        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(1);
        final String eventData = "blahblahblah";
        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);
        mCountly.onStart(null);
        mCountly.onTimer();
        verify(requestQueueProvider).updateSession(0);
        verify(requestQueueProvider).recordEvents(eventData);
    }
    @Test
    public void testRoundedSecondsSinceLastSessionDurationUpdate() {
        long prevSessionDurationStartTime = System.currentTimeMillis() - 1000;
        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);
        assertEquals(1, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());
        prevSessionDurationStartTime = System.currentTimeMillis() - 2000;
        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);
        assertEquals(2, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());
        prevSessionDurationStartTime = System.currentTimeMillis() - 1600;
        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);
        assertEquals(2, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());
        prevSessionDurationStartTime = System.currentTimeMillis() - 1200;
        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);
        assertEquals(1, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());
    }
    @Test
    public void testIsValidURL_badURLs() {
        assertFalse(UtilsNetworking.isValidURL(null));
        assertFalse(UtilsNetworking.isValidURL(""));
        assertFalse(UtilsNetworking.isValidURL(" "));
        assertFalse(UtilsNetworking.isValidURL("blahblahblah.com"));
    }
    @Test
    public void testIsValidURL_goodURL() {
        assertTrue(UtilsNetworking.isValidURL("http://test.count.ly"));
    }
    @Test
    public void testCurrentTimestamp() {
        final int testTimestamp = (int) (System.currentTimeMillis() / 1000L);
        final int actualTimestamp = UtilsTime.currentTimestampSeconds();
        assertTrue(((testTimestamp - 1) <= actualTimestamp) && ((testTimestamp + 1) >= actualTimestamp));
    }
    @Test
    public void testLoggingFlag() {
        assertFalse(mUninitedCountly.isLoggingEnabled());
        mUninitedCountly.setLoggingEnabled(true);
        assertTrue(mUninitedCountly.isLoggingEnabled());
        mUninitedCountly.setLoggingEnabled(false);
        assertFalse(mUninitedCountly.isLoggingEnabled());
    }
    /*
    //todo fix these
    @Test
    public void testOnTimer_activeSession_emptyEventQueue_sessionTimeUpdatesDisabled() {
        final ConnectionQueue mockConnectionQueue = mock(ConnectionQueue.class);
        mCountly.setConnectionQueue(mockConnectionQueue);
        mCountly.setDisableUpdateSessionRequests(true);
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(0);
        mCountly.onStart(null);
        mCountly.onTimer();
        verify(mockConnectionQueue, times(0)).updateSession(anyInt());
        verify(mockConnectionQueue, times(0)).recordEvents(anyString());
    }
    @Test
    public void testOnTimer_activeSession_nonEmptyEventQueue_sessionTimeUpdatesDisabled() {
        final ConnectionQueue mockConnectionQueue = mock(ConnectionQueue.class);
        mCountly.setConnectionQueue(mockConnectionQueue);
        mCountly.setDisableUpdateSessionRequests(true);
        mCountly.config_.storageProvider = mock(StorageProvider.class);
        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(1);
        final String eventData = "blahblahblah";
        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);
        mCountly.onStart(null);
        mCountly.onTimer();
        verify(mockConnectionQueue, times(0)).updateSession(anyInt());
        verify(mockConnectionQueue).recordEvents(eventData);
    }
    @Test
    public void testSetDisableUpdateSessionRequests() {
        assertFalse(mCountly.getDisableUpdateSessionRequests());
        mCountly.setDisableUpdateSessionRequests(true);
        assertTrue(mCountly.getDisableUpdateSessionRequests());
        mCountly.setDisableUpdateSessionRequests(false);
        assertFalse(mCountly.getDisableUpdateSessionRequests());
    }
    */
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;
import ly.count.android.sdk.messaging.ModulePush;
public class ModuleEvents extends ModuleBase implements EventProvider {
    static final Map<String, Event> timedEvents = new HashMap<>();
    final static String ACTION_EVENT_KEY = "[CLY]_action";
    final static String VISIBILITY_KEY = "cly_v";
    final static String PREVIOUS_EVENT_NAME_KEY = "cly_pen";
    final static String PREVIOUS_VIEW_NAME_KEY = "cly_pvn";
    final static String CURRENT_VIEW_NAME_KEY = "cly_cvn";
    //interface for SDK users
    final Events eventsInterface;
    //used for tracking recorded custom event ID's. This is not updated when internal events are recorded
    String previousEventId = "";
    String previousEventName = "";
    EventQueueProvider eventQueueProvider;
    ViewIdProvider viewIdProvider;
    SafeIDGenerator safeEventIDGenerator;
    private final boolean viewNameRecordingEnabled;
    private final boolean visibilityTracking;
    ModuleEvents(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleEvents] Initialising");
        eventProvider = this;
        config.eventProvider = this;
        eventQueueProvider = config.eventQueueProvider;
        safeEventIDGenerator = config.safeEventIDGenerator;
        viewNameRecordingEnabled = config.experimental.viewNameRecordingEnabled;
        visibilityTracking = config.experimental.visibilityTrackingEnabled;
        eventsInterface = new Events();
    }
    void checkCachedPushData(CountlyStore cs) {
        L.d("[ModuleEvents] Starting cache call");
        String[] cachedData = cs.getCachedPushData();
        if (cachedData != null && cachedData[0] != null && cachedData[1] != null) {
            //found valid data cached, record it
            L.d("[ModuleEvents] Found cached push event, recording it");
            Map<String, Object> map = new HashMap<>();
            map.put(ModulePush.PUSH_EVENT_ACTION_PLATFORM_KEY, ModulePush.PUSH_EVENT_ACTION_PLATFORM_VALUE);
            map.put(ModulePush.PUSH_EVENT_ACTION_ID_KEY, cachedData[0]);
            map.put(ModulePush.PUSH_EVENT_ACTION_INDEX_KEY, cachedData[1]);
            recordEventInternal(ModulePush.PUSH_EVENT_ACTION, map, 1, 0, 0, null, null);
        }
        if (cachedData != null && (cachedData[0] != null || cachedData[1] != null)) {
            //if something was recorded, clear it
            cs.clearCachedPushData();
        }
    }
    /**
     * @param key
     * @param segmentation
     * @param count
     * @param sum
     * @param dur
     * @param instant
     * @param eventIdOverride
     */
    public void recordEventInternal(@Nullable final String key, @Nullable Map<String, Object> segmentation, int count, final double sum, final double dur, UtilsTime.Instant instant, final String eventIdOverride) {
        //assert key != null;
        assert count >= 1;
        assert _cly.isInitialized();
        long pccTsStartRecordEventInternal = 0L;
        if (pcc != null) {
            pccTsStartRecordEventInternal = UtilsTime.getNanoTime();
        }
        L.v("[ModuleEvents] calling 'recordEventInternal'");
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] recordEventInternal, Valid Countly event key is required. Event will be ignored.");
            return;
        }
        if (count < 1) {
            L.e("[ModuleEvents] recordEventInternal, event count should be greater than zero. Key:[" + key + "] count:[" + count + "]");
            count = 1;
        }
        L.d("[ModuleEvents] recordEventInternal, key:[" + key + "] eventIdOverride:[" + eventIdOverride + "] segmentation:[" + segmentation + "] count:[" + count + "] sum:[" + sum + "] dur:[" + dur + "] instant:[" + instant + "]");
        if (segmentation != null) {
            UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);
        }
        //record the current event timestamps
        //if a past event is recorded, instant value will not be null
        if (instant == null) {
            instant = UtilsTime.getCurrentInstant();
        }
        String eventId;
        if (eventIdOverride == null) { // if eventIdOverride not provided generate an event ID
            eventId = safeEventIDGenerator.GenerateValue();
        } else if (eventIdOverride.length() == 0) {
            L.w("[ModuleEvents] provided event ID override value is empty. Will generate a new one.");
            eventId = safeEventIDGenerator.GenerateValue();
        } else { // if eventIdOverride is provided use it the event ID
            eventId = eventIdOverride;
        }
        final long timestamp = instant.timestampMs;
        final int hour = instant.hour;
        final int dow = instant.dow;
        String pvid = null; // Previous View ID
        String cvid = null; // Current View ID
        String pvn = null;
        String pen = null;
        String cvn = null;
        if (key.equals(ModuleViews.VIEW_EVENT_KEY)) {
            pvid = viewIdProvider.getPreviousViewId();
            if (viewNameRecordingEnabled) {
                pvn = _cly.moduleViews.previousViewName;
                if (pvn == null) {
                    pvn = "";
                }
            }
        } else {
            cvid = viewIdProvider.getCurrentViewId();
            if (viewNameRecordingEnabled) {
                pen = previousEventName;
                cvn = _cly.moduleViews.currentViewName;
                if (pen == null) {
                    pen = "";
                }
                if (cvn == null) {
                    cvn = "";
                }
            }
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternalGenID", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);
        }
        //before each event is recorded, check if user profile data needs to be saved
        _cly.moduleUserProfile.saveInternal();
        if (visibilityTracking) {
            if (segmentation == null) {
                segmentation = new HashMap<>();
            }
            if (ModuleViews.VIEW_EVENT_KEY.equals(key) && !segmentation.containsKey("visit")) {
                L.d("[ModuleEvents] recordEventInternal, visibility key will not be added to the end view event");
            } else {
                String appInBackground = deviceInfo.isInBackground();
                int state = 1; // in foreground
                if ("true".equals(appInBackground)) {
                    state = 0; // in background
                }
                L.d("[ModuleEvents] recordEventInternal, Adding visibility tracking to segmentation app in background:[" + appInBackground + "] cly_v:[" + state + "]");
                segmentation.put(VISIBILITY_KEY, state);
            }
        }
        switch (key) {
            case ModuleFeedback.NPS_EVENT_KEY:
            case ModuleFeedback.SURVEY_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);
                }
                break;
            case ModuleFeedback.RATING_EVENT_KEY: //these events can be reported from a lot of sources, therefore multiple consents could apply
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating) || consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModuleViews.VIEW_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {
                    if (segmentation == null) {
                        segmentation = new HashMap<>();
                    }
                    if (viewNameRecordingEnabled) {
                        segmentation.put(PREVIOUS_VIEW_NAME_KEY, pvn);
                    }
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModuleViews.ORIENTATION_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModulePush.PUSH_EVENT_ACTION:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.push)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);
                }
                break;
            case ACTION_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.clicks) || consentProvider.getConsent(Countly.CountlyFeatureNames.scrolls)) {
                    if (segmentation != null) {
                        UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);
                    }
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            default:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {
                    String keyTruncated = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleEvents] recordEventInternal");
                    if (segmentation == null) {
                        segmentation = new HashMap<>();
                    }
                    UtilsInternalLimits.applySdkInternalLimitsToSegmentation(segmentation, _cly.config_.sdkInternalLimits, L, "[ModuleEvents] recordEventInternal");
                    if (viewNameRecordingEnabled) {
                        segmentation.put(CURRENT_VIEW_NAME_KEY, cvn);
                        segmentation.put(PREVIOUS_EVENT_NAME_KEY, pen);
                    }
                    eventQueueProvider.recordEventToEventQueue(keyTruncated, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, previousEventId);
                    previousEventId = eventId;
                    previousEventName = keyTruncated;
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternal", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);
        }
    }
    boolean startEventInternal(final String key) {
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't start event with a null or empty key");
            return false;
        }
        if (timedEvents.containsKey(key)) {
            return false;
        }
        L.d("[ModuleEvents] Starting event: [" + key + "]");
        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();
        timedEvents.put(key, new Event(key, instant.timestampMs, instant.hour, instant.dow));
        return true;
    }
    boolean endEventInternal(@Nullable final String key, @Nullable final Map<String, Object> segmentation, int count, final double sum) {
        L.d("[ModuleEvents] Ending event: [" + key + "]");
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't end event with a null or empty key");
            return false;
        }
        Event event = timedEvents.remove(key);
        if (event != null) {
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {
                return true;
            }
            if (count < 1) {
                L.e("[ModuleEvents] endEventInternal, event count should be greater than zero, key [" + key + "], dur:[" + count + "]. Count will be reset to '1'.");
                count = 1;
            }
            L.d("[ModuleEvents] Ending event: [" + key + "]");
            long currentTimestamp = UtilsTime.currentTimestampMs();
            double duration = (currentTimestamp - event.timestamp) / 1000.0;
            UtilsTime.Instant instant = new UtilsTime.Instant(event.timestamp, event.hour, event.dow);
            eventProvider.recordEventInternal(key, segmentation, count, sum, duration, instant, null);
            return true;
        } else {
            return false;
        }
    }
    boolean cancelEventInternal(final String key) {
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't cancel event with a null or empty key");
            return false;
        }
        Event event = timedEvents.remove(key);
        return event != null;
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        checkCachedPushData(_cly.countlyStore);
    }
    @Override
    void halt() {
        timedEvents.clear();
    }
    public class Events {
        /**
         * Record a event with a custom timestamp.
         * Use this in case you want to record events that you have tracked
         * and stored internally
         *
         * @param key event key
         * @param segmentation custom segmentation you want to set, leave null if you don't want to add anything
         * @param timestamp unix timestamp in milliseconds of when the event occurred
         */
        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, long timestamp) {
            synchronized (_cly) {
                recordPastEvent(key, segmentation, 1, 0, 0, timestamp);
            }
        }
        /**
         * Record a event with a custom timestamp.
         * Use this in case you want to record events that you have tracked
         * and stored internally
         *
         * @param key event key
         * @param segmentation custom segmentation you want to set, leave null if you don't want to add anything
         * @param count how many of these events have occurred, default value is "1"
         * @param sum set sum if needed, default value is "0"
         * @param dur duration of the event, default value is "0"
         * @param timestamp unix timestamp in milliseconds of when the event occurred
         */
        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur, long timestamp) {
            synchronized (_cly) {
                L.i("[Events] Calling recordPastEvent: [" + key + "]");
                if (timestamp <= 0) {
                    L.e("Provided timestamp has to be greater that zero. Replacing that timestamp with the current time");
                    timestamp = UtilsTime.currentTimestampMs();
                }
                UtilsTime.Instant instant = UtilsTime.Instant.get(timestamp);
                recordEventInternal(key, segmentation, count, sum, dur, instant, null);
            }
        }
        /**
         * Start timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string or null
         * @return true if no event with this key existed before and event is started, false otherwise
         */
        public boolean startEvent(@NonNull final String key) {
            synchronized (_cly) {
                L.i("[Events] Calling startEvent: [" + key + "]");
                return startEventInternal(key);
            }
        }
        /**
         * End timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string or null
         * @return true if event with this key has been previously started, false otherwise
         */
        public boolean endEvent(@NonNull final String key) {
            synchronized (_cly) {
                return endEvent(key, null, 1, 0);
            }
        }
        /**
         * End timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null
         * @param count count to associate with the event, should be more than zero, default value is 1
         * @param sum sum to associate with the event, default value is 0
         * @return true if event with this key has been previously started, false otherwise
         */
        public boolean endEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {
            synchronized (_cly) {
                L.i("[Events] Calling endEvent: [" + key + "]");
                return endEventInternal(key, segmentation, count, sum);
            }
        }
        /**
         * Cancel timed event with a specified key
         *
         * @return true if event with this key has been previously started, false otherwise
         **/
        public boolean cancelEvent(@NonNull final String key) {
            synchronized (_cly) {
                L.i("[Events] Calling cancelEvent: [" + key + "]");
                return cancelEventInternal(key);
            }
        }
        /**
         * Records a custom event with no segmentation values, a count of one and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         */
        public void recordEvent(@NonNull final String key) {
            synchronized (_cly) {
                recordEvent(key, null, 1, 0);
            }
        }
        /**
         * Records a custom event with no segmentation values, the specified count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param count count to associate with the event, should be more than zero
         */
        public void recordEvent(@NonNull final String key, final int count) {
            synchronized (_cly) {
                recordEvent(key, null, count, 0);
            }
        }
        /**
         * Records a custom event with no segmentation values, and the specified count and sum.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         */
        public void recordEvent(@NonNull final String key, final int count, final double sum) {
            synchronized (_cly) {
                recordEvent(key, null, count, sum);
            }
        }
        /**
         * Records a custom event with the specified segmentation values and count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation) {
            synchronized (_cly) {
                recordEvent(key, segmentation, 1, 0);
            }
        }
        /**
         * Records a custom event with the specified segmentation values and count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         * @param count count to associate with the event, should be more than zero
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count) {
            synchronized (_cly) {
                recordEvent(key, segmentation, count, 0);
            }
        }
        /**
         * Records a custom event with the specified values.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {
            synchronized (_cly) {
                recordEvent(key, segmentation, count, sum, 0);
            }
        }
        /**
         * Records a custom event with the specified values.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         * @param dur duration of an event
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur) {
            synchronized (_cly) {
                L.i("[Events] Calling recordEvent: [" + key + "]");
                if (segmentation != null) {
                    UtilsInternalLimits.truncateSegmentationValues(segmentation, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[Events] recordEvent,", L);
                }
                eventProvider.recordEventInternal(key, segmentation, count, sum, dur, null, null);
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import org.json.JSONException;
import org.json.JSONObject;
class ModuleConfiguration extends ModuleBase implements ConfigurationProvider {
    ImmediateRequestGenerator immediateRequestGenerator;
    boolean serverConfigEnabled = false;
    JSONObject latestRetrievedConfigurationFull = null;
    JSONObject latestRetrievedConfiguration = null;
    //config keys
    final static String keyTracking = "tracking";
    final static String keyNetworking = "networking";
    //request keys
    final static String keyRTimestamp = "t";
    final static String keyRVersion = "v";
    final static String keyRConfig = "c";
    final static boolean defaultVTracking = true;
    final static boolean defaultVNetworking = true;
    boolean currentVTracking = true;
    boolean currentVNetworking = true;
    boolean configurationFetched = false;
    ModuleConfiguration(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleConfiguration] Initialising");
        config.configProvider = this;
        configProvider = this;
        serverConfigEnabled = config.serverConfigurationEnabled;
        immediateRequestGenerator = config.immediateRequestGenerator;
        config.countlyStore.setConfigurationProvider(this);
        if (serverConfigEnabled) {
            //load the previously saved configuration
            loadConfigFromStorage();
            //update the config variables according to the new state
            updateConfigVariables();
        }
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (serverConfigEnabled) {
            //once the SDK has loaded, init fetching the server config
            fetchConfigFromServer();
        }
    }
    @Override
    void halt() {
    }
    /**
     * Reads from storage to local json objects
     */
    void loadConfigFromStorage() {
        String sConfig = storageProvider.getServerConfig();
        L.v("[ModuleConfiguration] loadConfigFromStorage, [" + sConfig + "]");
        if (sConfig == null || sConfig.isEmpty()) {
            L.d("[ModuleConfiguration] loadStoredConfig, no configs persistently stored");
            return;
        }
        try {
            latestRetrievedConfigurationFull = new JSONObject(sConfig);
            latestRetrievedConfiguration = latestRetrievedConfigurationFull.getJSONObject(keyRConfig);
            L.d("[ModuleConfiguration] loadStoredConfig, stored config loaded [" + sConfig + "]");
        } catch (JSONException e) {
            L.w("[ModuleConfiguration] loadStoredConfig, failed to parse, " + e);
            latestRetrievedConfigurationFull = null;
            latestRetrievedConfiguration = null;
        }
    }
    //update the config variables according to the current config obj state
    void updateConfigVariables() {
        L.v("[ModuleConfiguration] updateConfigVariables");
        //set all to defaults
        currentVNetworking = defaultVNetworking;
        currentVTracking = defaultVTracking;
        if (latestRetrievedConfiguration == null) {
            //no config, don't continue
            return;
        }
        //networking
        if (latestRetrievedConfiguration.has(keyNetworking)) {
            try {
                currentVNetworking = latestRetrievedConfiguration.getBoolean(keyNetworking);
            } catch (JSONException e) {
                L.w("[ModuleConfiguration] updateConfigs, failed to load 'networking', " + e);
            }
        }
        //tracking
        if (latestRetrievedConfiguration.has(keyTracking)) {
            try {
                currentVTracking = latestRetrievedConfiguration.getBoolean(keyTracking);
            } catch (JSONException e) {
                L.w("[ModuleConfiguration] updateConfigs, failed to load 'tracking', " + e);
            }
        }
    }
    void saveAndStoreDownloadedConfig(@NonNull JSONObject config) {
        L.v("[ModuleConfiguration] saveAndStoreDownloadedConfig");
        if (!config.has(keyRVersion)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'version' field. Config will be ignored.");
            return;
        }
        if (!config.has(keyRTimestamp)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'timestamp' field. Config will be ignored.");
            return;
        }
        if (!config.has(keyRConfig)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'configuration' field. Config will be ignored.");
            return;
        }
        //at this point it is a valid response
        latestRetrievedConfigurationFull = config;
        String configAsString = null;
        try {
            latestRetrievedConfiguration = config.getJSONObject(keyRConfig);
            configAsString = config.toString();
        } catch (JSONException e) {
            latestRetrievedConfigurationFull = null;
            latestRetrievedConfiguration = null;
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Failed retrieving internal config, " + e);
            return;
        }
        //save to storage
        storageProvider.setServerConfig(configAsString);
        //update config variables
        updateConfigVariables();
    }
    /**
     * Perform network request for retrieving latest config
     * If valid config is downloaded, save it, and update the values
     *
     * Example response:
     * {
     * "v":1,
     * "t":1681808287464,
     * "c":{
     * "tracking":false,
     * "networking":false,
     * "crashes":false,
     * "views":false,
     * "heartbeat":61,
     * "event_queue":11,
     * "request_queue":1001
     * }
     * }
     */
    void fetchConfigFromServer() {
        L.v("[ModuleConfiguration] fetchConfigFromServer");
        if (!serverConfigEnabled) {
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, server config is disabled");
            return;
        }
        // why _cly? because module configuration is created before module device id, so we need to access it like this
        // call order to module device id is after module configuration and device id provider is module device id
        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {
            //temporary id mode enabled, abort
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, temporary device ID mode is set");
            return;
        }
        if (configurationFetched) {
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, config already fetched");
            return;
        }
        configurationFetched = true;
        String requestData = requestQueueProvider.prepareServerConfigRequest();
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, true, checkResponse -> {
            if (checkResponse == null) {
                L.w("[ModuleConfiguration] Not possible to retrieve configuration data. Probably due to lack of connection to the server");
                return;
            }
            L.d("[ModuleConfiguration] Retrieved configuration response: [" + checkResponse.toString() + "]");
            saveAndStoreDownloadedConfig(checkResponse);
        }, L);
    }
    // configuration getters
    @Override
    public boolean getNetworkingEnabled() {
        if (!serverConfigEnabled) {
            return defaultVNetworking;
        }
        return currentVNetworking;
    }
    @Override
    public boolean getTrackingEnabled() {
        if (!serverConfigEnabled) {
            return defaultVTracking;
        }
        return currentVTracking;
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
interface StorageProvider {
    String[] getRequests();
    String[] getEvents();
    List<Event> getEventList();
    @NonNull String getRequestQueueRaw();
    void addRequest(final String requestStr, final boolean writeInSync);
    void removeRequest(final String requestStr);
    void replaceRequests(final String[] newConns);
    void replaceRequestList(final List<String> newConns);
    void removeEvents(final List<Event> eventsToRemove);
    int getEventQueueSize();
    String getEventsForRequestAndEmptyEventQueue();
    @Nullable String getDeviceID();
    @Nullable String getDeviceIDType();
    void setDeviceID(String id);
    void setDeviceIDType(String type);
    void setStarRatingPreferences(String preferences);//not integrated
    String getStarRatingPreferences();//not integrated
    void setCachedAdvertisingId(String advertisingId);//not integrated
    String getCachedAdvertisingId();//not integrated
    void setRemoteConfigValues(String values);//not integrated
    String getRemoteConfigValues();//not integrated
    void esWriteCacheToStorage(@Nullable ExplicitStorageCallback callback);//required for explicit storage
    void setServerConfig(String config);
    String getServerConfig();
    //fields for data migration
    int getDataSchemaVersion();
    void setDataSchemaVersion(int version);
    boolean anythingSetInStorage();
    @NonNull String getHealthCheckCounterState();
    void setHealthCheckCounterState(String counterState);
}
package ly.count.android.sdk;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Looper;
import android.webkit.WebSettings;
import android.webkit.WebView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleFeedback extends ModuleBase {
    public enum FeedbackWidgetType {survey, nps, rating}
    public static class CountlyFeedbackWidget {
        public String widgetId;
        public FeedbackWidgetType type;
        public String name;
        public String[] tags;
    }
    final static String NPS_EVENT_KEY = "[CLY]_nps";
    final static String SURVEY_EVENT_KEY = "[CLY]_survey";
    final static String RATING_EVENT_KEY = "[CLY]_star_rating";
    final String cachedAppVersion;
    Feedback feedbackInterface = null;
    ModuleFeedback(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleFeedback] Initialising");
        cachedAppVersion = deviceInfo.mp.getAppVersion(config.context);
        feedbackInterface = new Feedback();
    }
    public interface RetrieveFeedbackWidgets {
        void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error);
    }
    public interface RetrieveFeedbackWidgetData {
        void onFinished(JSONObject retrievedWidgetData, String error);
    }
    public interface FeedbackCallback {
        void onClosed();
        void onFinished(String error);
    }
    void getAvailableFeedbackWidgetsInternal(final RetrieveFeedbackWidgets devCallback) {
        L.d("[ModuleFeedback] calling 'getAvailableFeedbackWidgetsInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved without a callback");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            return;
        }
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestData = requestQueueProvider.prepareFeedbackListRequest();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved request: [" + checkResponse.toString() + "]");
                List<CountlyFeedbackWidget> feedbackEntries = parseFeedbackList(checkResponse);
                devCallback.onFinished(feedbackEntries, null);
            }
        }, L);
    }
    static List<CountlyFeedbackWidget> parseFeedbackList(JSONObject requestResponse) {
        Countly.sharedInstance().L.d("[ModuleFeedback] calling 'parseFeedbackList'");
        List<CountlyFeedbackWidget> parsedRes = new ArrayList<>();
        try {
            if (requestResponse != null) {
                JSONArray jArray = requestResponse.optJSONArray("result");
                if (jArray == null) {
                    Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, response does not have a valid 'result' entry. No widgets retrieved.");
                    return parsedRes;
                }
                for (int a = 0; a < jArray.length(); a++) {
                    try {
                        JSONObject jObj = jArray.getJSONObject(a);
                        String valId = jObj.optString("_id", "");
                        String valType = jObj.optString("type", "");
                        String valName = jObj.optString("name", "");
                        List<String> valTagsArr = new ArrayList<String>();
                        JSONArray jTagArr = jObj.optJSONArray("tg");
                        if (jTagArr == null) {
                            Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, no tags received");
                        } else {
                            for (int in = 0; in < jTagArr.length(); in++) {
                                valTagsArr.add(jTagArr.getString(in));
                            }
                        }
                        if (valId.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget id, dropping");
                            continue;
                        }
                        if (valType.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget type, dropping");
                            continue;
                        }
                        FeedbackWidgetType plannedType;
                        if (valType.equals("survey")) {
                            plannedType = FeedbackWidgetType.survey;
                        } else if (valType.equals("nps")) {
                            plannedType = FeedbackWidgetType.nps;
                        } else if (valType.equals("rating")) {
                            plannedType = FeedbackWidgetType.rating;
                        } else {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved unknown widget type, dropping");
                            continue;
                        }
                        CountlyFeedbackWidget se = new CountlyFeedbackWidget();
                        se.type = plannedType;
                        se.widgetId = valId;
                        se.name = valName;
                        se.tags = valTagsArr.toArray(new String[0]);
                        parsedRes.add(se);
                    } catch (Exception ex) {
                        Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, failed to parse json, [" + ex.toString() + "]");
                    }
                }
            }
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, Encountered exception while parsing feedback list, [" + ex.toString() + "]");
        }
        return parsedRes;
    }
    void presentFeedbackWidgetInternal(@Nullable final CountlyFeedbackWidget widgetInfo, @Nullable final Context context, @Nullable final String closeButtonText, @Nullable final FeedbackCallback devCallback) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't present widget with null widget info");
            if (devCallback != null) {
                devCallback.onFinished("Can't present widget with null widget info");
            }
            return;
        }
        L.d("[ModuleFeedback] presentFeedbackWidgetInternal, callback set:[" + (devCallback != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "]");
        if (context == null) {
            L.e("[ModuleFeedback] Can't show feedback, provided context is null");
            if (devCallback != null) {
                devCallback.onFinished("Can't show feedback, provided context is null");
            }
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            if (devCallback != null) {
                devCallback.onFinished("Consent is not granted");
            }
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            if (devCallback != null) {
                devCallback.onFinished("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            }
            return;
        }
        StringBuilder widgetListUrl = new StringBuilder();
        switch (widgetInfo.type) {
            case survey:
                //'/o/feedback/nps/widget?widget_ids=' + nps[0]._id
                //https://xxxx.count.ly/feedback/nps?widget_id=5f8445c4eecf2a6de4dcb53e
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/survey?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case nps:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/nps?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case rating:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/rating?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
        }
        widgetListUrl.append("&device_id=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()));
        widgetListUrl.append("&app_key=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey()));
        widgetListUrl.append("&sdk_version=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        widgetListUrl.append("&sdk_name=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        widgetListUrl.append("&platform=android");
        // TODO: this will be the base for the custom segmentation users can send while presenting a widget
        JSONObject customObjectToSendWithTheWidget = new JSONObject();
        try {
            customObjectToSendWithTheWidget.put("tc", 1);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        widgetListUrl.append("&custom=");
        widgetListUrl.append(customObjectToSendWithTheWidget.toString());
        final String preparedWidgetUrl = widgetListUrl.toString();
        L.d("[ModuleFeedback] Using following url for widget:[" + widgetListUrl + "]");
        //enable for chrome debugging
        //WebView.setWebContentsDebuggingEnabled(true);
        final boolean useAlertDialog = true;
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            public void run() {
                L.d("[ModuleFeedback] Calling on main thread");
                try {
                    ModuleRatings.RatingDialogWebView webView = new ModuleRatings.RatingDialogWebView(context);
                    webView.getSettings().setJavaScriptEnabled(true);
                    webView.clearCache(true);
                    webView.clearHistory();
                    webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                    webView.setWebViewClient(new ModuleRatings.FeedbackDialogWebViewClient());
                    webView.loadUrl(preparedWidgetUrl);
                    webView.requestFocus();
                    AlertDialog.Builder builder = prepareAlertDialog(context, webView, closeButtonText, widgetInfo, devCallback);
                    if (useAlertDialog) {
                        // use alert dialog to host the webView
                        L.d("[ModuleFeedback] Creating standalone Alert dialog");
                        builder.show();
                    } else {
                        // use dialog fragment to host the webView
                        L.d("[ModuleFeedback] Creating Alert dialog in dialogFragment");
                        //CountlyDialogFragment newFragment = CountlyDialogFragment.newInstance(builder);
                        //newFragment.show(fragmentManager, "CountlyFragmentDialog");
                    }
                    if (devCallback != null) {
                        devCallback.onFinished(null);
                    }
                } catch (Exception ex) {
                    L.e("[ModuleFeedback] Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    if (devCallback != null) {
                        devCallback.onFinished("Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    }
                }
            }
        });
    }
    AlertDialog.Builder prepareAlertDialog(@NonNull final Context context, @NonNull WebView webView, @Nullable String closeButtonText, @NonNull final CountlyFeedbackWidget widgetInfo, @Nullable final FeedbackCallback devCallback) {
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setView(webView);
        builder.setCancelable(false);
        String usedCloseButtonText = closeButtonText;
        if (closeButtonText == null || closeButtonText.isEmpty()) {
            usedCloseButtonText = "Close";
        }
        builder.setNeutralButton(usedCloseButtonText, new DialogInterface.OnClickListener() {
            @Override public void onClick(DialogInterface dialogInterface, int i) {
                L.d("[ModuleFeedback] Cancel button clicked for the feedback widget");
                reportFeedbackWidgetCancelButton(widgetInfo, deviceInfo.mp.getAppVersion(context));
                if (devCallback != null) {
                    devCallback.onClosed();
                }
            }
        });
        return builder;
    }
    void reportFeedbackWidgetCancelButton(@NonNull CountlyFeedbackWidget widgetInfo, @NonNull String appVersion) {
        L.d("[reportFeedbackWidgetCancelButton] Cancel button event");
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            final Map<String, Object> segm = new HashMap<>();
            segm.put("platform", "android");
            segm.put("app_version", appVersion);
            segm.put("widget_id", "" + widgetInfo.widgetId);
            segm.put("closed", "1");
            final String key;
            if (widgetInfo.type == FeedbackWidgetType.survey) {
                key = SURVEY_EVENT_KEY;
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                key = RATING_EVENT_KEY;
            } else {
                key = NPS_EVENT_KEY;
            }
            eventProvider.recordEventInternal(key, segm, 1, 0, 0, null, null);
        }
    }
    /**
     * Downloads widget info and returns it to the callback
     *
     * @param widgetInfo identifies the specific widget for which you want to download widget data
     * @param devCallback mandatory callback in which the downloaded data will be returned
     */
    void getFeedbackWidgetDataInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable final RetrieveFeedbackWidgetData devCallback) {
        L.d("[ModuleFeedback] calling 'getFeedbackWidgetDataInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved without a callback");
            return;
        }
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Feedback widget data if provided widget is 'null'");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            return;
        }
        StringBuilder requestData = new StringBuilder();
        String widgetDataEndpoint = "";
        switch (widgetInfo.type) {
            case survey:
                //https://xxxx.count.ly/o/surveys/survey/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/survey/widget";
                break;
            case nps:
                //https://xxxx.count.ly/o/surveys/nps/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/nps/widget";
                break;
            case rating:
                widgetDataEndpoint = "/o/surveys/rating/widget";
                break;
        }
        requestData.append("widget_id=");
        requestData.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
        requestData.append("&shown=1");
        requestData.append("&sdk_version=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        requestData.append("&sdk_name=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        requestData.append("&platform=android");
        requestData.append("&app_version=");
        requestData.append(cachedAppVersion);
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestDataStr = requestData.toString();
        L.d("[ModuleFeedback] Using following request params for retrieving widget data:[" + requestDataStr + "]");
        (new ImmediateRequestMaker()).doWork(requestDataStr, widgetDataEndpoint, cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved widget data request: [" + checkResponse.toString() + "]");
                devCallback.onFinished(checkResponse, null);
            }
        }, L);
    }
    /**
     * Report widget info and do data validation
     *
     * @param widgetInfo identifies the specific widget for which the feedback is filled out
     * @param widgetData widget data for this specific widget
     * @param widgetResult segmentation of the filled out feedback. If this segmentation is null, it will be assumed that the survey was closed before completion and mark it appropriately
     */
    void reportFeedbackWidgetManuallyInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't report feedback widget data manually with 'null' widget info");
            return;
        }
        L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetData set:[" + (widgetData != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "], widget result set:[" + (widgetResult != null) + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            L.w("[ModuleFeedback] Can't report feedback widget data, consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] feedback widget result can't be reported when in temporary device ID mode");
            return;
        }
        if (widgetResult != null) {
            //removing broken values first
            UtilsInternalLimits.removeUnsupportedDataTypes(widgetResult, L);
            Iterator<Map.Entry<String, Object>> iter = widgetResult.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, Object> entry = iter.next();
                if (entry.getKey() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getKey().isEmpty()) {
                    L.w("[ModuleFeedback] provided feedback widget result contains an empty string key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getValue() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' value, it will be removed, key[" + entry.getKey() + "]");
                    iter.remove();
                }
                if (entry.getValue() instanceof String) {
                    // TODO, if applicable think about applying key and segmentation count limit for the widget result
                    String truncatedValue = UtilsInternalLimits.truncateValueSize(entry.getValue().toString(), _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleFeedback] reportFeedbackWidgetManuallyInternal");
                    if (!truncatedValue.equals(entry.getValue())) {
                        entry.setValue(truncatedValue);
                    }
                }
            }
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                //in case a nps widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided NPS widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided NPS widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 0 || ratingValI > 10) {
                    L.e("Provided NPS widget 'rating' value is out of bounds of the required value '[0;10]', it is probably an error");
                }
                if (!widgetResult.containsKey("comment")) {
                    L.w("Provided NPS widget result does not have a 'comment' field");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                //in case a survey widget was completed
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                //in case a rating widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided Rating widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided Rating widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 1 || ratingValI > 5) {
                    L.e("Provided Rating widget 'rating' value is out of bounds of the required value '[1;5]', it is probably an error");
                }
            }
        }
        if (widgetData == null) {
            L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetInfo is 'null', no validation will be done");
        } else {
            //perform data validation
            String idInData = widgetData.optString("_id");
            if (!widgetInfo.widgetId.equals(idInData)) {
                L.w("[ModuleFeedback] id in widget info does not match the id in widget data");
            }
            String typeInData = widgetData.optString("type");
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                if (!"nps".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [nps]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                if (!"survey".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [survey]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                if (!"rating".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [rating]");
                }
            }
        }
        final String usedEventKey;
        if (widgetInfo.type == FeedbackWidgetType.nps) {
            usedEventKey = NPS_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9d2e563e892016316339","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570486021,"hour":15,"dow":1}
            //event when answered
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9b24563e89201631631f","platform":"android","app_version":"0.0","rating":10,"comment":"Thanks"},"timestamp":1611570182023,"hour":15,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.survey) {
            usedEventKey = SURVEY_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570709449,"hour":16,"dow":1}
            //event when answered
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","answ-1611570700-0":"ch1611570700-0"},"timestamp":1611570895465,"hour":16,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.rating) {
            usedEventKey = RATING_EVENT_KEY;
            //event when closed
            // {"key":"[CLY]_star_rating","count":1,"timestamp":1671783040088,"hour":11,"dow":5,"segmentation":{"app_version":"1.0","widget_id":"614871419f030e44be07d82f","closed":"1","platform":"android"}
            //event when answered
            //{"key":"[CLY]_star_rating","count":1,"segmentation":{"widget_id":"614871419f030e44be07d82f","contactMe":false,"platform":"android","app_version":"1","platform_version_rate":"","rating":4,"email":"","comment":""}
        } else {
            usedEventKey = "";
        }
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", cachedAppVersion);
        segm.put("widget_id", widgetInfo.widgetId);
        if (widgetResult == null) {
            //mark as closed
            segm.put("closed", "1");
        } else {
            //widget was filled out
            //merge given segmentation
            segm.putAll(widgetResult);
        }
        eventProvider.recordEventInternal(usedEventKey, segm, 1, 0, 0, null, null);
    }
    /**
     * Present a feedback widget based on the provided nameIDorTag, internal function to use
     *
     * @param type the type of the feedback widget to present
     * @param nameIDorTag the widget id, widget name or widget tag of the feedback widget to present
     */
    private void presentFeedbackWidgetNameIDorTag(@NonNull Context context, @NonNull FeedbackWidgetType type, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
        getAvailableFeedbackWidgetsInternal(new RetrieveFeedbackWidgets() {
            @Override public void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error) {
                if (error != null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, Failed to retrieve feedback widget list, [" + error + "]");
                    return;
                }
                if (retrievedWidgets.isEmpty()) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widgets available");
                    return;
                }
                CountlyFeedbackWidget selectedWidget = null;
                for (CountlyFeedbackWidget widget : retrievedWidgets) {
                    if (widget.type == type) {
                        if (!nameIDorTag.isEmpty()) {
                            if (widget.widgetId.equals(nameIDorTag) || widget.name.equals(nameIDorTag)) {
                                selectedWidget = widget;
                                break;
                            }
                            for (String tag : widget.tags) {
                                if (tag.equals(nameIDorTag)) {
                                    selectedWidget = widget;
                                    break;
                                }
                            }
                        } else {
                            selectedWidget = widget;
                            break;
                        }
                    }
                }
                if (selectedWidget == null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widget found with the provided nameIDorTag or type");
                    return;
                }
                presentFeedbackWidgetInternal(selectedWidget, context, null, devCallback);
            }
        });
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
    }
    @Override
    void halt() {
        feedbackInterface = null;
    }
    public class Feedback {
        /**
         * Get a list of available feedback widgets for this device ID
         *
         * @param callback
         */
        public void getAvailableFeedbackWidgets(@Nullable RetrieveFeedbackWidgets callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget list");
                getAvailableFeedbackWidgetsInternal(callback);
            }
        }
        /**
         * Present a chosen feedback widget in an alert dialog
         *
         * @param widgetInfo
         * @param context
         * @param closeButtonText if this is null, no "close" button will be shown
         * @param devCallback
         */
        public void presentFeedbackWidget(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable Context context, @Nullable String closeButtonText, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to present feedback widget in an alert dialog");
                presentFeedbackWidgetInternal(widgetInfo, context, closeButtonText, devCallback);
            }
        }
        /**
         * Download data for a specific widget so that it can be displayed with a custom UI
         * When requesting this data, it will count as a shown widget (will increment that "shown" count in the dashboard)
         *
         * @param widgetInfo
         * @param callback
         */
        public void getFeedbackWidgetData(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable RetrieveFeedbackWidgetData callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget data");
                getFeedbackWidgetDataInternal(widgetInfo, callback);
            }
        }
        /**
         * Manually report a feedback widget in case a custom interface was used
         * In case widgetResult is passed as "null", it would be assumed that the widget was cancelled
         *
         * @param widgetInfo
         * @param widgetData
         * @param widgetResult
         */
        public void reportFeedbackWidgetManually(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to report feedback widget manually");
                reportFeedbackWidgetManuallyInternal(widgetInfo, widgetData, widgetResult);
            }
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag) {
            presentNPS(context, nameIDorTag, null);
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentNPS(@NonNull Context context) {
            presentNPS(context, "");
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag) {
            presentSurvey(context, nameIDorTag, null);
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentSurvey(@NonNull Context context) {
            presentSurvey(context, "");
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag) {
            presentRating(context, nameIDorTag, null);
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentRating(@NonNull Context context) {
            presentRating(context, "");
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentNPS, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.nps, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentSurvey, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.survey, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentRating, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.rating, nameIDorTag, devCallback);
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleUserProfile extends ModuleBase {
    static final String NAME_KEY = "name";
    static final String USERNAME_KEY = "username";
    static final String EMAIL_KEY = "email";
    static final String ORG_KEY = "organization";
    static final String PHONE_KEY = "phone";
    static final String PICTURE_KEY = "picture";//the one sending the url
    static final String PICTURE_PATH_KEY = "picturePath";//path to a local file
    static final String GENDER_KEY = "gender";
    static final String BYEAR_KEY = "byear";
    static final String CUSTOM_KEY = "custom";
    String[] namedFields = { NAME_KEY, USERNAME_KEY, EMAIL_KEY, ORG_KEY, PHONE_KEY, PICTURE_KEY, PICTURE_PATH_KEY, GENDER_KEY, BYEAR_KEY };
    boolean isSynced = true;
    UserProfile userProfileInterface;
    //fields from the old object
    String name;
    String username;
    String email;
    String org;
    String phone;
    String picture;
    static String picturePath;//protected only for testing
    String gender;
    Map<String, Object> custom;
    Map<String, JSONObject> customMods;
    int byear = 0;
    ModuleUserProfile(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleUserProfile] Initialising");
        userProfileInterface = new UserProfile();
    }
    /**
     * Returns &user_details= prefixed url to add to request data when making request to server
     *
     * @return a String user_details url part with provided user data
     */
    String getDataForRequest() {
        if (!isSynced) {
            isSynced = true;
            final JSONObject json = toJSON();
            if (json != null) {
                String result = json.toString();
                try {
                    result = java.net.URLEncoder.encode(result, "UTF-8");
                    if (result != null && !result.equals("")) {
                        result = "&user_details=" + result;
                        if (picturePath != null) {
                            result += "&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");
                        }
                    } else {
                        result = "";
                        if (picturePath != null) {
                            result += "&user_details&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");
                        }
                    }
                } catch (UnsupportedEncodingException ignored) {
                    // should never happen because Android guarantees UTF-8 support
                }
                if (result != null) {
                    return result;
                }
            }
        }
        return "";
    }
    /**
     * Creates and returns a JSONObject containing the user data from this object.
     *
     * @return a JSONObject containing the user data from this object
     */
    protected JSONObject toJSON() {
        final JSONObject json = new JSONObject();
        try {
            if (name != null) {
                if (name.equals("")) {
                    json.put(NAME_KEY, JSONObject.NULL);
                } else {
                    json.put(NAME_KEY, name);
                }
            }
            if (username != null) {
                if (username.equals("")) {
                    json.put(USERNAME_KEY, JSONObject.NULL);
                } else {
                    json.put(USERNAME_KEY, username);
                }
            }
            if (email != null) {
                if (email.equals("")) {
                    json.put(EMAIL_KEY, JSONObject.NULL);
                } else {
                    json.put(EMAIL_KEY, email);
                }
            }
            if (org != null) {
                if (org.equals("")) {
                    json.put(ORG_KEY, JSONObject.NULL);
                } else {
                    json.put(ORG_KEY, org);
                }
            }
            if (phone != null) {
                if (phone.equals("")) {
                    json.put(PHONE_KEY, JSONObject.NULL);
                } else {
                    json.put(PHONE_KEY, phone);
                }
            }
            if (picture != null) {
                if (picture.equals("")) {
                    json.put(PICTURE_KEY, JSONObject.NULL);
                } else {
                    json.put(PICTURE_KEY, picture);
                }
            }
            if (gender != null) {
                if (gender.equals("")) {
                    json.put(GENDER_KEY, JSONObject.NULL);
                } else {
                    json.put(GENDER_KEY, gender);
                }
            }
            if (byear != 0) {
                if (byear > 0) {
                    json.put(BYEAR_KEY, byear);
                } else {
                    json.put(BYEAR_KEY, JSONObject.NULL);
                }
            }
            JSONObject ob;
            if (custom != null) {
                UtilsInternalLimits.truncateSegmentationValues(custom, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleUserProfile] toJSON", _cly.L);
                ob = new JSONObject(custom);
            } else {
                ob = new JSONObject();
            }
            if (customMods != null) {
                for (Map.Entry<String, JSONObject> entry : customMods.entrySet()) {
                    ob.put(entry.getKey(), entry.getValue());
                }
            }
            json.put(CUSTOM_KEY, ob);
        } catch (JSONException e) {
            L.w("[UserData] Got exception converting an UserData to JSON", e);
        }
        return json;
    }
    /**
     * Sets user data fields to values from its JSON representation.
     *
     * @param json JSON object to extract event data from
     */
    void fromJSON(final JSONObject json) {
        if (json != null) {
            name = json.optString(NAME_KEY, null);
            username = json.optString(USERNAME_KEY, null);
            email = json.optString(EMAIL_KEY, null);
            org = json.optString(ORG_KEY, null);
            phone = json.optString(PHONE_KEY, null);
            picture = json.optString(PICTURE_KEY, null);
            gender = json.optString(GENDER_KEY, null);
            byear = json.optInt(BYEAR_KEY, 0);
            if (!json.isNull(CUSTOM_KEY)) {
                JSONObject customJson;
                try {
                    customJson = json.getJSONObject(CUSTOM_KEY);
                    if (customJson.length() == 0) {
                        custom = null;
                    } else {
                        custom = new HashMap<>(customJson.length());
                        Iterator<String> nameItr = customJson.keys();
                        while (nameItr.hasNext()) {
                            final String key = nameItr.next();
                            if (!customJson.isNull(key)) {
                                custom.put(key, customJson.getString(key));
                            }
                        }
                    }
                } catch (JSONException e) {
                    L.w("[ModuleUserProfile] Got exception converting an Custom Json to Custom User data", e);
                }
            }
        }
    }
    /**
     * Atomic modifications on custom user property.
     *
     * @param key String with property name to modify
     * @param value String value to use in modification
     * @param mod String with modification command
     */
    void modifyCustomData(String key, Object value, String mod) {
        try {
            if (!(value instanceof Double || value instanceof Integer || value instanceof String)) {
                L.w("[ModuleUserProfile] modifyCustomDataCommon, provided an unsupported type for 'value'");
                return;
            }
            Object valueAdded;
            String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] modifyCustomData");
            if (value instanceof String) {
                valueAdded = UtilsInternalLimits.truncateValueSize((String) value, _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] modifyCustomData");
            } else if (UtilsInternalLimits.isSupportedDataType(value)) {
                valueAdded = value;
            } else {
                L.w("[ModuleUserProfile] modifyCustomData, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], mod: [" + mod + "], omitting call");
                return;
            }
            if (customMods == null) {
                customMods = new HashMap<>();
            }
            JSONObject ob;
            if (!mod.equals("$pull") && !mod.equals("$push") && !mod.equals("$addToSet")) {
                ob = new JSONObject();
                ob.put(mod, valueAdded);
            } else {
                if (customMods.containsKey(truncatedKey)) {
                    ob = customMods.get(truncatedKey);
                } else {
                    ob = new JSONObject();
                }
                ob.accumulate(mod, valueAdded);
            }
            customMods.put(truncatedKey, ob);
            isSynced = false;
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    /**
     * This mainly performs the filtering of provided values
     * This single call would be used for both predefined properties and custom user properties
     *
     * @param data
     */
    void setPropertiesInternal(@NonNull Map<String, Object> data) {
        if (data.isEmpty()) {
            L.w("[ModuleUserProfile] setPropertiesInternal, no data was provided");
            return;
        }
        //todo recheck if in the future these can be <String, Object>
        Map<String, String> dataNamedFields = new HashMap<>();
        Map<String, Object> dataCustomFields = new HashMap<>();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value == null) {
                L.w("[ModuleUserProfile] setPropertiesInternal, provided value for key [" + key + "] is 'null'");
                continue;
            }
            boolean isNamed = false;
            // limit to the picture path is applied when request is being made in the ConnectionProcessor
            if (value instanceof String) {
                if (key.equals(PICTURE_PATH_KEY) || key.equals(PICTURE_KEY)) {
                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSizePicture, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                } else {
                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                }
            }
            for (String namedField : namedFields) {
                if (namedField.equals(key)) {
                    //if it's a name field
                    isNamed = true;
                    dataNamedFields.put(key, value.toString());
                    break;
                }
            }
            if (!isNamed) {
                String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                if (UtilsInternalLimits.isSupportedDataType(value)) {
                    dataCustomFields.put(truncatedKey, value);
                } else {
                    L.w("[ModuleUserProfile] setPropertiesInternal, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], omitting call");
                }
            }
        }
        //setting predefined properties
        setData(dataNamedFields);
        //setting custom properties
        if (custom == null) {
            custom = new HashMap<>();
        }
        custom.putAll(dataCustomFields);
        isSynced = false;
    }
    /**
     * Sets user data values.
     *
     * @param data Map with user data
     */
    public void setData(Map<String, String> data) {
        if (data.containsKey(ModuleUserProfile.NAME_KEY)) {
            name = data.get(ModuleUserProfile.NAME_KEY);
        }
        if (data.containsKey(ModuleUserProfile.USERNAME_KEY)) {
            username = data.get(ModuleUserProfile.USERNAME_KEY);
        }
        if (data.containsKey(ModuleUserProfile.EMAIL_KEY)) {
            email = data.get(ModuleUserProfile.EMAIL_KEY);
        }
        if (data.containsKey(ModuleUserProfile.ORG_KEY)) {
            org = data.get(ModuleUserProfile.ORG_KEY);
        }
        if (data.containsKey(ModuleUserProfile.PHONE_KEY)) {
            phone = data.get(ModuleUserProfile.PHONE_KEY);
        }
        if (data.containsKey(ModuleUserProfile.PICTURE_PATH_KEY)) {
            picturePath = data.get(ModuleUserProfile.PICTURE_PATH_KEY);
        }
        if (picturePath != null) {
            File sourceFile = new File(picturePath);
            if (!sourceFile.isFile()) {
                L.w("[UserData] Provided Picture path file [" + picturePath + "] can not be opened");
                picturePath = null;
            }
        }
        if (data.containsKey(ModuleUserProfile.PICTURE_KEY)) {
            picture = data.get(ModuleUserProfile.PICTURE_KEY);
        }
        if (data.containsKey(ModuleUserProfile.GENDER_KEY)) {
            gender = data.get(ModuleUserProfile.GENDER_KEY);
        }
        if (data.containsKey(ModuleUserProfile.BYEAR_KEY)) {
            try {
                byear = Integer.parseInt(data.get(ModuleUserProfile.BYEAR_KEY));
            } catch (NumberFormatException e) {
                L.w("[UserData] Incorrect byear number format");
                byear = 0;
            }
        }
    }
    void saveInternal() {
        L.d("[ModuleUserProfile] saveInternal");
        String cachedUserData = getDataForRequest();
        if (cachedUserData.isEmpty()) {
            L.d("[ModuleUserProfile] saveInternal, no user data to save");
            return;
        }
        _cly.moduleRequestQueue.sendEventsIfNeeded(true);
        requestQueueProvider.sendUserData(cachedUserData);
        clearInternal();
    }
    void clearInternal() {
        L.d("[ModuleUserProfile] clearInternal");
        name = null;
        username = null;
        email = null;
        org = null;
        phone = null;
        picture = null;
        picturePath = null;
        gender = null;
        custom = null;
        customMods = null;
        byear = 0;
        isSynced = true;
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (config.providedUserProperties != null) {
            L.i("[ModuleUserProfile] Custom user properties were provided during init [" + config.providedUserProperties.size() + "]");
            setPropertiesInternal(config.providedUserProperties);
            saveInternal();
        }
    }
    @Override
    void halt() {
        userProfileInterface = null;
    }
    public class UserProfile {
        /**
         * Increment custom property value by 1.
         *
         * @param key String with property name to increment
         */
        public void increment(String key) {
            synchronized (_cly) {
                modifyCustomData(key, 1, "$inc");
            }
        }
        /**
         * Increment custom property value by provided value.
         *
         * @param key String with property name to increment
         * @param value int value by which to increment
         */
        public void incrementBy(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$inc");
            }
        }
        /**
         * Multiply custom property value by provided value.
         *
         * @param key String with property name to multiply
         * @param value int value by which to multiply
         */
        public void multiply(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$mul");
            }
        }
        /**
         * Save maximal value between existing and provided.
         *
         * @param key String with property name to check for max
         * @param value int value to check for max
         */
        public void saveMax(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$max");
            }
        }
        /**
         * Save minimal value between existing and provided.
         *
         * @param key String with property name to check for min
         * @param value int value to check for min
         */
        public void saveMin(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$min");
            }
        }
        /**
         * Set value only if property does not exist yet
         *
         * @param key String with property name to set
         * @param value String value to set
         */
        public void setOnce(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$setOnce");
            }
        }
        /**
         * Create array property, if property does not exist and add value to array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to add to array
         */
        public void push(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$push");
            }
        }
        /**
         * Create array property, if property does not exist and add value to array, only if value is not yet in the array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to add to array
         */
        public void pushUnique(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$addToSet");
            }
        }
        /**
         * Create array property, if property does not exist and remove value from array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to remove from array
         */
        public void pull(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$pull");
            }
        }
        /**
         * Remove custom user property
         */
        //public void unset() {
        //    //todo add in the future
        //}
        /**
         * Set a single user property. It can be either a custom one or one of the predefined ones.
         *
         * @param key the key for the user property
         * @param value the value for the user property to be set. The value should be the allowed data type.
         */
        public void setProperty(String key, Object value) {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'setProperty'");
                Map<String, Object> data = new HashMap<>();
                data.put(key, value);
                setPropertiesInternal(data);
            }
        }
        /**
         * Provide a map of user properties to set.
         * Those can be either custom user properties or predefined user properties
         *
         * @param data
         */
        public void setProperties(Map<String, Object> data) {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'setProperties'");
                if (data == null) {
                    L.i("[UserProfile] Provided data can not be 'null'");
                    return;
                }
                setPropertiesInternal(data);
            }
        }
        /**
         * Send provided values to server
         */
        public void save() {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'save'");
                saveInternal();
            }
        }
        /**
         * Clear queued operations / modifications
         */
        public void clear() {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'clear'");
                clearInternal();
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Map;
import org.json.JSONException;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verifyZeroInteractions;
@RunWith(AndroidJUnit4.class)
public class ModuleConsentTests {
    protected static final String[] usedFeatureNames = {
        Countly.CountlyFeatureNames.sessions,
        Countly.CountlyFeatureNames.events,
        Countly.CountlyFeatureNames.views,
        Countly.CountlyFeatureNames.location,
        Countly.CountlyFeatureNames.crashes,
        Countly.CountlyFeatureNames.attribution,
        Countly.CountlyFeatureNames.users,
        Countly.CountlyFeatureNames.push,
        Countly.CountlyFeatureNames.starRating,
        Countly.CountlyFeatureNames.remoteConfig,
        Countly.CountlyFeatureNames.apm,
        Countly.CountlyFeatureNames.feedback,
        Countly.CountlyFeatureNames.clicks,
        Countly.CountlyFeatureNames.scrolls,
        Countly.CountlyFeatureNames.content,
    };
    @Before
    public void setUp() {
    }
    @After
    public void tearDown() {
    }
    Countly helperCreateAndInitCountly() {
        return null;
    }
    /**
     * Make sure that all used feature names are valid
     */
    @Test
    public void usingValidFeatureList() {
        Assert.assertEquals(usedFeatureNames.length, ModuleConsent.validFeatureNames.length);
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertEquals(usedFeatureNames[a], ModuleConsent.validFeatureNames[a]);
        }
    }
    /**
     * Test scenario were consent is required but no consent given on init
     * This should create a scenario where "getConsent" returns "false" for all features
     */
    @Test
    public void enableConsentWithoutConsentGiven() {
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[a]));
        }
    }
    /**
     * Test scenario were consent is required and consent for all features is given during init
     * This should create a scenario where "getConsent" returns "true" for all features
     */
    @Test
    public void enableConsentGiveAll() {
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, usedFeatureNames, null));
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));
        }
    }
    /**
     * Give consent to all features during init and remove them all afterwards
     * Make sure that giving all and removing all correctly toggles the feature state
     */
    @Test
    public void enableConsentRemoveAfter() {
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, usedFeatureNames, null));
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));
        }
        mCountly.consent().removeConsentAll();
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[a]));
        }
        mCountly.consent().giveConsentAll();
        for (int a = 0; a < usedFeatureNames.length; a++) {
            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));
        }
    }
    /**
     * Makes sure all modules have the consent interface set
     */
    @Test
    public void checkIfConsentProviderSet() {
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));
        for (ModuleBase module : mCountly.modules) {
            Assert.assertEquals(mCountly.moduleConsent, module.consentProvider);
        }
        Assert.assertEquals(mCountly.moduleConsent, mCountly.connectionQueue_.consentProvider);
        Assert.assertEquals(mCountly.moduleConsent, mCountly.config_.consentProvider);
    }
    /**
     * Set all consent values setting them one by one after init
     * Validate "anyConsentGiven" in a couple of scenarios
     */
    @Test
    public void checkSettingConsentAfterInit() {
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));
        Assert.assertFalse(mCountly.moduleConsent.consentProvider.anyConsentGiven());
        for (int a = 0; a < usedFeatureNames.length; a++) {
            mCountly.consent().giveConsent(new String[] { usedFeatureNames[a] });
            for (int b = 0; b < usedFeatureNames.length; b++) {
                if (b <= a) {
                    Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[b]));
                } else {
                    Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[b]));
                }
            }
        }
        Assert.assertTrue(mCountly.moduleConsent.consentProvider.anyConsentGiven());
    }
    /**
     * Make sure that feature names are not changed by accident
     */
    @Test
    public void validateFeatureNames() {
        Assert.assertEquals("sessions", Countly.CountlyFeatureNames.sessions);
        Assert.assertEquals("events", Countly.CountlyFeatureNames.events);
        Assert.assertEquals("views", Countly.CountlyFeatureNames.views);
        Assert.assertEquals("location", Countly.CountlyFeatureNames.location);
        Assert.assertEquals("crashes", Countly.CountlyFeatureNames.crashes);
        Assert.assertEquals("attribution", Countly.CountlyFeatureNames.attribution);
        Assert.assertEquals("users", Countly.CountlyFeatureNames.users);
        Assert.assertEquals("push", Countly.CountlyFeatureNames.push);
        Assert.assertEquals("star-rating", Countly.CountlyFeatureNames.starRating);
        Assert.assertEquals("apm", Countly.CountlyFeatureNames.apm);
        Assert.assertEquals("feedback", Countly.CountlyFeatureNames.feedback);
        Assert.assertEquals("remote-config", Countly.CountlyFeatureNames.remoteConfig);
        Assert.assertEquals("scrolls", Countly.CountlyFeatureNames.scrolls);
        Assert.assertEquals("clicks", Countly.CountlyFeatureNames.clicks);
    }
    /**
     * Require no consent at init time and provide no consent values.
     * Does not provide any location or anything else
     * No requests should be created.
     * There should be no interactions with the mock
     */
    @Test
    public void initTimeNoConsentRequiredRQ() {
        RequestQueueProvider rqp = mock(RequestQueueProvider.class);
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(false, null, null, rqp));
        verifyZeroInteractions(rqp);
    }
    /**
     * Consent required at init time but no consent values are given
     *
     * This should create a request of false consent values and a location request with removed location
     */
    @Test
    public void initTimeNoConsentGivenRQ() throws JSONException {
        RequestQueueProvider rqp = mock(RequestQueueProvider.class);
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null, rqp));
        Assert.assertEquals(2, Mockito.mockingDetails(rqp).getInvocations().size());
        TestUtils.verifyLocationValuesInRQMock(1, true, null, null, null, null, rqp);
        TestUtils.verifyConsentValuesInRQMock(1, new String[] {}, usedFeatureNames, rqp);
    }
    /**
     * Consent required at init time and a few consent values are given
     * No location consent is given
     *
     * This should create a request with the relevant consent values and a location request with removed location
     */
    @Test
    public void initTimeSetConsentRQ_2() throws JSONException {
        RequestQueueProvider rqp = mock(RequestQueueProvider.class);
        String[] initialConsent = { Countly.CountlyFeatureNames.clicks, Countly.CountlyFeatureNames.push, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback };
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp));
        //this should send consent state and empty location
        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);
        TestUtils.verifyLocationValuesInRQMockDisabled(rqp);
    }
    /**
     * Consent required at init time and a few consent values are given
     * No location consent is given
     *
     * This should create a request with the relevant consent values and no location request (consent given but no values provided)
     */
    @Test
    public void initTimeSetConsentRQ_3() throws JSONException {
        RequestQueueProvider rqp = mock(RequestQueueProvider.class);
        String[] initialConsent = { Countly.CountlyFeatureNames.clicks, Countly.CountlyFeatureNames.push, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback, Countly.CountlyFeatureNames.location };
        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp));
        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);
        TestUtils.verifyLocationValuesInRQMockNotGiven(rqp);
    }
    /**
     * Consent required at init time and a few consent values are given
     * No location consent is given
     *
     * This should create a request with the relevant consent values and location request with the given values
     */
    @Test
    public void initTimeSetConsentRQ_4() throws JSONException {
        RequestQueueProvider rqp = mock(RequestQueueProvider.class);
        String[] initialConsent = { Countly.CountlyFeatureNames.attribution, Countly.CountlyFeatureNames.starRating, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback, Countly.CountlyFeatureNames.location };
        CountlyConfig cc = TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp);
        cc.setLocation("qw", "Bston ", "123.9009", "qwe890");
        Countly mCountly = new Countly().init(cc);
        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);
        TestUtils.verifyLocationValuesInRQMockValues(cc.locationCountyCode, cc.locationCity, cc.locationLocation, cc.locationIpAddress, rqp);
    }
    protected static void validateConsentRequest(String deviceId, int idx, boolean[] consents) {
        Map<String, Object> consentsMap =
            TestUtils.map("sessions", consents[0], "crashes", consents[1], "users", consents[2], "push", consents[3], "feedback", consents[4], "scrolls", consents[5], "remote-config", consents[6], "attribution", consents[7], "clicks", consents[8], "location", consents[9], "star-rating",
                consents[10], "events", consents[11], "views", consents[12], "apm", consents[13], "content", consents[14]);
        TestUtils.validateRequest(deviceId, TestUtils.map("consent", consentsMap), idx);
    }
    protected static void validateAllConsentRequest(String deviceId, int idx) {
        validateConsentRequest(deviceId, idx, new boolean[] { true, true, true, true, true, true, true, true, true, true, true, true, true, true, true });
    }
    // TODO test that makes sure that the consent change request is created correctly
    // TODO test that makes sure that the consent change request is not created for duplicate triggers
    // TODO make sure that the consent request is correctly created after init
    // TODO test that consent given / removed triggers are played correctly
    // TODO ?make tests for formatConsentState
    // TODO test give all consent
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleAttribution extends ModuleBase {
    Attribution attributionInterface;
    ModuleAttribution(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleAttribution] Initialising");
        attributionInterface = new ModuleAttribution.Attribution();
    }
    void recordDirectAttributionInternal(@Nullable String campaignType, @Nullable String campaignData) {
        L.d("[ModuleAttribution] recordDirectAttributionInternal, campaign id:[" + campaignType + "], user id:[" + campaignData + "]");
        if (campaignType == null || campaignType.isEmpty()) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, provided campaign type value is not valid. Execution will be aborted.");
            return;
        }
        if (campaignData == null || campaignData.isEmpty()) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, provided campaign data value is not valid. Execution will be aborted.");
            return;
        }
        if (!campaignType.equals("countly") && !campaignType.equals("_special_test")) {
            //stop execution if the type is not "countly"
            //this is a temporary exception
            L.w("[ModuleAttribution] recordDirectAttributionInternal, recording direct attribution with a type other than 'countly' is currently not supported. Execution will be aborted.");
            return;
        }
        if (campaignType.equals("_special_test")) {
            reportSpecialTestAttribution(campaignData);
        }
        if (campaignType.equals("countly")) {
            reportLegacyInstallAttribution(campaignData);
        }
    }
    void reportLegacyInstallAttribution(@NonNull String campaignData) {
        JSONObject jObj;
        try {
            jObj = new JSONObject(campaignData);
        } catch (JSONException e) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, recording direct attribution data is not in the correct format. Execution will be aborted.");
            return;
        }
        if (!jObj.has("cid")) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, direct attribution can't be recorded because the data does not contain the 'cid' value. Execution will be aborted.");
            return;
        }
        String campaignId = null;
        try {
            campaignId = jObj.getString("cid");
            if (campaignId.isEmpty()) {
                L.e("[ModuleAttribution] recordDirectAttributionInternal, 'cid' value can't be empty string. Execution will be aborted.");
                return;
            }
        } catch (JSONException e) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, encountered issue while accessing 'cid'. Execution will be aborted.");
            return;
        }
        String campaignUserId = null;
        try {
            if (jObj.has("cuid")) {
                campaignUserId = jObj.getString("cuid");
                if (campaignUserId.isEmpty()) {
                    L.w("[ModuleAttribution] recordDirectAttributionInternal, 'cuid' value can't be empty string. value will be ignored.");
                    campaignUserId = null;
                }
            }
        } catch (JSONException e) {
            L.e("[ModuleAttribution] recordDirectAttributionInternal, encountered issue while accessing 'cuid'. Execution will be aborted.");
            return;
        }
        requestQueueProvider.sendDirectAttributionLegacy(campaignId, campaignUserId);
    }
    void reportSpecialTestAttribution(@NonNull String attributionData) {
        requestQueueProvider.sendDirectAttributionTest(attributionData);
    }
    void recordIndirectAttributionInternal(@Nullable Map<String, String> attributionId) {
        L.d("[ModuleAttribution] recordIndirectAttributionInternal, attribution id:[" + attributionId + "]");
        if (attributionId == null || attributionId.isEmpty()) {
            L.e("[ModuleAttribution] recordIndirectAttributionInternal, provided id values are not valid. Execution will be aborted.");
            return;
        }
        JSONObject jObj = new JSONObject();
        for (Map.Entry<String, String> entry : attributionId.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            if (key == null || key.isEmpty()) {
                L.e("[ModuleAttribution] recordIndirectAttributionInternal, provided key is not valid [" + key + "].");
                continue;
            }
            if (value == null || value.isEmpty()) {
                L.e("[ModuleAttribution] recordIndirectAttributionInternal, for the key[" + key + "] the provided value is not valid [" + value + "].");
                continue;
            }
            try {
                jObj.putOpt(key, value);
            } catch (JSONException e) {
                L.e("[ModuleAttribution] recordIndirectAttributionInternal, an issue happened while trying to add a value: " + e.toString());
            }
        }
        if (jObj.length() == 0) {
            L.e("[ModuleAttribution] recordIndirectAttributionInternal, no valid attribution values were provided");
            return;
        }
        String attributionObj = jObj.toString();
        requestQueueProvider.sendIndirectAttribution(attributionObj);
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //check if any indirect attribution value is set
        if (config.iaAttributionValues != null) {
            if (config.iaAttributionValues.isEmpty()) {
                L.e("[ModuleAttribution] provided attribution ID for indirect attribution is empty string.");
            } else {
                recordIndirectAttributionInternal(config.iaAttributionValues);
            }
        }
        //checking if any direct attribution value is set
        if (config.daCampaignData != null || config.daCampaignType != null) {
            if (config.daCampaignType == null || config.daCampaignType.isEmpty()) {
                L.e("[ModuleAttribution] Can't record direct attribution can't be recorded with an invalid campaign id.");
            } else {
                if (config.daCampaignData != null && config.daCampaignData.isEmpty()) {
                    L.e("[ModuleAttribution] For direct attribution the provided Campaign user ID can't be empty string.");
                }
                recordDirectAttributionInternal(config.daCampaignType, config.daCampaignData);
            }
        }
    }
    @Override
    public void halt() {
        attributionInterface = null;
    }
    public class Attribution {
        /**
         * Report direct user attribution
         */
        public void recordDirectAttribution(String campaignType, String campaignData) {
            synchronized (_cly) {
                L.i("[Attribution] calling 'recordCampaign'");
                recordDirectAttributionInternal(campaignType, campaignData);
            }
        }
        /**
         * Report indirect user attribution
         *
         * @param attributionValues
         */
        public void recordIndirectAttribution(Map<String, String> attributionValues) {
            synchronized (_cly) {
                L.i("[Attribution] calling 'recordIndirectAttribution'");
                recordIndirectAttributionInternal(attributionValues);
            }
        }
    }
}
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.content.Context;
import android.content.SharedPreferences;
import android.provider.Settings;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.UUID;
public class ModuleDeviceId extends ModuleBase implements OpenUDIDProvider, DeviceIdProvider {
    boolean exitTempIdAfterInit = false;
    boolean cleanupTempIdAfterInit = false;
    ly.count.android.sdk.DeviceId deviceIdInstance;
    DeviceId deviceIdInterface;
    ModuleDeviceId(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleDeviceId] Initialising");
        boolean customIDWasProvided = config.deviceID != null;
        if (config.temporaryDeviceIdEnabled && !customIDWasProvided) {
            //if we want to use temporary ID mode and no developer custom ID is provided
            //then we override that custom ID to set the temporary mode
            config.deviceID = ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId;
        }
        deviceIdInstance = new ly.count.android.sdk.DeviceId(config.deviceID, config.storageProvider, L, this);
        config.deviceIdProvider = this;
        boolean temporaryDeviceIdIsCurrentlyEnabled = deviceIdInstance.isTemporaryIdModeEnabled();
        L.d("[ModuleDeviceId] [TemporaryDeviceId] Temp ID should be enabled[" + config.temporaryDeviceIdEnabled + "] Currently enabled: [" + temporaryDeviceIdIsCurrentlyEnabled + "]");
        if (temporaryDeviceIdIsCurrentlyEnabled && customIDWasProvided) {
            //if a custom ID was provided and we are still in temporary ID mode
            //it means the we had tempID mode at the previous app end
            //exit tempID after init finished
            L.d("[ModuleDeviceId] [TemporaryDeviceId] Decided we have to exit temporary device ID mode, mode enabled: [" + config.temporaryDeviceIdEnabled + "], custom Device ID Set: [" + customIDWasProvided + "]");
            exitTempIdAfterInit = true;
        } else {
            if (!temporaryDeviceIdIsCurrentlyEnabled) {
                //if temp ID mode is not enabled then there should also be no temp ID requests in the RQ
                //note to perform queue cleanup
                cleanupTempIdAfterInit = true;
            }
        }
        deviceIdInterface = new DeviceId();
    }
    void replaceTempIDWithRealIDinRQ(@NonNull String targetDeviceId) {
        String[] storedRequests = storageProvider.getRequests();
        String temporaryIdTag = "&device_id=" + ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId;
        String newIdTag = "&device_id=" + targetDeviceId;
        boolean foundOne = false;
        for (int a = 0; a < storedRequests.length; a++) {
            if (storedRequests[a].contains(temporaryIdTag)) {
                L.d("[ModuleDeviceId] [exitTemporaryIdMode] Found a tag to replace in: [" + storedRequests[a] + "]");
                storedRequests[a] = storedRequests[a].replace(temporaryIdTag, newIdTag);
                foundOne = true;
            }
        }
        if (foundOne) {
            storageProvider.replaceRequests(storedRequests);
        }
    }
    void exitTemporaryIdMode(@NonNull String deviceId) {
        L.d("[ModuleDeviceId] Calling exitTemporaryIdMode");
        if (!_cly.isInitialized()) {
            throw new IllegalStateException("init must be called before exitTemporaryIdMode");
        }
        //start by changing stored ID
        deviceIdInstance.changeToCustomId(deviceId);
        // trigger fetching if the temp id given on init
        _cly.moduleConfiguration.fetchConfigFromServer();
        //update stored request for ID change to use this new ID
        replaceTempIDWithRealIDinRQ(deviceId);
        //update remote config_ values if automatic update is enabled
        _cly.moduleRemoteConfig.RCAutomaticDownloadTrigger(false);
        _cly.requestQueue().attemptToSendStoredRequests();
        // trigger sending if the temp id given on init
        _cly.moduleHealthCheck.sendHealthCheck();
    }
    /**
     * Changes current device id type to the one specified in parameter. Closes current session and
     * reopens new one with new id. Doesn't merge user profiles on the server
     *
     * @param deviceId Optional device ID for a case when type = DEVELOPER_SPECIFIED
     */
    void changeDeviceIdWithoutMergeInternal(@NonNull String deviceId) {
        if (isTemporaryIdEnabled() && deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {
            // we already are in temporary mode and we want to set temporary mode
            // in this case we just ignore the request since nothing has to be done
            return;
        }
        if (deviceIdInstance.getCurrentId().equals(deviceId)) {
            //if we are attempting to change the device ID to the same ID, do nothing
            L.w("[ModuleDeviceId] changeDeviceIdWithoutMergeInternal, We are attempting to change the device ID to the same ID, request will be ignored");
            return;
        }
        if (isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {
            // we are about to exit temporary ID mode
            // because of the previous check, we know that the new type is a different one
            // we just call our method for exiting it
            // we don't end the session, we just update the device ID and connection queue
            exitTemporaryIdMode(deviceId);
            return;
        }
        // we are either making a simple ID change or entering temporary mode
        // in both cases we act the same as the temporary ID requests will be updated with the final ID later
        //force flush events so that they are associated correctly
        _cly.moduleRequestQueue.sendEventsIfNeeded(true);
        //send user profile data because we are flushing the event queue
        _cly.moduleUserProfile.saveInternal();
        //update remote config_ values after id change if automatic update is enabled
        _cly.moduleRemoteConfig.clearAndDownloadAfterIdChange();
        if (!_cly.moduleSessions.manualSessionControlEnabled) {
            //if manual session control is not enabled, end the current session
            _cly.moduleSessions.endSessionInternal(); // this will check consent
        }
        //remove all consent
        _cly.moduleConsent.removeConsentAllInternal(ModuleConsent.ConsentChangeSource.DeviceIDChangedNotMerged);
        if (deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {
            // entering temp ID mode
            deviceIdInstance.enterTempIDMode();
        } else {
            // setting a custom device ID
            deviceIdInstance.changeToCustomId(deviceId);
        }
        //clear automated star rating session values because now we have a new user
        _cly.moduleRatings.clearAutomaticStarRatingSessionCountInternal();
        _cly.notifyDeviceIdChange(true);
    }
    /**
     * Changes current device id to the one specified in parameter. Merges user profile with new id
     * (if any) with old profile.
     *
     * @param deviceId new device id
     */
    void changeDeviceIdWithMergeInternal(@NonNull String deviceId) {
        if (deviceId.isEmpty()) {
            L.e("changeDeviceIdWithMergeInternal, provided device ID can't be empty string");
            return;
        }
        if (deviceIdInstance.getCurrentId().equals(deviceId)) {
            //if we are attempting to change the device ID to the same ID, do nothing
            L.w("[ModuleDeviceId] changeDeviceIdWithMergeInternal, We are attempting to change the device ID to the same ID, request will be ignored");
            return;
        }
        if (isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {
            //if we are in temporary ID mode or
            //at some moment have enabled temporary mode
            if (deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {
                //if we want to enter temporary ID mode
                //just exit, nothing to do
                L.w("[ModuleDeviceId, changeDeviceId] About to enter temporary ID mode when already in it");
                return;
            }
            // if a developer supplied ID is provided
            //we just exit this mode and set the id to the provided one
            exitTemporaryIdMode(deviceId);
        } else {
            //we are not in temporary mode, nothing special happens
            // we are either making a simple ID change or entering temporary mode
            // in both cases we act the same as the temporary ID requests will be updated with the final ID later
            //update remote config_ values after id change if automatic update is enabled
            _cly.moduleRemoteConfig.clearAndDownloadAfterIdChange();
            requestQueueProvider.changeDeviceId(deviceId, deviceIdInstance.getCurrentId());
            deviceIdInstance.changeToCustomId(deviceId);
            _cly.notifyDeviceIdChange(false);
        }
    }
    private void setIDInternal(String newDeviceID) {
        if (Utils.isNullOrEmpty(newDeviceID)) {
            L.w("[ModuleDeviceId] setID, Empty id passed to setID method");
            return;
        }
        if (deviceIdInstance.getCurrentId() != null && deviceIdInstance.getCurrentId().equals(newDeviceID)) {
            L.w("[ModuleDeviceId] setID, Same id passed to setID method, ignoring");
            return;
        }
        DeviceIdType currentType = deviceIdInstance.getType();
        if (currentType.equals(DeviceIdType.DEVELOPER_SUPPLIED)) {
            // an ID was provided by the host app previously
            // we can assume that a device ID change with merge was executed previously
            // now we change it without merging
            changeDeviceIdWithoutMergeInternal(newDeviceID);
        } else {
            // SDK generated ID
            // we change device ID with merge so that data is combined
            changeDeviceIdWithMergeInternal(newDeviceID);
        }
    }
    @Override
    public void initFinished(@NonNull CountlyConfig config) {
        if (exitTempIdAfterInit) {
            L.i("[ModuleDeviceId, initFinished] Exiting temp ID at the end of init");
            exitTemporaryIdMode(config.deviceID);
        } else if (cleanupTempIdAfterInit) {
            L.i("[ModuleDeviceId, initFinished] Cleaning up potentially left temp ID requests in queue");
            String storedDevId = getDeviceId();
            if (storedDevId != null && !storedDevId.isEmpty()) {
                replaceTempIDWithRealIDinRQ(storedDevId);
            } else {
                L.w("[ModuleDeviceId, initFinished] Can't cleanup RQ, device ID is either null or empty [" + storedDevId + "]");
            }
        }
    }
    @Override
    void halt() {
    }
    public final static String PREF_KEY = "openudid";
    public final static String PREFS_NAME = "openudid_prefs";
    @SuppressLint("HardwareIds")
    @Override @NonNull public String getOpenUDID() {
        String retrievedID;
        SharedPreferences mPreferences = _cly.context_.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        //Try to get the openudid from local preferences
        retrievedID = mPreferences.getString(PREF_KEY, null);
        if (retrievedID == null) //Not found if temp storage
        {
            Countly.sharedInstance().L.d("[OpenUDID] Generating openUDID");
            //Try to get the ANDROID_ID
            retrievedID = Settings.Secure.getString(_cly.context_.getContentResolver(), Settings.Secure.ANDROID_ID);
            if (retrievedID == null || retrievedID.equals("9774d56d682e549c") || retrievedID.length() < 15) {
                //if ANDROID_ID is null, or it's equals to the GalaxyTab generic ANDROID_ID or is too short bad, generates a new one
                //the new one would be random
                retrievedID = UUID.randomUUID().toString();
            }
            final SharedPreferences.Editor e = mPreferences.edit();
            e.putString(PREF_KEY, retrievedID);
            e.apply();
        }
        Countly.sharedInstance().L.d("[OpenUDID] ID: " + retrievedID);
        return retrievedID;
    }
    @Override public @Nullable String getDeviceId() {
        return deviceIdInstance.getCurrentId();
    }
    @Override public boolean isTemporaryIdEnabled() {
        return deviceIdInstance.isTemporaryIdModeEnabled();
    }
    @Override public @NonNull ly.count.android.sdk.DeviceId getDeviceIdInstance() {
        return deviceIdInstance;
    }
    public class DeviceId {
        /**
         * Changes current device id to the one specified in parameter. Closes current session and
         * reopens new one with new id. Doesn't merge user profiles on the server
         *
         * @param deviceId New device ID
         */
        public void changeWithoutMerge(@Nullable String deviceId) {
            synchronized (_cly) {
                L.d("[DeviceId] Calling 'changeDeviceIdWithoutMerge'");
                if (deviceId == null) {
                    L.e("[DeviceId] changeDeviceIdWithoutMerge, provided device ID value was 'null'. Request will be ignored");
                    return;
                }
                changeDeviceIdWithoutMergeInternal(deviceId);
            }
        }
        /**
         * Changes current device id to the one specified in parameter. Merges user profile with new id
         * (if any) with old profile.
         *
         * @param deviceId new device id
         */
        public void changeWithMerge(@Nullable String deviceId) {
            synchronized (_cly) {
                L.d("[DeviceId] Calling 'changeDeviceIdWithMerge'");
                if (deviceId == null) {
                    L.e("[DeviceId] changeDeviceIdWithMerge, provided device ID value was 'null'. Request will be ignored");
                    return;
                }
                changeDeviceIdWithMergeInternal(deviceId);
            }
        }
        /**
         * Returns the device id used by countly for this device
         *
         * @return device ID
         */
        public String getID() {
            synchronized (_cly) {
                L.d("[DeviceId] Calling 'getDeviceID'");
                return getDeviceId();
            }
        }
        /**
         * Sets device ID according to the device ID Type.
         * If previous ID was Developer Supplied sets it without merge, otherwise with merge.
         *
         * @param newDeviceID device id to set
         */
        public void setID(String newDeviceID) {
            synchronized (_cly) {
                L.d("[DeviceId] Calling 'setID'");
                setIDInternal(newDeviceID);
            }
        }
        /**
         * Returns the type of the device ID used by countly for this device.
         *
         * @return device ID type
         */
        public DeviceIdType getType() {
            synchronized (_cly) {
                L.d("[DeviceId] Calling 'getDeviceIDType'");
                return deviceIdInstance.getType();
            }
        }
        /**
         * Go into temporary device ID mode
         */
        public void enableTemporaryIdMode() {
            synchronized (_cly) {
                L.i("[DeviceId] Calling 'enableTemporaryIdMode'");
                changeDeviceIdWithoutMergeInternal(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId);
            }
        }
    }
}
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.os.Build;
import android.util.Log;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class PerformanceCounterCollector {
    HashMap<String, Double> perfCounter = new HashMap<String, Double>();
    public void Clear() {
        perfCounter.clear();
    }
    public void TrackCounterTimeNs(String key, long valueNs) {
        TrackCounter(key, valueNs / 1_000_000_000.0);
    }
    public void TrackCounter(String key, double value) {
        assert Utils.isNotNullOrEmpty(key);
        if (value < 0) {
            Log.w("Countly", "Problem, we should only log positive values");
        }
        Double retrievedValue = perfCounter.get(key);
        if (retrievedValue == null) {
            retrievedValue = 0.0;
        }
        retrievedValue += value;
        perfCounter.put(key, retrievedValue);
    }
    public String ReturnResults() {
        List<String> entries = new ArrayList<>(perfCounter.size());
        //create all string entries
        for (Map.Entry<String, Double> entry : perfCounter.entrySet()) {
            String key = entry.getKey();
            Double value = entry.getValue();
            @SuppressLint("DefaultLocale")
            String strValue = String.format("%.6f", value);
            entries.add(key + " - " + strValue + "\n");
        }
        //sort if possible
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            entries.sort(String::compareTo);
        }
        //combine into printable String
        StringBuilder res = new StringBuilder();
        for (String s : entries) {
            res.append(s);
        }
        return res.toString();
    }
}