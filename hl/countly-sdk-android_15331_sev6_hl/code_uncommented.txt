package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;public class ModuleRequestQueue extends ModuleBase implements BaseInfoProvider {    RequestQueue requestQueueInterface;    @NonNull String appKey;    @NonNull String serverURL;    private boolean shouldIgnoreCrawlers = true;    private boolean deviceIsAppCrawler = false;    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")    private final List<String> appCrawlerNames = new ArrayList<>(Arrays.asList("Calypso AppCrawler"));    static final String APP_KEY_KEY = "app_key";    static final String HOUR_KEY = "hour";    static final String DOW_KEY = "dow";    static final String TZ_KEY = "tz";    static final String SDK_VERSION_KEY = "sdk_version";    static final String SDK_NAME_KEY = "sdk_name";    static final String DEVICE_ID_KEY = "device_id";    static final String OLD_DEVICE_ID_KEY = "old_device_id";    static final String CHECKSUM_KEY = "checksum";    static final String CHECKSUM_256_KEY = "checksum256";    String[] preDefinedKeys = { APP_KEY_KEY, HOUR_KEY, DOW_KEY, TZ_KEY, SDK_VERSION_KEY, SDK_NAME_KEY, DEVICE_ID_KEY, OLD_DEVICE_ID_KEY, CHECKSUM_KEY, CHECKSUM_256_KEY };    ModuleRequestQueue(@NonNull Countly cly, @NonNull CountlyConfig config) {        super(cly, config);        L.v("[ModuleRequestQueue] Initialising");        config.baseInfoProvider = this;        baseInfoProvider = this;        appKey = config.appKey;        serverURL = config.serverURL;        if (config.shouldIgnoreAppCrawlers) {            L.d("[ModuleRequestQueue] Ignoring app crawlers");            shouldIgnoreCrawlers = config.shouldIgnoreAppCrawlers;        }        if (config.appCrawlerNames != null) {            L.d("[ModuleRequestQueue] Adding app crawlers names");            appCrawlerNames.addAll(Arrays.asList(config.appCrawlerNames));        }        checkIfDeviceIsAppCrawler();        requestQueueInterface = new RequestQueue();    }    @Override public @NonNull String getAppKey() {        return appKey;    }    @Override public @NonNull String getServerURL() {        return serverURL;    }    synchronized List<String> requestQueueReplaceWithAppKey(String[] storedRequests, String targetAppKey) {        try {            List<String> filteredRequests = new ArrayList<>();            if (storedRequests == null) {                L.w("[ModuleRequestQueue] requestQueueReplaceWithAppKey, stopping replacing due to stored requests being 'null'");                return filteredRequests;            }            if (targetAppKey == null || targetAppKey.isEmpty()) {                L.w("[ModuleRequestQueue] requestQueueReplaceWithAppKey, stopping replacing due to target app key being 'null' or empty string");                return filteredRequests;            }            String replacementPart = "app_key=" + UtilsNetworking.urlEncodeString(targetAppKey);            for (String storedRequest : storedRequests) {                if (storedRequest == null) {                    continue;                }                boolean found = false;                String[] parts = storedRequest.split("&");                for (int b = 0; b < parts.length; b++) {                    if (parts[b].contains("app_key=")) {                        parts[b] = replacementPart;                        found = true;                        break;                    }                }                StringBuilder stringBuilder = new StringBuilder(storedRequest.length());                for (int c = 0; c < parts.length; c++) {                    if (c != 0) {                        stringBuilder.append("&");                    }                    stringBuilder.append(parts[c]);                }                filteredRequests.add(stringBuilder.toString());            }            return filteredRequests;        } catch (Exception ex) {            L.e("[ModuleRequestQueue] Failed while overwriting appKeys, " + ex.toString());            return null;        }    }    synchronized List<String> requestQueueRemoveWithoutAppKey(String[] storedRequests, String targetAppKey) {        List<String> filteredRequests = new ArrayList<>();        if (storedRequests == null || targetAppKey == null) {            return filteredRequests;        }        String searchablePart = "app_key=" + targetAppKey;        for (String storedRequest : storedRequests) {            if (storedRequest == null) {                continue;            }            if (!storedRequest.contains(searchablePart)) {                L.d("[ModuleRequestQueue] requestQueueEraseAppKeysRequests, Found a entry to remove: [" + storedRequest + "]");            } else {                filteredRequests.add(storedRequest);            }        }        return filteredRequests;    }    protected void sendEventsIfNeeded(boolean forceSendingEvents) {        int eventsInEventQueue = storageProvider.getEventQueueSize();        L.v("[ModuleRequestQueue] forceSendingEvents, forced:[" + forceSendingEvents + "], event count:[" + eventsInEventQueue + "]");        if ((forceSendingEvents && eventsInEventQueue > 0) || eventsInEventQueue >= _cly.EVENT_QUEUE_SIZE_THRESHOLD) {            requestQueueProvider.recordEvents(storageProvider.getEventsForRequestAndEmptyEventQueue());        }    }    boolean isHttpPostForcedInternal() {        return _cly.isHttpPostForced;    }    boolean isDeviceAppCrawlerInternal() {        return deviceIsAppCrawler;    }    boolean ifShouldIgnoreCrawlersInternal() {        return shouldIgnoreCrawlers;    }    private void checkIfDeviceIsAppCrawler() {        String deviceName = deviceInfo.mp.getDevice();        for (int a = 0; a < appCrawlerNames.size(); a++) {            if (deviceName.equals(appCrawlerNames.get(a))) {                deviceIsAppCrawler = true;                return;            }        }    }    public void flushQueuesInternal() {        CountlyStore store = _cly.countlyStore;        final String[] storedRequests = store.getRequests();        store.replaceRequests(new String[] {});        L.d("[ModuleRequestQueue] flushRequestQueues removed [" + storedRequests.length + "] requests");    }    public void attemptToSendStoredRequestsInternal() {        L.i("[ModuleRequestQueue] Calling attemptToSendStoredRequests");        sendEventsIfNeeded(true);        _cly.moduleUserProfile.saveInternal();        requestQueueProvider.tick();    }    synchronized public void requestQueueOverwriteAppKeysInternal() {        L.i("[ModuleRequestQueue] Calling requestQueueOverwriteAppKeys");        List<String> filteredRequests = requestQueueReplaceWithAppKey(storageProvider.getRequests(), baseInfoProvider.getAppKey());        if (filteredRequests != null) {            storageProvider.replaceRequestList(filteredRequests);            attemptToSendStoredRequestsInternal();        }    }    synchronized public void requestQueueEraseAppKeysRequestsInternal() {        L.i("[ModuleRequestQueue] Calling requestQueueEraseAppKeysRequests");        List<String> filteredRequests = requestQueueRemoveWithoutAppKey(storageProvider.getRequests(), baseInfoProvider.getAppKey());        storageProvider.replaceRequestList(filteredRequests);        attemptToSendStoredRequestsInternal();    }    synchronized public void addDirectRequestInternal(@NonNull Map<String, String> requestMap) {        long pccTsStartAddDirectRequest = 0L;        if (pcc != null) {            pccTsStartAddDirectRequest = UtilsTime.getNanoTime();        }        L.i("[ModuleRequestQueue] Calling addDirectRequestInternal");        if (!_cly.isInitialized()) {            L.e("Countly.sharedInstance().init must be called before adding direct request, returning");            return;        }        if (!consentProvider.anyConsentGiven()) {            L.e("[ModuleRequestQueue] addDirectRequest, no consent is given, returning");            return;        }        if (requestMap == null || requestMap.isEmpty()) {            L.e("[ModuleRequestQueue] addDirectRequest, provided requestMap was null or empty, returning");            return;        }        Map<String, String> filteredRequestMap = new HashMap<>();        for (Map.Entry<String, String> entry : requestMap.entrySet()) {            String key = entry.getKey();            Object value = entry.getValue();            boolean isPreDefinedKey = false;            for (String preDefinedKey : preDefinedKeys) {                if (preDefinedKey.equals(key)) {                    isPreDefinedKey = true;                    L.w("[ModuleRequestQueue] addDirectRequest, removing provided key: [" + key + "] is a restricted key.");                    break;                }            }            if (!isPreDefinedKey) {                filteredRequestMap.put(key, value.toString());            }        }        if (filteredRequestMap.isEmpty()) {            L.e("[ModuleRequestQueue] addDirectRequest, filteredRequestMap was null or empty, returning");            return;        }        int requestDataCount = requestMap.size();        int filteredDataCount = filteredRequestMap.size();        int delta = requestDataCount - filteredDataCount;        if (delta > 0) {            L.w("[ModuleRequestQueue] addDirectRequest, [" + delta + "] restricted keys are removed");        }        requestQueueProvider.sendDirectRequest(filteredRequestMap);        if (pcc != null) {            pcc.TrackCounterTimeNs("ModuleRequestQueue_addDirectRequestInternal", UtilsTime.getNanoTime() - pccTsStartAddDirectRequest);        }    }    void esWriteCachesToPersistenceInternal(@Nullable ExplicitStorageCallback callback) {        L.i("[ModuleRequestQueue] Calling esWriteCachesToPersistenceInternal");        storageProvider.esWriteCacheToStorage(callback);    }    boolean doesBelongToCurrentAppKeyOrDeviceId(@NonNull String request) {        return request.contains(APP_KEY_KEY + "=" + baseInfoProvider.getAppKey()) && request.contains(DEVICE_ID_KEY + "=" + deviceIdProvider.getDeviceId());    }    @Override    void halt() {        requestQueueInterface = null;    }    public class RequestQueue {        public boolean isHttpPostForced() {            synchronized (_cly) {                L.v("[RequestQueue] Calling 'isHttpPostForced'");                return isHttpPostForcedInternal();            }        }        public boolean isDeviceAppCrawler() {            synchronized (_cly) {                L.v("[RequestQueue] Calling 'isDeviceAppCrawler'");                return isDeviceAppCrawlerInternal();            }        }        public boolean ifShouldIgnoreCrawlers() {            synchronized (_cly) {                L.v("[RequestQueue] Calling 'ifShouldIgnoreCrawlers'");                return ifShouldIgnoreCrawlersInternal();            }        }        public void flushQueues() {            synchronized (_cly) {                L.v("[RequestQueue] Calling 'flushQueues'");                flushQueuesInternal();            }        }        public void attemptToSendStoredRequests() {            synchronized (_cly) {                L.v("[RequestQueue] Calling 'attemptToSendStoredRequestsInternal'");                attemptToSendStoredRequestsInternal();            }        }        public void overwriteAppKeys() {            synchronized (_cly) {                L.i("[Countly] Calling overwriteAppKeys");                requestQueueOverwriteAppKeysInternal();            }        }        public void eraseWrongAppKeyRequests() {            synchronized (_cly) {                L.i("[Countly] Calling eraseWrongAppKeyRequests");                requestQueueEraseAppKeysRequestsInternal();            }        }        public void addDirectRequest(@NonNull Map<String, String> requestMap) {            synchronized (_cly) {                L.i("[Countly] Calling addDirectRequest");                addDirectRequestInternal(requestMap);            }        }        public void esWriteCachesToPersistence() {            synchronized (_cly) {                L.i("[Countly] Calling esWriteCachesToStorage");                esWriteCachesToPersistenceInternal(null);            }        }        public void esWriteCachesToPersistence(@Nullable ExplicitStorageCallback callback) {            synchronized (_cly) {                L.i("[Countly] Calling esWriteCachesToStorage");                esWriteCachesToPersistenceInternal(callback);            }        }    }}package ly.count.android.sdk;import android.app.Activity;import android.content.res.Configuration;import androidx.annotation.NonNull;import java.util.List;abstract class ModuleBase {    final Countly _cly;    ModuleLog L;    ConsentProvider consentProvider;    StorageProvider storageProvider;    EventProvider eventProvider;    RequestQueueProvider requestQueueProvider;    DeviceIdProvider deviceIdProvider;    BaseInfoProvider baseInfoProvider;    ViewIdProvider viewIdProvider;    ConfigurationProvider configProvider;    HealthTracker healthTracker;    DeviceInfo deviceInfo;    PerformanceCounterCollector pcc;    ModuleBase(@NonNull Countly cly, @NonNull CountlyConfig config) {        _cly = cly;        L = cly.L;        consentProvider = config.consentProvider;        storageProvider = config.storageProvider;        eventProvider = config.eventProvider;        requestQueueProvider = config.requestQueueProvider;        deviceIdProvider = config.deviceIdProvider;        baseInfoProvider = config.baseInfoProvider;        viewIdProvider = config.viewIdProvider;        configProvider = config.configProvider;        healthTracker = config.healthTracker;        deviceInfo = config.deviceInfo;        pcc = config.pcc;    }    void halt() {        throw new UnsupportedOperationException();    }    void onConfigurationChanged(Configuration newConfig) {    }    void onActivityStarted(Activity activity, int updatedActivityCount) {    }    void onActivityStopped(int updatedActivityCount) {    }    void callbackOnActivityResumed(Activity activity) {    }    void callbackOnActivityStopped(Activity activity) {    }    void deviceIdChanged(boolean withoutMerge) {    }    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {    }    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {    }    void sdkConfigurationChanged() {    }    void initFinished(@NonNull CountlyConfig config) {    }}package ly.count.android.sdk;import android.annotation.SuppressLint;import android.app.Activity;import android.app.Application;import android.content.ComponentCallbacks;import android.content.Context;import android.content.res.Configuration;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.lifecycle.Lifecycle;import androidx.lifecycle.ProcessLifecycleOwner;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;public class Countly {    private final String DEFAULT_COUNTLY_SDK_VERSION_STRING = "24.7.8";    private final String DEFAULT_COUNTLY_SDK_NAME = "java-native-android";    public String COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;    public String COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;    protected static final String DEFAULT_APP_VERSION = "1.0";    public static final String TAG = "Countly";    public ModuleLog L = new ModuleLog();    public static final String CONSENT_BROADCAST = "ly.count.android.sdk.Countly.CONSENT_BROADCAST";    int EVENT_QUEUE_SIZE_THRESHOLD = 100;    private static final long TIMER_DELAY_IN_SECONDS = 60;    protected static String[] publicKeyPinCertificates;    protected static String[] certificatePinCertificates;    interface LifecycleObserver {        boolean LifeCycleAtleastStarted();    }    public enum CountlyMessagingMode {        TEST,        PRODUCTION,    }    public enum CountlyMessagingProvider {        FCM,            HMS,        }    final int maxKeyLengthDefault = 128;    final int maxValueSizeDefault = 256;    final int maxSegmentationValuesDefault = 100;    final int maxBreadcrumbCountDefault = 100;    final int maxStackTraceLinesPerThreadDefault = 30;    final int maxStackTraceLineLengthDefault = 200;    final int maxStackTraceThreadCountDefault = 50;    private static class SingletonHolder {        @SuppressLint("StaticFieldLeak")        static final Countly instance = new Countly();    }    ConnectionQueue connectionQueue_;    private ScheduledExecutorService timerService_;    private ScheduledFuture<?> timerFuture = null;    private int activityCount_;    boolean disableUpdateSessionRequests_ = false;    boolean sdkIsInitialised = false;    BaseInfoProvider baseInfoProvider;    RequestQueueProvider requestQueueProvider;    private boolean enableLogging_;    Context context_;    List<ModuleBase> modules = new ArrayList<>();    ModuleCrash moduleCrash = null;    ModuleEvents moduleEvents = null;    ModuleViews moduleViews = null;    ModuleRatings moduleRatings = null;    ModuleSessions moduleSessions = null;    ModuleRemoteConfig moduleRemoteConfig = null;    ModuleAPM moduleAPM = null;    ModuleConsent moduleConsent = null;    ModuleDeviceId moduleDeviceId = null;    ModuleLocation moduleLocation = null;    ModuleFeedback moduleFeedback = null;    ModuleRequestQueue moduleRequestQueue = null;    ModuleAttribution moduleAttribution = null;    ModuleUserProfile moduleUserProfile = null;    ModuleConfiguration moduleConfiguration = null;    ModuleHealthCheck moduleHealthCheck = null;    ModuleContent moduleContent = null;    CountlyStore countlyStore;    boolean isHttpPostForced = false;    private boolean addMetadataToPushIntents = false;    private boolean calledAtLeastOnceOnStart = false;    protected boolean isBeginSessionSent = false;    Map<String, String> requestHeaderCustomValues;    static long applicationStart = System.currentTimeMillis();    String[] locationFallback;    protected CountlyConfig config_ = null;    final static long lastRegistrationCallDebounceDuration = 60 * 1000;    long lastRegistrationCallTs = 0;    String lastRegistrationCallID = null;    CountlyMessagingProvider lastRegistrationCallProvider = null;    boolean applicationClassProvided = false;    public static class CountlyFeatureNames {        public static final String sessions = "sessions";        public static final String events = "events";        public static final String views = "views";        public static final String scrolls = "scrolls";        public static final String clicks = "clicks";        public static final String location = "location";        public static final String crashes = "crashes";        public static final String attribution = "attribution";        public static final String users = "users";        public static final String push = "push";        public static final String starRating = "star-rating";        public static final String apm = "apm";        public static final String feedback = "feedback";        public static final String remoteConfig = "remote-config";        public static final String content = "content";    }    public static Countly sharedInstance() {        return SingletonHolder.instance;    }    Countly() {        connectionQueue_ = new ConnectionQueue();        timerService_ = Executors.newSingleThreadScheduledExecutor();    }    private void startTimerService(ScheduledExecutorService service, ScheduledFuture<?> previousTimer, long timerDelay) {        if (previousTimer != null && !previousTimer.isCancelled()) {            previousTimer.cancel(false);        }        if (timerDelay < 1) {            timerDelay = 1;        }        timerFuture = service.scheduleWithFixedDelay(this::onTimer, timerDelay, timerDelay, TimeUnit.SECONDS);    }    public synchronized Countly init(CountlyConfig config) {        if (config == null) {            throw new IllegalArgumentException("Can't init SDK with 'null' config");        }        if (config.loggingEnabled) {            setLoggingEnabled(true);        }        L.SetListener(config.providedLogCallback);        if (COUNTLY_SDK_NAME.equals(DEFAULT_COUNTLY_SDK_NAME) && COUNTLY_SDK_VERSION_STRING.equals(DEFAULT_COUNTLY_SDK_VERSION_STRING)) {            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "]");        } else {            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "] default name[" + DEFAULT_COUNTLY_SDK_NAME + "] default version[" + DEFAULT_COUNTLY_SDK_VERSION_STRING + "]");        }        if (config.context == null) {            if (config.application != null) {                L.d("[Init] No explicit context provided. Using context from the provided application class");                config.context = config.application;            } else {                throw new IllegalArgumentException("valid context is required in Countly init, but was provided 'null'");            }        } else {            L.d("[Init] Using explicitly provided context");        }        if (!UtilsNetworking.isValidURL(config.serverURL)) {            throw new IllegalArgumentException("valid serverURL is required");        }        if (config.serverURL.charAt(config.serverURL.length() - 1) == '/') {            L.v("[Init] Removing trailing '/' from provided server url");            config.serverURL = config.serverURL.substring(0, config.serverURL.length() - 1);        }        if (config.appKey == null || config.appKey.isEmpty()) {            throw new IllegalArgumentException("valid appKey is required, but was provided either 'null' or empty String");        }        if (config.application == null) {            L.w("[Init] Initialising the SDK without providing the application class. Some functionality will not work.");        }        applicationClassProvided = config.application != null;        if (config.deviceID != null && config.deviceID.isEmpty()) {            L.w("[Countly] init, Provided device ID is an empty string. It will be ignored. And a new one will be generated by the SDK.");            config.setDeviceId(null);        }        L.d("[Init] SDK initialised with the URL:[" + config.serverURL + "] and the appKey:[" + config.appKey + "]");        if (L.logEnabled()) {            L.i("[Init] Checking init parameters");            Class contextClass = config.context.getClass();            Class contextSuperClass = contextClass.getSuperclass();            String contextText = "[Init] Provided Context [" + config.context.getClass().getSimpleName() + "]";            if (contextSuperClass != null) {                contextText += ", it's superclass: [" + contextSuperClass.getSimpleName() + "]";            }            L.i(contextText);        }        context_ = config.context.getApplicationContext();        if (!sdkIsInitialised) {            L.d("[Init] About to init internal systems");            config_ = config;            if (config.sdkInternalLimits.maxKeyLength != null) {                if (config.sdkInternalLimits.maxKeyLength < 1) {                    config.sdkInternalLimits.maxKeyLength = 1;                    L.w("[Init] provided 'maxKeyLength' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxKeyLength' override:[" + config.sdkInternalLimits.maxKeyLength + "]");            } else {                config.sdkInternalLimits.maxKeyLength = maxKeyLengthDefault;            }            if (config.sdkInternalLimits.maxValueSize != null) {                if (config.sdkInternalLimits.maxValueSize < 1) {                    config.sdkInternalLimits.maxValueSize = 1;                    L.w("[Init] provided 'maxValueSize' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxValueSize' override:[" + config.sdkInternalLimits.maxValueSize + "]");            } else {                config.sdkInternalLimits.maxValueSize = maxValueSizeDefault;            }            if (config.sdkInternalLimits.maxSegmentationValues != null) {                if (config.sdkInternalLimits.maxSegmentationValues < 1) {                    config.sdkInternalLimits.maxSegmentationValues = 1;                    L.w("[Init] provided 'maxSegmentationValues' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxSegmentationValues' override:[" + config.sdkInternalLimits.maxSegmentationValues + "]");            } else {                config.sdkInternalLimits.maxSegmentationValues = maxSegmentationValuesDefault;            }            if (config.sdkInternalLimits.maxBreadcrumbCount != null) {                if (config.sdkInternalLimits.maxBreadcrumbCount < 1) {                    config.sdkInternalLimits.maxBreadcrumbCount = 1;                    L.w("[Init] provided 'maxBreadcrumbCount' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxBreadcrumbCount' override:[" + config.sdkInternalLimits.maxBreadcrumbCount + "]");            } else {                config.sdkInternalLimits.maxBreadcrumbCount = maxBreadcrumbCountDefault;            }            if (config.sdkInternalLimits.maxStackTraceLinesPerThread != null) {                if (config.sdkInternalLimits.maxStackTraceLinesPerThread < 1) {                    config.sdkInternalLimits.maxStackTraceLinesPerThread = 1;                    L.w("[Init] provided 'maxStackTraceLinesPerThread' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxStackTraceLinesPerThread' override:[" + config.sdkInternalLimits.maxStackTraceLinesPerThread + "]");            } else {                config.sdkInternalLimits.maxStackTraceLinesPerThread = maxStackTraceLinesPerThreadDefault;            }            if (config.sdkInternalLimits.maxStackTraceLineLength != null) {                if (config.sdkInternalLimits.maxStackTraceLineLength < 1) {                    config.sdkInternalLimits.maxStackTraceLineLength = 1;                    L.w("[Init] provided 'maxStackTraceLineLength' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxStackTraceLineLength' override:[" + config.sdkInternalLimits.maxStackTraceLineLength + "]");            } else {                config.sdkInternalLimits.maxStackTraceLineLength = maxStackTraceLineLengthDefault;            }            long timerDelay = TIMER_DELAY_IN_SECONDS;            if (config.sessionUpdateTimerDelay != null) {                L.d("[Init] Setting custom session update timer delay, [" + config.sessionUpdateTimerDelay + "]");                timerDelay = config.sessionUpdateTimerDelay;            }            startTimerService(timerService_, timerFuture, timerDelay);            if (config.explicitStorageModeEnabled) {                L.i("[Init] Explicit storage mode is being enabled");            }            if (config.countlyStore != null) {                countlyStore = config.countlyStore;            } else {                countlyStore = new CountlyStore(config.context, L, config.explicitStorageModeEnabled);                config.setCountlyStore(countlyStore);            }            if (config.pcc != null) {                L.i("[Init] Attaching a performance counter collector");                countlyStore.pcc = config.pcc;            }            if (config.maxRequestQueueSize < 1) {                L.e("[Init] provided request queue size is less than 1. Replacing it with 1.");                config.maxRequestQueueSize = 1;            }            L.d("[Init] request queue size set to [" + config.maxRequestQueueSize + "]");            countlyStore.setLimits(config.maxRequestQueueSize);            if (config.storageProvider == null) {                config.storageProvider = config.countlyStore;            } else {                L.d("[Init] Custom event storage provider was provided");            }            if (config.eventQueueProvider == null) {                config.eventQueueProvider = countlyStore;            } else {                L.d("[Init] Custom event queue provider was provided");            }            if (config.requestQueueProvider == null) {                config.requestQueueProvider = connectionQueue_;            } else {                L.d("[Init] Custom request queue provider was provided");            }            if (config.safeViewIDGenerator == null) {                config.safeViewIDGenerator = new SafeIDGenerator() {                    @NonNull @Override public String GenerateValue() {                        return Utils.safeRandomVal();                    }                };            }            if (config.safeEventIDGenerator == null) {                config.safeEventIDGenerator = new SafeIDGenerator() {                    @NonNull @Override public String GenerateValue() {                        return Utils.safeRandomVal();                    }                };            }            if (config.immediateRequestGenerator == null) {                config.immediateRequestGenerator = new ImmediateRequestGenerator() {                    @Override public ImmediateRequestI CreateImmediateRequestMaker() {                        return (new ImmediateRequestMaker());                    }                };            }            if (config.lifecycleObserver == null) {                config.lifecycleObserver = new LifecycleObserver() {                    @Override public boolean LifeCycleAtleastStarted() {                        return lifecycleStateAtLeastStartedInternal();                    }                };            }            if (config.metricProviderOverride != null) {                L.d("[Init] Custom metric provider was provided");            }            config.deviceInfo = new DeviceInfo(config.metricProviderOverride);            if (config.tamperingProtectionSalt != null) {                L.d("[Init] Parameter tampering protection salt set");            }            if (config.dropAgeHours < 0) {                config.dropAgeHours = 0;                L.d("[Init] Drop older requests threshold can not be negative. No threshold will be set.");            }            if (config.dropAgeHours > 0) {                L.d("[Init] Drop older requests threshold set to:[" + config.dropAgeHours + "] hours");            }            if (connectionQueue_ == null) {                L.e("[Init] SDK failed to initialize because the connection queue failed to be created");                return this;            }            if (locationFallback != null && config.locationCountyCode == null && config.locationCity == null && config.locationLocation == null && config.locationIpAddress == null) {                config.locationCountyCode = locationFallback[0];                config.locationCity = locationFallback[1];                config.locationLocation = locationFallback[2];                config.locationIpAddress = locationFallback[3];            }            try {                Map<String, Object> migrationParams = new HashMap<>();                migrationParams.put(MigrationHelper.key_from_0_to_1_custom_id_set, config.deviceID != null);                MigrationHelper mHelper = new MigrationHelper(config.storageProvider, L, context_);                mHelper.doWork(migrationParams);            } catch (Exception ex) {                L.e("[Init] SDK failed while performing data migration. SDK is not capable to initialize.");                return this;            }            moduleHealthCheck = new ModuleHealthCheck(this, config);            moduleConfiguration = new ModuleConfiguration(this, config);            moduleRequestQueue = new ModuleRequestQueue(this, config);            moduleConsent = new ModuleConsent(this, config);            moduleDeviceId = new ModuleDeviceId(this, config);            moduleCrash = new ModuleCrash(this, config);            moduleEvents = new ModuleEvents(this, config);            moduleUserProfile = new ModuleUserProfile(this, config);            moduleViews = new ModuleViews(this, config);            moduleRatings = new ModuleRatings(this, config);            moduleSessions = new ModuleSessions(this, config);            moduleRemoteConfig = new ModuleRemoteConfig(this, config);            moduleAPM = new ModuleAPM(this, config);            moduleLocation = new ModuleLocation(this, config);            moduleFeedback = new ModuleFeedback(this, config);            moduleAttribution = new ModuleAttribution(this, config);            moduleContent = new ModuleContent(this, config);            modules.clear();            modules.add(moduleConfiguration);            modules.add(moduleRequestQueue);            modules.add(moduleConsent);            modules.add(moduleDeviceId);            modules.add(moduleCrash);            modules.add(moduleEvents);            modules.add(moduleUserProfile);            modules.add(moduleViews);            modules.add(moduleRatings);            modules.add(moduleSessions);            modules.add(moduleRemoteConfig);            modules.add(moduleAPM);            modules.add(moduleLocation);            modules.add(moduleFeedback);            modules.add(moduleAttribution);            modules.add(moduleContent);            modules.add(moduleHealthCheck);            if (config.testModuleListener != null) {                modules.add(config.testModuleListener);            }            moduleConfiguration.consentProvider = config.consentProvider;            moduleRequestQueue.consentProvider = config.consentProvider;            moduleHealthCheck.consentProvider = config.consentProvider;            moduleRequestQueue.deviceIdProvider = config.deviceIdProvider;            moduleConsent.eventProvider = config.eventProvider;            moduleConsent.deviceIdProvider = config.deviceIdProvider;            moduleDeviceId.eventProvider = config.eventProvider;            moduleCrash.eventProvider = config.eventProvider;            moduleEvents.viewIdProvider = config.viewIdProvider;            baseInfoProvider = config.baseInfoProvider;            requestQueueProvider = config.requestQueueProvider;            L.setHealthChecker(config.healthTracker);            L.i("[Init] Finished initialising modules");            if (config.customNetworkRequestHeaders != null) {                L.i("[Countly] Calling addCustomNetworkRequestHeaders");                requestHeaderCustomValues = config.customNetworkRequestHeaders;                connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);            }            if (config.httpPostForced) {                L.d("[Init] Setting HTTP POST to be forced");                isHttpPostForced = config.httpPostForced;            }            if (config.tamperingProtectionSalt != null) {                L.d("[Init] Enabling tamper protection");            }            if (config.dropAgeHours > 0) {                L.d("[Init] Enabling drop older request threshold");                countlyStore.setRequestAgeLimit(config.dropAgeHours);            }            if (config.pushIntentAddMetadata) {                L.d("[Init] Enabling push intent metadata");                addMetadataToPushIntents = config.pushIntentAddMetadata;            }            if (config.eventQueueSizeThreshold != null) {                L.d("[Init] Setting event queue size: [" + config.eventQueueSizeThreshold + "]");                if (config.eventQueueSizeThreshold < 1) {                    L.d("[Init] queue size can't be less than zero");                    config.eventQueueSizeThreshold = 1;                }                EVENT_QUEUE_SIZE_THRESHOLD = config.eventQueueSizeThreshold;            }            if (config.publicKeyPinningCertificates != null) {                sharedInstance().L.i("[Init] Enabling public key pinning");                publicKeyPinCertificates = config.publicKeyPinningCertificates;            }            if (config.certificatePinningCertificates != null) {                Countly.sharedInstance().L.i("[Init] Enabling certificate pinning");                certificatePinCertificates = config.certificatePinningCertificates;            }            connectionQueue_.L = L;            connectionQueue_.healthTracker = config.healthTracker;            connectionQueue_.configProvider = config.configProvider;            connectionQueue_.consentProvider = moduleConsent;            connectionQueue_.moduleRequestQueue = moduleRequestQueue;            connectionQueue_.deviceInfo = config.deviceInfo;            connectionQueue_.pcc = config.pcc;            connectionQueue_.setStorageProvider(config.storageProvider);            connectionQueue_.setupSSLContext();            connectionQueue_.setBaseInfoProvider(config.baseInfoProvider);            connectionQueue_.setDeviceId(config.deviceIdProvider);            connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);            connectionQueue_.setMetricOverride(config.metricOverride);            connectionQueue_.setContext(context_);            connectionQueue_.requestInfoProvider = new RequestInfoProvider() {                @Override public boolean isHttpPostForced() {                    return requestQueue().isHttpPostForced();                }                @Override public boolean isDeviceAppCrawler() {                    return requestQueue().isDeviceAppCrawler();                }                @Override public boolean ifShouldIgnoreCrawlers() {                    return requestQueue().ifShouldIgnoreCrawlers();                }                @Override public int getRequestDropAgeHours() {                    return config.dropAgeHours;                }                @Override public String getRequestSalt() {                    return config.tamperingProtectionSalt;                }            };            sdkIsInitialised = true;            if (config.application != null) {                L.d("[Countly] Calling registerActivityLifecycleCallbacks");                config.application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {                    @Override                    public void onActivityCreated(Activity activity, Bundle bundle) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityCreated, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityStarted(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityStarted, " + activity.getClass().getSimpleName());                        }                        onStartInternal(activity);                    }                    @Override                    public void onActivityResumed(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityResumed, " + activity.getClass().getSimpleName());                        }                        for (ModuleBase module : modules) {                            module.callbackOnActivityResumed(activity);                        }                    }                    @Override                    public void onActivityPaused(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityPaused, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityStopped(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityStopped, " + activity.getClass().getSimpleName());                        }                        onStopInternal();                        for (ModuleBase module : modules) {                            module.callbackOnActivityStopped(activity);                        }                    }                    @Override                    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivitySaveInstanceState, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityDestroyed(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityDestroyed, " + activity.getClass().getSimpleName());                        }                    }                });                config.application.registerComponentCallbacks(new ComponentCallbacks() {                    @Override                    public void onConfigurationChanged(Configuration configuration) {                        L.d("[Countly] ComponentCallbacks, onConfigurationChanged");                        onConfigurationChangedInternal(configuration);                    }                    @Override                    public void onLowMemory() {                        L.d("[Countly] ComponentCallbacks, onLowMemory");                    }                });            } else {                L.d("[Countly] Global activity listeners not registred due to no Application class");            }            if (config_.lifecycleObserver.LifeCycleAtleastStarted()) {                L.d("[Countly] SDK detects that the app is in the foreground. Increasing the activity counter and setting the foreground state.");                activityCount_++;                config.deviceInfo.inForeground();            }            L.i("[Init] About to call module 'initFinished'");            for (ModuleBase module : modules) {                module.initFinished(config);            }            L.i("[Init] Finished initialising SDK");        } else {            L.i("[Init] Getting in the 'else' block");            connectionQueue_.setContext(context_);        }        return this;    }    @SuppressWarnings("BooleanMethodIsAlwaysInverted")    public boolean isInitialized() {        return sdkIsInitialised;    }    boolean lifecycleStateAtLeastStartedInternal() {        return ProcessLifecycleOwner.get().getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED);    }    private void stopTimer() {        L.i("[Countly] stopTimer, Stopping global timer");        if (timerService_ != null) {            try {                timerService_.shutdown();                if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {                    timerService_.shutdownNow();                    if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {                        L.e("[Countly] stopTimer, Global timer must be locked");                    }                }            } catch (Throwable t) {                L.e("[Countly] stopTimer, Error while stopping global timer " + t);            }        }    }    public synchronized void halt() {        L.i("Halting Countly!");        sdkIsInitialised = false;        L.SetListener(null);        stopTimer();        if (connectionQueue_ != null) {            if (countlyStore != null) {                countlyStore.clear();            }            connectionQueue_.setContext(null);            connectionQueue_ = null;        }        activityCount_ = 0;        for (ModuleBase module : modules) {            module.halt();        }        modules.clear();        moduleCrash = null;        moduleViews = null;        moduleEvents = null;        moduleRatings = null;        moduleSessions = null;        moduleRemoteConfig = null;        moduleConsent = null;        moduleAPM = null;        moduleDeviceId = null;        moduleLocation = null;        moduleFeedback = null;        moduleRequestQueue = null;        moduleConfiguration = null;        moduleHealthCheck = null;        moduleContent = null;        COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;        COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;        connectionQueue_ = new ConnectionQueue();        timerService_ = Executors.newSingleThreadScheduledExecutor();    }    synchronized void notifyDeviceIdChange(boolean withoutMerge) {        L.d("Notifying modules that device ID changed");        for (ModuleBase module : modules) {            module.deviceIdChanged(withoutMerge);        }    }    void onStartInternal(Activity activity) {        if (L.logEnabled()) {            String activityName = "NULL ACTIVITY PROVIDED";            if (activity != null) {                activityName = activity.getClass().getSimpleName();            }            L.d("Countly onStartInternal called, name:[" + activityName + "], [" + activityCount_ + "] -> [" + (activityCount_ + 1) + "] activities now open");        }        ++activityCount_;        if (activityCount_ == 1 && !moduleSessions.manualSessionControlEnabled) {            moduleSessions.beginSessionInternal();        }        config_.deviceInfo.inForeground();        for (ModuleBase module : modules) {            module.onActivityStarted(activity, activityCount_);        }        calledAtLeastOnceOnStart = true;    }    void onStopInternal() {        L.d("Countly onStopInternal called, [" + activityCount_ + "] -> [" + (activityCount_ - 1) + "] activities now open");        if (activityCount_ == 0) {            L.e("must call onStart before onStop");            return;        }        --activityCount_;        if (activityCount_ == 0 && !moduleSessions.manualSessionControlEnabled) {            moduleSessions.endSessionInternal();        }        config_.deviceInfo.inBackground();        for (ModuleBase module : modules) {            module.onActivityStopped(activityCount_);        }    }    public synchronized void onConfigurationChangedInternal(Configuration newConfig) {        L.i("Calling [onConfigurationChangedInternal]");        for (ModuleBase module : modules) {            module.onConfigurationChanged(newConfig);        }    }    public synchronized void onStart(Activity activity) {        if (!isInitialized()) {            L.e("init must be called before onStart");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onStartInternal(activity);    }    public synchronized void onStop() {        if (!isInitialized()) {            L.e("init must be called before onStop");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onStopInternal();    }    public synchronized void onConfigurationChanged(Configuration newConfig) {        if (!isInitialized()) {            L.e("init must be called before onConfigurationChanged");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onConfigurationChanged' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onConfigurationChangedInternal(newConfig);    }    synchronized void onTimer() {        L.v("[onTimer] Calling heartbeat, Activity count:[" + activityCount_ + "]");        if (isInitialized()) {            final boolean appIsInForeground = activityCount_ > 0;            if (appIsInForeground && !moduleSessions.manualSessionControlEnabled) {                moduleSessions.updateSessionInternal();            } else if (moduleSessions.manualSessionControlEnabled && moduleSessions.manualSessionControlHybridModeEnabled && moduleSessions.sessionIsRunning()) {                moduleSessions.updateSessionInternal();            }            moduleRequestQueue.sendEventsIfNeeded(true);            moduleUserProfile.saveInternal();            requestQueueProvider.tick();        }    }    public void onRegistrationId(String registrationId, CountlyMessagingProvider provider) {        if (!config_.consentProvider.getConsent(CountlyFeatureNames.push)) {            return;        }        if (!isInitialized()) {            L.w("[onRegistrationId] Calling this before the SDK is initialized.");        }        long currentTs = UtilsTime.currentTimestampMs();        long timeDelta = currentTs - lastRegistrationCallTs;        if (lastRegistrationCallID != null && lastRegistrationCallID.equals(registrationId) &&            lastRegistrationCallProvider != null && lastRegistrationCallProvider == provider &&            timeDelta < lastRegistrationCallDebounceDuration) {            L.w("[onRegistrationId] Calling this with the same values within the debounce interval. elapsedT:[" + timeDelta + "] ms");            return;        }        lastRegistrationCallTs = currentTs;        lastRegistrationCallID = registrationId;        lastRegistrationCallProvider = provider;        connectionQueue_.tokenSession(registrationId, provider);    }    public void setLoggingEnabled(final boolean enableLogging) {        enableLogging_ = enableLogging;        L.d("Enabling logging");    }    public boolean isLoggingEnabled() {        return enableLogging_;    }    public boolean hasBeenCalledOnStart() {        return calledAtLeastOnceOnStart;    }    public ModuleCrash.Crashes crashes() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing crashes");            return null;        }        return moduleCrash.crashesInterface;    }    public ModuleEvents.Events events() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing events");            return null;        }        return moduleEvents.eventsInterface;    }    public ModuleViews.Views views() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing views");            return null;        }        return moduleViews.viewsInterface;    }    public ModuleRatings.Ratings ratings() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing ratings");            return null;        }        return moduleRatings.ratingsInterface;    }    public ModuleSessions.Sessions sessions() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing sessions");            return null;        }        return moduleSessions.sessionInterface;    }    public ModuleRemoteConfig.RemoteConfig remoteConfig() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing remote config");            return null;        }        return moduleRemoteConfig.remoteConfigInterface;    }    public ModuleAPM.Apm apm() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing apm");            return null;        }        return moduleAPM.apmInterface;    }    public ModuleConsent.Consent consent() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing consent");            return null;        }        return moduleConsent.consentInterface;    }    public ModuleLocation.Location location() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing location");            return null;        }        return moduleLocation.locationInterface;    }    public ModuleFeedback.Feedback feedback() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing feedback");            return null;        }        return moduleFeedback.feedbackInterface;    }    public ModuleRequestQueue.RequestQueue requestQueue() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing request queue");            return null;        }        return moduleRequestQueue.requestQueueInterface;    }    public ModuleAttribution.Attribution attribution() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing attribution");            return null;        }        return moduleAttribution.attributionInterface;    }    public ModuleDeviceId.DeviceId deviceId() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing deviceId");            return null;        }        return moduleDeviceId.deviceIdInterface;    }    public ModuleUserProfile.UserProfile userProfile() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing user profile");            return null;        }        return moduleUserProfile.userProfileInterface;    }    public ModuleContent.Content contents() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing content");            return null;        }        return moduleContent.contentInterface;    }    public static void applicationOnCreate() {    }    ConnectionQueue getConnectionQueue() {        return connectionQueue_;    }    ExecutorService getTimerService() {        return timerService_;    }    long getPrevSessionDurationStartTime() {        return moduleSessions.prevSessionDurationStartTime_;    }    void setPrevSessionDurationStartTime(final long prevSessionDurationStartTime) {        moduleSessions.prevSessionDurationStartTime_ = prevSessionDurationStartTime;    }    int getActivityCount() {        return activityCount_;    }    synchronized boolean getDisableUpdateSessionRequests() {        return disableUpdateSessionRequests_;    }}package ly.count.android.sdk;import android.app.Activity;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.net.Uri;import android.os.Handler;import android.os.Looper;import android.view.LayoutInflater;import android.view.View;import android.webkit.WebResourceRequest;import android.webkit.WebResourceResponse;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.RatingBar;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.HashMap;import java.util.Map;import org.json.JSONException;import org.json.JSONObject;public class ModuleRatings extends ModuleBase {    StarRatingCallback starRatingCallback_;    boolean showStarRatingDialogOnFirstActivity = false;    final Ratings ratingsInterface;    ModuleRatings(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleRatings] Initialising");        starRatingCallback_ = config.starRatingCallback;        setStarRatingInitConfig(config.starRatingSessionLimit, config.starRatingTextTitle, config.starRatingTextMessage, config.starRatingTextDismiss);        setIfRatingDialogIsCancellableInternal(config.starRatingDialogIsCancellable);        setShowDialogAutomatically(config.starRatingShownAutomatically);        setStarRatingDisableAskingForEachAppVersion(config.starRatingDisableAskingForEachAppVersion);        ratingsInterface = new Ratings();    }    void recordManualRatingInternal(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {        L.d("[ModuleRatings] Calling recordManualRatingInternal");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            return;        }        if (widgetId == null) {            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is null, returning");            return;        }        if (widgetId.isEmpty()) {            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is empty, returning");            return;        }        if (rating < 1) {            rating = 1;            L.d("[ModuleRatings] recordManualRatingInternal, given rating too low, defaulting to 1");        }        if (rating > 5) {            rating = 5;            L.d("[ModuleRatings] recordManualRatingInternal, given rating too high, defaulting to 5");        }        String truncatedEmail = UtilsInternalLimits.truncateValueSize(email, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");        String truncatedComment = UtilsInternalLimits.truncateValueSize(comment, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");        Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", deviceInfo.mp.getAppVersion(_cly.context_));        segm.put("rating", "" + rating);        segm.put("widget_id", widgetId);        segm.put("contactMe", userCanBeContacted);        if (truncatedEmail != null && !truncatedEmail.isEmpty()) {            segm.put("email", truncatedEmail);        }        if (truncatedComment != null && !truncatedComment.isEmpty()) {            segm.put("comment", truncatedComment);        }        eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);    }    private void saveStarRatingPreferences(final StarRatingPreferences srp) {        storageProvider.setStarRatingPreferences(srp.toJSON().toString());    }    void setStarRatingInitConfig(final int limit, final String starRatingTextTitle, final String starRatingTextMessage, final String starRatingTextDismiss) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        if (limit >= 0) {            srp.sessionLimit = limit;        }        if (starRatingTextTitle != null) {            srp.dialogTextTitle = starRatingTextTitle;        }        if (starRatingTextMessage != null) {            srp.dialogTextMessage = starRatingTextMessage;        }        if (starRatingTextDismiss != null) {            srp.dialogTextDismiss = starRatingTextDismiss;        }        saveStarRatingPreferences(srp);    }    void setShowDialogAutomatically(final boolean shouldShow) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.automaticRatingShouldBeShown = shouldShow;        saveStarRatingPreferences(srp);    }    boolean getIfStarRatingShouldBeShownAutomatically() {        StarRatingPreferences srp = loadStarRatingPreferences(_cly.countlyStore);        return srp.automaticRatingShouldBeShown;    }    void setStarRatingDisableAskingForEachAppVersion(final boolean disableAsking) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.disabledAutomaticForNewVersions = disableAsking;        saveStarRatingPreferences(srp);    }    void registerAppSession(final Context context, final StarRatingCallback starRatingCallback) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        String currentAppVersion = deviceInfo.mp.getAppVersion(context);        if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {            srp.appVersion = currentAppVersion;            srp.isShownForCurrentVersion = false;            srp.sessionAmount = 0;        }        srp.sessionAmount++;        if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {            showStarRatingDialogOnFirstActivity = true;        }        saveStarRatingPreferences(srp);    }    static int getAutomaticStarRatingSessionLimitInternal(final StorageProvider sp) {        StarRatingPreferences srp = loadStarRatingPreferences(sp);        return srp.sessionLimit;    }    int getCurrentVersionsSessionCountInternal(final StorageProvider sp) {        StarRatingPreferences srp = loadStarRatingPreferences(sp);        return srp.sessionAmount;    }    void clearAutomaticStarRatingSessionCountInternal() {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.sessionAmount = 0;        saveStarRatingPreferences(srp);    }    void setIfRatingDialogIsCancellableInternal(final boolean isCancellable) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.isDialogCancellable = isCancellable;        saveStarRatingPreferences(srp);    }    static class StarRatingPreferences {        String appVersion = "";         int sessionLimit = 5;         int sessionAmount = 0;         boolean isShownForCurrentVersion = false;         boolean automaticRatingShouldBeShown = false;         boolean disabledAutomaticForNewVersions = false;         boolean automaticHasBeenShown = false;         boolean isDialogCancellable = true;         String dialogTextTitle = "App rating";        String dialogTextMessage = "Please rate this app";        String dialogTextDismiss = "Cancel";        private static final String KEY_APP_VERSION = "sr_app_version";        private static final String KEY_SESSION_LIMIT = "sr_session_limit";        private static final String KEY_SESSION_AMOUNT = "sr_session_amount";        private static final String KEY_IS_SHOWN_FOR_CURRENT = "sr_is_shown";        private static final String KEY_AUTOMATIC_RATING_IS_SHOWN = "sr_is_automatic_shown";        private static final String KEY_DISABLE_AUTOMATIC_NEW_VERSIONS = "sr_is_disable_automatic_new";        private static final String KEY_AUTOMATIC_HAS_BEEN_SHOWN = "sr_automatic_has_been_shown";        private static final String KEY_DIALOG_IS_CANCELLABLE = "sr_automatic_dialog_is_cancellable";        private static final String KEY_DIALOG_TEXT_TITLE = "sr_text_title";        private static final String KEY_DIALOG_TEXT_MESSAGE = "sr_text_message";        private static final String KEY_DIALOG_TEXT_DISMISS = "sr_text_dismiss";        JSONObject toJSON() {            final JSONObject json = new JSONObject();            try {                json.put(KEY_APP_VERSION, appVersion);                json.put(KEY_SESSION_LIMIT, sessionLimit);                json.put(KEY_SESSION_AMOUNT, sessionAmount);                json.put(KEY_IS_SHOWN_FOR_CURRENT, isShownForCurrentVersion);                json.put(KEY_AUTOMATIC_RATING_IS_SHOWN, automaticRatingShouldBeShown);                json.put(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, disabledAutomaticForNewVersions);                json.put(KEY_AUTOMATIC_HAS_BEEN_SHOWN, automaticHasBeenShown);                json.put(KEY_DIALOG_IS_CANCELLABLE, isDialogCancellable);                json.put(KEY_DIALOG_TEXT_TITLE, dialogTextTitle);                json.put(KEY_DIALOG_TEXT_MESSAGE, dialogTextMessage);                json.put(KEY_DIALOG_TEXT_DISMISS, dialogTextDismiss);            } catch (JSONException e) {                Countly.sharedInstance().L.w("Got exception converting an StarRatingPreferences to JSON", e);            }            return json;        }        static StarRatingPreferences fromJSON(final JSONObject json) {            StarRatingPreferences srp = new StarRatingPreferences();            if (json != null) {                try {                    srp.appVersion = json.getString(KEY_APP_VERSION);                    srp.sessionLimit = json.optInt(KEY_SESSION_LIMIT, 5);                    srp.sessionAmount = json.optInt(KEY_SESSION_AMOUNT, 0);                    srp.isShownForCurrentVersion = json.optBoolean(KEY_IS_SHOWN_FOR_CURRENT, false);                    srp.automaticRatingShouldBeShown = json.optBoolean(KEY_AUTOMATIC_RATING_IS_SHOWN, true);                    srp.disabledAutomaticForNewVersions = json.optBoolean(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, false);                    srp.automaticHasBeenShown = json.optBoolean(KEY_AUTOMATIC_HAS_BEEN_SHOWN, false);                    srp.isDialogCancellable = json.optBoolean(KEY_DIALOG_IS_CANCELLABLE, true);                    if (!json.isNull(KEY_DIALOG_TEXT_TITLE)) {                        srp.dialogTextTitle = json.getString(KEY_DIALOG_TEXT_TITLE);                    }                    if (!json.isNull(KEY_DIALOG_TEXT_MESSAGE)) {                        srp.dialogTextMessage = json.getString(KEY_DIALOG_TEXT_MESSAGE);                    }                    if (!json.isNull(KEY_DIALOG_TEXT_DISMISS)) {                        srp.dialogTextDismiss = json.getString(KEY_DIALOG_TEXT_DISMISS);                    }                } catch (JSONException e) {                    Countly.sharedInstance().L.w("Got exception converting JSON to a StarRatingPreferences", e);                }            }            return srp;        }    }    void showStarRatingInternal(final Context context, final StarRatingCallback callback) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        showStarRatingCustom(context, srp.dialogTextTitle, srp.dialogTextMessage, srp.dialogTextDismiss, srp.isDialogCancellable, callback);    }    static StarRatingPreferences loadStarRatingPreferences(final StorageProvider sp) {        String srpString = sp.getStarRatingPreferences();        StarRatingPreferences srp;        if (!srpString.equals("")) {            JSONObject srJSON;            try {                srJSON = new JSONObject(srpString);                srp = StarRatingPreferences.fromJSON(srJSON);            } catch (JSONException e) {                e.printStackTrace();                srp = new StarRatingPreferences();            }        } else {            srp = new StarRatingPreferences();        }        return srp;    }    void showStarRatingCustom(@NonNull final Context context, final String title, final String message, final String cancelText, final boolean isCancellable, @Nullable final StarRatingCallback callback) {        if (!(context instanceof Activity)) {            L.e("[ModuleRatings] Can't show star rating dialog, the provided context is not based off a activity");            return;        }        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);        View dialogLayout = inflater.inflate(R.layout.star_rating_layout, null);        RatingBar ratingBar = dialogLayout.findViewById(R.id.ratingBar);        final AlertDialog.Builder builder = new AlertDialog.Builder(context)            .setTitle(title)            .setMessage(message)            .setCancelable(isCancellable)            .setView(dialogLayout)            .setOnCancelListener(new DialogInterface.OnCancelListener() {                @Override                public void onCancel(DialogInterface dialogInterface) {                    if (callback != null) {                        callback.onDismiss();                    }                }            })            .setPositiveButton(cancelText, new DialogInterface.OnClickListener() {                @Override                public void onClick(DialogInterface dialogInterface, int i) {                    if (callback != null) {                        callback.onDismiss();                    }                }            });        final AlertDialog dialog = builder.show();        ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {            @Override            public void onRatingChanged(RatingBar ratingBar, float v, boolean b) {                int rating = (int) v;                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {                    Map<String, Object> segm = new HashMap<>();                    segm.put("platform", "android");                    segm.put("app_version", deviceInfo.mp.getAppVersion(context));                    segm.put("rating", "" + rating);                    eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);                }                dialog.dismiss();                if (callback != null) {                    callback.onRate(rating);                }            }        });    }    synchronized void showFeedbackPopupInternal(@Nullable final String widgetId, @Nullable final String closeButtonText, @Nullable final Activity activity, @Nullable final FeedbackRatingCallback devCallback) {        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");        if (widgetId == null || widgetId.isEmpty()) {            if (devCallback != null) {                devCallback.callback("Countly widgetId cannot be null or empty");            }            L.e("[ModuleRatings] Countly widgetId cannot be null or empty");            return;        }        if (activity == null) {            if (devCallback != null) {                devCallback.callback("When showing feedback popup, Activity can't be null");            }            L.e("[ModuleRatings] When showing feedback popup, Activity can't be null");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            if (devCallback != null) {                devCallback.callback("Consent is not granted");            }            return;        }        final boolean deviceIsPhone;        final boolean deviceIsTablet;        final boolean deviceIsTv;        deviceIsTv = Utils.isDeviceTv(activity);        if (!deviceIsTv) {            deviceIsPhone = !Utils.isDeviceTablet(activity);            deviceIsTablet = Utils.isDeviceTablet(activity);        } else {            deviceIsTablet = false;            deviceIsPhone = false;        }        String requestData = requestQueueProvider.prepareRatingWidgetRequest(widgetId);        final String ratingWidgetUrl = baseInfoProvider.getServerURL() + "/feedback?widget_id=" + widgetId +            "&device_id=" + UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()) +            "&app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey());        L.d("[ModuleRatings] rating widget url :[" + ratingWidgetUrl + "]");        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        (new ImmediateRequestMaker()).doWork(requestData, "/o/feedback/widget", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override            public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably a lack of connection to the server");                    if (devCallback != null) {                        devCallback.callback("Not possible to show Rating popup, probably no internet connection or wrong widget id");                    }                    return;                }                if (!checkResponse.has("target_devices")) {                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably using a widget_id not intended for the rating widget");                    if (devCallback != null) {                        devCallback.callback("Not possible to show Rating popup, probably using a widget_id not intended for the rating widget");                    }                    return;                }                try {                    JSONObject jDevices = checkResponse.getJSONObject("target_devices");                    boolean showOnTv = jDevices.optBoolean("desktop", false);                    boolean showOnPhone = jDevices.optBoolean("phone", false);                    boolean showOnTablet = jDevices.optBoolean("tablet", false);                    if ((deviceIsPhone && showOnPhone) || (deviceIsTablet && showOnTablet) || (deviceIsTv && showOnTv)) {                        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");                        Handler handler = new Handler(Looper.getMainLooper());                        handler.post(new Runnable() {                            public void run() {                                L.d("[ModuleRatings] Calling on main thread");                                RatingDialogWebView webView = new RatingDialogWebView(activity);                                webView.clearCache(true);                                webView.clearHistory();                                webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);                                webView.getSettings().setJavaScriptEnabled(true);                                webView.loadUrl(ratingWidgetUrl);                                AlertDialog.Builder builder = new AlertDialog.Builder(activity);                                builder.setView(webView);                                if (closeButtonText != null && !closeButtonText.isEmpty()) {                                    builder.setNeutralButton(closeButtonText, new DialogInterface.OnClickListener() {                                        @Override public void onClick(DialogInterface dialog, int which) {                                            L.d("[ModuleRatings] Calling callback from 'close' button");                                            if (devCallback != null) {                                                devCallback.callback(null);                                            }                                        }                                    });                                }                                builder.show();                            }                        });                    } else {                        if (devCallback != null) {                            devCallback.callback("Rating dialog is not meant for this form factor");                        }                    }                } catch (JSONException e) {                    L.e("[ModuleRatings] Encountered a issue while trying to parse the results of the widget config", e);                }            }        }, L);    }    static class RatingDialogWebView extends WebView {        public RatingDialogWebView(Context context) {            super(context);        }        @Override        public boolean onCheckIsTextEditor() {            return true;        }    }    static class FeedbackDialogWebViewClient extends WebViewClient {        @Override        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {            String url = request.getUrl().toString();            if (url.endsWith("cly_x_int=1")) {                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));                view.getContext().startActivity(intent);                return true;            }            return false;        }        @Override        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {            return null;        }        @Override        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {            return null;        }    }    @Override    void callbackOnActivityResumed(Activity activity) {        if (showStarRatingDialogOnFirstActivity) {            StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);            srp.isShownForCurrentVersion = true;            srp.automaticHasBeenShown = true;            showStarRatingInternal(activity, starRatingCallback_);            saveStarRatingPreferences(srp);            showStarRatingDialogOnFirstActivity = false;        }    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            registerAppSession(config.context, starRatingCallback_);        }    }    @Override    void halt() {    }    public class Ratings {        public void recordManualRating(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {            L.i("[Ratings] Calling recordManualRating");            recordRatingWidgetWithID(widgetId, rating, email, comment, userCanBeContacted);        }        public void recordRatingWidgetWithID(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {            synchronized (_cly) {                L.i("[Ratings] Calling recordRatingWidgetWithID");                if (widgetId == null || widgetId.isEmpty()) {                    throw new IllegalStateException("A valid widgetID must be provided. The current one is either null or empty");                }                recordManualRatingInternal(widgetId, rating, email, comment, userCanBeContacted);            }        }        public void showFeedbackPopup(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {            L.i("[Ratings] Calling showFeedbackPopup");            presentRatingWidgetWithID(widgetId, closeButtonText, activity, callback);        }        public void presentRatingWidgetWithID(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {            synchronized (_cly) {                L.i("[Ratings] Calling presentRatingWidgetWithID");                showFeedbackPopupInternal(widgetId, closeButtonText, activity, callback);            }        }        public void showStarRating(Activity activity, StarRatingCallback callback) {            synchronized (_cly) {                L.i("[Ratings] Calling showStarRating");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {                    return;                }                showStarRatingInternal(activity, callback);            }        }        public int getCurrentVersionsSessionCount() {            synchronized (_cly) {                int sessionCount = getCurrentVersionsSessionCountInternal(_cly.countlyStore);                L.i("[Ratings] Getting star rating current version session count: [" + sessionCount + "]");                return sessionCount;            }        }        public void clearAutomaticStarRatingSessionCount() {            synchronized (_cly) {                L.i("[Ratings] Clearing star rating session count");                clearAutomaticStarRatingSessionCountInternal();            }        }        public int getAutomaticStarRatingSessionLimit() {            synchronized (_cly) {                int sessionLimit = ModuleRatings.getAutomaticStarRatingSessionLimitInternal(_cly.countlyStore);                L.i("[Ratings] Getting automatic star rating session limit: [" + sessionLimit + "]");                return sessionLimit;            }        }    }}package ly.count.android.sdk;import android.util.Log;public class ModuleLog {    public interface LogCallback {        void LogHappened(String logMessage, ModuleLog.LogLevel logLevel);    }    public enum LogLevel {Verbose, Debug, Info, Warning, Error}    LogCallback logListener = null;    HealthTracker healthTracker;    int countWarnings = 0;    int countErrors = 0;    void SetListener(LogCallback logListener) {        this.logListener = logListener;    }    void trackWarning() {        if (healthTracker == null) {            countWarnings++;        } else {            healthTracker.logWarning();        }    }    void trackError() {        if (healthTracker == null) {            countErrors++;        } else {            healthTracker.logError();        }    }    void setHealthChecker(HealthTracker healthTracker) {        v("[ModuleLog] Setting healthTracker W:" + countWarnings + " E:" + countErrors);        this.healthTracker = healthTracker;        if (healthTracker == null) {            return;        }        for (int a = 0; a < countErrors; a++) {            healthTracker.logError();        }        for (int a = 0; a < countWarnings; a++) {            healthTracker.logWarning();        }        countWarnings = 0;        countErrors = 0;    }    public void v(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.v(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Verbose);    }    public void d(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.d(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Debug);    }    public void i(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.i(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Info);    }    public void w(String msg) {        w(msg, null);    }    public void w(String msg, Throwable t) {        trackWarning();        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.w(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Warning);    }    public void e(String msg) {        e(msg, null);    }    public void e(String msg, Throwable t) {        trackError();        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.e(Countly.TAG, msg, t);        }        informListener(msg, t, LogLevel.Error);    }    public boolean logEnabled() {        return logListener != null || Countly.sharedInstance().isLoggingEnabled();    }    private void informListener(String msg, final Throwable t, final LogLevel level) {        try {            if (msg == null) {                msg = "";            }            if (t != null) {                msg += Log.getStackTraceString(t);            }            if (logListener != null) {                logListener.LogHappened(msg, level);            }        } catch (Exception ex) {            Log.e(Countly.TAG, "[ModuleLog] Failed to inform listener [" + ex.toString() + "]");        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.Map;interface RequestQueueProvider {    void beginSession(boolean locationDisabled, @Nullable String locationCountryCode, @Nullable String locationCity, @Nullable String locationGpsCoordinates, @Nullable String locationIpAddress, @NonNull String preparedMetrics);    void updateSession(final int duration);    void changeDeviceId(String deviceId, String oldDeviceId);    void tokenSession(String token, Countly.CountlyMessagingProvider provider);    void endSession(final int duration);    void sendLocation(boolean locationDisabled, String locationCountryCode, String locationCity, String locationGpsCoordinates, String locationIpAddress);    void sendUserData(String userdata);    void sendIndirectAttribution(@NonNull String attributionObj);    void sendDirectAttributionLegacy(@NonNull String campaignID, @Nullable String userID);    void sendDirectAttributionTest(@NonNull String attributionData);    void sendCrashReport(@NonNull final String crashData, final boolean nonFatalCrash);    void recordEvents(final String events);    void sendConsentChanges(String formattedConsentChanges);    void sendAPMCustomTrace(String key, Long durationMs, Long startMs, Long endMs, String customMetrics);    void sendAPMNetworkTrace(String networkTraceKey, Long responseTimeMs, int responseCode, int requestPayloadSize, int responsePayloadSize, Long startMs, Long endMs);    void sendAPMAppStart(long durationMs, Long startMs, Long endMs);    void sendAPMScreenTime(boolean recordForegroundTime, long durationMs, Long startMs, Long endMs);    void sendDirectRequest(@NonNull final Map<String, String> requestData);    void enrollToKeys(@NonNull String[] keys);    void exitForKeys(@NonNull String[] keys);    boolean queueContainsTemporaryIdItems();    void tick();    ConnectionProcessor createConnectionProcessor();    String prepareRemoteConfigRequestLegacy(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics);    String prepareRemoteConfigRequest(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics, boolean autoEnroll);    String prepareFetchAllVariants();     String prepareFetchAllExperiments();     String prepareEnrollVariant(String key, String Variant);     String prepareRatingWidgetRequest(String widgetId);    String prepareFeedbackListRequest();    String prepareServerConfigRequest();    String prepareHealthCheckRequest(String preparedMetrics);    String prepareFetchContents(int portraitWidth, int portraitHeight, int landscapeWidth, int landscapeHeight, String[] categories, String language);}package ly.count.android.sdk;interface DeviceIdProvider {    String getDeviceId();    DeviceId getDeviceIdInstance();    boolean isTemporaryIdEnabled();}package ly.count.android.sdk;import android.annotation.SuppressLint;import android.annotation.TargetApi;import android.app.ActivityManager;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.pm.FeatureInfo;import android.content.pm.PackageManager;import android.content.res.Configuration;import android.media.AudioManager;import android.net.ConnectivityManager;import android.os.BatteryManager;import android.os.Build;import android.os.Environment;import android.os.StatFs;import android.telephony.TelephonyManager;import android.util.DisplayMetrics;import android.view.Display;import android.view.WindowManager;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Locale;import java.util.Map;import java.util.TimeZone;import java.util.concurrent.ConcurrentHashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.json.JSONObject;class DeviceInfo {    private final static int startTime = UtilsTime.currentTimestampSeconds();    private boolean inBackground = true;    private static long totalMemory = 0;    MetricProvider mp;    public DeviceInfo(MetricProvider mpOverride) {        mp = mpOverride;        if (mp == null) {            mp = new MetricProvider() {                @NonNull                @Override public String getOS() {                    return "Android";                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getOSVersion() {                    return android.os.Build.VERSION.RELEASE;                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getDevice() {                    return android.os.Build.MODEL;                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getManufacturer() {                    return Build.MANUFACTURER;                }                @NonNull                @Override                public String getResolution(@NonNull final Context context) {                    String resolution = "";                    try {                        final DisplayMetrics metrics = getDisplayMetrics(context);                        resolution = metrics.widthPixels + "x" + metrics.heightPixels;                    } catch (Throwable t) {                        Countly.sharedInstance().L.i("[DeviceInfo] Device resolution cannot be determined");                    }                    return resolution;                }                @NonNull                @Override                public DisplayMetrics getDisplayMetrics(@NonNull final Context context) {                    final WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);                    final Display display = wm.getDefaultDisplay();                    final DisplayMetrics metrics = new DisplayMetrics();                    display.getMetrics(metrics);                    return metrics;                }                @NonNull                @Override                public String getDensity(@NonNull final Context context) {                    String densityStr;                    final int density = context.getResources().getDisplayMetrics().densityDpi;                    switch (density) {                        case DisplayMetrics.DENSITY_LOW:                            densityStr = "LDPI";                            break;                        case DisplayMetrics.DENSITY_MEDIUM:                            densityStr = "MDPI";                            break;                        case DisplayMetrics.DENSITY_TV:                            densityStr = "TVDPI";                            break;                        case DisplayMetrics.DENSITY_HIGH:                            densityStr = "HDPI";                            break;                        case DisplayMetrics.DENSITY_260:                        case DisplayMetrics.DENSITY_280:                        case DisplayMetrics.DENSITY_300:                        case DisplayMetrics.DENSITY_XHIGH:                            densityStr = "XHDPI";                            break;                        case DisplayMetrics.DENSITY_340:                        case DisplayMetrics.DENSITY_360:                        case DisplayMetrics.DENSITY_400:                        case DisplayMetrics.DENSITY_420:                        case DisplayMetrics.DENSITY_XXHIGH:                            densityStr = "XXHDPI";                            break;                        case DisplayMetrics.DENSITY_560:                        case DisplayMetrics.DENSITY_XXXHIGH:                            densityStr = "XXXHDPI";                            break;                        default:                            densityStr = "other";                            break;                    }                    return densityStr;                }                @NonNull                @Override                public String getCarrier(@NonNull final Context context) {                    String carrier = "";                    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);                    if (manager != null) {                        carrier = manager.getNetworkOperatorName();                    }                    if (carrier == null || carrier.length() == 0) {                        carrier = "";                        Countly.sharedInstance().L.i("[DeviceInfo] No carrier found");                    }                    if (carrier.equals("--")) {                        carrier = "";                    }                    return carrier;                }                @Override                public int getTimezoneOffset() {                    return TimeZone.getDefault().getOffset(new Date().getTime()) / 60_000;                }                @NonNull                @Override                public String getLocale() {                    final Locale locale = Locale.getDefault();                    return locale.getLanguage() + "_" + locale.getCountry();                }                @NonNull                @Override                public String getAppVersion(@NonNull final Context context) {                    String result = Countly.DEFAULT_APP_VERSION;                    try {                        String tmpVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;                        if (tmpVersion != null) {                            result = tmpVersion;                        }                    } catch (PackageManager.NameNotFoundException e) {                        Countly.sharedInstance().L.i("[DeviceInfo] No app version found");                    }                    return result;                }                @NonNull                @Override                public String getStore(@NonNull final Context context) {                    String result = "";                    try {                        result = context.getPackageManager().getInstallerPackageName(context.getPackageName());                    } catch (Exception e) {                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] Can't get Installer package ");                    }                    if (result == null || result.length() == 0) {                        result = "";                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] No store found");                    }                    return result;                }                @NonNull                @Override                public String getDeviceType(@NonNull final Context context) {                    if (Utils.isDeviceTv(context)) {                        return "smarttv";                    }                    if (Utils.isDeviceTablet(context)) {                        return "tablet";                    }                    return "mobile";                }                @Override                public long getTotalRAM() {                    if (totalMemory == 0) {                        RandomAccessFile reader = null;                        String load;                        try {                            reader = new RandomAccessFile("/proc/meminfo", "r");                            load = reader.readLine();                            Pattern p = Pattern.compile("(\\d+)");                            Matcher m = p.matcher(load);                            String value = "";                            while (m.find()) {                                value = m.group(1);                            }                            try {                                if (value != null) {                                    totalMemory = Long.parseLong(value) / 1024;                                } else {                                    totalMemory = 0;                                }                            } catch (NumberFormatException ex) {                                totalMemory = 0;                            }                        } catch (IOException ex) {                            try {                                if (reader != null) {                                    reader.close();                                }                            } catch (IOException exc) {                                exc.printStackTrace();                            }                            ex.printStackTrace();                        } finally {                            try {                                if (reader != null) {                                    reader.close();                                }                            } catch (IOException exc) {                                exc.printStackTrace();                            }                        }                    }                    return totalMemory;                }                @NonNull                @Override                public String getRamCurrent(Context context) {                    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();                    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);                    activityManager.getMemoryInfo(mi);                    return Long.toString(getTotalRAM() - (mi.availMem / 1_048_576L));                }                @NonNull                @Override                public String getRamTotal() {                    return Long.toString(getTotalRAM());                }                @NonNull                @Override                public String getCpu() {                    return Build.SUPPORTED_ABIS[0];                }                @NonNull                @Override                public String getOpenGL(Context context) {                    PackageManager packageManager = context.getPackageManager();                    FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();                    if (featureInfos != null && featureInfos.length > 0) {                        for (FeatureInfo featureInfo : featureInfos) {                            if (featureInfo.name == null) {                                if (featureInfo.reqGlEsVersion != FeatureInfo.GL_ES_VERSION_UNDEFINED) {                                    return Integer.toString((featureInfo.reqGlEsVersion & 0xffff0000) >> 16);                                } else {                                    return "1";                                 }                            }                        }                    }                    return "1";                }                @TargetApi(18)                @NonNull                @Override                public String getDiskCurrent() {                    if (android.os.Build.VERSION.SDK_INT < 18) {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();                        long free = (long) statFs.getAvailableBlocks() * (long) statFs.getBlockSize();                        return Long.toString((total - free) / 1_048_576L);                    } else {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();                        long free = statFs.getAvailableBlocksLong() * statFs.getBlockSizeLong();                        return Long.toString((total - free) / 1048576L);                    }                }                @TargetApi(18)                @NonNull                @Override                public String getDiskTotal() {                    if (android.os.Build.VERSION.SDK_INT < 18) {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();                        return Long.toString(total / 1048576L);                    } else {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();                        return Long.toString(total / 1048576L);                    }                }                @Nullable                @Override                public String getBatteryLevel(Context context) {                    try {                        Intent batteryIntent;                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED), null, null, Context.RECEIVER_NOT_EXPORTED);                        } else {                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));                        }                        if (batteryIntent != null) {                            int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);                            int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);                            if (level > -1 && scale > 0) {                                return Float.toString(((float) level / (float) scale) * 100.0f);                            }                        }                    } catch (Exception e) {                        Countly.sharedInstance().L.i("Can't get battery level");                    }                    return null;                }                @Nullable                @Override                public String getOrientation(Context context) {                    int orientation = context.getResources().getConfiguration().orientation;                    switch (orientation) {                        case Configuration.ORIENTATION_LANDSCAPE:                            return "Landscape";                        case Configuration.ORIENTATION_PORTRAIT:                            return "Portrait";                        case Configuration.ORIENTATION_SQUARE:                            return "Square";                        case Configuration.ORIENTATION_UNDEFINED:                            return "Unknown";                        default:                            return null;                    }                }                @NonNull                @Override                public String isRooted() {                    String[] paths = {                        "/sbin/su", "/system/bin/su", "/system/xbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su",                        "/system/bin/failsafe/su", "/data/local/su"                    };                    for (String path : paths) {                        if (new File(path).exists()) return "true";                    }                    return "false";                }                @SuppressLint("MissingPermission")                @Nullable                @Override                public String isOnline(Context context) {                    try {                        ConnectivityManager conMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);                        if (conMgr != null && conMgr.getActiveNetworkInfo() != null                            && conMgr.getActiveNetworkInfo().isAvailable()                            && conMgr.getActiveNetworkInfo().isConnected()) {                            return "true";                        }                        return "false";                    } catch (Exception e) {                        Countly.sharedInstance().L.w("isOnline, Got exception determining netwprl connectivity", e);                    }                    return null;                }                @NonNull                @Override                public String isMuted(Context context) {                    try {                        AudioManager audio = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);                        switch (audio.getRingerMode()) {                            case AudioManager.RINGER_MODE_SILENT:                            case AudioManager.RINGER_MODE_VIBRATE:                                return "true";                            default:                                return "false";                        }                    } catch (Throwable thr) {                        return "false";                    }                }                @Override                public String hasHinge(Context context) {                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {                        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_SENSOR_HINGE_ANGLE) + "";                    }                    return "false";                }                @Override public String getRunningTime() {                    return Integer.toString(UtilsTime.currentTimestampSeconds() - startTime);                }            };        }    }    @NonNull    Map<String, Object> getCommonMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        final Map<String, Object> map = new ConcurrentHashMap<>();        putIfNotNullAndNotEmpty(map, "_device", mp.getDevice());        putIfNotNullAndNotEmpty(map, "_os", mp.getOS());        putIfNotNullAndNotEmpty(map, "_os_version", mp.getOSVersion());        putIfNotNullAndNotEmpty(map, "_resolution", mp.getResolution(context));        putIfNotNullAndNotEmpty(map, "_app_version", mp.getAppVersion(context));        putIfNotNullAndNotEmpty(map, "_manufacturer", mp.getManufacturer());        putIfNotNullAndNotEmpty(map, "_has_hinge", mp.hasHinge(context));        if (metricOverride != null) {            try {                if (metricOverride.containsKey("_device")) {                    map.put("_device", metricOverride.get("_device"));                }                if (metricOverride.containsKey("_os")) {                    map.put("_os", metricOverride.get("_os"));                }                if (metricOverride.containsKey("_os_version")) {                    map.put("_os_version", metricOverride.get("_os_version"));                }                if (metricOverride.containsKey("_resolution")) {                    map.put("_resolution", metricOverride.get("_resolution"));                }                if (metricOverride.containsKey("_app_version")) {                    map.put("_app_version", metricOverride.get("_app_version"));                }                if (metricOverride.containsKey("_manufacturer")) {                    map.put("_manufacturer", metricOverride.get("_manufacturer"));                }                if (metricOverride.containsKey("_has_hinge")) {                    map.put("_has_hinge", metricOverride.get("_has_hinge"));                }            } catch (Exception e) {                L.e("[DeviceInfo] getCommonMetrics, SDK encountered failure while trying to apply metric override, " + e);            }        }        return map;    }    private void putIfNotNullAndNotEmpty(@NonNull Map<String, Object> metrics, String key, String value) {        if (value != null && !value.isEmpty()) {            metrics.put(key, value);        }    }    @NonNull    String getMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        Map<String, Object> metrics = getCommonMetrics(context, null, L);        putIfNotNullAndNotEmpty(metrics, "_carrier", mp.getCarrier(context));        putIfNotNullAndNotEmpty(metrics, "_density", mp.getDensity(context));        putIfNotNullAndNotEmpty(metrics, "_locale", mp.getLocale());        putIfNotNullAndNotEmpty(metrics, "_store", mp.getStore(context));        putIfNotNullAndNotEmpty(metrics, "_device_type", mp.getDeviceType(context));        if (metricOverride != null) {            for (String k : metricOverride.keySet()) {                if (k == null || k.isEmpty()) {                    L.w("[DeviceInfo] getMetrics, Provided metric override key can't be null or empty");                    continue;                }                String overrideValue = metricOverride.get(k);                if (overrideValue == null) {                    L.w("[DeviceInfo] getMetrics, Provided metric override value can't be null, key:[" + k + "]");                    continue;                }                metrics.put(k, overrideValue);            }        }        String result = new JSONObject(metrics).toString();        try {            result = java.net.URLEncoder.encode(result, "UTF-8");        } catch (UnsupportedEncodingException ex) {            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");        }        return result;    }    @NonNull    String getMetricsHealthCheck(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {        Map<String, Object> metrics = new ConcurrentHashMap<>();        String appVersion = mp.getAppVersion(context);        if (metricOverride != null) {            if (metricOverride.containsKey("_app_version")) {                appVersion = metricOverride.get("_app_version");            }        }        metrics.put("_app_version", appVersion);        String result = new JSONObject(metrics).toString();        try {            result = java.net.URLEncoder.encode(result, "UTF-8");        } catch (UnsupportedEncodingException ex) {            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");        }        return result;    }    @NonNull    JSONObject getCrashDataJSON(@NonNull CrashData crashData, final boolean isNativeCrash) {        Map<String, Object> crashDataMap = crashData.getCrashMetrics();        crashDataMap.put("_ob", crashData.getChangedFieldsAsInt());        putIfNotNullAndNotEmpty(crashDataMap, "_error", crashData.getStackTrace());        putIfNotNullAndNotEmpty(crashDataMap, "_nonfatal", Boolean.toString(!crashData.getFatal()));        if (!isNativeCrash) {            String breadcrumbs = crashData.getBreadcrumbsAsString();            if (!breadcrumbs.isEmpty()) {                crashDataMap.put("_logs", breadcrumbs);            }        }        if (!crashData.getCrashSegmentation().isEmpty()) {            crashDataMap.put("_custom", crashData.getCrashSegmentation());        }        return new JSONObject(crashDataMap);    }    @NonNull    Map<String, Object> getCrashMetrics(@NonNull final Context context, boolean isNativeCrash, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        Map<String, Object> metrics = getCommonMetrics(context, metricOverride, L);        putIfNotNullAndNotEmpty(metrics, "_cpu", mp.getCpu());        putIfNotNullAndNotEmpty(metrics, "_opengl", mp.getOpenGL(context));        putIfNotNullAndNotEmpty(metrics, "_root", mp.isRooted());        putIfNotNullAndNotEmpty(metrics, "_ram_total", mp.getRamTotal());        putIfNotNullAndNotEmpty(metrics, "_disk_total", mp.getDiskTotal());        if (!isNativeCrash) {            putIfNotNullAndNotEmpty(metrics, "_ram_current", mp.getRamCurrent(context));            putIfNotNullAndNotEmpty(metrics, "_disk_current", mp.getDiskCurrent());            putIfNotNullAndNotEmpty(metrics, "_bat", mp.getBatteryLevel(context));            putIfNotNullAndNotEmpty(metrics, "_run", mp.getRunningTime());            putIfNotNullAndNotEmpty(metrics, "_orientation", mp.getOrientation(context));            putIfNotNullAndNotEmpty(metrics, "_online", mp.isOnline(context));            putIfNotNullAndNotEmpty(metrics, "_muted", mp.isMuted(context));            putIfNotNullAndNotEmpty(metrics, "_background", isInBackground());        } else {            metrics.put("_native_cpp", true);        }        return metrics;    }    @NonNull    public String getAppVersionWithOverride(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {        String appVersion = mp.getAppVersion(context);        if (metricOverride != null && metricOverride.containsKey("_app_version")) {            String overrideVersion = metricOverride.get("_app_version");            if (overrideVersion != null) {                appVersion = overrideVersion;            }        }        return appVersion;    }    void inForeground() {        inBackground = false;    }    void inBackground() {        inBackground = true;    }    String isInBackground() {        return Boolean.toString(inBackground);    }}package ly.count.android.sdk;import android.app.Application;import android.content.Context;import java.util.ArrayList;import java.util.List;import java.util.Map;public class CountlyConfig {    protected CountlyStore countlyStore = null;    protected ConsentProvider consentProvider = null;    protected StorageProvider storageProvider = null;    protected EventProvider eventProvider = null;    protected EventQueueProvider eventQueueProvider = null;    protected RequestQueueProvider requestQueueProvider = null;    protected DeviceIdProvider deviceIdProvider = null;    protected ViewIdProvider viewIdProvider = null;    protected BaseInfoProvider baseInfoProvider = null;    protected ConfigurationProvider configProvider = null;    protected SafeIDGenerator safeViewIDGenerator = null;    protected SafeIDGenerator safeEventIDGenerator = null;    protected ImmediateRequestGenerator immediateRequestGenerator = null;    protected HealthTracker healthTracker;    protected MetricProvider metricProviderOverride = null;    protected DeviceInfo deviceInfo = null;    protected ModuleBase testModuleListener = null;    protected Map<String, Object> providedUserProperties = null;    protected Countly.LifecycleObserver lifecycleObserver = null;    protected Context context = null;    protected String serverURL = null;    protected String appKey = null;    protected String deviceID = null;    protected int starRatingSessionLimit = 5;    protected StarRatingCallback starRatingCallback = null;    protected String starRatingTextTitle = null;    protected String starRatingTextMessage = null;    protected String starRatingTextDismiss = null;    protected boolean loggingEnabled = false;    protected boolean enableAutomaticViewTracking = false;    protected boolean autoTrackingUseShortName = false;    protected Class[] automaticViewTrackingExceptions = null;    protected Map<String, Object> globalViewSegmentation = null;    protected Map<String, String> customNetworkRequestHeaders = null;    protected boolean pushIntentAddMetadata = false;    protected boolean enableRemoteConfigAutomaticDownloadTriggers = false;    protected boolean enableAutoEnrollFlag = false;    boolean enableRemoteConfigValueCaching = false;    protected RemoteConfigCallback remoteConfigCallbackLegacy = null;    protected List<RCDownloadCallback> remoteConfigGlobalCallbackList = new ArrayList<>(2);    protected boolean shouldRequireConsent = false;    protected boolean enableAllConsents = false;    protected String[] enabledFeatureNames = null;    protected boolean httpPostForced = false;    protected boolean temporaryDeviceIdEnabled = false;    protected String tamperingProtectionSalt = null;    protected Integer eventQueueSizeThreshold = null;    protected boolean trackOrientationChange = true;    protected boolean manualSessionControlEnabled = false;    protected boolean manualSessionControlHybridModeEnabled = false;    protected boolean disableUpdateSessionRequests = false;    protected boolean shouldIgnoreAppCrawlers = false;    protected String[] appCrawlerNames = null;    protected String[] publicKeyPinningCertificates = null;    protected String[] certificatePinningCertificates = null;    protected Integer sessionUpdateTimerDelay = null;    protected CrashFilterCallback crashFilterCallback;    protected boolean starRatingDialogIsCancellable = false;    protected boolean starRatingShownAutomatically = false;    protected boolean starRatingDisableAskingForEachAppVersion = false;    protected Application application = null;    boolean disableLocation = false;    String locationCountyCode = null;    String locationCity = null;    String locationLocation = null;    String locationIpAddress = null;    Map<String, String> metricOverride = null;    int maxRequestQueueSize = 1000;    ModuleLog.LogCallback providedLogCallback;    String daCampaignType = null;    String daCampaignData = null;    Map<String, String> iaAttributionValues = null;    boolean explicitStorageModeEnabled = false;    boolean serverConfigurationEnabled = false;    boolean healthCheckEnabled = true;    int dropAgeHours = 0;    public PerformanceCounterCollector pcc;    public synchronized CountlyConfig setMaxSegmentationValues(int maxSegmentationValues) {        sdkInternalLimits.setMaxSegmentationValues(maxSegmentationValues);        return this;    }    public synchronized CountlyConfig setMaxBreadcrumbCount(int maxBreadcrumbCount) {        sdkInternalLimits.setMaxBreadcrumbCount(maxBreadcrumbCount);        return this;    }    public CountlyConfig() {    }    public CountlyConfig(Context context, String appKey, String serverURL) {        setContext(context);        setAppKey(appKey);        setServerURL(serverURL);    }    public CountlyConfig(Application application, String appKey, String serverURL) {        setAppKey(appKey);        setServerURL(serverURL);        setApplication(application);    }    public synchronized CountlyConfig setContext(Context context) {        this.context = context;        return this;    }    public synchronized CountlyConfig setServerURL(String serverURL) {        this.serverURL = serverURL;        return this;    }    public synchronized CountlyConfig setAppKey(String appKey) {        this.appKey = appKey;        return this;    }    public synchronized CountlyConfig setDeviceId(String deviceID) {        this.deviceID = deviceID;        return this;    }    public synchronized CountlyConfig setIdMode(DeviceIdType idMode) {        return this;    }    public synchronized CountlyConfig setStarRatingSessionLimit(int starRatingLimit) {        this.starRatingSessionLimit = starRatingLimit;        return this;    }    public synchronized CountlyConfig setStarRatingCallback(StarRatingCallback starRatingCallback) {        this.starRatingCallback = starRatingCallback;        return this;    }    public synchronized CountlyConfig setStarRatingTextTitle(String starRatingTextTitle) {        this.starRatingTextTitle = starRatingTextTitle;        return this;    }    public synchronized CountlyConfig setStarRatingTextMessage(String starRatingTextMessage) {        this.starRatingTextMessage = starRatingTextMessage;        return this;    }    public synchronized CountlyConfig setStarRatingTextDismiss(String starRatingTextDismiss) {        this.starRatingTextDismiss = starRatingTextDismiss;        return this;    }    public synchronized CountlyConfig setLoggingEnabled(boolean enabled) {        this.loggingEnabled = enabled;        return this;    }    public synchronized CountlyConfig enableCrashReporting() {        crashes.enableCrashReporting();        return this;    }    public synchronized CountlyConfig setViewTracking(boolean enable) {        this.enableAutomaticViewTracking = enable;        return this;    }    public synchronized CountlyConfig enableAutomaticViewTracking() {        this.enableAutomaticViewTracking = true;        return this;    }    public synchronized CountlyConfig enableAutomaticViewShortNames() {        this.autoTrackingUseShortName = true;        return this;    }    public synchronized CountlyConfig setAutoTrackingUseShortName(boolean enable) {        this.autoTrackingUseShortName = enable;        return this;    }    public synchronized CountlyConfig setGlobalViewSegmentation(Map<String, Object> segmentation) {        globalViewSegmentation = segmentation;        return this;    }    public synchronized CountlyConfig setAutomaticViewSegmentation(Map<String, Object> segmentation) {        globalViewSegmentation = segmentation;        return this;    }    public synchronized CountlyConfig setAutomaticViewTrackingExclusions(Class[] exclusions) {        if (exclusions != null) {            for (Class exception : exclusions) {                if (exception == null) {                    throw new IllegalArgumentException("setAutomaticViewTrackingExclusions(...) does not accept 'null' activities");                }            }        }        automaticViewTrackingExceptions = exclusions;        return this;    }    public synchronized CountlyConfig setAutoTrackingExceptions(Class[] exceptions) {        return setAutomaticViewTrackingExclusions(exceptions);    }    public synchronized CountlyConfig addCustomNetworkRequestHeaders(Map<String, String> customHeaderValues) {        this.customNetworkRequestHeaders = customHeaderValues;        return this;    }    public synchronized CountlyConfig setPushIntentAddMetadata(boolean enable) {        pushIntentAddMetadata = enable;        return this;    }    public synchronized CountlyConfig setRemoteConfigAutomaticDownload(boolean enabled, RemoteConfigCallback callback) {        enableRemoteConfigAutomaticDownloadTriggers = enabled;        remoteConfigCallbackLegacy = callback;        return this;    }    public synchronized CountlyConfig enableRemoteConfigAutomaticTriggers() {        enableRemoteConfigAutomaticDownloadTriggers = true;        return this;    }    public synchronized CountlyConfig enrollABOnRCDownload() {        enableAutoEnrollFlag = true;        return this;    }    public synchronized CountlyConfig setRequestDropAgeHours(int dropAgeHours) {        this.dropAgeHours = dropAgeHours;        return this;    }    public synchronized CountlyConfig enableRemoteConfigValueCaching() {        enableRemoteConfigValueCaching = true;        return this;    }    public synchronized CountlyConfig RemoteConfigRegisterGlobalCallback(RCDownloadCallback callback) {        remoteConfigGlobalCallbackList.add(callback);        return this;    }    public synchronized CountlyConfig setRequiresConsent(boolean shouldRequireConsent) {        this.shouldRequireConsent = shouldRequireConsent;        return this;    }    public synchronized CountlyConfig setConsentEnabled(String[] featureNames) {        enabledFeatureNames = featureNames;        return this;    }    public synchronized CountlyConfig giveAllConsents() {        enableAllConsents = true;        return this;    }    public synchronized CountlyConfig setHttpPostForced(boolean isForced) {        httpPostForced = isForced;        return this;    }    public synchronized CountlyConfig enableTemporaryDeviceIdMode() {        temporaryDeviceIdEnabled = true;        return this;    }    public synchronized CountlyConfig setCrashFilterCallback(CrashFilterCallback callback) {        crashFilterCallback = callback;        return this;    }    public synchronized CountlyConfig setParameterTamperingProtectionSalt(String salt) {        tamperingProtectionSalt = salt;        return this;    }    public synchronized CountlyConfig setTrackOrientationChanges(boolean shouldTrackOrientation) {        trackOrientationChange = shouldTrackOrientation;        return this;    }    public synchronized CountlyConfig setRecordAllThreadsWithCrash() {        crashes.enableRecordAllThreadsWithCrash();        return this;    }    public synchronized CountlyConfig setEnableAttribution(boolean enableAttribution) {        return this;    }    public synchronized CountlyConfig enablePublicKeyPinning(String[] certificates) {        publicKeyPinningCertificates = certificates;        return this;    }    public synchronized CountlyConfig enableCertificatePinning(String[] certificates) {        certificatePinningCertificates = certificates;        return this;    }    public synchronized CountlyConfig setShouldIgnoreAppCrawlers(boolean shouldIgnore) {        shouldIgnoreAppCrawlers = shouldIgnore;        return this;    }    public synchronized CountlyConfig setAppCrawlerNames(String[] appCrawlerNames) {        this.appCrawlerNames = appCrawlerNames;        return this;    }    public synchronized CountlyConfig setEventQueueSizeToSend(int threshold) {        eventQueueSizeThreshold = threshold;        return this;    }    public synchronized CountlyConfig enableManualSessionControl() {        manualSessionControlEnabled = true;        return this;    }    public synchronized CountlyConfig enableManualSessionControlHybridMode() {        manualSessionControlHybridModeEnabled = true;        return this;    }    public synchronized CountlyConfig setCustomCrashSegment(Map<String, Object> crashSegment) {        crashes.setCustomCrashSegmentation(crashSegment);        return this;    }    protected synchronized CountlyConfig checkForNativeCrashDumps(boolean checkForDumps) {        return this;    }    public synchronized CountlyConfig setUpdateSessionTimerDelay(int delay) {        sessionUpdateTimerDelay = delay;        return this;    }    protected synchronized CountlyConfig setCountlyStore(CountlyStore store) {        countlyStore = store;        return this;    }    protected synchronized CountlyConfig setDisableUpdateSessionRequests(boolean disable) {        disableUpdateSessionRequests = disable;        return this;    }    public synchronized CountlyConfig setIfStarRatingDialogIsCancellable(boolean isCancellable) {        starRatingDialogIsCancellable = isCancellable;        return this;    }    public synchronized CountlyConfig setIfStarRatingShownAutomatically(boolean isShownAutomatically) {        starRatingShownAutomatically = isShownAutomatically;        return this;    }    public synchronized CountlyConfig setStarRatingDisableAskingForEachAppVersion(boolean disableAsking) {        starRatingDisableAskingForEachAppVersion = disableAsking;        return this;    }    public synchronized CountlyConfig setApplication(Application application) {        this.application = application;        return this;    }    public synchronized CountlyConfig setRecordAppStartTime(boolean recordAppStartTime) {        apm.trackAppStartTime = recordAppStartTime;        return this;    }    public synchronized CountlyConfig setDisableLocation() {        disableLocation = true;        return this;    }    public synchronized CountlyConfig setLocation(String country_code, String city, String gpsCoordinates, String ipAddress) {        locationCountyCode = country_code;        locationCity = city;        locationLocation = gpsCoordinates;        locationIpAddress = ipAddress;        return this;    }    public synchronized CountlyConfig setMetricOverride(Map<String, String> providedMetricOverride) {        metricOverride = providedMetricOverride;        return this;    }    public synchronized CountlyConfig setAppStartTimestampOverride(long appStartTimestampOverride) {        apm.setAppStartTimestampOverride(appStartTimestampOverride);        return this;    }    public synchronized CountlyConfig enableManualAppLoadedTrigger() {        apm.enableManualAppLoadedTrigger();        return this;    }    public synchronized CountlyConfig enableManualForegroundBackgroundTriggerAPM() {        apm.manualForegroundBackgroundTrigger = true;        return this;    }    public synchronized CountlyConfig setLogListener(ModuleLog.LogCallback logCallback) {        providedLogCallback = logCallback;        return this;    }    public synchronized CountlyConfig setMaxRequestQueueSize(int newMaxSize) {        maxRequestQueueSize = newMaxSize;        return this;    }    public synchronized CountlyConfig setDirectAttribution(String campaignType, String campaignData) {        daCampaignType = campaignType;        daCampaignData = campaignData;        return this;    }    public synchronized CountlyConfig setIndirectAttribution(Map<String, String> attributionValues) {        iaAttributionValues = attributionValues;        return this;    }    public synchronized CountlyConfig setUserProperties(Map<String, Object> userProperties) {        providedUserProperties = userProperties;        return this;    }    public synchronized CountlyConfig enableExplicitStorageMode() {        explicitStorageModeEnabled = true;        return this;    }    public synchronized CountlyConfig enableServerConfiguration() {        serverConfigurationEnabled = true;        return this;    }    protected synchronized CountlyConfig disableHealthCheck() {        healthCheckEnabled = false;        return this;    }    public final ConfigApm apm = new ConfigApm();    public final ConfigSdkInternalLimits sdkInternalLimits = new ConfigSdkInternalLimits();    public final ConfigCrashes crashes = new ConfigCrashes();    public final ConfigContent content = new ConfigContent();    public final ConfigExperimental experimental = new ConfigExperimental();}package ly.count.android.sdk;import android.content.Intent;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class ModuleConsent extends ModuleBase implements ConsentProvider {    Consent consentInterface = null;    protected static final String[] validFeatureNames = {        Countly.CountlyFeatureNames.sessions,        Countly.CountlyFeatureNames.events,        Countly.CountlyFeatureNames.views,        Countly.CountlyFeatureNames.location,        Countly.CountlyFeatureNames.crashes,        Countly.CountlyFeatureNames.attribution,        Countly.CountlyFeatureNames.users,        Countly.CountlyFeatureNames.push,        Countly.CountlyFeatureNames.starRating,        Countly.CountlyFeatureNames.remoteConfig,        Countly.CountlyFeatureNames.apm,        Countly.CountlyFeatureNames.feedback,        Countly.CountlyFeatureNames.clicks,        Countly.CountlyFeatureNames.scrolls,        Countly.CountlyFeatureNames.content,    };    public enum ConsentChangeSource {ChangeConsentCall, DeviceIDChangedNotMerged}    protected boolean requiresConsent = false;    final Map<String, Boolean> featureConsentValues = new HashMap<>();    private final Map<String, String[]> groupedFeatures = new HashMap<>();    ModuleConsent(@NonNull final Countly cly, @NonNull final CountlyConfig config) {        super(cly, config);        consentProvider = this;        config.consentProvider = this;        L.v("[ModuleConsent] constructor, Initialising");        L.i("[ModuleConsent] Is consent required? [" + config.shouldRequireConsent + "]");        for (String featureName : validFeatureNames) {            featureConsentValues.put(featureName, false);        }        if (config.shouldRequireConsent) {            requiresConsent = config.shouldRequireConsent;            if (config.enabledFeatureNames == null && !config.enableAllConsents) {                L.i("[ModuleConsent] constructor, Consent has been required but no consent was given during init");            } else {                if (config.enableAllConsents) {                    L.i("[ModuleConsent] constructor, Giving consent for all features");                    for (String featureName : validFeatureNames) {                        featureConsentValues.put(featureName, true);                    }                } else {                    L.i("[ModuleConsent] constructor, Giving consent for features named: [" + Arrays.toString(config.enabledFeatureNames) + "]");                    for (String providedFeature : config.enabledFeatureNames) {                        featureConsentValues.put(providedFeature, true);                    }                }            }        }        consentInterface = new Consent();    }    public boolean getConsent(@NonNull final String featureName) {        return getConsentInternal(featureName);    }    public boolean anyConsentGiven() {        if (!requiresConsent) {            return true;        }        for (String key : featureConsentValues.keySet()) {            if (getConsentTrue(key)) {                return true;            }        }        return false;    }    boolean getConsentInternal(@Nullable final String featureName) {        if (featureName == null) {            L.e("[ModuleConsent] getConsentInternal, Can't call this with a 'null' feature name!");            return false;        }        if (!requiresConsent) {            return true;        }        boolean returnValue = getConsentTrue(featureName);        L.v("[ModuleConsent] getConsentInternal, Returning consent for feature named: [" + featureName + "] [" + returnValue + "]");        return returnValue;    }    private boolean getConsentTrue(@NonNull final String featureName) {        Boolean returnValue = featureConsentValues.get(featureName);        if (returnValue == null) {            returnValue = false;        }        return returnValue;    }    public void checkAllConsentInternal() {        L.d("[ModuleConsent] checkAllConsentInternal, consentRequired: [" + requiresConsent + "]");        getConsent(Countly.CountlyFeatureNames.push);        StringBuilder sb = new StringBuilder();        for (String key : featureConsentValues.keySet()) {            sb.append("Feature named [").append(key).append("], consent value: [").append(featureConsentValues.get(key)).append("]\n");        }        L.d("[ModuleConsent] checkAllConsentInternal, Current consent state: [" + sb + "]");    }    void doPushConsentSpecialAction(final boolean consentValue) {        L.d("[ModuleConsent] doPushConsentSpecialAction, consentValue: [" + consentValue + "]");        _cly.countlyStore.setConsentPush(consentValue);        _cly.context_.sendBroadcast(new Intent(Countly.CONSENT_BROADCAST));    }    private boolean isValidFeatureName(@Nullable final String name) {        for (String fName : validFeatureNames) {            if (fName.equals(name)) {                return true;            }        }        return false;    }    private @NonNull String formatConsentState(@NonNull final Map<String, Boolean> features) {        StringBuilder preparedConsent = new StringBuilder();        preparedConsent.append("{");        boolean commaAdded = false;        for (Map.Entry<String, Boolean> entry : features.entrySet()) {            if (commaAdded) {                preparedConsent.append(",");            } else {                commaAdded = true;            }            preparedConsent.append('"');            preparedConsent.append(entry.getKey());            preparedConsent.append('"');            preparedConsent.append(':');            preparedConsent.append(entry.getValue());        }        preparedConsent.append("}");        return preparedConsent.toString();    }    void setConsentInternal(@Nullable final String[] featureNames, final boolean isConsentGiven, final ConsentChangeSource changeSource) {        L.d("[ModuleConsent] setConsentInternal, featureNames: [" + Arrays.toString(featureNames) + "] to value: [" + isConsentGiven + "], changeSource: [" + changeSource + "]");        if (!requiresConsent) {            L.i("[ModuleConsent] setConsentInternal, Consent is not required, ignoring the call");            return;        }        if (featureNames == null) {            L.w("[ModuleConsent] setConsentInternal, Calling setConsent with null featureNames!");            return;        }        List<String> consentThatWillChange = new ArrayList<>(featureNames.length);        Map<String, Boolean> consentUpdateMap = new ConcurrentHashMap<>();        for (String featureName : featureNames) {            if (!isValidFeatureName(featureName)) {                L.w("[ModuleConsent] setConsentInternal, Given feature: [" + featureName + "] is not a valid name, ignoring it");                continue;            }            if (getConsentTrue(featureName) != isConsentGiven) {                consentThatWillChange.add(featureName);                consentUpdateMap.put(featureName, isConsentGiven);            }        }        for (ModuleBase module : _cly.modules) {            module.consentWillChange(consentThatWillChange, isConsentGiven);        }        featureConsentValues.putAll(consentUpdateMap);        for (ModuleBase module : _cly.modules) {            module.onConsentChanged(consentThatWillChange, isConsentGiven, changeSource);        }        if (isConsentGiven || !changeSource.equals(ConsentChangeSource.DeviceIDChangedNotMerged)) {            String formattedConsentState = formatConsentState(featureConsentValues);            L.v("[ModuleConsent] setConsentInternal, Sending consent changes: [" + formattedConsentState + "]");            requestQueueProvider.sendConsentChanges(formattedConsentState);        }    }    public void removeConsentInternal(@Nullable final String[] featureNames, final ConsentChangeSource changeSource) {        L.d("[ModuleConsent] removeConsentInternal, featureNames: [" + Arrays.toString(featureNames) + "], changeSource: [" + changeSource + "]");        setConsentInternal(featureNames, false, changeSource);    }    public void removeConsentAllInternal(final ConsentChangeSource changeSource) {        L.d("[ModuleConsent] removeConsentAllInternal, changeSource: [" + changeSource + "]");        removeConsentInternal(validFeatureNames, changeSource);    }    @Override    void initFinished(@NonNull final CountlyConfig config) {        L.d("[ModuleConsent] initFinished, requiresConsent: [" + requiresConsent + "]");        if (requiresConsent) {            doPushConsentSpecialAction(getConsentTrue(Countly.CountlyFeatureNames.push));            String formattedConsentState = formatConsentState(featureConsentValues);            L.d("[ModuleConsent] initFinished, Sending consent changes after init: [" + formattedConsentState + "]");            requestQueueProvider.sendConsentChanges(formattedConsentState);            if (L.logEnabled()) {                checkAllConsentInternal();            }        }    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        L.d("[ModuleConsent] onConsentChanged, consentChangeDelta: [" + consentChangeDelta + "], newConsent: [" + newConsent + "], changeSource: [" + changeSource + "]");        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.push)) {            doPushConsentSpecialAction(newConsent);        }    }    @Override    void halt() {        consentInterface = null;    }    public class Consent {        public void checkAllConsent() {            L.i("[Countly] checkAllConsent");            synchronized (_cly) {                L.i("[Consent] calling checkAllConsent");                checkAllConsentInternal();            }        }        public boolean getConsent(@Nullable final String featureName) {            L.i("[Countly] getConsent, featureName: [" + featureName + "]");            synchronized (_cly) {                return getConsentInternal(featureName);            }        }        public void removeConsentAll() {            L.i("[Countly] removeConsentAll");            synchronized (_cly) {                removeConsentAllInternal(ConsentChangeSource.ChangeConsentCall);            }        }        public void removeConsent(@Nullable final String[] featureNames) {            L.i("[Countly] removeConsent");            synchronized (_cly) {                removeConsentInternal(featureNames, ConsentChangeSource.ChangeConsentCall);            }        }        public void giveConsentAll() {            synchronized (_cly) {                L.i("[Consent] Giving consent for all features");                setConsentInternal(validFeatureNames, true, ConsentChangeSource.ChangeConsentCall);            }        }        public void giveConsent(@Nullable final String[] featureNames) {            L.i("[Countly] giveConsent");            synchronized (_cly) {                setConsentInternal(featureNames, true, ConsentChangeSource.ChangeConsentCall);            }        }        public void setConsent(@Nullable final String[] featureNames, final boolean isConsentGiven) {            L.i("[Countly] setConsent");            synchronized (_cly) {                setConsentInternal(featureNames, isConsentGiven, ConsentChangeSource.ChangeConsentCall);            }        }        public void setConsentFeatureGroup(@Nullable final String groupName, final boolean isConsentGiven) {            L.i("[Countly] setConsentFeatureGroup, groupName: [" + groupName + "], isConsentGiven: [" + isConsentGiven + "]");            synchronized (_cly) {                if (!groupedFeatures.containsKey(groupName)) {                    L.d("[Countly] setConsentFeatureGroup, Trying to set consent for a unknown feature group: [" + groupName + "]");                    return;                }                setConsentInternal(groupedFeatures.get(groupName), isConsentGiven, ConsentChangeSource.ChangeConsentCall);            }        }        public void createFeatureGroup(@Nullable final String groupName, @Nullable final String[] features) {            L.i("[Countly] createFeatureGroup, groupName: [" + groupName + "], features: [" + Arrays.toString(features) + "]");            synchronized (_cly) {                groupedFeatures.put(groupName, features);            }        }    }}package ly.count.android.sdk;import android.text.TextUtils;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import ly.count.android.sdk.internal.RemoteConfigHelper;import ly.count.android.sdk.internal.RemoteConfigValueStore;import org.json.JSONException;import org.json.JSONObject;import static ly.count.android.sdk.ModuleConsent.ConsentChangeSource.ChangeConsentCall;public class ModuleRemoteConfig extends ModuleBase {    ImmediateRequestGenerator iRGenerator;    boolean updateRemoteConfigAfterIdChange = false;    Map<String, String[]> variantContainer = new HashMap<>();     Map<String, ExperimentInformation> experimentContainer = new HashMap<>();     RemoteConfig remoteConfigInterface = null;    boolean automaticDownloadTriggersEnabled;    boolean autoEnrollEnabled;    boolean remoteConfigValuesShouldBeCached = false;    List<RCDownloadCallback> downloadCallbacks = new ArrayList<>(2);    public final static String variantObjectNameKey = "name";    @Nullable    Map<String, String> metricOverride = null;    ModuleRemoteConfig(Countly cly, final CountlyConfig config) {        super(cly, config);        L.v("[ModuleRemoteConfig] Initialising");        metricOverride = config.metricOverride;        iRGenerator = config.immediateRequestGenerator;        L.d("[ModuleRemoteConfig] Setting if remote config Automatic triggers enabled, " + config.enableRemoteConfigAutomaticDownloadTriggers + ", caching enabled: " + config.enableRemoteConfigValueCaching + ", auto enroll enabled: " + config.enableAutoEnrollFlag);        automaticDownloadTriggersEnabled = config.enableRemoteConfigAutomaticDownloadTriggers;        remoteConfigValuesShouldBeCached = config.enableRemoteConfigValueCaching;        autoEnrollEnabled = config.enableAutoEnrollFlag;        downloadCallbacks.addAll(config.remoteConfigGlobalCallbackList);        if (config.remoteConfigCallbackLegacy != null) {            downloadCallbacks.add((downloadResult, error, fullValueUpdate, downloadedValues) -> config.remoteConfigCallbackLegacy.callback(error));        }        remoteConfigInterface = new RemoteConfig();    }    void updateRemoteConfigValues(@Nullable final String[] keysOnly, @Nullable final String[] keysExcept, final boolean useLegacyAPI, @Nullable final RCDownloadCallback devProvidedCallback) {        L.d("[ModuleRemoteConfig] Updating remote config values, legacyAPI:[" + useLegacyAPI + "]");        String[] preparedKeys = RemoteConfigHelper.prepareKeysIncludeExclude(keysOnly, keysExcept, L);        boolean fullUpdate = (preparedKeys[0] == null || preparedKeys[0].length() == 0) && (preparedKeys[1] == null || preparedKeys[1].length() == 0);        try {            if (deviceIdProvider.getDeviceId() == null) {                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, deviceID is null");                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, device ID is null", fullUpdate, null);                return;            }            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, temporary device ID mode is set");                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, temporary device ID is set", fullUpdate, null);                return;            }            String preparedMetrics = deviceInfo.getMetrics(_cly.context_, metricOverride, L);            String requestData;            if (useLegacyAPI) {                requestData = requestQueueProvider.prepareRemoteConfigRequestLegacy(preparedKeys[0], preparedKeys[1], preparedMetrics);            } else {                requestData = requestQueueProvider.prepareRemoteConfigRequest(preparedKeys[0], preparedKeys[1], preparedMetrics, autoEnrollEnabled);            }            L.d("[ModuleRemoteConfig] RemoteConfig requestData:[" + requestData + "]");            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {                L.d("[ModuleRemoteConfig] Processing remote config received response, received response is null:[" + (checkResponse == null) + "]");                if (checkResponse == null) {                    NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered problem while trying to reach the server, possibly no internet connection", fullUpdate, null);                    return;                }                String error = null;                Map<String, RCData> newRC = RemoteConfigHelper.DownloadedValuesIntoMap(checkResponse);                try {                    boolean clearOldValues = keysExcept == null && keysOnly == null;                    mergeCheckResponseIntoCurrentValues(clearOldValues, newRC);                } catch (Exception ex) {                    L.e("[ModuleRemoteConfig] updateRemoteConfigValues - execute, Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]");                    error = "Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]";                }                NotifyDownloadCallbacks(devProvidedCallback, error == null ? RequestResult.Success : RequestResult.Error, error, fullUpdate, newRC);            }, L);        } catch (Exception ex) {            L.e("[ModuleRemoteConfig] Encountered internal error while trying to perform a remote config update. " + ex.toString());            NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered internal error while trying to perform a remote config update", fullUpdate, null);        }    }    void enrollIntoABTestsForKeysInternal(@NonNull String[] keys) {        L.d("[ModuleRemoteConfig] Enrolling user for the given keys:" + keys);        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {            L.d("[ModuleRemoteConfig] Enrolling user was aborted, temporary device ID mode is set or device ID is null.");            return;        }        requestQueueProvider.enrollToKeys(keys);    }    void exitABTestsForKeysInternal(@NonNull String[] keys) {        L.d("[ModuleRemoteConfig] Removing user for the tests with given keys:" + keys);        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {            L.d("[ModuleRemoteConfig] Removing user from tests was aborted, temporary device ID mode is set or device ID is null.");            return;        }        requestQueueProvider.exitForKeys(keys);    }    void testingFetchVariantInformationInternal(@NonNull final RCVariantCallback callback, final boolean shouldFetchExperimentInfo) {        try {            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info");            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {                L.d("[ModuleRemoteConfig] Fetching all A/B test variants was aborted, temporary device ID mode is set or device ID is null.");                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");                return;            }            String requestData = shouldFetchExperimentInfo ? requestQueueProvider.prepareFetchAllExperiments() : requestQueueProvider.prepareFetchAllVariants();            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info requestData:[" + requestData + "]");            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants/info received response, received response is null:[" + (checkResponse == null) + "]");                if (checkResponse == null) {                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");                    return;                }                if (shouldFetchExperimentInfo) {                    experimentContainer = RemoteConfigHelper.convertExperimentInfoJsonToMap(checkResponse, L);                } else {                    variantContainer = RemoteConfigHelper.convertVariantsJsonToMap(checkResponse, L);                }                callback.callback(RequestResult.Success, null);            }, L);        } catch (Exception ex) {            L.e("[ModuleRemoteConfig] Encountered internal error while trying to fetch all A/B test variants/info. " + ex.toString());            callback.callback(RequestResult.Error, "Encountered internal error while trying to fetch all A/B test variants/info.");        }    }    void testingEnrollIntoVariantInternal(@NonNull final String key, @NonNull final String variant, @NonNull final RCVariantCallback callback) {        try {            L.d("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pairs:[" + key + "][" + variant + "]");            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {                L.d("[ModuleRemoteConfig] Enrolling A/B test variants was aborted, temporary device ID mode is set or device ID is null.");                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");                return;            }            if (TextUtils.isEmpty(key) || TextUtils.isEmpty(variant)) {                L.w("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pair is invalid. Aborting.");                callback.callback(RequestResult.Error, "Provided key/variant pair is invalid.");                return;            }            String requestData = requestQueueProvider.prepareEnrollVariant(key, variant);            L.d("[ModuleRemoteConfig] Enrolling A/B test variants requestData:[" + requestData + "]");            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/i", cp, false, networkingIsEnabled, checkResponse -> {                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants received response, received response is null:[" + (checkResponse == null) + "]");                if (checkResponse == null) {                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");                    return;                }                try {                    if (!isResponseValid(checkResponse)) {                        callback.callback(RequestResult.NetworkIssue, "Bad response from the server:" + checkResponse.toString());                        return;                    }                    RCAutomaticDownloadTrigger(true);                    callback.callback(RequestResult.Success, null);                } catch (Exception ex) {                    L.e("[ModuleRemoteConfig] testingEnrollIntoVariantInternal - execute, Encountered internal issue while trying to enroll to the variant, [" + ex.toString() + "]");                    callback.callback(RequestResult.Error, "Encountered internal error while trying to take care of the A/B test variant enrolment.");                }            }, L);        } catch (Exception ex) {            L.e("[ModuleRemoteConfig] Encountered internal error while trying to enroll A/B test variants. " + ex.toString());            callback.callback(RequestResult.Error, "Encountered internal error while trying to enroll A/B test variants.");        }    }    void mergeCheckResponseIntoCurrentValues(boolean clearOldValues, @NonNull Map<String, RCData> newRC) {        RemoteConfigValueStore rcvs = loadConfig();        rcvs.mergeValues(newRC, clearOldValues);        L.d("[ModuleRemoteConfig] Finished remote config processing, starting saving");        saveConfig(rcvs);        L.d("[ModuleRemoteConfig] Finished remote config saving");    }    boolean isResponseValid(@NonNull JSONObject responseJson) {        boolean result = false;        try {            if (responseJson.get("result").equals("Success")) {                result = true;            }        } catch (JSONException e) {            L.e("[ModuleRemoteConfig] isResponseValid, encountered issue, " + e);            return false;        }        return result;    }    RCData getRCValue(@NonNull String key) {        try {            RemoteConfigValueStore rcvs = loadConfig();            return rcvs.getValue(key);        } catch (Exception ex) {            L.e("[ModuleRemoteConfig] getValue, Call failed:[" + ex.toString() + "]");            return new RCData(null, true);        }    }    Object getRCValueLegacy(@NonNull String key) {        try {            RemoteConfigValueStore rcvs = loadConfig();            return rcvs.getValueLegacy(key);        } catch (Exception ex) {            L.e("[ModuleRemoteConfig] getValueLegacy, Call failed:[" + ex.toString() + "]");            return null;        }    }    void saveConfig(@NonNull RemoteConfigValueStore rcvs) {        storageProvider.setRemoteConfigValues(rcvs.dataToString());    }    @NonNull RemoteConfigValueStore loadConfig() {        String rcvsString = storageProvider.getRemoteConfigValues();        RemoteConfigValueStore rcvs = RemoteConfigValueStore.dataFromString(rcvsString, remoteConfigValuesShouldBeCached);        return rcvs;    }    void clearValueStoreInternal() {        storageProvider.setRemoteConfigValues("");    }    @NonNull Map<String, Object> getAllRemoteConfigValuesInternalLegacy() {        try {            RemoteConfigValueStore rcvs = loadConfig();            return rcvs.getAllValuesLegacy();        } catch (Exception ex) {            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");            return new HashMap<>();        }    }    @NonNull Map<String, RCData> getAllRemoteConfigValuesInternal() {        try {            RemoteConfigValueStore rcvs = loadConfig();            return rcvs.getAllValues();        } catch (Exception ex) {            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");            return new HashMap<>();        }    }    @NonNull Map<String, String[]> testingGetAllVariantsInternal() {        return variantContainer;    }    @Nullable String[] testingGetVariantsForKeyInternal(@NonNull String key) {        String[] variantResponse = null;        if (variantContainer.containsKey(key)) {            variantResponse = variantContainer.get(key);        }        return variantResponse;    }    void clearAndDownloadAfterIdChange() {        L.v("[RemoteConfig] Clearing remote config values and preparing to download after ID update");        CacheOrClearRCValuesIfNeeded();        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {            updateRemoteConfigAfterIdChange = true;        }    }    void CacheOrClearRCValuesIfNeeded() {        L.v("[RemoteConfig] CacheOrClearRCValuesIfNeeded, cacheclearing values");        RemoteConfigValueStore rc = loadConfig();        rc.cacheClearValues();        saveConfig(rc);    }    void NotifyDownloadCallbacks(RCDownloadCallback devProvidedCallback, RequestResult requestResult, String message, boolean fullUpdate, Map<String, RCData> downloadedValues) {        for (RCDownloadCallback callback : downloadCallbacks) {            callback.callback(requestResult, message, fullUpdate, downloadedValues);        }        if (devProvidedCallback != null) {            devProvidedCallback.callback(requestResult, message, fullUpdate, downloadedValues);        }    }    void RCAutomaticDownloadTrigger(boolean cacheClearOldValues) {        if (cacheClearOldValues) {            CacheOrClearRCValuesIfNeeded();        }        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {            L.d("[RemoteConfig] Automatically updating remote config values");            updateRemoteConfigValues(null, null, false, null);        } else {            L.v("[RemoteConfig] Automatic RC update trigger skipped");        }    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.remoteConfig) && changeSource == ChangeConsentCall) {            if (newConsent) {                L.d("[RemoteConfig] onConsentChanged, Consent given, will update RC values");                RCAutomaticDownloadTrigger(false);            }        }    }    @Override    void deviceIdChanged(boolean withoutMerge) {        L.v("[RemoteConfig] Device ID changed will update values: [" + updateRemoteConfigAfterIdChange + "]");        if (updateRemoteConfigAfterIdChange) {            updateRemoteConfigAfterIdChange = false;            RCAutomaticDownloadTrigger(true);        }    }    @Override    public void initFinished(@NonNull CountlyConfig config) {        if (!deviceIdProvider.isTemporaryIdEnabled()) {            RCAutomaticDownloadTrigger(false);        }    }    @Override    public void halt() {        remoteConfigInterface = null;    }    public class RemoteConfig {        public void clearStoredValues() {            synchronized (_cly) {                L.i("[RemoteConfig] clearStoredValues");                clearValueStoreInternal();            }        }        public Map<String, Object> getAllValues() {            synchronized (_cly) {                L.i("[RemoteConfig] getAllValues");                return getAllRemoteConfigValuesInternalLegacy();            }        }        public Object getValueForKey(String key) {            synchronized (_cly) {                L.i("[RemoteConfig] remoteConfigValueForKey, " + key);                return getRCValueLegacy(key);            }        }        public void updateExceptKeys(String[] keysToExclude, RemoteConfigCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] updateExceptKeys");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback("No consent given");                    }                    return;                }                if (keysToExclude == null) {                    L.w("[RemoteConfig] updateExceptKeys passed 'keys to ignore' array is null");                }                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    if (callback != null) {                        callback.callback(error);                    }                };                updateRemoteConfigValues(null, keysToExclude, true, innerCall);            }        }        public void updateForKeysOnly(String[] keysToInclude, RemoteConfigCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] updateForKeysOnly");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback("No consent given");                    }                    return;                }                if (keysToInclude == null) {                    L.w("[RemoteConfig] updateForKeysOnly passed 'keys to include' array is null");                }                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    if (callback != null) {                        callback.callback(error);                    }                };                updateRemoteConfigValues(keysToInclude, null, true, innerCall);            }        }        public void update(RemoteConfigCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] update");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback("No consent given");                    }                    return;                }                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    if (callback != null) {                        callback.callback(error);                    }                };                updateRemoteConfigValues(null, null, true, innerCall);            }        }        public void downloadOmittingKeys(@Nullable String[] keysToOmit, @Nullable RCDownloadCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] downloadOmittingKeys");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback(RequestResult.Error, null, false, null);                    }                    return;                }                if (keysToOmit == null) {                    L.w("[RemoteConfig] downloadOmittingKeys passed 'keys to ignore' array is null");                }                if (callback == null) {                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    };                }                updateRemoteConfigValues(null, keysToOmit, false, callback);            }        }        public void downloadSpecificKeys(@Nullable String[] keysToInclude, @Nullable RCDownloadCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] downloadSpecificKeys");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback(RequestResult.Error, null, false, null);                    }                    return;                }                if (keysToInclude == null) {                    L.w("[RemoteConfig] downloadSpecificKeys passed 'keys to include' array is null");                }                if (callback == null) {                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    };                }                updateRemoteConfigValues(keysToInclude, null, false, callback);            }        }        public void downloadAllKeys(@Nullable RCDownloadCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] downloadAllKeys");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    if (callback != null) {                        callback.callback(RequestResult.Error, null, true, null);                    }                    return;                }                if (callback == null) {                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {                    };                }                updateRemoteConfigValues(null, null, false, callback);            }        }        public @NonNull Map<String, RCData> getValues() {            synchronized (_cly) {                L.i("[RemoteConfig] getValues");                return getAllRemoteConfigValuesInternal();            }        }        public @NonNull Map<String, RCData> getAllValuesAndEnroll() {            synchronized (_cly) {                L.i("[RemoteConfig] getAllValuesAndEnroll");                Map<String, RCData> values = getAllRemoteConfigValuesInternal();                if (values.isEmpty()) {                    L.i("[RemoteConfig] getAllValuesAndEnroll, No value to enroll");                } else {                    Set<String> setOfKeys = values.keySet();                    String[] arrayOfKeys = new String[setOfKeys.size()];                    int i = 0;                    for (String key : setOfKeys) {                        arrayOfKeys[i++] = key;                    }                    enrollIntoABTestsForKeys(arrayOfKeys);                }                return values;            }        }        public @NonNull RCData getValue(final @Nullable String key) {            synchronized (_cly) {                L.i("[RemoteConfig] getValue, key:[" + key + "]");                if (key == null || key.equals("")) {                    L.i("[RemoteConfig] getValue, A valid key should be provided to get its value.");                    return new RCData(null, true);                }                return getRCValue(key);            }        }        public @NonNull RCData getValueAndEnroll(@Nullable String key) {            synchronized (_cly) {                L.i("[RemoteConfig] getValueAndEnroll, key:[" + key + "]");                if (key == null || key.equals("")) {                    L.i("[RemoteConfig] getValueAndEnroll, A valid key should be provided to get its value.");                    return new RCData(null, true);                }                RCData data = getRCValue(key);                if (data.value == null) {                    L.i("[RemoteConfig] getValueAndEnroll, No value to enroll");                } else {                    String[] arrayOfKeys = { key };                    enrollIntoABTestsForKeys(arrayOfKeys);                }                return data;            }        }        public void enrollIntoABTestsForKeys(@Nullable String[] keys) {            synchronized (_cly) {                L.i("[RemoteConfig] enrollIntoABTestsForKeys");                if (keys == null || keys.length == 0) {                    L.w("[RemoteConfig] enrollIntoABTestsForKeys, A key should be provided to enroll the user.");                    return;                }                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    return;                }                enrollIntoABTestsForKeysInternal(keys);            }        }        public void exitABTestsForKeys(@Nullable String[] keys) {            synchronized (_cly) {                L.i("[RemoteConfig] exitABTestsForKeys");                if (keys == null) {                    keys = new String[0];                }                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    return;                }                exitABTestsForKeysInternal(keys);            }        }        public void registerDownloadCallback(@Nullable RCDownloadCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] registerDownloadCallback");                downloadCallbacks.add(callback);            }        }        public void removeDownloadCallback(@Nullable RCDownloadCallback callback) {            synchronized (_cly) {                L.i("[RemoteConfig] removeDownloadCallback");                downloadCallbacks.remove(callback);            }        }        public void clearAll() {            synchronized (_cly) {                L.i("[RemoteConfig] clearAll");                clearStoredValues();            }        }        public @NonNull Map<String, String[]> testingGetAllVariants() {            synchronized (_cly) {                L.i("[RemoteConfig] testingGetAllVariants");                return testingGetAllVariantsInternal();            }        }        public @NonNull Map<String, ExperimentInformation> testingGetAllExperimentInfo() {            synchronized (_cly) {                L.i("[RemoteConfig] testingGetAllExperimentInfo");                return experimentContainer;            }        }        public @Nullable String[] testingGetVariantsForKey(@Nullable String key) {            synchronized (_cly) {                L.i("[RemoteConfig] testingGetVariantsForKey");                if (key == null) {                    L.i("[RemoteConfig] testingGetVariantsForKey, provided variant key can not be null");                    return null;                }                return testingGetVariantsForKeyInternal(key);            }        }        public void testingDownloadVariantInformation(@Nullable RCVariantCallback completionCallback) {            synchronized (_cly) {                L.i("[RemoteConfig] testingFetchVariantInformation");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    return;                }                if (completionCallback == null) {                    completionCallback = (result, error) -> {                    };                }                testingFetchVariantInformationInternal(completionCallback, false);            }        }        public void testingDownloadExperimentInformation(@Nullable RCVariantCallback completionCallback) {            synchronized (_cly) {                L.i("[RemoteConfig] testingDownloadExperimentInformation");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    return;                }                if (completionCallback == null) {                    completionCallback = (result, error) -> {                    };                }                testingFetchVariantInformationInternal(completionCallback, true);            }        }        public void testingEnrollIntoVariant(@Nullable String keyName, String variantName, @Nullable RCVariantCallback completionCallback) {            synchronized (_cly) {                L.i("[RemoteConfig] testingEnrollIntoVariant");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {                    return;                }                if (keyName == null || variantName == null) {                    L.w("[RemoteConfig] testEnrollIntoVariant, passed key or variant is null. Aborting.");                    return;                }                if (completionCallback == null) {                    completionCallback = (result, error) -> {                    };                }                testingEnrollIntoVariantInternal(keyName, variantName, completionCallback);            }        }    }}package ly.count.android.sdk;import android.app.Activity;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class ModuleAPM extends ModuleBase {    final static String[] reservedKeys = { "response_time", "response_payload_size", "response_code", "request_payload_size", "duration", "slow_rendering_frames", "frozen_frames" };    Apm apmInterface = null;    Map<String, Long> codeTraces;    Map<String, Long> networkTraces;    boolean hasFirstOnResumeHappened = false;    long lastScreenSwitchTime = -1;    int activitiesOpen;    boolean useManualAppLoadedTrigger;    long appStartTimestamp;    boolean manualForegroundBackgroundTriggers;    boolean trackForegroundBackground;    boolean manualOverrideInForeground = false;    boolean appStartRecorded = false;    ModuleAPM(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleAPM] Initialising");        codeTraces = new HashMap<>();        networkTraces = new HashMap<>();        activitiesOpen = 0;        useManualAppLoadedTrigger = config.apm.appLoadedManualTrigger;        if (config.apm.appStartTimestampOverride != null) {            appStartTimestamp = config.apm.appStartTimestampOverride;            L.d("[ModuleAPM] Using app start timestamp override");        } else {            appStartTimestamp = Countly.applicationStart;        }        if (config.apm.appLoadedManualTrigger) {            L.d("[ModuleAPM] Using manual app finished loading trigger for app start");        }        manualForegroundBackgroundTriggers = config.apm.manualForegroundBackgroundTrigger;        if (manualForegroundBackgroundTriggers) {            L.d("[ModuleAPM] Using manual foreground/background triggers");        }        trackForegroundBackground = config.apm.trackForegroundBackground;        if (trackForegroundBackground) {            L.d("[ModuleAPM] tracking foreground/background is enabled");        }        apmInterface = new Apm();    }    void startTraceInternal(String traceKey) {        L.d("[ModuleAPM] Calling 'startTraceInternal' with key:[" + traceKey + "]");        if (traceKey == null || traceKey.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid trace key");            return;        }        Long currentTimestamp = UtilsTime.currentTimestampMs();        codeTraces.put(traceKey, currentTimestamp);    }    void endTraceInternal(@NonNull String traceKey, @NonNull Map<String, Integer> customMetrics) {        Long currentTimestamp = UtilsTime.currentTimestampMs();        assert traceKey != null && !traceKey.isEmpty();        assert customMetrics != null;        L.d("[ModuleAPM] Calling 'endTraceInternal' with key:[" + traceKey + "]");        if (codeTraces.containsKey(traceKey)) {            Long startTimestamp = codeTraces.remove(traceKey);            if (startTimestamp == null) {                L.e("[ModuleAPM] endTraceInternal, retrieved 'startTimestamp' is null, dropping trace");            } else {                Long durationMs = currentTimestamp - startTimestamp;                if (!customMetrics.isEmpty()) {                    removeReservedInvalidKeys(customMetrics);                    UtilsInternalLimits.truncateSegmentationKeys(customMetrics, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] endTraceInternal");                    UtilsInternalLimits.truncateSegmentationValues(customMetrics, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleAPM] endTraceInternal", L);                }                String metricString = customMetricsToString(customMetrics);                String truncatedTraceKey = UtilsInternalLimits.truncateKeyLength(traceKey, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] endTraceInternal");                String modifiedTraceKey = validateAndModifyTraceKey(truncatedTraceKey);                requestQueueProvider.sendAPMCustomTrace(modifiedTraceKey, durationMs, startTimestamp, currentTimestamp, metricString);            }        } else {            L.w("[ModuleAPM] endTraceInternal, trying to end trace which was not started");        }    }    void cancelTraceInternal(String traceKey) {        L.d("[ModuleAPM] Calling 'cancelTraceInternal' with key:[" + traceKey + "]");        if (traceKey == null || traceKey.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid trace key");            return;        }        if (!codeTraces.containsKey(traceKey)) {            L.w("[ModuleAPM] no trace with key [" + traceKey + "] found");            return;        }        codeTraces.remove(traceKey);    }    void cancelAllTracesInternal() {        L.d("[ModuleAPM] Calling 'cancelAllTracesInternal'");        codeTraces.clear();    }    static String customMetricsToString(@NonNull Map<String, Integer> customMetrics) {        assert customMetrics != null;        StringBuilder ret = new StringBuilder();        for (Map.Entry<String, Integer> entry : customMetrics.entrySet()) {            String key = entry.getKey();            Integer value = entry.getValue();            ret.append(",\"");            ret.append(key);            ret.append("\":");            ret.append(value);        }        return ret.toString();    }    void removeReservedInvalidKeys(Map<String, Integer> customMetrics) {        if (customMetrics == null) {            return;        }        for (String rKey : ModuleAPM.reservedKeys) {            customMetrics.remove(rKey);        }        for (Iterator<Map.Entry<String, Integer>> it = customMetrics.entrySet().iterator(); it.hasNext(); ) {            Map.Entry<String, Integer> entry = it.next();            String key = entry.getKey();            Integer value = entry.getValue();            if (key == null || key.isEmpty() || value == null) {                it.remove();                L.w("[ModuleAPM] custom metrics can't contain null or empty key/value");                continue;            }            int keyLength = key.length();            if (keyLength > 32) {                it.remove();                L.w("[ModuleAPM] custom metric key can't be longer than 32 characters, skipping entry, [" + key + "]");                continue;            }            if (key.charAt(0) == '$') {                L.w("[ModuleAPM] custom metric key can't start with '$', it will be removed server side, [" + key + "]");            }            if (key.contains(".")) {                L.w("[ModuleAPM] custom metric key can't contain '.', those will be removed server side, [" + key + "]");            }        }    }    String validateAndModifyTraceKey(String traceKey) {        if (traceKey.charAt(0) == '$') {            L.w("[ModuleAPM] validateAndModifyTraceKey, trace keys can't start with '$', it will be removed server side");        }        if (traceKey.length() > 2048) {            traceKey = traceKey.substring(0, 2047);            L.w("[ModuleAPM] validateAndModifyTraceKey, trace keys can't be longer than 2048 characters, it will be trimmed down");        }        return traceKey;    }    void startNetworkRequestInternal(String networkTraceKey, String uniqueId) {        L.d("[ModuleAPM] Calling 'startNetworkRequestInternal' with key:[" + networkTraceKey + "]");        if (networkTraceKey == null || networkTraceKey.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid trace key");            return;        }        if (uniqueId == null || uniqueId.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid uniqueId");            return;        }        String internalTraceKey = networkTraceKey + "|" + uniqueId;        Long currentTimestamp = UtilsTime.currentTimestampMs();        networkTraces.put(internalTraceKey, currentTimestamp);    }    void endNetworkRequestInternal(String networkTraceKey, String uniqueId, int responseCode, int requestPayloadSize, int responsePayloadSize) {        long currentTimestamp = UtilsTime.currentTimestampMs();        L.d("[ModuleAPM] Calling 'endNetworkRequestInternal' with key:[" + networkTraceKey + "]");        if (networkTraceKey == null || networkTraceKey.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid trace key");            return;        }        if (uniqueId == null || uniqueId.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid uniqueId");            return;        }        String internalTraceKey = networkTraceKey + "|" + uniqueId;        if (networkTraces.containsKey(internalTraceKey)) {            Long startTimestamp = networkTraces.remove(internalTraceKey);            if (startTimestamp == null) {                L.e("[ModuleAPM] endNetworkRequestInternal, retrieved 'startTimestamp' is null");            } else {                recordNetworkRequestInternal(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, startTimestamp, currentTimestamp);            }        } else {            L.w("[ModuleAPM] endNetworkRequestInternal, trying to end trace which was not started");        }    }    void recordNetworkRequestInternal(String networkTraceKey, int responseCode, int requestPayloadSize, int responsePayloadSize, long startTimestamp, long endTimestamp) {        L.v("[ModuleAPM] Calling 'recordNetworkRequestInternal' with key:[" + networkTraceKey + "]");        if (networkTraceKey == null || networkTraceKey.isEmpty()) {            L.e("[ModuleAPM] Provided a invalid trace key, aborting request");            return;        }        if (!(responseCode >= 100 && responseCode < 600)) {            L.e("[ModuleAPM] Invalid response code was provided, setting to '0'");            responseCode = 0;        }        if (requestPayloadSize < 0) {            L.e("[ModuleAPM] Invalid request payload size was provided, setting to '0'");            requestPayloadSize = 0;        }        if (responsePayloadSize < 0) {            L.e("[ModuleAPM] Invalid response payload size was provided, setting to '0'");            responsePayloadSize = 0;        }        if (startTimestamp > endTimestamp) {            L.e("[ModuleAPM] End timestamp is smaller than start timestamp, switching values");            long tmp = startTimestamp;            startTimestamp = endTimestamp;            endTimestamp = tmp;        }        networkTraceKey = UtilsInternalLimits.truncateKeyLength(networkTraceKey, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleAPM] recordNetworkRequestInternal");        networkTraceKey = validateAndModifyTraceKey(networkTraceKey);        Long responseTimeMs = endTimestamp - startTimestamp;        requestQueueProvider.sendAPMNetworkTrace(networkTraceKey, responseTimeMs, responseCode, requestPayloadSize, responsePayloadSize, startTimestamp, endTimestamp);    }    void clearNetworkTraces() {        L.v("[ModuleAPM] Calling 'clearNetworkTraces'");        networkTraces.clear();    }    void recordAppStart(long appLoadedTimestamp) {        if (!_cly.config_.apm.trackAppStartTime) {            L.d("[ModuleAPM] Calling 'recordAppStart', call will be ignored due to app start tracking not being enabled");            return;        }        if (appStartRecorded) {            L.w("[ModuleAPM] Calling 'recordAppStart', call will be ignored due to it already being registered before");            return;        }        L.d("[ModuleAPM] Calling 'recordAppStart' [" + appLoadedTimestamp + "] [" + appStartTimestamp + "]");        long durationMs = appLoadedTimestamp - appStartTimestamp;        if (durationMs <= 0) {            L.e("[ModuleAPM] Encountered negative app start duration:[" + durationMs + "] dropping app start duration request");            return;        }        requestQueueProvider.sendAPMAppStart(durationMs, appStartTimestamp, appLoadedTimestamp);        appStartRecorded = true;    }    void calculateAppRunningTimes(int previousCount, int newCount) {        boolean goingToBackground = previousCount == 1 && newCount == 0;        boolean goingToForeground = previousCount == 0 && newCount == 1;        L.v("[ModuleAPM] calculateAppRunningTimes, going toBG[" + goingToBackground + "] going toFG[" + goingToForeground + "] | [" + previousCount + "][" + newCount + "]");        doForegroundBackgroundCalculations(goingToBackground, goingToForeground);    }    void doForegroundBackgroundCalculations(boolean goingToBackground, boolean goingToForeground) {        L.d("[ModuleAPM] Calling 'doForegroundBackgroundCalculations', [" + goingToBackground + "] [" + goingToForeground + "]");        if (goingToBackground || goingToForeground) {            long currentTimeMs = UtilsTime.currentTimestampMs();            if (lastScreenSwitchTime != -1) {                long durationMs = currentTimeMs - lastScreenSwitchTime;                if (goingToForeground) {                    requestQueueProvider.sendAPMScreenTime(false, durationMs, lastScreenSwitchTime, currentTimeMs);                } else if (goingToBackground) {                    requestQueueProvider.sendAPMScreenTime(true, durationMs, lastScreenSwitchTime, currentTimeMs);                }            } else {                L.d("[ModuleAPM] 'doForegroundBackgroundCalculations' last screen switch time was '-1', doing nothing");            }            lastScreenSwitchTime = currentTimeMs;        } else {            L.d("[ModuleAPM] Calling 'doForegroundBackgroundCalculations', just changing screens, ignoring request");        }    }    void goToForeground() {        L.d("[ModuleAPM] Calling 'goToForeground'");        if (manualOverrideInForeground) {            return;        }        manualOverrideInForeground = true;        doForegroundBackgroundCalculations(false, true);    }    void goToBackground() {        L.d("[ModuleAPM] Calling 'goToBackground'");        if (!manualOverrideInForeground) {            return;        }        manualOverrideInForeground = false;        doForegroundBackgroundCalculations(true, false);    }    @Override    void halt() {        codeTraces = null;        networkTraces = null;    }    @Override    void callbackOnActivityResumed(Activity activity) {        L.d("[Apm] Calling 'callbackOnActivityResumed'");    }    @Override    void onActivityStarted(Activity activity, int updatedActivityCount) {        L.d("[Apm] Calling 'onActivityStarted', [" + activitiesOpen + "] -> [" + (activitiesOpen + 1) + "]");        long currentTimestamp = System.currentTimeMillis();        if (trackForegroundBackground && !manualForegroundBackgroundTriggers) {            calculateAppRunningTimes(activitiesOpen, activitiesOpen + 1);        }        activitiesOpen++;        if (!hasFirstOnResumeHappened) {            hasFirstOnResumeHappened = true;            if (!useManualAppLoadedTrigger) {                recordAppStart(currentTimestamp);            }        }    }    @Override    void callbackOnActivityStopped(Activity activity) {        L.d("[Apm] Calling 'callbackOnActivityStopped', [" + activitiesOpen + "] -> [" + (activitiesOpen - 1) + "]");        if (trackForegroundBackground & !manualForegroundBackgroundTriggers) {            calculateAppRunningTimes(activitiesOpen, activitiesOpen - 1);        }        activitiesOpen--;    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.apm)) {            if (!newConsent) {                _cly.moduleAPM.clearNetworkTraces();                _cly.moduleAPM.cancelAllTracesInternal();            }        }    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (_cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Increasing the activity counter.");            activitiesOpen++;        }        if (trackForegroundBackground && !manualForegroundBackgroundTriggers && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Starting to track foreground time");            calculateAppRunningTimes(activitiesOpen - 1, activitiesOpen);        }        if (config.apm.trackAppStartTime && !config.apm.appLoadedManualTrigger && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {            L.d("[ModuleAPM] SDK detects that the app is in the foreground. Recording automatic app start duration");            long currentTimestamp = System.currentTimeMillis();            recordAppStart(currentTimestamp);        }    }    public class Apm {        public void startTrace(String traceKey) {            synchronized (_cly) {                L.i("[Apm] Calling 'startTrace' with key:[" + traceKey + "]");                startTraceInternal(traceKey);            }        }        public void endTrace(@Nullable String traceKey, @Nullable Map<String, Integer> customMetrics) {            synchronized (_cly) {                L.i("[Apm] Calling 'endTrace' with key:[" + traceKey + "]");                if (traceKey == null || traceKey.isEmpty()) {                    L.e("[Apm] Calling 'endTrace' with invalid traceKey");                    return;                }                Map<String, Integer> customMetricsInternal;                if (customMetrics == null) {                    customMetricsInternal = new ConcurrentHashMap<>();                } else {                    customMetricsInternal = customMetrics;                }                endTraceInternal(traceKey, customMetricsInternal);            }        }        public void cancelTrace(String traceKey) {            synchronized (_cly) {                L.i("[Apm] Calling 'cancelTrace' with key:[" + traceKey + "]");                cancelTraceInternal(traceKey);            }        }        public void cancelAllTraces() {            synchronized (_cly) {                L.i("[Apm] Calling 'cancelAllTraces'");                cancelAllTracesInternal();                clearNetworkTraces();            }        }        public void startNetworkRequest(String networkTraceKey, String uniqueId) {            synchronized (_cly) {                L.i("[Apm] Calling 'startNetworkRequest' with key:[" + networkTraceKey + "], uniqueID:[" + uniqueId + "]");                startNetworkRequestInternal(networkTraceKey, uniqueId);            }        }        public void endNetworkRequest(String networkTraceKey, String uniqueId, int responseCode, int requestPayloadSize, int responsePayloadSize) {            synchronized (_cly) {                L.i("[Apm] Calling 'endNetworkRequest' with key:[" + networkTraceKey + "], uniqueID:[" + uniqueId + "]");                endNetworkRequestInternal(networkTraceKey, uniqueId, responseCode, requestPayloadSize, responsePayloadSize);            }        }        public void recordNetworkTrace(String networkTraceKey, int responseCode, int requestPayloadSize, int responsePayloadSize, long requestStartTimestampMs, long requestEndTimestampMs) {            synchronized (_cly) {                L.i("[Apm] Calling 'recordNetworkTrace' with key:[" + networkTraceKey + "]");                recordNetworkRequestInternal(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, requestStartTimestampMs, requestEndTimestampMs);            }        }        public void setAppIsLoaded() {            synchronized (_cly) {                L.i("[Apm] Calling 'setAppIsLoaded'");                long timestamp = System.currentTimeMillis();                if (!useManualAppLoadedTrigger) {                    L.w("[Apm] trying to record that app has finished loading without enabling manual trigger");                    return;                }                recordAppStart(timestamp);            }        }        public void triggerForeground() {            synchronized (_cly) {                L.i("[Apm] Calling 'triggerForeground'");                if (!trackForegroundBackground) {                    L.w("[Apm] triggerForeground, tracking foreground is disabled");                    return;                }                if (!manualForegroundBackgroundTriggers) {                    L.w("[Apm] trying to use manual foreground triggers without enabling them");                    return;                }                goToForeground();            }        }        public void triggerBackground() {            synchronized (_cly) {                L.i("[Apm] Calling 'triggerBackground'");                if (!trackForegroundBackground) {                    L.w("[Apm] triggerBackground, tracking background is disabled");                    return;                }                if (!manualForegroundBackgroundTriggers) {                    L.w("[Apm] triggerBackground, trying to use manual background triggers without enabling them");                    return;                }                goToBackground();            }        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.List;import java.util.Map;public class ModuleSessions extends ModuleBase {    boolean manualSessionControlEnabled = false;    boolean manualSessionControlHybridModeEnabled = false;    long prevSessionDurationStartTime_ = System.currentTimeMillis();    boolean sessionRunning = false;    final Sessions sessionInterface;    @Nullable    Map<String, String> metricOverride = null;    ModuleSessions(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleSessions] Initialising");        metricOverride = config.metricOverride;        manualSessionControlEnabled = config.manualSessionControlEnabled;        if (manualSessionControlEnabled) {            L.d("[ModuleSessions] Enabling manual session control");        }        manualSessionControlHybridModeEnabled = config.manualSessionControlHybridModeEnabled;        if (manualSessionControlHybridModeEnabled) {            L.d("[ModuleSessions] Enabling manual session control hybrid mode");        }        if (config.disableUpdateSessionRequests) {            L.d("[ModuleSessions] Disabling periodic session time updates");            _cly.disableUpdateSessionRequests_ = config.disableUpdateSessionRequests;        }        sessionInterface = new Sessions();    }    void beginSessionInternal() {        L.d("[ModuleSessions] 'beginSessionInternal'");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {            return;        }        if (sessionIsRunning()) {            L.w("[ModuleSessions] A session is already running, this 'beginSessionInternal' will be ignored");            healthTracker.logSessionStartedWhileRunning();            return;        }        String preparedMetrics = deviceInfo.getMetrics(_cly.context_, metricOverride, L);        sessionRunning = true;        prevSessionDurationStartTime_ = System.currentTimeMillis();        requestQueueProvider.beginSession(_cly.moduleLocation.locationDisabled, _cly.moduleLocation.locationCountryCode, _cly.moduleLocation.locationCity, _cly.moduleLocation.locationGpsCoordinates, _cly.moduleLocation.locationIpAddress, preparedMetrics);        if (_cly.moduleViews.trackOrientationChanges) {            _cly.moduleViews.updateOrientation(_cly.context_.getResources().getConfiguration().orientation, true);        }    }    void updateSessionInternal() {        L.d("[ModuleSessions] 'updateSessionInternal'");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {            return;        }        if (!sessionIsRunning()) {            L.w("[ModuleSessions] No session is running, this 'updateSessionInternal' will be ignored");            healthTracker.logSessionUpdatedWhileNotRunning();            return;        }        if (!_cly.disableUpdateSessionRequests_) {            requestQueueProvider.updateSession(roundedSecondsSinceLastSessionDurationUpdate());        }    }    void endSessionInternal(boolean checkConsent) {        L.d("[ModuleSessions] endSessionInternal, checkConsent:[" + checkConsent + "]");        if (checkConsent && !consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {            return;        }        if (!sessionIsRunning()) {            L.w("[ModuleSessions] No session is running, this 'endSessionInternal' will be ignored");            healthTracker.logSessionEndedWhileNotRunning();            return;        }        _cly.moduleRequestQueue.sendEventsIfNeeded(true);        _cly.moduleUserProfile.saveInternal();        requestQueueProvider.endSession(roundedSecondsSinceLastSessionDurationUpdate());        sessionRunning = false;        _cly.moduleViews.resetFirstView();    }    void endSessionInternal() {        endSessionInternal(true);    }    public boolean sessionIsRunning() {        return sessionRunning;    }    int roundedSecondsSinceLastSessionDurationUpdate() {        if (prevSessionDurationStartTime_ < 1) {            L.e("[ModuleSessions] roundedSecondsSinceLastSessionDurationUpdate, called with prevSessionDurationStartTime_ being less than 1, returning 0, values was:[" + prevSessionDurationStartTime_ + "]");            return 0;        }        final long currentTimestampInMilliseconds = System.currentTimeMillis();        final long unsentSessionLengthInMilliseconds = currentTimestampInMilliseconds - prevSessionDurationStartTime_;        prevSessionDurationStartTime_ = currentTimestampInMilliseconds;        int seconds = (int) Math.round(unsentSessionLengthInMilliseconds / 1_000.0d);        L.d("[ModuleSessions] roundedSecondsSinceLastSessionDurationUpdate, psds_:[" + prevSessionDurationStartTime_ + "], ctim:[" + currentTimestampInMilliseconds + "], uslim:[" + unsentSessionLengthInMilliseconds + "], uslim_s:[" + seconds + "]");        return seconds;    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        L.d("[ModuleSessions] onConsentChanged, consentChangeDelta:[" + consentChangeDelta + "], newConsent:[" + newConsent + "], changeSource:[" + changeSource + "]");        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.sessions)) {            if (newConsent) {                if (!manualSessionControlEnabled && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {                    beginSessionInternal();                }            } else {                L.d("[ModuleSessions] Ending session due to consent change");                if (!_cly.isBeginSessionSent) {                    _cly.moduleLocation.sendCurrentLocationIfValid();                }                if (sessionIsRunning()) {                    endSessionInternal(false);                } else {                    _cly.moduleViews.resetFirstView();                }            }        }    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (!manualSessionControlEnabled && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {            beginSessionInternal();        }    }    @Override    void halt() {        prevSessionDurationStartTime_ = 0;        sessionRunning = false;    }    @Override    void deviceIdChanged(boolean withoutMerge) {        if (!manualSessionControlEnabled && withoutMerge && _cly.config_.lifecycleObserver.LifeCycleAtleastStarted()) {            L.d("[ModuleSessions] deviceIdChanged, automatic session control enabled and device id changed without merge, starting a new session");            beginSessionInternal();        }    }    public class Sessions {        public void beginSession() {            synchronized (_cly) {                L.i("[Sessions] Calling 'beginSession', manual session control enabled:[" + manualSessionControlEnabled + "]");                if (!manualSessionControlEnabled) {                    L.w("[Sessions] 'beginSession' will be ignored since manual session control is not enabled");                    return;                }                beginSessionInternal();            }        }        public void updateSession() {            synchronized (_cly) {                L.i("[Sessions] Calling 'updateSession', manual session control enabled:[" + manualSessionControlEnabled + "]");                if (!manualSessionControlEnabled) {                    L.w("[Sessions] 'updateSession' will be ignored since manual session control is not enabled");                    return;                }                if (manualSessionControlHybridModeEnabled) {                    L.w("[Sessions] 'updateSession' will be ignored since manual session control hybrid mode is enabled");                    return;                }                updateSessionInternal();            }        }        public void endSession() {            synchronized (_cly) {                L.i("[Sessions] Calling 'endSession', manual session control enabled:[" + manualSessionControlEnabled + "]");                if (!manualSessionControlEnabled) {                    L.w("[Sessions] 'endSession' will be ignored since manual session control is not enabled");                    return;                }                endSessionInternal();            }        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;class ModuleHealthCheck extends ModuleBase {    ImmediateRequestGenerator immediateRequestGenerator;    HealthCheckCounter hCounter;    boolean healthCheckEnabled = true;    boolean healthCheckSent = false;    ModuleHealthCheck(@NonNull Countly cly, @NonNull CountlyConfig config) {        super(cly, config);        L.v("[ModuleHealthCheck] Initialising, enabled: " + healthCheckEnabled);        hCounter = new HealthCheckCounter(config.storageProvider, L);        config.healthTracker = hCounter;        immediateRequestGenerator = config.immediateRequestGenerator;        healthCheckEnabled = config.healthCheckEnabled;    }    @Override    void initFinished(@NonNull final CountlyConfig config) {        if (healthCheckEnabled) {            sendHealthCheck();        }    }    @Override    void halt() {        hCounter = null;        immediateRequestGenerator = null;    }    @Override    void onActivityStopped(int updatedActivityCount) {        hCounter.saveState();    }    void sendHealthCheck() {        L.v("[ModuleHealthCheck] sendHealthCheck, attempting to send health information");        if (!healthCheckEnabled) {            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check is disabled");            return;        }        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, temporary device ID mode is set");            return;        }        if (healthCheckSent) {            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check already sent");            return;        }        healthCheckSent = true;        String preparedMetrics = deviceInfo.getMetricsHealthCheck(_cly.context_, _cly.config_.metricOverride);        StringBuilder requestData = new StringBuilder(requestQueueProvider.prepareHealthCheckRequest(preparedMetrics));        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        requestData.append(hCounter.createRequestParam());        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData.toString(), "/i", cp, false, networkingIsEnabled, checkResponse -> {            if (checkResponse == null) {                L.w("[ModuleHealthCheck] No response for sending health check Probably due to lack of connection to the server");                return;            }            L.d("[ModuleHealthCheck] Retrieved request response: [" + checkResponse.toString() + "]");            if (!checkResponse.has("result")) {                L.d("[ModuleHealthCheck] Retrieved request response does not match expected pattern");                return;            }            L.d("[ModuleHealthCheck] sendHealthCheck, SDK health information sent successfully");            hCounter.clearAndSave();        }, L);    }}package ly.count.android.sdk;import android.content.Intent;import android.content.res.Configuration;import android.content.res.Resources;import android.util.DisplayMetrics;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.Arrays;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.json.JSONArray;import org.json.JSONObject;public class ModuleContent extends ModuleBase {    private final ImmediateRequestGenerator iRGenerator;    Content contentInterface;    CountlyTimer countlyTimer;    private boolean shouldFetchContents = false;    private final int zoneTimerInterval;    private final ContentCallback globalContentCallback;    static int waitForDelay = 0;    ModuleContent(@NonNull Countly cly, @NonNull CountlyConfig config) {        super(cly, config);        L.v("[ModuleContent] Initialising");        iRGenerator = config.immediateRequestGenerator;        contentInterface = new Content();        countlyTimer = new CountlyTimer();        zoneTimerInterval = config.content.zoneTimerInterval;        globalContentCallback = config.content.globalContentCallback;    }    void fetchContentsInternal(@NonNull String[] categories) {        L.d("[ModuleContent] fetchContentsInternal, shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(categories) + "]");        DisplayMetrics displayMetrics = deviceInfo.mp.getDisplayMetrics(_cly.context_);        String requestData = prepareContentFetchRequest(displayMetrics, categories);        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk/content", cp, false, networkingIsEnabled, checkResponse -> {            L.d("[ModuleContent] fetchContentsInternal, processing fetched contents, received response is :[" + checkResponse + "]");            if (checkResponse == null) {                return;            }            try {                if (validateResponse(checkResponse)) {                    L.d("[ModuleContent] fetchContentsInternal, got new content data, showing it");                    Map<Integer, TransparentActivityConfig> placementCoordinates = parseContent(checkResponse, displayMetrics);                    if (placementCoordinates.isEmpty()) {                        L.d("[ModuleContent] fetchContentsInternal, placement coordinates are empty, skipping");                        return;                    }                    Intent intent = new Intent(_cly.context_, TransparentActivity.class);                    intent.putExtra(TransparentActivity.CONFIGURATION_LANDSCAPE, placementCoordinates.get(Configuration.ORIENTATION_LANDSCAPE));                    intent.putExtra(TransparentActivity.CONFIGURATION_PORTRAIT, placementCoordinates.get(Configuration.ORIENTATION_PORTRAIT));                    intent.putExtra(TransparentActivity.ORIENTATION, _cly.context_.getResources().getConfiguration().orientation);                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                    _cly.context_.startActivity(intent);                    shouldFetchContents = false;                 } else {                    L.w("[ModuleContent] fetchContentsInternal, response is not valid, skipping");                }            } catch (Exception ex) {                L.e("[ModuleContent] fetchContentsInternal, Encountered internal issue while trying to fetch contents, [" + ex + "]");            }        }, L);    }    void registerForContentUpdates(@Nullable String[] categories) {        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.w("[ModuleContent] registerForContentUpdates, temporary device ID is enabled, skipping");            return;        }        String[] validCategories;        if (categories == null) {            L.w("[ModuleContent] registerForContentUpdates, categories is null, providing empty array");            validCategories = new String[] {};        } else {            validCategories = categories;        }        countlyTimer.startTimer(zoneTimerInterval, () -> {            L.d("[ModuleContent] registerForContentUpdates, waitForDelay: [" + waitForDelay + "], shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(validCategories) + "]");            if (waitForDelay > 0) {                waitForDelay--;                return;            }            if (!shouldFetchContents) {                L.w("[ModuleContent] registerForContentUpdates, shouldFetchContents is false, skipping");                return;            }            fetchContentsInternal(validCategories);        }, L);    }    @NonNull    private String prepareContentFetchRequest(@NonNull DisplayMetrics displayMetrics, @NonNull String[] categories) {        Resources resources = _cly.context_.getResources();        int currentOrientation = resources.getConfiguration().orientation;        boolean portrait = currentOrientation == Configuration.ORIENTATION_PORTRAIT;        int scaledWidth = (int) Math.ceil(displayMetrics.widthPixels / displayMetrics.density);        int scaledHeight = (int) Math.ceil(displayMetrics.heightPixels / displayMetrics.density);        int portraitWidth = portrait ? scaledWidth : scaledHeight;        int portraitHeight = portrait ? scaledHeight : scaledWidth;        int landscapeWidth = portrait ? scaledHeight : scaledWidth;        int landscapeHeight = portrait ? scaledWidth : scaledHeight;        String language = Locale.getDefault().getLanguage().toLowerCase();        return requestQueueProvider.prepareFetchContents(portraitWidth, portraitHeight, landscapeWidth, landscapeHeight, categories, language);    }    boolean validateResponse(@NonNull JSONObject response) {        return response.has("geo");    }    @NonNull    Map<Integer, TransparentActivityConfig> parseContent(@NonNull JSONObject response, @NonNull DisplayMetrics displayMetrics) {        Map<Integer, TransparentActivityConfig> placementCoordinates = new ConcurrentHashMap<>();        JSONArray contents = response.optJSONArray("content");        JSONObject contentObj = response;         assert contentObj != null;        String content = contentObj.optString("html");        JSONObject coordinates = contentObj.optJSONObject("geo");        assert coordinates != null;        placementCoordinates.put(Configuration.ORIENTATION_PORTRAIT, extractOrientationPlacements(coordinates, displayMetrics.density, "p", content));        placementCoordinates.put(Configuration.ORIENTATION_LANDSCAPE, extractOrientationPlacements(coordinates, displayMetrics.density, "l", content));        return placementCoordinates;    }    private TransparentActivityConfig extractOrientationPlacements(@NonNull JSONObject placements, float density, @NonNull String orientation, @NonNull String content) {        if (placements.has(orientation)) {            JSONObject orientationPlacements = placements.optJSONObject(orientation);            assert orientationPlacements != null;            int x = orientationPlacements.optInt("x");            int y = orientationPlacements.optInt("y");            int w = orientationPlacements.optInt("w");            int h = orientationPlacements.optInt("h");            L.d("[ModuleContent] extractOrientationPlacements, orientation: [" + orientation + "], x: [" + x + "], y: [" + y + "], w: [" + w + "], h: [" + h + "]");            TransparentActivityConfig config = new TransparentActivityConfig((int) Math.ceil(x * density), (int) Math.ceil(y * density), (int) Math.ceil(w * density), (int) Math.ceil(h * density));            config.url = content;            TransparentActivity.globalContentCallback = globalContentCallback;            return config;        }        return null;    }    @Override    void halt() {        contentInterface = null;        countlyTimer.stopTimer(L);        countlyTimer = null;    }    private void optOutFromContent() {        exitContentZoneInternal();        shouldFetchContents = false;    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        L.d("[ModuleContent] onConsentChanged, consentChangeDelta: [" + consentChangeDelta + "], newConsent: [" + newConsent + "], changeSource: [" + changeSource + "]");        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.content) && !newConsent) {            optOutFromContent();        }    }    @Override    void deviceIdChanged(boolean withoutMerge) {        L.d("[ModuleContent] deviceIdChanged, withoutMerge: [" + withoutMerge + "]");        if (withoutMerge) {            optOutFromContent();        }    }    protected void exitContentZoneInternal() {        shouldFetchContents = false;        countlyTimer.stopTimer(L);    }    public class Content {        private void enterContentZone(@Nullable String... categories) {            L.d("[ModuleContent] openForContent, categories: [" + Arrays.toString(categories) + "]");            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {                L.w("[ModuleContent] openForContent, Consent is not granted, skipping");                return;            }            shouldFetchContents = true;            registerForContentUpdates(categories);        }        public void enterContentZone() {            enterContentZone(new String[] {});        }        public void exitContentZone() {            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {                L.w("[ModuleContent] exitFromContent, Consent is not granted, skipping");                return;            }            exitContentZoneInternal();        }        private void changeContent(@Nullable String... categories) {            L.d("[ModuleContent] changeContent, categories: [" + Arrays.toString(categories) + "]");            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {                L.w("[ModuleContent] changeContent, Consent is not granted, skipping");                return;            }            registerForContentUpdates(categories);        }    }}package ly.count.android.sdk;import androidx.test.ext.junit.runners.AndroidJUnit4;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import static org.mockito.Mockito.mock;@RunWith(AndroidJUnit4.class)public class ModuleBaseTests {    Countly mCountly;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        mCountly = new Countly();        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http:    }    @After    public void tearDown() {    }    @Test    public void checkup() {        Assert.assertEquals(17, mCountly.modules.size());    }    @Test    public void onConfigurationChanged() {        mCountly.onConfigurationChanged(null);    }    @Test    public void onActivityStartStop() {        mCountly.onStart(null);        mCountly.onStop();    }}package ly.count.android.sdk;import android.app.Activity;import android.app.Application;import android.content.Context;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.test.core.app.ApplicationProvider;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Random;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.atomic.AtomicInteger;import org.json.JSONException;import org.json.JSONObject;import org.junit.Assert;import org.mockito.ArgumentCaptor;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;public class TestUtils {    public static final String[] eKeys = { "eventKey1", "eventKey2", "eventKey3", "eventKey4", "eventKey5", "eventKey6", "eventKey7" };    public static final String[] vNames = { "vienName1", "vienName2", "vienName3", "vienName4", "vienName5", "vienName6", "vienName7" };    public static final String[] requestEntries = { "blah", "blah1", "blah2", "123", "456", "678", "890" };    public static final String[] tooOldRequestEntries = { "&timestamp=1664273584000", "&timestamp=1664273554000", "&timestamp=1664272584000" };    public static final String[] viewIDVals = { "idv1", "idv2", "idv3", "idv4", "idv5", "idv6", "idv7", "idv8", "idv9", "idv10" };    public static final String[] eventIDVals = { "ide1", "ide2", "ide3", "ide4", "ide5", "ide6", "ide7", "ide8", "ide9", "ide10" };    public final static String commonURL = "http:    public final static String commonAppKey = "appkey";    public final static String commonDeviceId = "1234";    public final static String SDK_NAME = "java-native-android";    public final static String SDK_VERSION = "24.7.8";    public static final int MAX_THREAD_COUNT_PER_STACK_TRACE = 50;    public static class Activity2 extends Activity {    }    public static class Activity3 extends Activity {    }    public static CountlyConfig createConfigurationConfig(boolean enableServerConfig, ImmediateRequestGenerator irGen) {        CountlyConfig cc = createBaseConfig();        cc.immediateRequestGenerator = irGen;        if (enableServerConfig) {            cc.enableServerConfiguration();        }        return cc;    }    public static CountlyConfig createVariantConfig(ImmediateRequestGenerator irGen) {        CountlyConfig cc = createBaseConfig();        cc.immediateRequestGenerator = irGen;        return cc;    }    public static CountlyConfig createConsentCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener, RequestQueueProvider rqp) {        CountlyConfig cc = createBaseConfig();        cc.setRequiresConsent(requiresConsent)            .setConsentEnabled(givenConsent)            .disableHealthCheck();        cc.testModuleListener = testModuleListener;        cc.requestQueueProvider = rqp;        return cc;    }    public static CountlyConfig createConsentCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener) {        return createConsentCountlyConfig(requiresConsent, givenConsent, testModuleListener, null);    }    public static CountlyConfig createAttributionCountlyConfig(boolean requiresConsent, String[] givenConsent, ModuleBase testModuleListener, RequestQueueProvider rqp, String daType, String daValue, Map<String, String> iaValues) {        CountlyConfig cc = createBaseConfig();        cc.setDirectAttribution(daType, daValue)            .setIndirectAttribution(iaValues)            .setRequiresConsent(requiresConsent)            .setConsentEnabled(givenConsent)            .disableHealthCheck();        cc.testModuleListener = testModuleListener;        cc.requestQueueProvider = rqp;        return cc;    }    public static CountlyConfig createViewCountlyConfig(boolean orientationTracking, boolean useShortNames, boolean automaticViewTracking, SafeIDGenerator safeViewIDGenerator, Map<String, Object> globalViewSegms) {        CountlyConfig cc = createBaseConfig();        cc.setTrackOrientationChanges(orientationTracking);        if (useShortNames) {            cc.enableAutomaticViewShortNames();        }        cc.safeViewIDGenerator = safeViewIDGenerator;        cc.setGlobalViewSegmentation(globalViewSegms);        if (automaticViewTracking) {            cc.enableAutomaticViewTracking();        }        return cc;    }    public static CountlyConfig createScenarioEventIDConfig(SafeIDGenerator safeViewIDGenerator, SafeIDGenerator safeEventIDGenerator) {        CountlyConfig cc = createBaseConfig();        cc.enableAutomaticViewShortNames();        cc.safeViewIDGenerator = safeViewIDGenerator;        cc.safeEventIDGenerator = safeEventIDGenerator;        return cc;    }    public static CountlyConfig createBaseConfig() {        return createBaseConfig(commonDeviceId);    }    public static CountlyConfig createBaseConfig(String deviceId) {        CountlyConfig cc = new CountlyConfig(getApplication(), commonAppKey, commonURL)            .setDeviceId(deviceId)            .setLoggingEnabled(true)            .enableCrashReporting();        return cc;    }    public static CountlyConfig createBaseConfig(Context context) {        CountlyConfig cc = new CountlyConfig(context, commonAppKey, commonURL)            .setDeviceId(commonDeviceId)            .setLoggingEnabled(true)            .enableCrashReporting();        return cc;    }    public static String[] createStringArray(int count) {        String[] sArr = new String[count];        Random rnd = new Random();        for (int a = 0; a < sArr.length; a++) {            sArr[a] = "" + rnd.nextInt();        }        return sArr;    }    public static Map<String, Object> createMapString(int count) {        Map<String, Object> mRes = new HashMap<>(count);        Random rnd = new Random();        for (int a = 0; a < count; a++) {            mRes.put("" + rnd.nextInt(), "" + rnd.nextInt());        }        return mRes;    }    public static StorageProvider setStorageProviderToMock(Countly countly, StorageProvider sp) {        for (ModuleBase module : countly.modules) {            module.storageProvider = sp;        }        countly.config_.storageProvider = sp;        return sp;    }    public static EventProvider setEventProviderToMock(Countly countly, EventProvider ep) {        for (ModuleBase module : countly.modules) {            module.eventProvider = ep;        }        countly.config_.eventProvider = ep;        return ep;    }    public static EventQueueProvider setCreateEventQueueProviderMock(Countly countly) {        return setEventQueueProviderToMock(countly, mock(EventQueueProvider.class));    }    public static EventQueueProvider setEventQueueProviderToMock(Countly countly, EventQueueProvider eqp) {        countly.moduleEvents.eventQueueProvider = eqp;        countly.config_.eventQueueProvider = eqp;        return eqp;    }    public static RequestQueueProvider setRequestQueueProviderToMock(Countly countly, RequestQueueProvider rqp) {        for (ModuleBase module : countly.modules) {            module.requestQueueProvider = rqp;        }        countly.config_.requestQueueProvider = rqp;        countly.requestQueueProvider = rqp;        return rqp;    }    @SuppressWarnings("InfiniteRecursion")    public static void stackOverflow() {        stackOverflow();    }    @SuppressWarnings("ConstantConditions")    public static Countly crashTest(int crashNumber) {        if (crashNumber == 1) {            stackOverflow();        } else if (crashNumber == 2) {            @SuppressWarnings("NumericOverflow") int test = 10 / 0;        } else if (crashNumber == 3) {            throw new RuntimeException("This is a crash");        } else {            String test = null;            test.charAt(1);        }        return Countly.sharedInstance();    }    public static void bothJSONObjEqual(@NonNull JSONObject jA, @NonNull JSONObject jB) throws JSONException {        Assert.assertNotNull(jA);        Assert.assertNotNull(jB);        Assert.assertEquals(jA.length(), jB.length());        Iterator<String> iter = jA.keys();        while (iter.hasNext()) {            String key = iter.next();            Assert.assertEquals(jA.get(key), jB.get(key));        }    }    public static List<String> getRequestsWithParam(String[] requests, String param) {        List<String> filteredRequests = new ArrayList<>();        String targetParamValue = "&" + param + "=";        for (String entry : requests) {            if (entry.contains(targetParamValue)) {                filteredRequests.add(entry);            }        }        return filteredRequests;    }    public static String getParamValueFromRequest(String request, String param) {        String[] params = request.split("&");        for (String entry : params) {            String[] pair = entry.split("=");            if (pair[0].equals(param)) {                return pair[1];            }        }        return null;    }    public static void validateThatRQContainsCorrectEntry(CountlyStore store, String param, String targetValue, int entryCount) {        List<String> filteredVals = TestUtils.getRequestsWithParam(store.getRequests(), param);        Assert.assertEquals(entryCount, filteredVals.size());        if (entryCount != 0) {            String paramValue = TestUtils.getParamValueFromRequest(filteredVals.get(0), param);            Assert.assertEquals(targetValue, paramValue);        }    }    public static String[] subtractConsentFromArray(String[] input, String[] subtraction) {        ArrayList<String> res = new ArrayList<>();        for (String v : input) {            boolean contains = false;            for (String sv : subtraction) {                if (sv.equals(v)) {                    contains = true;                    break;                }            }            if (!contains) {                res.add(v);            }        }        return res.toArray(new String[0]);    }    public static String[] getReminderConsent(String[] subtraction) {        return subtractConsentFromArray(ModuleConsentTests.usedFeatureNames, subtraction);    }    public static void verifyLocationValuesInRQMockDisabled(RequestQueueProvider rqp) {        verifyLocationValuesInRQMock(1, true, null, null, null, null, rqp);    }    public static void verifyLocationValuesInRQMockNotGiven(RequestQueueProvider rqp) {        verifyLocationValuesInRQMock(0, true, null, null, null, null, rqp);    }    public static void verifyLocationValuesInRQMockValues(String countryCode, String city, String location, String ip, RequestQueueProvider rqp) {        verifyLocationValuesInRQMock(1, false, countryCode, city, location, ip, rqp);    }    public static void verifyLocationValuesInRQMock(int count, Boolean enabled, String countryCode, String city, String location, String ip, RequestQueueProvider rqp) {        ArgumentCaptor<Boolean> acLocationDisabled = ArgumentCaptor.forClass(Boolean.class);        ArgumentCaptor<String> acCountryCode = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> acCity = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> acGps = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> acIp = ArgumentCaptor.forClass(String.class);        verify(rqp, times(count)).sendLocation(acLocationDisabled.capture(), acCountryCode.capture(), acCity.capture(), acGps.capture(), acIp.capture());        if (count == 0) {            return;        }        Assert.assertEquals(enabled, acLocationDisabled.getValue());        Assert.assertEquals(countryCode, acCountryCode.getValue());        Assert.assertEquals(city, acCity.getValue());        Assert.assertEquals(location, acGps.getValue());        Assert.assertEquals(ip, acIp.getValue());    }    public static void verifyConsentValuesInRQMock(int count, String[] valuesTrue, String[] valuesFalse, RequestQueueProvider rqp) throws JSONException {        ArgumentCaptor<String> consentChanges = ArgumentCaptor.forClass(String.class);        verify(rqp, times(count)).sendConsentChanges(consentChanges.capture());        String changes = consentChanges.getValue();        Assert.assertNotNull(changes);        JSONObject jObj = new JSONObject(changes);        Assert.assertEquals(ModuleConsentTests.usedFeatureNames.length, jObj.length());        Assert.assertEquals(ModuleConsentTests.usedFeatureNames.length, valuesTrue.length + valuesFalse.length);        for (String v : valuesTrue) {            Assert.assertTrue((Boolean) jObj.get(v));        }        for (String v : valuesFalse) {            Assert.assertFalse((Boolean) jObj.get(v));        }    }    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation, Integer count, Double sum, Double duration, UtilsTime.Instant instant, String idOverride) {        validateRecordEventInternalMock(ep, eventKey, segmentation, count, sum, duration, instant, idOverride, 0, 1);    }    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey) {        validateRecordEventInternalMock(ep, eventKey, null, null, null, null, null, null, 0, 1);    }    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation) {        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, 0.0, null, null, 0, 1);    }    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, Map<String, Object> segmentation, String idOverride, int index, Integer interactionCount) {        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, 0.0, null, idOverride, index, interactionCount);    }    public static void validateRecordEventInternalMock(EventProvider ep, String eventKey, double duration, Map<String, Object> segmentation, String idOverride, int index, Integer interactionCount) {        validateRecordEventInternalMock(ep, eventKey, segmentation, 1, 0.0, duration, null, idOverride, index, interactionCount);    }    public static void validateRecordEventInternalMockInteractions(EventProvider ep, int interactionCount) {        ArgumentCaptor<String> arg1 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<Map> arg2 = ArgumentCaptor.forClass(Map.class);        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> arg4 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Double> arg5 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<UtilsTime.Instant> arg6 = ArgumentCaptor.forClass(UtilsTime.Instant.class);        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);        verify(ep, times(interactionCount)).recordEventInternal(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture());    }    public static void validateRecordEventInternalMock(final @NonNull EventProvider ep, final @NonNull String eventKey, final @Nullable Map<String, Object> segmentation, final @Nullable Integer count, final @Nullable Double sum, final @Nullable Double duration,        final @Nullable UtilsTime.Instant instant, final @Nullable String idOverride, int index, int interactionCount) {        ArgumentCaptor<String> arg1 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<Map> arg2 = ArgumentCaptor.forClass(Map.class);        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> arg4 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Double> arg5 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<UtilsTime.Instant> arg6 = ArgumentCaptor.forClass(UtilsTime.Instant.class);        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);        verify(ep, times(interactionCount)).recordEventInternal(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture());        if (interactionCount == 0) {            return;        }        String cEventKey = arg1.getAllValues().get(index);        Map cSegment = arg2.getAllValues().get(index);        Integer cCount = arg3.getAllValues().get(index);        Double cSum = arg4.getAllValues().get(index);        Double cDuration = arg5.getAllValues().get(index);        UtilsTime.Instant cInstant = arg6.getAllValues().get(index);        String cIdOverride = arg7.getAllValues().get(index);        Assert.assertNotNull(cEventKey);        Assert.assertEquals(eventKey, cEventKey);        if (segmentation != null) {            Assert.assertEquals(segmentation, cSegment);        }        Assert.assertTrue(cCount > 0);        if (count != null) {            Assert.assertEquals(count, cCount);        }        if (sum != null) {            Assert.assertEquals(sum, cSum);        }        Assert.assertTrue(cDuration >= 0);        if (duration != null) {            Assert.assertEquals(duration, cDuration);        }        if (instant != null) {            Assert.assertTrue(cInstant.timestampMs > 0);            Assert.assertEquals(instant.timestampMs, cInstant.timestampMs);            Assert.assertEquals(instant.hour, cInstant.hour);            Assert.assertEquals(instant.dow, cInstant.dow);        }        if (cIdOverride != null) {            Assert.assertTrue(cIdOverride.length() > 0);        }        if (idOverride != null) {            Assert.assertEquals(idOverride, cIdOverride);        }    }    public static void verifyBeginSessionNotCalled(RequestQueueProvider requestQueueProvider) {        verifyBeginSessionTimes(requestQueueProvider, 0);    }    public static void verifyBeginSessionTimes(RequestQueueProvider requestQueueProvider, int count) {        ArgumentCaptor<Boolean> arg1 = ArgumentCaptor.forClass(Boolean.class);        ArgumentCaptor<String> arg2 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg3 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg4 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg5 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg6 = ArgumentCaptor.forClass(String.class);        verify(requestQueueProvider, count == 0 ? never() : times(count)).beginSession(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture());    }    public static void verifyBeginSessionValues(RequestQueueProvider requestQueueProvider, Boolean v1, String v2, String v3, String v4, String v5) {        ArgumentCaptor<Boolean> arg1 = ArgumentCaptor.forClass(Boolean.class);        ArgumentCaptor<String> arg2 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg3 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg4 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg5 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg6 = ArgumentCaptor.forClass(String.class);        verify(requestQueueProvider, times(1)).beginSession(arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture());        Assert.assertEquals(v1, arg1.getAllValues().get(0));        Assert.assertEquals(v2, arg2.getAllValues().get(0));        Assert.assertEquals(v3, arg3.getAllValues().get(0));        Assert.assertEquals(v4, arg4.getAllValues().get(0));        Assert.assertEquals(v5, arg5.getAllValues().get(0));    }    public static void verifyCurrentPreviousViewID(ModuleViews mv, String current, String previous) {        Assert.assertEquals(current, mv.getCurrentViewId());        Assert.assertEquals(previous, mv.getPreviousViewId());    }    protected static CountlyStore getCountyStore() {        return new CountlyStore(getContext(), mock(ModuleLog.class), false);    }    protected static @NonNull Map<String, String>[] getCurrentRQ() {        return getCurrentRQ("");    }    protected static @NonNull Map<String, String>[] getCurrentRQ(String filter) {        String[] requests = getCountyStore().getRequests();        Map<String, String>[] resultMapArray = new ConcurrentHashMap[requests.length];        for (int i = 0; i < requests.length; i++) {            if (!requests[i].contains(filter)) {                continue;            }            String[] params = requests[i].split("&");            Map<String, String> paramMap = new ConcurrentHashMap<>();            for (String param : params) {                String[] pair = param.split("=");                paramMap.put(UtilsNetworking.urlDecodeString(pair[0]), pair.length == 1 ? "" : UtilsNetworking.urlDecodeString(pair[1]));            }            resultMapArray[i] = paramMap;        }        return resultMapArray;    }    protected static void removeRequestContains(String search) {        for (String request : getCountyStore().getRequests()) {            if (request.contains(search)) {                getCountyStore().removeRequest(request);            }        }    }    protected static Map<String, Object> map(Object... args) {        Map<String, Object> map = new ConcurrentHashMap<>();        if (args.length < 1) {            return map;        }        if (args.length % 2 != 0) {            return map;        }        for (int a = 0; a < args.length; a += 2) {            if (args[a] != null && args[a + 1] != null) {                map.put(args[a].toString(), args[a + 1]);            }        }        return map;    }    protected static JSONObject json(Object... args) {        return new JSONObject(TestUtils.map(args));    }    public static Context getContext() {        return ApplicationProvider.getApplicationContext();    }    public static Application getApplication() {        return (Application) getContext();    }    public static void validateSdkIdentityParams(Map<String, String> params) {        Assert.assertEquals(SDK_VERSION, params.get("sdk_version"));        Assert.assertEquals(SDK_NAME, params.get("sdk_name"));    }    public static void validateRequiredParams(@NonNull Map<String, String> params) {        validateRequiredParams(params, commonDeviceId);    }    public static void validateRequiredParams(Map<String, String> params, String deviceId) {        int hour = Integer.parseInt(params.get("hour"));        int dow = Integer.parseInt(params.get("dow"));        int tz = Integer.parseInt(params.get("tz"));        validateSdkIdentityParams(params);        Assert.assertEquals(deviceId, params.get("device_id"));        Assert.assertEquals(commonAppKey, params.get("app_key"));        Assert.assertEquals(Countly.DEFAULT_APP_VERSION, params.get("av"));        Assert.assertTrue(Long.parseLong(params.get("timestamp")) > 0);        Assert.assertTrue(hour >= 0 && hour < 24);        Assert.assertTrue(dow >= 0 && dow < 7);        Assert.assertTrue(tz >= -720 && tz <= 840);    }    protected static void put(JSONObject json, String key, Object value) {        try {            json.put(key, value);        } catch (JSONException ignored) {        }    }    public static void assertQueueSizes(int rqSize, int eqSize, CountlyStore cs) {        Assert.assertEquals(rqSize, cs.getRequests().length);        Assert.assertEquals(eqSize, cs.getEventQueueSize());    }    protected static String generateRandomString(int length) {        byte[] array = new byte[length];        new Random().nextBytes(array);        return new String(array, java.nio.charset.StandardCharsets.UTF_8);    }    protected static void validateRequest(String deviceId, Map<String, Object> expectedExtras, int idx) {        Map<String, String> request = getCurrentRQ()[idx];        validateRequiredParams(getCurrentRQ()[idx], deviceId);        for (Map.Entry<String, Object> entry : expectedExtras.entrySet()) {            if (entry.getValue() instanceof Map) {                assertEqualsMap((Map<String, Object>) entry.getValue(), parseMap(request.get(entry.getKey())));            } else {                Assert.assertEquals(entry.getValue(), request.get(entry.getKey()));            }        }    }    private static Map<String, Object> parseMap(String mapCandidate) {        Map<String, Object> map = new ConcurrentHashMap<>();        try {            JSONObject json = new JSONObject(mapCandidate);            Iterator<String> keys = json.keys();            while (keys.hasNext()) {                String key = keys.next();                map.put(key, json.get(key));            }        } catch (JSONException e) {            Assert.fail(e.getMessage());        }        return map;    }    protected static void assertArraysEquals(Object arr1, Object arr2) {        if (!arr1.getClass().isArray() || !arr2.getClass().isArray()) {            Assert.fail("Both parameters must be arrays.");        }        if (arr1 instanceof int[] && arr2 instanceof int[]) {            Assert.assertTrue(Arrays.equals((int[]) arr1, (int[]) arr2));        } else if (arr1 instanceof long[] && arr2 instanceof long[]) {            Assert.assertTrue(Arrays.equals((long[]) arr1, (long[]) arr2));        } else if (arr1 instanceof double[] && arr2 instanceof double[]) {            Assert.assertTrue(Arrays.equals((double[]) arr1, (double[]) arr2));        } else if (arr1 instanceof float[] && arr2 instanceof float[]) {            Assert.assertTrue(Arrays.equals((float[]) arr1, (float[]) arr2));        } else if (arr1 instanceof char[] && arr2 instanceof char[]) {            Assert.assertTrue(Arrays.equals((char[]) arr1, (char[]) arr2));        } else if (arr1 instanceof byte[] && arr2 instanceof byte[]) {            Assert.assertTrue(Arrays.equals((byte[]) arr1, (byte[]) arr2));        } else if (arr1 instanceof short[] && arr2 instanceof short[]) {            Assert.assertTrue(Arrays.equals((short[]) arr1, (short[]) arr2));        } else if (arr1 instanceof boolean[] && arr2 instanceof boolean[]) {            Assert.assertTrue(Arrays.equals((boolean[]) arr1, (boolean[]) arr2));        }        else if (arr1 instanceof Object[] && arr2 instanceof Object[]) {            Assert.assertTrue(Arrays.equals((Object[]) arr1, (Object[]) arr2));        }        else {            Assert.fail("Array types do not match.");        }    }    protected static void assertEqualsMap(Map<String, Object> map1, Map<String, Object> map2) {        Assert.assertEquals(map1.size(), map2.size());        for (Map.Entry<String, Object> entry : map1.entrySet()) {            if (entry.getValue().getClass().isArray()) {                assertArraysEquals(entry.getValue(), map2.get(entry.getKey()));            } else {                Assert.assertEquals(entry.getValue(), map2.get(entry.getKey()));            }        }    }    protected static void assertRQSize(int size) {        Assert.assertEquals(size, getCurrentRQ().length);    }    static SafeIDGenerator incrementalViewIdGenerator() {        AtomicInteger counter = new AtomicInteger(0);        return () -> "idv" + counter.incrementAndGet();    }    static SafeIDGenerator incrementalEventIdGenerator() {        AtomicInteger counter = new AtomicInteger(0);        return () -> "ide" + counter.incrementAndGet();    }}package ly.count.android.sdk;import android.app.Activity;import android.content.res.Configuration;import android.content.res.Resources;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class ModuleViews extends ModuleBase implements ViewIdProvider {    private String currentViewID = null;    private String previousViewID = null;    String previousViewName = "";    String currentViewName = "";    private boolean firstView = true;    boolean autoViewTracker = false;    boolean automaticTrackingShouldUseShortName = false;    boolean trackOrientationChanges;    int currentOrientation = -1;    final static String ORIENTATION_EVENT_KEY = "[CLY]_orientation";    final static String VIEW_EVENT_KEY = "[CLY]_view";    Class[] autoTrackingActivityExceptions = null;    Map<String, Object> automaticViewSegmentation = new HashMap<>();    final Map<String, ViewData> viewDataMap = new ConcurrentHashMap<>();     SafeIDGenerator safeViewIDGenerator;    String[] reservedSegmentationKeysViews = { "name", "visit", "start", "segment" };    public @NonNull String getCurrentViewId() {        return currentViewID == null ? "" : currentViewID;    }    public @NonNull String getPreviousViewId() {        return previousViewID == null ? "" : previousViewID;    }    static class ViewData {        String viewID;        long viewStartTimeSeconds;         String viewName;        boolean isAutoStoppedView = false;        Map<String, Object> viewSegmentation = null;         boolean willStartAgain = false;     }    final Views viewsInterface;    ModuleViews(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleViews] Initializing");        if (config.enableAutomaticViewTracking) {            L.d("[ModuleViews] Enabling automatic view tracking");            autoViewTracker = config.enableAutomaticViewTracking;        }        if (config.autoTrackingUseShortName) {            L.d("[ModuleViews] Enabling automatic view tracking short names");            automaticTrackingShouldUseShortName = config.autoTrackingUseShortName;        }        config.viewIdProvider = this;        safeViewIDGenerator = config.safeViewIDGenerator;        setGlobalViewSegmentationInternal(config.globalViewSegmentation);        autoTrackingActivityExceptions = config.automaticViewTrackingExceptions;        trackOrientationChanges = config.trackOrientationChange;        viewsInterface = new Views();    }    void setGlobalViewSegmentationInternal(@Nullable Map<String, Object> segmentation) {        L.d("[ModuleViews] Calling setGlobalViewSegmentationInternal with[" + (segmentation == null ? "null" : segmentation.size()) + "] entries");        automaticViewSegmentation.clear();        applyLimitsToViewSegmentation(segmentation, "setGlobalViewSegmentationInternal", automaticViewSegmentation);    }    public void updateGlobalViewSegmentationInternal(@NonNull Map<String, Object> segmentation) {        applyLimitsToViewSegmentation(segmentation, "updateGlobalViewSegmentationInternal", automaticViewSegmentation);    }    boolean isActivityInExceptionList(Activity act) {        if (autoTrackingActivityExceptions == null) {            return false;        }        for (Class autoTrackingActivityException : autoTrackingActivityExceptions) {            if (act.getClass().equals(autoTrackingActivityException)) {                return true;            }        }        return false;    }    public void resetFirstView() {        firstView = true;    }    Map<String, Object> CreateViewEventSegmentation(@NonNull ViewData vd, boolean firstView, boolean visit, @NonNull Map<String, Object> customViewSegmentation) {        Map<String, Object> viewSegmentation = new ConcurrentHashMap<>(customViewSegmentation);        String truncatedViewName = UtilsInternalLimits.truncateKeyLength(vd.viewName, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleViews] CreateViewEventSegmentation");        viewSegmentation.put("name", truncatedViewName);        if (visit) {            viewSegmentation.put("visit", "1");        }        if (firstView) {            viewSegmentation.put("start", "1");        }        viewSegmentation.put("segment", "Android");        return viewSegmentation;    }    void autoCloseRequiredViews(boolean closeAllViews, @Nullable Map<String, Object> customViewSegmentation) {        L.d("[ModuleViews] autoCloseRequiredViews");        List<ViewData> viewsToRemove = new ArrayList<>(1);        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {            ViewData vd = entry.getValue();            if (closeAllViews || (!vd.willStartAgain && vd.isAutoStoppedView)) {                viewsToRemove.add(vd);            }        }        if (!viewsToRemove.isEmpty()) {            L.d("[ModuleViews] autoCloseRequiredViews, about to close [" + viewsToRemove.size() + "] views");        }        for (int a = 0; a < viewsToRemove.size(); a++) {            ViewData vd = viewsToRemove.get(a);            if (!vd.willStartAgain) {                stopViewWithIDInternal(vd.viewID, customViewSegmentation);            } else if (closeAllViews) {                viewDataMap.remove(vd.viewID);            }        }    }    @Nullable String startViewInternal(@Nullable String viewName, @Nullable Map<String, Object> customViewSegmentation, boolean viewShouldBeAutomaticallyStopped) {        if (!_cly.isInitialized()) {            L.e("Countly.sharedInstance().init must be called before startViewInternal");            return null;        }        if (viewName == null || viewName.isEmpty()) {            L.e("[ModuleViews] startViewInternal, Trying to record view with null or empty view name, ignoring request");            return null;        }        if (L.logEnabled()) {            int segmCount = 0;            if (customViewSegmentation != null) {                segmCount = customViewSegmentation.size();            }            L.d("[ModuleViews] Recording view with name: [" + viewName + "], previous view ID:[" + currentViewID + "] custom view segment count:[" + segmCount + "], first:[" + firstView + "], autoStop:[" + viewShouldBeAutomaticallyStopped + "]");        }        autoCloseRequiredViews(false, null);        ViewData currentViewData = new ViewData();        currentViewData.viewID = safeViewIDGenerator.GenerateValue();        currentViewData.viewName = viewName;        currentViewData.viewStartTimeSeconds = UtilsTime.currentTimestampSeconds();        currentViewData.isAutoStoppedView = viewShouldBeAutomaticallyStopped;        viewDataMap.put(currentViewData.viewID, currentViewData);        previousViewID = currentViewID;        previousViewName = currentViewName;        currentViewID = currentViewData.viewID;        currentViewName = viewName;        Map<String, Object> accumulatedEventSegm = new HashMap<>(automaticViewSegmentation);        applyLimitsToViewSegmentation(customViewSegmentation, "startViewInternal", accumulatedEventSegm);        boolean firstViewInSession = firstView && _cly.moduleSessions.sessionIsRunning();        Map<String, Object> viewSegmentation = CreateViewEventSegmentation(currentViewData, firstViewInSession, true, accumulatedEventSegm);        if (firstViewInSession) {            L.d("[ModuleViews] Recording view as the first one in the session. [" + viewName + "]");            firstView = false;        }        eventProvider.recordEventInternal(VIEW_EVENT_KEY, viewSegmentation, 1, 0, 0, null, currentViewData.viewID);        return currentViewData.viewID;    }    void stopViewWithNameInternal(@Nullable String viewName, @Nullable Map<String, Object> customViewSegmentation) {        if (viewName == null || viewName.isEmpty()) {            L.e("[ModuleViews] stopViewWithNameInternal, Trying to record view with null or empty view name, ignoring request");            return;        }        String viewID = null;        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {            ViewData vd = entry.getValue();            if (vd != null && viewName.equals(vd.viewName)) {                viewID = entry.getKey();            }        }        if (viewID == null) {            L.e("[ModuleViews] stopViewWithNameInternal, No view entry found with the provided name :[" + viewName + "]");            return;        }        stopViewWithIDInternal(viewID, customViewSegmentation);    }    void stopViewWithIDInternal(@Nullable String viewID, @Nullable Map<String, Object> customViewSegmentation) {        if (viewID == null || viewID.isEmpty()) {            L.e("[ModuleViews] stopViewWithNameInternal, Trying to record view with null or empty view ID, ignoring request");            return;        }        if (!viewDataMap.containsKey(viewID)) {            L.w("[ModuleViews] stopViewWithIDInternal, there is no view with the provided view id to close");            return;        }        ViewData vd = viewDataMap.get(viewID);        if (vd == null) {            L.e("[ModuleViews] stopViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");            return;        }        L.d("[ModuleViews] View [" + vd.viewName + "], id:[" + vd.viewID + "] is getting closed, reporting duration: [" + (UtilsTime.currentTimestampSeconds() - vd.viewStartTimeSeconds) + "] s, current timestamp: [" + UtilsTime.currentTimestampSeconds() + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {            L.w("[ModuleViews] stopViewWithIDInternal, no consent given for views, ignoring call");            return;        }        recordViewEndEvent(vd, customViewSegmentation, "stopViewWithIDInternal");        if (!vd.willStartAgain) {            viewDataMap.remove(vd.viewID);        }    }    void recordViewEndEvent(ViewData vd, @Nullable Map<String, Object> customViewSegmentation, String viewRecordingSource) {        long lastElapsedDurationSeconds = 0;        if (vd.viewStartTimeSeconds < 0) {            L.e("[ModuleViews] " + viewRecordingSource + ", view start time value is not normal: [" + vd.viewStartTimeSeconds + "], ignoring that duration");        } else if (vd.viewStartTimeSeconds == 0) {            L.i("[ModuleViews] " + viewRecordingSource + ", view is either paused or didn't run, ignoring start timestamp");        } else {            lastElapsedDurationSeconds = UtilsTime.currentTimestampSeconds() - vd.viewStartTimeSeconds;        }        if (vd.viewName == null) {            L.e("[ModuleViews] recordViewEndEvent, view has no internal name, ignoring it");            return;        }        Map<String, Object> accumulatedEventSegm = new HashMap<>(automaticViewSegmentation);        if (vd.viewSegmentation != null) {            accumulatedEventSegm.putAll(vd.viewSegmentation);        }        applyLimitsToViewSegmentation(customViewSegmentation, "recordViewEndEvent", accumulatedEventSegm);        UtilsInternalLimits.truncateSegmentationValues(accumulatedEventSegm, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleViews] recordViewEndEvent", L);        long viewDurationSeconds = lastElapsedDurationSeconds;        Map<String, Object> segments = CreateViewEventSegmentation(vd, false, false, accumulatedEventSegm);        eventProvider.recordEventInternal(VIEW_EVENT_KEY, segments, 1, 0, viewDurationSeconds, null, vd.viewID);    }    void pauseViewWithIDInternal(String viewID) {        if (viewID == null || viewID.isEmpty()) {            L.e("[ModuleViews] pauseViewWithIDInternal, Trying to record view with null or empty view ID, ignoring request");            return;        }        if (!viewDataMap.containsKey(viewID)) {            L.w("[ModuleViews] pauseViewWithIDInternal, there is no view with the provided view id to close");            return;        }        ViewData vd = viewDataMap.get(viewID);        if (vd == null) {            L.e("[ModuleViews] pauseViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {            return;        }        L.d("[ModuleViews] pauseViewWithIDInternal, pausing view for ID:[" + viewID + "], name:[" + vd.viewName + "]");        if (vd.viewStartTimeSeconds == 0) {            L.w("[ModuleViews] pauseViewWithIDInternal, pausing a view that is already paused. ID:[" + viewID + "], name:[" + vd.viewName + "]");            return;        }        recordViewEndEvent(vd, null, "pauseViewWithIDInternal");        vd.viewStartTimeSeconds = 0;    }    void resumeViewWithIDInternal(String viewID) {        if (viewID == null || viewID.isEmpty()) {            L.e("[ModuleViews] resumeViewWithIDInternal, Trying to record view with null or empty view ID, ignoring request");            return;        }        if (!viewDataMap.containsKey(viewID)) {            L.w("[ModuleViews] resumeViewWithIDInternal, there is no view with the provided view id to close");            return;        }        ViewData vd = viewDataMap.get(viewID);        if (vd == null) {            L.e("[ModuleViews] resumeViewWithIDInternal, view id:[" + viewID + "] has a 'null' value. This should not be happening");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {            return;        }        L.d("[ModuleViews] resumeViewWithIDInternal, resuming view for ID:[" + viewID + "], name:[" + vd.viewName + "]");        if (vd.viewStartTimeSeconds > 0) {            L.w("[ModuleViews] resumeViewWithIDInternal, resuming a view that is already running. ID:[" + viewID + "], name:[" + vd.viewName + "]");            return;        }        vd.viewStartTimeSeconds = UtilsTime.currentTimestampSeconds();    }    public void addSegmentationToViewWithIDInternal(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {        if (viewID == null || viewSegmentation == null || viewID.isEmpty() || viewSegmentation.isEmpty()) {            L.e("[Views] addSegmentationToViewWithID, null or empty parameters provided");            return;        }        if (!viewDataMap.containsKey(viewID)) {            L.w("[ModuleViews] addSegmentationToViewWithID, there is no view with the provided view id");            return;        }        ViewData vd = viewDataMap.get(viewID);        if (vd == null) {            L.e("[ModuleViews] addSegmentationToViewWithID, view id:[" + viewID + "] has a 'null' view data. This should not be happening");            return;        }        if (vd.viewSegmentation == null) {            vd.viewSegmentation = new HashMap<>();        }        applyLimitsToViewSegmentation(viewSegmentation, "addSegmentationToViewWithIDInternal", vd.viewSegmentation);    }    private void applyLimitsToViewSegmentation(@Nullable Map<String, Object> viewSegmentation, @NonNull String function, @NonNull Map<String, Object> source) {        if (viewSegmentation == null) {            viewSegmentation = new HashMap<>();        }        assert viewSegmentation != null;        assert source != null;        assert function != null;        UtilsInternalLimits.removeReservedKeysFromSegmentation(viewSegmentation, reservedSegmentationKeysViews, "[ModuleViews] " + function + ", ", L);        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(viewSegmentation, _cly.config_.sdkInternalLimits, L, "[ModuleViews] " + function);        source.putAll(viewSegmentation);        UtilsInternalLimits.truncateSegmentationValues(source, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleViews] " + function, L);    }    public void addSegmentationToViewWithNameInternal(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {        String viewID = null;        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {            ViewData vd = entry.getValue();            if (vd != null && viewName != null && viewName.equals(vd.viewName)) {                viewID = entry.getKey();            }        }        if (viewID == null) {            L.e("[ModuleViews] addSegmentationToViewWithName, No view entry found with the provided name :[" + viewName + "]");            return;        }        L.i("[ModuleViews] Will add segmentation for view: [" + viewName + "] with ID:[" + viewID + "]");        addSegmentationToViewWithIDInternal(viewID, viewSegmentation);    }    void stopAllViewsInternal(Map<String, Object> viewSegmentation) {        L.d("[ModuleViews] stopAllViewsInternal");        autoCloseRequiredViews(true, viewSegmentation);    }    void updateOrientation(int newOrientation, boolean forceSend) {        L.d("[ModuleViews] updateOrientation,  forceSend: [" + forceSend + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {            L.d("[ModuleViews] updateOrientation, no consent given for users, skipping orientation tracking");            return;        }        if (!forceSend && currentOrientation == newOrientation) {            L.d("[ModuleViews] updateOrientation, orientation did not change, skipping");            return;        }        L.i("[ModuleViews] updateOrientation, new orientation:[" + newOrientation + "], current orientation:[" + currentOrientation + "], landscape:[" + Configuration.ORIENTATION_LANDSCAPE + "], portrait:[" + Configuration.ORIENTATION_PORTRAIT + "]");        currentOrientation = newOrientation;        Map<String, Object> segm = new HashMap<>();        if (currentOrientation == Configuration.ORIENTATION_PORTRAIT) {            segm.put("mode", "portrait");        } else {            segm.put("mode", "landscape");        }        eventProvider.recordEventInternal(ORIENTATION_EVENT_KEY, segm, 1, 0, 0, null, null);    }    void updateOrientation(int newOrientation) {        updateOrientation(newOrientation, false);    }    void stopRunningViewsAndSend() {        L.d("[ModuleViews] stopRunningViewsAndSend, going to the background and stopping views");        for (Map.Entry<String, ViewData> entry : viewDataMap.entrySet()) {            ViewData vd = entry.getValue();            vd.willStartAgain = true;            stopViewWithIDInternal(vd.viewID, null);        }    }    void startStoppedViews() {        L.d("[ModuleViews] startStoppedViews, app is coming back to the foreground, starting views that were stopped");        Iterator<Map.Entry<String, ViewData>> iterator = viewDataMap.entrySet().iterator();        while (iterator.hasNext()) {            Map.Entry<String, ViewData> value = iterator.next();            ViewData vd = value.getValue();            if (vd.willStartAgain) {                iterator.remove();                startViewInternal(vd.viewName, vd.viewSegmentation, vd.isAutoStoppedView);            }        }    }    @Override    void onConfigurationChanged(Configuration newConfig) {        if (trackOrientationChanges) {            Integer orient = getOrientationFromConfiguration(newConfig);            if (orient != null) {                updateOrientation(orient);            }        }    }    @Override    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {        if (consentThatWillChange.contains(Countly.CountlyFeatureNames.views) && !isConsentGiven) {            stopAllViewsInternal(null);        }    }    @Override    void onActivityStopped(int updatedActivityCount) {        if (autoViewTracker) {            if (updatedActivityCount <= 0) {                stopViewWithIDInternal(currentViewID, null);            }        }        if (updatedActivityCount <= 0) {            stopRunningViewsAndSend();        }    }    @Override    void onActivityStarted(Activity activity, int updatedActivityCount) {        if (autoViewTracker) {            if (!isActivityInExceptionList(activity)) {                String usedActivityName = "NULL ACTIVITY";                if (activity != null) {                    if (automaticTrackingShouldUseShortName) {                        usedActivityName = activity.getClass().getSimpleName();                    } else {                        usedActivityName = activity.getClass().getName();                    }                }                startViewInternal(usedActivityName, automaticViewSegmentation, true);            } else {                L.d("[ModuleViews] [onStart] Ignoring activity because it's in the exception list");            }        }        if (trackOrientationChanges) {            Integer orient = getOrientationFromActivity(activity);            if (orient != null) {                updateOrientation(orient);            }        }        if (updatedActivityCount == 1) {            startStoppedViews();        }    }    Integer getOrientationFromConfiguration(@Nullable Configuration conf) {        if (conf == null) {            return null;        }        return conf.orientation;    }    Integer getOrientationFromActivity(Activity act) {        if (act == null) {            return null;        }        Resources resources = act.getResources();        if (resources != null) {            return resources.getConfiguration().orientation;        } else {            return null;        }    }    @Override    void halt() {        if (automaticViewSegmentation != null) {            automaticViewSegmentation.clear();            automaticViewSegmentation = null;        }        autoTrackingActivityExceptions = null;    }    public class Views {        public boolean isAutomaticViewTrackingEnabled() {            synchronized (_cly) {                L.i("[Views] Calling isAutomaticViewTrackingEnabled");                return autoViewTracker;            }        }        public Countly recordView(@Nullable String viewName) {            synchronized (_cly) {                return recordView(viewName, null);            }        }        public Countly recordView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling recordView [" + viewName + "]");                if (autoViewTracker) {                    L.e("[Views] recordView, manual view call will be ignored since automatic tracking is enabled.");                    return _cly;                }                startViewInternal(viewName, viewSegmentation, true);                return _cly;            }        }        public String startAutoStoppedView(@Nullable String viewName) {            synchronized (_cly) {                return startAutoStoppedView(viewName, null);            }        }        public String startAutoStoppedView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling startAutoStoppedView [" + viewName + "]");                if (autoViewTracker) {                    L.e("[Views] startAutoStoppedView, manual view call will be ignored since automatic tracking is enabled.");                    return null;                }                return startViewInternal(viewName, viewSegmentation, true);            }        }        public void addSegmentationToViewWithID(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling addSegmentationToViewWithID for view ID: [" + viewID + "]");                if (autoViewTracker) {                    L.e("[Views] addSegmentationToViewWithID, manual view call will be ignored since automatic tracking is enabled.");                    return;                }                addSegmentationToViewWithIDInternal(viewID, viewSegmentation);            }        }        public void addSegmentationToViewWithName(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling addSegmentationToViewWithName for Name: [" + viewName + "]");                if (autoViewTracker) {                    L.e("[Views] addSegmentationToViewWithName, manual view call will be ignored since automatic tracking is enabled.");                    return;                }                addSegmentationToViewWithNameInternal(viewName, viewSegmentation);            }        }        public @Nullable String startView(@Nullable String viewName) {            synchronized (_cly) {                L.i("[Views] Calling startView vn[" + viewName + "]");                if (autoViewTracker) {                    L.e("[Views] startView, manual view call will be ignored since automatic tracking is enabled.");                    return null;                }                return startViewInternal(viewName, null, false);            }        }        public @Nullable String startView(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling startView vn[" + viewName + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");                if (autoViewTracker) {                    L.e("[Views] startView, manual view call will be ignored since automatic tracking is enabled.");                    return null;                }                return startViewInternal(viewName, viewSegmentation, false);            }        }        public void stopViewWithName(@Nullable String viewName) {            synchronized (_cly) {                L.i("[Views] Calling stopViewWithName vn[" + viewName + "]");                stopViewWithNameInternal(viewName, null);            }        }        public void stopViewWithName(@Nullable String viewName, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling stopViewWithName vn[" + viewName + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");                stopViewWithNameInternal(viewName, viewSegmentation);            }        }        public void stopViewWithID(@Nullable String viewID) {            synchronized (_cly) {                L.i("[Views] Calling stopViewWithID vi[" + viewID + "]");                stopViewWithIDInternal(viewID, null);            }        }        public void stopViewWithID(@Nullable String viewID, @Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling stopViewWithName vi[" + viewID + "] sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");                stopViewWithIDInternal(viewID, viewSegmentation);            }        }        public void pauseViewWithID(@Nullable String viewID) {            synchronized (_cly) {                L.i("[Views] Calling pauseViewWithID vi[" + viewID + "]");                pauseViewWithIDInternal(viewID);            }        }        public void resumeViewWithID(@Nullable String viewID) {            synchronized (_cly) {                L.i("[Views] Calling resumeViewWithID vi[" + viewID + "]");                resumeViewWithIDInternal(viewID);            }        }        public void setGlobalViewSegmentation(@Nullable Map<String, Object> segmentation) {            synchronized (_cly) {                L.i("[Views] Calling setGlobalViewSegmentation sg[" + (segmentation == null ? segmentation : segmentation.size()) + "]");                setGlobalViewSegmentationInternal(segmentation);            }        }        public void updateGlobalViewSegmentation(@Nullable Map<String, Object> segmentation) {            synchronized (_cly) {                L.i("[Views] Calling updateGlobalViewSegmentation sg[" + (segmentation == null ? segmentation : segmentation.size()) + "]");                if (segmentation == null) {                    L.w("[View] When updating segmentation values, they can't be 'null'.");                    return;                }                updateGlobalViewSegmentationInternal(segmentation);            }        }        public void stopAllViews(@Nullable Map<String, Object> viewSegmentation) {            synchronized (_cly) {                L.i("[Views] Calling stopAllViews sg[" + (viewSegmentation == null ? viewSegmentation : viewSegmentation.size()) + "]");                stopAllViewsInternal(viewSegmentation);            }        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.List;public class ModuleLocation extends ModuleBase {    boolean locationDisabled = false;    String locationCountryCode = null;    String locationCity = null;    String locationGpsCoordinates = null;    String locationIpAddress = null;    Location locationInterface = null;    ModuleLocation(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleLocation] Initialising");        locationInterface = new Location();    }    void resetLocationValues() {        locationCity = null;        locationCountryCode = null;        locationGpsCoordinates = null;        locationIpAddress = null;    }    void sendCurrentLocationIfValid() {        L.d("[ModuleLocation] Calling 'sendCurrentLocationIfValid'");        if (locationDisabled) {            return;        }        if (locationCountryCode != null || locationCity != null || locationIpAddress != null || locationGpsCoordinates != null) {            requestQueueProvider.sendLocation(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);        }    }    void disableLocationInternal() {        L.d("[ModuleLocation] Calling 'disableLocationInternal'");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {            return;        }        locationDisabled = true;        performLocationErasure();    }    void performLocationErasure() {        resetLocationValues();        requestQueueProvider.sendLocation(true, null, null, null, null);    }    void setLocationInternal(@Nullable String country_code, @Nullable String city, @Nullable String gpsCoordinates, @Nullable String ipAddress) {        L.d("[ModuleLocation] Calling 'setLocationInternal'");        L.d("[ModuleLocation] Setting location parameters, cc[" + country_code + "] cy[" + city + "] gps[" + gpsCoordinates + "] ip[" + ipAddress + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {            return;        }        locationCountryCode = country_code;        locationCity = city;        locationGpsCoordinates = gpsCoordinates;        locationIpAddress = ipAddress;        if ((country_code == null && city != null) || (city == null && country_code != null)) {            L.w("[ModuleLocation] In \"setLocation\" both city and country code need to be set at the same time to be sent");        }        if (country_code != null || city != null || gpsCoordinates != null || ipAddress != null) {            locationDisabled = false;        }        if (_cly.isBeginSessionSent || !consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {            requestQueueProvider.sendLocation(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);        } else {        }    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {            performLocationErasure();        } else {            if (config.disableLocation) {                disableLocationInternal();            } else {                if (config.locationIpAddress != null || config.locationLocation != null || config.locationCity != null || config.locationCountyCode != null) {                    setLocationInternal(config.locationCountyCode, config.locationCity, config.locationLocation, config.locationIpAddress);                }            }        }    }    @Override    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.location)) {            if (!newConsent) {                performLocationErasure();            }        }    }    @Override    void halt() {        locationInterface = null;    }    public class Location {        public void disableLocation() {            synchronized (_cly) {                L.i("[Location] Calling 'disableLocation'");                disableLocationInternal();            }        }        public void setLocation(@Nullable String countryCode, @Nullable String city, @Nullable String gpsCoordinates, @Nullable String ipAddress) {            synchronized (_cly) {                L.i("[Location] Calling 'setLocation'");                setLocationInternal(countryCode, city, gpsCoordinates, ipAddress);            }        }    }}package ly.count.android.sdk;import android.content.Context;import android.util.Base64;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.util.HashMap;import java.util.Map;public class ModuleCrash extends ModuleBase {    private static final String countlyFolderName = "Countly";    private static final String countlyNativeCrashFolderName = "CrashDumps";    GlobalCrashFilterCallback globalCrashFilterCallback;    CrashFilterCallback crashFilterCallback;    boolean recordAllThreads = false;    @Nullable    Map<String, Object> customCrashSegments = null;    final Crashes crashesInterface;    @Nullable    Map<String, String> metricOverride = null;    BreadcrumbHelper breadcrumbHelper;    ModuleCrash(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleCrash] Initialising");        globalCrashFilterCallback = config.crashes.globalCrashFilterCallback;        crashFilterCallback = config.crashFilterCallback;        recordAllThreads = config.crashes.recordAllThreadsWithCrash;        setCustomCrashSegmentsInternal(config.crashes.customCrashSegment);        metricOverride = config.metricOverride;        crashesInterface = new Crashes();        breadcrumbHelper = new BreadcrumbHelper(config.sdkInternalLimits.maxBreadcrumbCount, L);        assert breadcrumbHelper != null;    }    void checkForNativeCrashDumps(@NonNull Context context) {        assert context != null;        L.d("[ModuleCrash] Checking for native crash dumps");        String basePath = context.getCacheDir().getAbsolutePath();        String finalPath = basePath + File.separator + countlyFolderName + File.separator + countlyNativeCrashFolderName;        File folder = new File(finalPath);        if (folder.exists()) {            L.d("[ModuleCrash] Native crash folder exists, checking for dumps");            File[] dumpFiles = folder.listFiles();            int dumpFileCount = -1;            if (dumpFiles != null) {                dumpFileCount = dumpFiles.length;            }            L.d("[ModuleCrash] Crash dump folder contains [" + dumpFileCount + "] files");            if (dumpFiles != null) {                for (File dumpFile : dumpFiles) {                    recordNativeException(dumpFile);                    dumpFile.delete();                }            }        } else {            L.d("[ModuleCrash] Native crash folder does not exist");        }    }    private void recordNativeException(@NonNull File dumpFile) {        assert dumpFile != null;        L.d("[ModuleCrash] Recording native crash dump: [" + dumpFile.getName() + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {            return;        }        int size = (int) dumpFile.length();        byte[] bytes = new byte[size];        try {            BufferedInputStream buf = new BufferedInputStream(new FileInputStream(dumpFile));            buf.read(bytes, 0, bytes.length);            buf.close();        } catch (Exception e) {            L.e("[ModuleCrash] Failed to read dump file bytes");            e.printStackTrace();            return;        }        String dumpString = Base64.encodeToString(bytes, Base64.NO_WRAP);        CrashData crashData = prepareCrashData(dumpString, false, true, null);        if (!crashFilterCheck(crashData)) {            sendCrashReportToQueue(crashData, true);        }    }    private CrashData prepareCrashData(@NonNull String error, final boolean handled, final boolean isNativeCrash, @Nullable Map<String, Object> customSegmentation) {        assert error != null;        if (!isNativeCrash) {            error = error.substring(0, Math.min(20_000, error.length()));        }        Map<String, Object> combinedSegmentationValues = new HashMap<>();        if (customCrashSegments != null) {            combinedSegmentationValues.putAll(customCrashSegments);        }        if (customSegmentation != null) {            UtilsInternalLimits.applySdkInternalLimitsToSegmentation(customSegmentation, _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");            combinedSegmentationValues.putAll(customSegmentation);        }        UtilsInternalLimits.truncateSegmentationValues(combinedSegmentationValues, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleCrash] prepareCrashData", L);        return new CrashData(error, combinedSegmentationValues, breadcrumbHelper.getBreadcrumbs(), deviceInfo.getCrashMetrics(_cly.context_, isNativeCrash, metricOverride, L), !handled);    }    private String prepareStackTrace(Throwable e) {        StringWriter sw = new StringWriter();        PrintWriter pw = new PrintWriter(sw);        e.printStackTrace(pw);        if (recordAllThreads) {            addAllThreadInformationToCrash(pw, _cly.config_.sdkInternalLimits);        }        String truncatedStackTrace = UtilsInternalLimits.applyInternalLimitsToStackTraces(sw.toString(), _cly.config_.sdkInternalLimits.maxStackTraceLineLength, "[ModuleCrash] prepareStackTrace", L);        return truncatedStackTrace;    }    public void sendCrashReportToQueue(@NonNull CrashData crashData, final boolean isNativeCrash) {        assert crashData != null;        L.d("[ModuleCrash] sendCrashReportToQueue");        String crashDataString = deviceInfo.getCrashDataJSON(crashData, isNativeCrash).toString();        requestQueueProvider.sendCrashReport(crashDataString, !crashData.getFatal());    }    void setCustomCrashSegmentsInternal(@Nullable Map<String, Object> segments) {        L.d("[ModuleCrash] Calling setCustomCrashSegmentsInternal");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {            return;        }        Map<String, Object> customSegments;        if (segments == null) {            customSegments = new HashMap<>();        } else {            customSegments = segments;        }        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(customSegments, _cly.config_.sdkInternalLimits, L, "[ModuleCrash] setCustomCrashSegmentsInternal");        customCrashSegments = customSegments;    }    void enableCrashReporting() {        L.d("[ModuleCrash] Enabling unhandled crash reporting");        final Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();        Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) {                L.d("[ModuleCrash] Uncaught crash handler triggered");                if (consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {                    String stackTrace = prepareStackTrace(e);                    CrashData crashData = prepareCrashData(stackTrace, false, false, null);                    if (!crashFilterCheck(crashData)) {                        sendCrashReportToQueue(crashData, false);                    }                }                if (oldHandler != null) {                    oldHandler.uncaughtException(t, e);                }            }        };        Thread.setDefaultUncaughtExceptionHandler(handler);    }    boolean crashFilterCheck(@NonNull CrashData crashData) {        assert crashData != null;        L.d("[ModuleCrash] Calling crashFilterCheck");        if (crashFilterCallback != null) {            return crashFilterCallback.filterCrash(crashData.getStackTrace());        }        if (globalCrashFilterCallback == null) {            return false;        }        if (globalCrashFilterCallback.filterCrash(crashData)) {            L.d("[ModuleCrash] crashFilterCheck, Global Crash filter found a match, exception will be ignored, [" + crashData.getStackTrace().substring(0, Math.min(crashData.getStackTrace().length(), 60)) + "]");            return true;        }        crashData.calculateChangedFields();        UtilsInternalLimits.applyInternalLimitsToBreadcrumbs(crashData.getBreadcrumbs(), _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");        UtilsInternalLimits.applySdkInternalLimitsToSegmentation(crashData.getCrashSegmentation(), _cly.config_.sdkInternalLimits, L, "[ModuleCrash] sendCrashReportToQueue");        String truncatedStackTrace = UtilsInternalLimits.applyInternalLimitsToStackTraces(crashData.getStackTrace(), _cly.config_.sdkInternalLimits.maxStackTraceLineLength, "[ModuleCrash] sendCrashReportToQueue", L);        crashData.setStackTrace(truncatedStackTrace);        UtilsInternalLimits.removeUnsupportedDataTypes(crashData.getCrashSegmentation(), L);        UtilsInternalLimits.removeUnsupportedDataTypes(crashData.getCrashMetrics(), L);        return false;    }    void addAllThreadInformationToCrash(@NonNull PrintWriter pw, @NonNull ConfigSdkInternalLimits sdkInternalLimits) {        assert pw != null;        assert sdkInternalLimits != null;        Map<Thread, StackTraceElement[]> allThreads = Thread.getAllStackTraces();        int threadCount = 0;        for (Map.Entry<Thread, StackTraceElement[]> entry : allThreads.entrySet()) {            if (threadCount >= sdkInternalLimits.maxStackTraceThreadCount) {                break;            }            StackTraceElement[] val = entry.getValue();            Thread thread = entry.getKey();            if (val == null || thread == null) {                continue;            }            pw.println();            pw.println("Thread " + thread.getName());            for (int i = 0; i < Math.min(val.length, sdkInternalLimits.maxStackTraceLinesPerThread); i++) {                pw.println(val[i].toString());            }            threadCount++;        }    }    Countly recordExceptionInternal(@Nullable final Throwable exception, final boolean itIsHandled, final Map<String, Object> customSegmentation) {        L.i("[ModuleCrash] Logging exception, handled:[" + itIsHandled + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {            return _cly;        }        if (exception == null) {            L.d("[ModuleCrash] recordException, provided exception was null, returning");            return _cly;        }        String exceptionString = prepareStackTrace(exception);        CrashData crashData = prepareCrashData(exceptionString, itIsHandled, false, customSegmentation);        if (crashFilterCheck(crashData)) {            L.d("[ModuleCrash] Crash filter found a match, exception will be ignored, [" + exceptionString.substring(0, Math.min(exceptionString.length(), 60)) + "]");        } else {            sendCrashReportToQueue(crashData, false);        }        return _cly;    }    Countly addBreadcrumbInternal(@Nullable String breadcrumb) {        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {            return _cly;        }        if (breadcrumb == null || breadcrumb.isEmpty()) {            L.w("[ModuleCrash] addBreadcrumbInternal, Can't add a null or empty crash breadcrumb");            return _cly;        }        breadcrumbHelper.addBreadcrumb(breadcrumb, _cly.config_.sdkInternalLimits.maxValueSize);        return _cly;    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (config.crashes.enableUnhandledCrashReporting) {            enableCrashReporting();        }        if (config.crashes.checkForNativeCrashDumps) {            _cly.moduleCrash.checkForNativeCrashDumps(config.context);        }    }    @Override    void halt() {    }    public class Crashes {        public Countly addCrashBreadcrumb(String record) {            synchronized (_cly) {                L.i("[Crashes] Adding crash breadcrumb");                return addBreadcrumbInternal(record);            }        }        public Countly recordHandledException(Exception exception) {            synchronized (_cly) {                return recordExceptionInternal(exception, true, null);            }        }        public Countly recordHandledException(Throwable exception) {            synchronized (_cly) {                return recordExceptionInternal(exception, true, null);            }        }        public Countly recordUnhandledException(Exception exception) {            synchronized (_cly) {                return recordExceptionInternal(exception, false, null);            }        }        public Countly recordUnhandledException(Throwable exception) {            synchronized (_cly) {                return recordExceptionInternal(exception, false, null);            }        }        public Countly recordHandledException(final Throwable exception, final Map<String, Object> customSegmentation) {            synchronized (_cly) {                return recordExceptionInternal(exception, true, customSegmentation);            }        }        public Countly recordUnhandledException(final Throwable exception, final Map<String, Object> customSegmentation) {            synchronized (_cly) {                return recordExceptionInternal(exception, false, customSegmentation);            }        }    }}package ly.count.android.sdk;import android.content.Context;import androidx.test.ext.junit.runners.AndroidJUnit4;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import static androidx.test.InstrumentationRegistry.getContext;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import static org.mockito.Mockito.anyInt;import static org.mockito.Mockito.anyString;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.spy;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyZeroInteractions;import static org.mockito.Mockito.when;@RunWith(AndroidJUnit4.class)public class CountlyTests {    Countly mUninitedCountly;    Countly mCountly;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        mUninitedCountly = new Countly();        mCountly = new Countly();        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http:    }    @After    public void tearDown() {    }    @Test    public void testConstructor() {        assertNotNull(mUninitedCountly.getConnectionQueue());        assertNull(mUninitedCountly.getConnectionQueue().getContext());        assertNull(mUninitedCountly.getConnectionQueue().baseInfoProvider);        assertNull(mUninitedCountly.getConnectionQueue().getStorageProvider());        assertNotNull(mUninitedCountly.getTimerService());        assertEquals(0, mUninitedCountly.getActivityCount());        assertNull(mUninitedCountly.moduleSessions);        assertFalse(mUninitedCountly.getDisableUpdateSessionRequests());        assertFalse(mUninitedCountly.isLoggingEnabled());        assertTrue(mCountly.isInitialized());    }    @Test    public void testSharedInstance() {        Countly sharedCountly = Countly.sharedInstance();        assertNotNull(sharedCountly);        assertSame(sharedCountly, Countly.sharedInstance());    }    @Test    public void testInitWithNoDeviceID() {        mUninitedCountly = spy(mUninitedCountly);        CountlyConfig cc = new CountlyConfig(getContext(), "appkey", "http:        mUninitedCountly.init(cc);        verify(mUninitedCountly).init(cc);    }    @Test    public void testInit_nullContext() {        try {            mUninitedCountly.init(new CountlyConfig(null, "appkey", "http:            fail("expected null context to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_nullServerURL() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", null).setDeviceId("1234"));            fail("expected null server URL to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_emptyServerURL() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "").setDeviceId("1234"));            fail("expected empty server URL to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_invalidServerURL() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "not-a-valid-server-url").setDeviceId("1234"));            fail("expected invalid server URL to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_nullAppKey() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), null, "http:            fail("expected null app key to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_emptyAppKey() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "", "http:            fail("expected empty app key to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_nullDeviceID() {        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:    }    @Test(expected = AssertionError.class)    public void testInit_emptyDeviceID() {        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:            fail("expected empty device ID to throw IllegalArgumentException");        } catch (IllegalArgumentException ignored) {        }    }    @Test    public void testInit_emptyDeviceID_sdkGenerated() {        mCountly.halt();         mUninitedCountly.init(TestUtils.createBaseConfig().setDeviceId(""));        Assert.assertEquals(DeviceIdType.OPEN_UDID, mUninitedCountly.deviceId().getType());    }    @Test    public void testInit_twiceWithSameParams() {        final String deviceID = "1234";        final String appKey = "appkey";        final String serverURL = "http:        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));        final ConnectionQueue expectedConnectionQueue = mUninitedCountly.getConnectionQueue();        final StorageProvider expectedCountlyStore = expectedConnectionQueue.getStorageProvider();        Assert.assertTrue(mCountly.isInitialized());        assertNotNull(expectedConnectionQueue);        assertNotNull(expectedCountlyStore);        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));        Assert.assertTrue(mCountly.isInitialized());        assertSame(expectedConnectionQueue, mUninitedCountly.getConnectionQueue());        assertSame(expectedCountlyStore, mUninitedCountly.getConnectionQueue().getStorageProvider());        assertSame(getContext().getApplicationContext(), mUninitedCountly.getConnectionQueue().getContext());        assertEquals(serverURL, mUninitedCountly.getConnectionQueue().baseInfoProvider.getServerURL());        assertEquals(appKey, mUninitedCountly.getConnectionQueue().baseInfoProvider.getAppKey());        assertSame(mUninitedCountly.getConnectionQueue().getStorageProvider(), mUninitedCountly.countlyStore);    }    @Test    public void testInit_twiceWithDifferentContext() {        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:        Context mContext = mock(Context.class);        when(mContext.getCacheDir()).thenReturn(getContext().getCacheDir());        mUninitedCountly.init(new CountlyConfig(mContext, "appkey", "http:    }    @Test    public void testInit_twiceWithDifferentServerURL() {        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:        } catch (IllegalStateException ignored) {            fail("expected IllegalStateException to be thrown when calling init a second time with different serverURL");        }    }    @Test    public void testInit_twiceWithDifferentAppKey() {        mUninitedCountly.init(new CountlyConfig(getContext(), "appkey1", "http:        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey2", "http:        } catch (IllegalStateException ignored) {            fail("expected IllegalStateException to be thrown when calling init a second time with different app key");        }    }    @Test    public void testInit_twiceWithDifferentDeviceID() {        mUninitedCountly.init((new CountlyConfig(getContext(), "appkey", "http:        try {            mUninitedCountly.init(new CountlyConfig(getContext(), "appkey", "http:        } catch (IllegalStateException ignored) {            fail("expected IllegalStateException to be thrown when calling init a second time with different device ID");        }    }    @Test    public void testInit_normal() {        final String deviceID = "1234";        final String appKey = "appkey";        final String serverURL = "http:        mUninitedCountly.init(new CountlyConfig(getContext(), appKey, serverURL).setDeviceId(deviceID));        assertSame(getContext().getApplicationContext(), mUninitedCountly.getConnectionQueue().getContext());        assertEquals(serverURL, mUninitedCountly.getConnectionQueue().baseInfoProvider.getServerURL());        assertEquals(appKey, mUninitedCountly.getConnectionQueue().baseInfoProvider.getAppKey());        assertNotNull(mUninitedCountly.getConnectionQueue().getStorageProvider());        assertTrue(mCountly.isInitialized());        assertSame(mUninitedCountly.getConnectionQueue().getStorageProvider(), mUninitedCountly.countlyStore);    }    @Test    public void testHalt_notInitialized() {        mUninitedCountly.halt();        assertNotNull(mUninitedCountly.getConnectionQueue());        assertNull(mUninitedCountly.getConnectionQueue().getContext());        assertNull(mUninitedCountly.getConnectionQueue().baseInfoProvider);        assertNull(mUninitedCountly.getConnectionQueue().getStorageProvider());        assertNotNull(mUninitedCountly.getTimerService());        assertTrue(mCountly.isInitialized());        assertEquals(0, mUninitedCountly.getActivityCount());        assertNull(mUninitedCountly.moduleSessions);    }    @Test    public void testOnStart_initNotCalled() {        try {            mUninitedCountly.onStart(null);        } catch (IllegalStateException ignored) {            fail("expected calling onStart before init to throw IllegalStateException");        }    }    @Test    public void testOnStart_firstCall() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.onStart(null);        assertEquals(1, mCountly.getActivityCount());        final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();        assertTrue(prevSessionDurationStartTime > 0);        assertTrue(prevSessionDurationStartTime <= System.currentTimeMillis());        TestUtils.verifyBeginSessionValues(requestQueueProvider, false, null, null, null, null);    }    @Test    public void testOnStart_subsequentCall() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.onStart(null);         final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();        mCountly.onStart(null);         assertEquals(2, mCountly.getActivityCount());        assertEquals(prevSessionDurationStartTime, mCountly.getPrevSessionDurationStartTime());        TestUtils.verifyBeginSessionValues(requestQueueProvider, false, null, null, null, null);    }    @Test    public void testOnStop_initNotCalled() {        try {            mUninitedCountly.onStop();        } catch (IllegalStateException ignored) {            fail("expected calling onStop before init to throw IllegalStateException");        }    }    @Test    public void testOnStop_unbalanced() {        try {            mCountly.onStop();        } catch (IllegalStateException ignored) {            fail("expected calling onStop before init to throw IllegalStateException");        }    }    @Test    public void testOnStop_reallyStopping_emptyEventQueue() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.onStart(null);        mCountly.onStop();        assertEquals(0, mCountly.getActivityCount());        assertTrue(mCountly.getPrevSessionDurationStartTime() > 0);        verify(requestQueueProvider).endSession(0);        verify(requestQueueProvider, times(1)).recordEvents(anyString());     }    @Test    public void testOnStop_reallyStopping_nonEmptyEventQueue() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);        StorageProvider sp = mock(StorageProvider.class);        TestUtils.setStorageProviderToMock(mCountly, sp);        when(sp.getEventQueueSize()).thenReturn(1);        final String eventStr = "blahblahblahblah";        when(sp.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventStr);        mCountly.onStart(null);        mCountly.onStop();        assertEquals(0, mCountly.getActivityCount());        assertTrue(mCountly.getPrevSessionDurationStartTime() > 0);        verify(requestQueueProvider).endSession(0);        verify(requestQueueProvider).recordEvents(eventStr);    }    @Test    public void testOnStop_notStopping() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.onStart(null);        mCountly.onStart(null);        final long prevSessionDurationStartTime = mCountly.getPrevSessionDurationStartTime();        mCountly.onStop();        assertEquals(1, mCountly.getActivityCount());        assertEquals(prevSessionDurationStartTime, mCountly.getPrevSessionDurationStartTime());        verify(requestQueueProvider, times(0)).endSession(anyInt());        verify(requestQueueProvider, times(0)).recordEvents(anyString());    }    @Test    public void testSendEventsIfNeeded_emptyQueue() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.moduleEvents.storageProvider = mock(StorageProvider.class);        when(mCountly.moduleEvents.storageProvider.getEventQueueSize()).thenReturn(0);        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);        verify(mCountly.moduleEvents.storageProvider, times(0)).getEventsForRequestAndEmptyEventQueue();        verifyZeroInteractions(requestQueueProvider);    }    @Test    public void testSendEventsIfNeeded_lessThanThreshold() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.moduleEvents.storageProvider = mock(StorageProvider.class);        when(mCountly.moduleEvents.storageProvider.getEventQueueSize()).thenReturn(9);        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);        verify(mCountly.moduleEvents.storageProvider, times(0)).getEventsForRequestAndEmptyEventQueue();        verifyZeroInteractions(requestQueueProvider);    }    @Test    public void testSendEventsIfNeeded_equalToThreshold() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.config_.storageProvider = mock(StorageProvider.class);        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(100);        final String eventData = "blahblahblah";        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);        verify(mCountly.config_.storageProvider, times(1)).getEventsForRequestAndEmptyEventQueue();        verify(requestQueueProvider, times(1)).recordEvents(eventData);    }    @Test    public void testSendEventsIfNeeded_moreThanThreshold() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.config_.storageProvider = mock(StorageProvider.class);        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(120);        final String eventData = "blahblahblah";        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);        mCountly.moduleRequestQueue.sendEventsIfNeeded(false);        verify(mCountly.config_.storageProvider, times(1)).getEventsForRequestAndEmptyEventQueue();        verify(requestQueueProvider, times(1)).recordEvents(eventData);    }    @Test    public void testOnTimer_noActiveSession() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.config_.storageProvider = mock(StorageProvider.class);        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);        mCountly.onTimer();        verify(requestQueueProvider).tick();    }    @Test    public void testOnTimer_activeSession_emptyEventQueue() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.config_.storageProvider = mock(StorageProvider.class);        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(0);        mCountly.onStart(null);        mCountly.onTimer();        verify(requestQueueProvider).updateSession(0);        verify(requestQueueProvider, times(1)).recordEvents(anyString());     }    @Test    public void testOnTimer_activeSession_nonEmptyEventQueue() {        RequestQueueProvider requestQueueProvider = TestUtils.setRequestQueueProviderToMock(mCountly, mock(RequestQueueProvider.class));        mCountly.config_.storageProvider = mock(StorageProvider.class);        mCountly.moduleRequestQueue.storageProvider = mCountly.config_.storageProvider;        when(mCountly.config_.storageProvider.getEventQueueSize()).thenReturn(1);        final String eventData = "blahblahblah";        when(mCountly.config_.storageProvider.getEventsForRequestAndEmptyEventQueue()).thenReturn(eventData);        mCountly.onStart(null);        mCountly.onTimer();        verify(requestQueueProvider).updateSession(0);        verify(requestQueueProvider).recordEvents(eventData);    }    @Test    public void testRoundedSecondsSinceLastSessionDurationUpdate() {        long prevSessionDurationStartTime = System.currentTimeMillis() - 1000;        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);        assertEquals(1, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());        prevSessionDurationStartTime = System.currentTimeMillis() - 2000;        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);        assertEquals(2, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());        prevSessionDurationStartTime = System.currentTimeMillis() - 1600;        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);        assertEquals(2, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());        prevSessionDurationStartTime = System.currentTimeMillis() - 1200;        mCountly.setPrevSessionDurationStartTime(prevSessionDurationStartTime);        assertEquals(1, mCountly.moduleSessions.roundedSecondsSinceLastSessionDurationUpdate());    }    @Test    public void testIsValidURL_badURLs() {        assertFalse(UtilsNetworking.isValidURL(null));        assertFalse(UtilsNetworking.isValidURL(""));        assertFalse(UtilsNetworking.isValidURL(" "));        assertFalse(UtilsNetworking.isValidURL("blahblahblah.com"));    }    @Test    public void testIsValidURL_goodURL() {        assertTrue(UtilsNetworking.isValidURL("http:    }    @Test    public void testCurrentTimestamp() {        final int testTimestamp = (int) (System.currentTimeMillis() / 1000L);        final int actualTimestamp = UtilsTime.currentTimestampSeconds();        assertTrue(((testTimestamp - 1) <= actualTimestamp) && ((testTimestamp + 1) >= actualTimestamp));    }    @Test    public void testLoggingFlag() {        assertFalse(mUninitedCountly.isLoggingEnabled());        mUninitedCountly.setLoggingEnabled(true);        assertTrue(mUninitedCountly.isLoggingEnabled());        mUninitedCountly.setLoggingEnabled(false);        assertFalse(mUninitedCountly.isLoggingEnabled());    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.HashMap;import java.util.Map;import ly.count.android.sdk.messaging.ModulePush;public class ModuleEvents extends ModuleBase implements EventProvider {    static final Map<String, Event> timedEvents = new HashMap<>();    final static String ACTION_EVENT_KEY = "[CLY]_action";    final static String VISIBILITY_KEY = "cly_v";    final static String PREVIOUS_EVENT_NAME_KEY = "cly_pen";    final static String PREVIOUS_VIEW_NAME_KEY = "cly_pvn";    final static String CURRENT_VIEW_NAME_KEY = "cly_cvn";    final Events eventsInterface;    String previousEventId = "";    String previousEventName = "";    EventQueueProvider eventQueueProvider;    ViewIdProvider viewIdProvider;    SafeIDGenerator safeEventIDGenerator;    private final boolean viewNameRecordingEnabled;    private final boolean visibilityTracking;    ModuleEvents(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleEvents] Initialising");        eventProvider = this;        config.eventProvider = this;        eventQueueProvider = config.eventQueueProvider;        safeEventIDGenerator = config.safeEventIDGenerator;        viewNameRecordingEnabled = config.experimental.viewNameRecordingEnabled;        visibilityTracking = config.experimental.visibilityTrackingEnabled;        eventsInterface = new Events();    }    void checkCachedPushData(CountlyStore cs) {        L.d("[ModuleEvents] Starting cache call");        String[] cachedData = cs.getCachedPushData();        if (cachedData != null && cachedData[0] != null && cachedData[1] != null) {            L.d("[ModuleEvents] Found cached push event, recording it");            Map<String, Object> map = new HashMap<>();            map.put(ModulePush.PUSH_EVENT_ACTION_PLATFORM_KEY, ModulePush.PUSH_EVENT_ACTION_PLATFORM_VALUE);            map.put(ModulePush.PUSH_EVENT_ACTION_ID_KEY, cachedData[0]);            map.put(ModulePush.PUSH_EVENT_ACTION_INDEX_KEY, cachedData[1]);            recordEventInternal(ModulePush.PUSH_EVENT_ACTION, map, 1, 0, 0, null, null);        }        if (cachedData != null && (cachedData[0] != null || cachedData[1] != null)) {            cs.clearCachedPushData();        }    }    public void recordEventInternal(@Nullable final String key, @Nullable Map<String, Object> segmentation, int count, final double sum, final double dur, UtilsTime.Instant instant, final String eventIdOverride) {        assert count >= 1;        assert _cly.isInitialized();        long pccTsStartRecordEventInternal = 0L;        if (pcc != null) {            pccTsStartRecordEventInternal = UtilsTime.getNanoTime();        }        L.v("[ModuleEvents] calling 'recordEventInternal'");        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] recordEventInternal, Valid Countly event key is required. Event will be ignored.");            return;        }        if (count < 1) {            L.e("[ModuleEvents] recordEventInternal, event count should be greater than zero. Key:[" + key + "] count:[" + count + "]");            count = 1;        }        L.d("[ModuleEvents] recordEventInternal, key:[" + key + "] eventIdOverride:[" + eventIdOverride + "] segmentation:[" + segmentation + "] count:[" + count + "] sum:[" + sum + "] dur:[" + dur + "] instant:[" + instant + "]");        if (segmentation != null) {            UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);        }        if (instant == null) {            instant = UtilsTime.getCurrentInstant();        }        String eventId;        if (eventIdOverride == null) {             eventId = safeEventIDGenerator.GenerateValue();        } else if (eventIdOverride.length() == 0) {            L.w("[ModuleEvents] provided event ID override value is empty. Will generate a new one.");            eventId = safeEventIDGenerator.GenerateValue();        } else {             eventId = eventIdOverride;        }        final long timestamp = instant.timestampMs;        final int hour = instant.hour;        final int dow = instant.dow;        String pvid = null;         String cvid = null;         String pvn = null;        String pen = null;        String cvn = null;        if (key.equals(ModuleViews.VIEW_EVENT_KEY)) {            pvid = viewIdProvider.getPreviousViewId();            if (viewNameRecordingEnabled) {                pvn = _cly.moduleViews.previousViewName;                if (pvn == null) {                    pvn = "";                }            }        } else {            cvid = viewIdProvider.getCurrentViewId();            if (viewNameRecordingEnabled) {                pen = previousEventName;                cvn = _cly.moduleViews.currentViewName;                if (pen == null) {                    pen = "";                }                if (cvn == null) {                    cvn = "";                }            }        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternalGenID", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);        }        _cly.moduleUserProfile.saveInternal();        if (visibilityTracking) {            if (segmentation == null) {                segmentation = new HashMap<>();            }            if (ModuleViews.VIEW_EVENT_KEY.equals(key) && !segmentation.containsKey("visit")) {                L.d("[ModuleEvents] recordEventInternal, visibility key will not be added to the end view event");            } else {                String appInBackground = deviceInfo.isInBackground();                int state = 1;                 if ("true".equals(appInBackground)) {                    state = 0;                 }                L.d("[ModuleEvents] recordEventInternal, Adding visibility tracking to segmentation app in background:[" + appInBackground + "] cly_v:[" + state + "]");                segmentation.put(VISIBILITY_KEY, state);            }        }        switch (key) {            case ModuleFeedback.NPS_EVENT_KEY:            case ModuleFeedback.SURVEY_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);                }                break;            case ModuleFeedback.RATING_EVENT_KEY:                 if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating) || consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModuleViews.VIEW_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {                    if (segmentation == null) {                        segmentation = new HashMap<>();                    }                    if (viewNameRecordingEnabled) {                        segmentation.put(PREVIOUS_VIEW_NAME_KEY, pvn);                    }                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModuleViews.ORIENTATION_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModulePush.PUSH_EVENT_ACTION:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.push)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);                }                break;            case ACTION_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.clicks) || consentProvider.getConsent(Countly.CountlyFeatureNames.scrolls)) {                    if (segmentation != null) {                        UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);                    }                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            default:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {                    String keyTruncated = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleEvents] recordEventInternal");                    if (segmentation == null) {                        segmentation = new HashMap<>();                    }                    UtilsInternalLimits.applySdkInternalLimitsToSegmentation(segmentation, _cly.config_.sdkInternalLimits, L, "[ModuleEvents] recordEventInternal");                    if (viewNameRecordingEnabled) {                        segmentation.put(CURRENT_VIEW_NAME_KEY, cvn);                        segmentation.put(PREVIOUS_EVENT_NAME_KEY, pen);                    }                    eventQueueProvider.recordEventToEventQueue(keyTruncated, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, previousEventId);                    previousEventId = eventId;                    previousEventName = keyTruncated;                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternal", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);        }    }    boolean startEventInternal(final String key) {        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't start event with a null or empty key");            return false;        }        if (timedEvents.containsKey(key)) {            return false;        }        L.d("[ModuleEvents] Starting event: [" + key + "]");        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();        timedEvents.put(key, new Event(key, instant.timestampMs, instant.hour, instant.dow));        return true;    }    boolean endEventInternal(@Nullable final String key, @Nullable final Map<String, Object> segmentation, int count, final double sum) {        L.d("[ModuleEvents] Ending event: [" + key + "]");        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't end event with a null or empty key");            return false;        }        Event event = timedEvents.remove(key);        if (event != null) {            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {                return true;            }            if (count < 1) {                L.e("[ModuleEvents] endEventInternal, event count should be greater than zero, key [" + key + "], dur:[" + count + "]. Count will be reset to '1'.");                count = 1;            }            L.d("[ModuleEvents] Ending event: [" + key + "]");            long currentTimestamp = UtilsTime.currentTimestampMs();            double duration = (currentTimestamp - event.timestamp) / 1000.0;            UtilsTime.Instant instant = new UtilsTime.Instant(event.timestamp, event.hour, event.dow);            eventProvider.recordEventInternal(key, segmentation, count, sum, duration, instant, null);            return true;        } else {            return false;        }    }    boolean cancelEventInternal(final String key) {        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't cancel event with a null or empty key");            return false;        }        Event event = timedEvents.remove(key);        return event != null;    }    @Override    void initFinished(@NonNull CountlyConfig config) {        checkCachedPushData(_cly.countlyStore);    }    @Override    void halt() {        timedEvents.clear();    }    public class Events {        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, long timestamp) {            synchronized (_cly) {                recordPastEvent(key, segmentation, 1, 0, 0, timestamp);            }        }        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur, long timestamp) {            synchronized (_cly) {                L.i("[Events] Calling recordPastEvent: [" + key + "]");                if (timestamp <= 0) {                    L.e("Provided timestamp has to be greater that zero. Replacing that timestamp with the current time");                    timestamp = UtilsTime.currentTimestampMs();                }                UtilsTime.Instant instant = UtilsTime.Instant.get(timestamp);                recordEventInternal(key, segmentation, count, sum, dur, instant, null);            }        }        public boolean startEvent(@NonNull final String key) {            synchronized (_cly) {                L.i("[Events] Calling startEvent: [" + key + "]");                return startEventInternal(key);            }        }        public boolean endEvent(@NonNull final String key) {            synchronized (_cly) {                return endEvent(key, null, 1, 0);            }        }        public boolean endEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {            synchronized (_cly) {                L.i("[Events] Calling endEvent: [" + key + "]");                return endEventInternal(key, segmentation, count, sum);            }        }        public boolean cancelEvent(@NonNull final String key) {            synchronized (_cly) {                L.i("[Events] Calling cancelEvent: [" + key + "]");                return cancelEventInternal(key);            }        }        public void recordEvent(@NonNull final String key) {            synchronized (_cly) {                recordEvent(key, null, 1, 0);            }        }        public void recordEvent(@NonNull final String key, final int count) {            synchronized (_cly) {                recordEvent(key, null, count, 0);            }        }        public void recordEvent(@NonNull final String key, final int count, final double sum) {            synchronized (_cly) {                recordEvent(key, null, count, sum);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation) {            synchronized (_cly) {                recordEvent(key, segmentation, 1, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count) {            synchronized (_cly) {                recordEvent(key, segmentation, count, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {            synchronized (_cly) {                recordEvent(key, segmentation, count, sum, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur) {            synchronized (_cly) {                L.i("[Events] Calling recordEvent: [" + key + "]");                if (segmentation != null) {                    UtilsInternalLimits.truncateSegmentationValues(segmentation, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[Events] recordEvent,", L);                }                eventProvider.recordEventInternal(key, segmentation, count, sum, dur, null, null);            }        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import org.json.JSONException;import org.json.JSONObject;class ModuleConfiguration extends ModuleBase implements ConfigurationProvider {    ImmediateRequestGenerator immediateRequestGenerator;    boolean serverConfigEnabled = false;    JSONObject latestRetrievedConfigurationFull = null;    JSONObject latestRetrievedConfiguration = null;    final static String keyTracking = "tracking";    final static String keyNetworking = "networking";    final static String keyRTimestamp = "t";    final static String keyRVersion = "v";    final static String keyRConfig = "c";    final static boolean defaultVTracking = true;    final static boolean defaultVNetworking = true;    boolean currentVTracking = true;    boolean currentVNetworking = true;    boolean configurationFetched = false;    ModuleConfiguration(@NonNull Countly cly, @NonNull CountlyConfig config) {        super(cly, config);        L.v("[ModuleConfiguration] Initialising");        config.configProvider = this;        configProvider = this;        serverConfigEnabled = config.serverConfigurationEnabled;        immediateRequestGenerator = config.immediateRequestGenerator;        config.countlyStore.setConfigurationProvider(this);        if (serverConfigEnabled) {            loadConfigFromStorage();            updateConfigVariables();        }    }    @Override    void initFinished(@NonNull final CountlyConfig config) {        if (serverConfigEnabled) {            fetchConfigFromServer();        }    }    @Override    void halt() {    }    void loadConfigFromStorage() {        String sConfig = storageProvider.getServerConfig();        L.v("[ModuleConfiguration] loadConfigFromStorage, [" + sConfig + "]");        if (sConfig == null || sConfig.isEmpty()) {            L.d("[ModuleConfiguration] loadStoredConfig, no configs persistently stored");            return;        }        try {            latestRetrievedConfigurationFull = new JSONObject(sConfig);            latestRetrievedConfiguration = latestRetrievedConfigurationFull.getJSONObject(keyRConfig);            L.d("[ModuleConfiguration] loadStoredConfig, stored config loaded [" + sConfig + "]");        } catch (JSONException e) {            L.w("[ModuleConfiguration] loadStoredConfig, failed to parse, " + e);            latestRetrievedConfigurationFull = null;            latestRetrievedConfiguration = null;        }    }    void updateConfigVariables() {        L.v("[ModuleConfiguration] updateConfigVariables");        currentVNetworking = defaultVNetworking;        currentVTracking = defaultVTracking;        if (latestRetrievedConfiguration == null) {            return;        }        if (latestRetrievedConfiguration.has(keyNetworking)) {            try {                currentVNetworking = latestRetrievedConfiguration.getBoolean(keyNetworking);            } catch (JSONException e) {                L.w("[ModuleConfiguration] updateConfigs, failed to load 'networking', " + e);            }        }        if (latestRetrievedConfiguration.has(keyTracking)) {            try {                currentVTracking = latestRetrievedConfiguration.getBoolean(keyTracking);            } catch (JSONException e) {                L.w("[ModuleConfiguration] updateConfigs, failed to load 'tracking', " + e);            }        }    }    void saveAndStoreDownloadedConfig(@NonNull JSONObject config) {        L.v("[ModuleConfiguration] saveAndStoreDownloadedConfig");        if (!config.has(keyRVersion)) {            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'version' field. Config will be ignored.");            return;        }        if (!config.has(keyRTimestamp)) {            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'timestamp' field. Config will be ignored.");            return;        }        if (!config.has(keyRConfig)) {            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'configuration' field. Config will be ignored.");            return;        }        latestRetrievedConfigurationFull = config;        String configAsString = null;        try {            latestRetrievedConfiguration = config.getJSONObject(keyRConfig);            configAsString = config.toString();        } catch (JSONException e) {            latestRetrievedConfigurationFull = null;            latestRetrievedConfiguration = null;            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Failed retrieving internal config, " + e);            return;        }        storageProvider.setServerConfig(configAsString);        updateConfigVariables();    }    void fetchConfigFromServer() {        L.v("[ModuleConfiguration] fetchConfigFromServer");        if (!serverConfigEnabled) {            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, server config is disabled");            return;        }        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, temporary device ID mode is set");            return;        }        if (configurationFetched) {            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, config already fetched");            return;        }        configurationFetched = true;        String requestData = requestQueueProvider.prepareServerConfigRequest();        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, true, checkResponse -> {            if (checkResponse == null) {                L.w("[ModuleConfiguration] Not possible to retrieve configuration data. Probably due to lack of connection to the server");                return;            }            L.d("[ModuleConfiguration] Retrieved configuration response: [" + checkResponse.toString() + "]");            saveAndStoreDownloadedConfig(checkResponse);        }, L);    }    @Override    public boolean getNetworkingEnabled() {        if (!serverConfigEnabled) {            return defaultVNetworking;        }        return currentVNetworking;    }    @Override    public boolean getTrackingEnabled() {        if (!serverConfigEnabled) {            return defaultVTracking;        }        return currentVTracking;    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.Collection;import java.util.List;import java.util.Map;interface StorageProvider {    String[] getRequests();    String[] getEvents();    List<Event> getEventList();    @NonNull String getRequestQueueRaw();    void addRequest(final String requestStr, final boolean writeInSync);    void removeRequest(final String requestStr);    void replaceRequests(final String[] newConns);    void replaceRequestList(final List<String> newConns);    void removeEvents(final List<Event> eventsToRemove);    int getEventQueueSize();    String getEventsForRequestAndEmptyEventQueue();    @Nullable String getDeviceID();    @Nullable String getDeviceIDType();    void setDeviceID(String id);    void setDeviceIDType(String type);    void setStarRatingPreferences(String preferences);    String getStarRatingPreferences();    void setCachedAdvertisingId(String advertisingId);    String getCachedAdvertisingId();    void setRemoteConfigValues(String values);    String getRemoteConfigValues();    void esWriteCacheToStorage(@Nullable ExplicitStorageCallback callback);    void setServerConfig(String config);    String getServerConfig();    int getDataSchemaVersion();    void setDataSchemaVersion(int version);    boolean anythingSetInStorage();    @NonNull String getHealthCheckCounterState();    void setHealthCheckCounterState(String counterState);}package ly.count.android.sdk;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.os.Handler;import android.os.Looper;import android.webkit.WebSettings;import android.webkit.WebView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;public class ModuleFeedback extends ModuleBase {    public enum FeedbackWidgetType {survey, nps, rating}    public static class CountlyFeedbackWidget {        public String widgetId;        public FeedbackWidgetType type;        public String name;        public String[] tags;    }    final static String NPS_EVENT_KEY = "[CLY]_nps";    final static String SURVEY_EVENT_KEY = "[CLY]_survey";    final static String RATING_EVENT_KEY = "[CLY]_star_rating";    final String cachedAppVersion;    Feedback feedbackInterface = null;    ModuleFeedback(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleFeedback] Initialising");        cachedAppVersion = deviceInfo.mp.getAppVersion(config.context);        feedbackInterface = new Feedback();    }    public interface RetrieveFeedbackWidgets {        void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error);    }    public interface RetrieveFeedbackWidgetData {        void onFinished(JSONObject retrievedWidgetData, String error);    }    public interface FeedbackCallback {        void onClosed();        void onFinished(String error);    }    void getAvailableFeedbackWidgetsInternal(final RetrieveFeedbackWidgets devCallback) {        L.d("[ModuleFeedback] calling 'getAvailableFeedbackWidgetsInternal', callback set:[" + (devCallback != null) + "]");        if (devCallback == null) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved without a callback");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            devCallback.onFinished(null, "Consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            devCallback.onFinished(null, "[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            return;        }        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        String requestData = requestQueueProvider.prepareFeedbackListRequest();        (new ImmediateRequestMaker()).doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleFeedback] Not possible to retrieve widget list. Probably due to lack of connection to the server");                    devCallback.onFinished(null, "Not possible to retrieve widget list. Probably due to lack of connection to the server");                    return;                }                L.d("[ModuleFeedback] Retrieved request: [" + checkResponse.toString() + "]");                List<CountlyFeedbackWidget> feedbackEntries = parseFeedbackList(checkResponse);                devCallback.onFinished(feedbackEntries, null);            }        }, L);    }    static List<CountlyFeedbackWidget> parseFeedbackList(JSONObject requestResponse) {        Countly.sharedInstance().L.d("[ModuleFeedback] calling 'parseFeedbackList'");        List<CountlyFeedbackWidget> parsedRes = new ArrayList<>();        try {            if (requestResponse != null) {                JSONArray jArray = requestResponse.optJSONArray("result");                if (jArray == null) {                    Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, response does not have a valid 'result' entry. No widgets retrieved.");                    return parsedRes;                }                for (int a = 0; a < jArray.length(); a++) {                    try {                        JSONObject jObj = jArray.getJSONObject(a);                        String valId = jObj.optString("_id", "");                        String valType = jObj.optString("type", "");                        String valName = jObj.optString("name", "");                        List<String> valTagsArr = new ArrayList<String>();                        JSONArray jTagArr = jObj.optJSONArray("tg");                        if (jTagArr == null) {                            Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, no tags received");                        } else {                            for (int in = 0; in < jTagArr.length(); in++) {                                valTagsArr.add(jTagArr.getString(in));                            }                        }                        if (valId.isEmpty()) {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget id, dropping");                            continue;                        }                        if (valType.isEmpty()) {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget type, dropping");                            continue;                        }                        FeedbackWidgetType plannedType;                        if (valType.equals("survey")) {                            plannedType = FeedbackWidgetType.survey;                        } else if (valType.equals("nps")) {                            plannedType = FeedbackWidgetType.nps;                        } else if (valType.equals("rating")) {                            plannedType = FeedbackWidgetType.rating;                        } else {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved unknown widget type, dropping");                            continue;                        }                        CountlyFeedbackWidget se = new CountlyFeedbackWidget();                        se.type = plannedType;                        se.widgetId = valId;                        se.name = valName;                        se.tags = valTagsArr.toArray(new String[0]);                        parsedRes.add(se);                    } catch (Exception ex) {                        Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, failed to parse json, [" + ex.toString() + "]");                    }                }            }        } catch (Exception ex) {            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, Encountered exception while parsing feedback list, [" + ex.toString() + "]");        }        return parsedRes;    }    void presentFeedbackWidgetInternal(@Nullable final CountlyFeedbackWidget widgetInfo, @Nullable final Context context, @Nullable final String closeButtonText, @Nullable final FeedbackCallback devCallback) {        if (widgetInfo == null) {            L.e("[ModuleFeedback] Can't present widget with null widget info");            if (devCallback != null) {                devCallback.onFinished("Can't present widget with null widget info");            }            return;        }        L.d("[ModuleFeedback] presentFeedbackWidgetInternal, callback set:[" + (devCallback != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "]");        if (context == null) {            L.e("[ModuleFeedback] Can't show feedback, provided context is null");            if (devCallback != null) {                devCallback.onFinished("Can't show feedback, provided context is null");            }            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            if (devCallback != null) {                devCallback.onFinished("Consent is not granted");            }            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            if (devCallback != null) {                devCallback.onFinished("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            }            return;        }        StringBuilder widgetListUrl = new StringBuilder();        switch (widgetInfo.type) {            case survey:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/survey?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;            case nps:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/nps?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;            case rating:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/rating?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;        }        widgetListUrl.append("&device_id=");        widgetListUrl.append(UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()));        widgetListUrl.append("&app_key=");        widgetListUrl.append(UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey()));        widgetListUrl.append("&sdk_version=");        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);        widgetListUrl.append("&sdk_name=");        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_NAME);        widgetListUrl.append("&platform=android");        JSONObject customObjectToSendWithTheWidget = new JSONObject();        try {            customObjectToSendWithTheWidget.put("tc", 1);        } catch (JSONException e) {            throw new RuntimeException(e);        }        widgetListUrl.append("&custom=");        widgetListUrl.append(customObjectToSendWithTheWidget.toString());        final String preparedWidgetUrl = widgetListUrl.toString();        L.d("[ModuleFeedback] Using following url for widget:[" + widgetListUrl + "]");        final boolean useAlertDialog = true;        Handler handler = new Handler(Looper.getMainLooper());        handler.post(new Runnable() {            public void run() {                L.d("[ModuleFeedback] Calling on main thread");                try {                    ModuleRatings.RatingDialogWebView webView = new ModuleRatings.RatingDialogWebView(context);                    webView.getSettings().setJavaScriptEnabled(true);                    webView.clearCache(true);                    webView.clearHistory();                    webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);                    webView.setWebViewClient(new ModuleRatings.FeedbackDialogWebViewClient());                    webView.loadUrl(preparedWidgetUrl);                    webView.requestFocus();                    AlertDialog.Builder builder = prepareAlertDialog(context, webView, closeButtonText, widgetInfo, devCallback);                    if (useAlertDialog) {                        L.d("[ModuleFeedback] Creating standalone Alert dialog");                        builder.show();                    } else {                        L.d("[ModuleFeedback] Creating Alert dialog in dialogFragment");                    }                    if (devCallback != null) {                        devCallback.onFinished(null);                    }                } catch (Exception ex) {                    L.e("[ModuleFeedback] Failed at displaying feedback widget dialog, [" + ex.toString() + "]");                    if (devCallback != null) {                        devCallback.onFinished("Failed at displaying feedback widget dialog, [" + ex.toString() + "]");                    }                }            }        });    }    AlertDialog.Builder prepareAlertDialog(@NonNull final Context context, @NonNull WebView webView, @Nullable String closeButtonText, @NonNull final CountlyFeedbackWidget widgetInfo, @Nullable final FeedbackCallback devCallback) {        AlertDialog.Builder builder = new AlertDialog.Builder(context);        builder.setView(webView);        builder.setCancelable(false);        String usedCloseButtonText = closeButtonText;        if (closeButtonText == null || closeButtonText.isEmpty()) {            usedCloseButtonText = "Close";        }        builder.setNeutralButton(usedCloseButtonText, new DialogInterface.OnClickListener() {            @Override public void onClick(DialogInterface dialogInterface, int i) {                L.d("[ModuleFeedback] Cancel button clicked for the feedback widget");                reportFeedbackWidgetCancelButton(widgetInfo, deviceInfo.mp.getAppVersion(context));                if (devCallback != null) {                    devCallback.onClosed();                }            }        });        return builder;    }    void reportFeedbackWidgetCancelButton(@NonNull CountlyFeedbackWidget widgetInfo, @NonNull String appVersion) {        L.d("[reportFeedbackWidgetCancelButton] Cancel button event");        if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            final Map<String, Object> segm = new HashMap<>();            segm.put("platform", "android");            segm.put("app_version", appVersion);            segm.put("widget_id", "" + widgetInfo.widgetId);            segm.put("closed", "1");            final String key;            if (widgetInfo.type == FeedbackWidgetType.survey) {                key = SURVEY_EVENT_KEY;            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                key = RATING_EVENT_KEY;            } else {                key = NPS_EVENT_KEY;            }            eventProvider.recordEventInternal(key, segm, 1, 0, 0, null, null);        }    }    void getFeedbackWidgetDataInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable final RetrieveFeedbackWidgetData devCallback) {        L.d("[ModuleFeedback] calling 'getFeedbackWidgetDataInternal', callback set:[" + (devCallback != null) + "]");        if (devCallback == null) {            L.e("[ModuleFeedback] Feedback widget data can't be retrieved without a callback");            return;        }        if (widgetInfo == null) {            L.e("[ModuleFeedback] Feedback widget data if provided widget is 'null'");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            devCallback.onFinished(null, "Consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");            devCallback.onFinished(null, "[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");            return;        }        StringBuilder requestData = new StringBuilder();        String widgetDataEndpoint = "";        switch (widgetInfo.type) {            case survey:                widgetDataEndpoint = "/o/surveys/survey/widget";                break;            case nps:                widgetDataEndpoint = "/o/surveys/nps/widget";                break;            case rating:                widgetDataEndpoint = "/o/surveys/rating/widget";                break;        }        requestData.append("widget_id=");        requestData.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));        requestData.append("&shown=1");        requestData.append("&sdk_version=");        requestData.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);        requestData.append("&sdk_name=");        requestData.append(Countly.sharedInstance().COUNTLY_SDK_NAME);        requestData.append("&platform=android");        requestData.append("&app_version=");        requestData.append(cachedAppVersion);        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        String requestDataStr = requestData.toString();        L.d("[ModuleFeedback] Using following request params for retrieving widget data:[" + requestDataStr + "]");        (new ImmediateRequestMaker()).doWork(requestDataStr, widgetDataEndpoint, cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleFeedback] Not possible to retrieve widget data. Probably due to lack of connection to the server");                    devCallback.onFinished(null, "Not possible to retrieve widget data. Probably due to lack of connection to the server");                    return;                }                L.d("[ModuleFeedback] Retrieved widget data request: [" + checkResponse.toString() + "]");                devCallback.onFinished(checkResponse, null);            }        }, L);    }    void reportFeedbackWidgetManuallyInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {        if (widgetInfo == null) {            L.e("[ModuleFeedback] Can't report feedback widget data manually with 'null' widget info");            return;        }        L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetData set:[" + (widgetData != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "], widget result set:[" + (widgetResult != null) + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            L.w("[ModuleFeedback] Can't report feedback widget data, consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] feedback widget result can't be reported when in temporary device ID mode");            return;        }        if (widgetResult != null) {            UtilsInternalLimits.removeUnsupportedDataTypes(widgetResult, L);            Iterator<Map.Entry<String, Object>> iter = widgetResult.entrySet().iterator();            while (iter.hasNext()) {                Map.Entry<String, Object> entry = iter.next();                if (entry.getKey() == null) {                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' key, it will be removed, value[" + entry.getValue() + "]");                    iter.remove();                } else if (entry.getKey().isEmpty()) {                    L.w("[ModuleFeedback] provided feedback widget result contains an empty string key, it will be removed, value[" + entry.getValue() + "]");                    iter.remove();                } else if (entry.getValue() == null) {                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' value, it will be removed, key[" + entry.getKey() + "]");                    iter.remove();                }                if (entry.getValue() instanceof String) {                    String truncatedValue = UtilsInternalLimits.truncateValueSize(entry.getValue().toString(), _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleFeedback] reportFeedbackWidgetManuallyInternal");                    if (!truncatedValue.equals(entry.getValue())) {                        entry.setValue(truncatedValue);                    }                }            }            if (widgetInfo.type == FeedbackWidgetType.nps) {                if (!widgetResult.containsKey("rating")) {                    L.e("Provided NPS widget result does not have a 'rating' field, result can't be reported");                    return;                }                Object ratingValue = widgetResult.get("rating");                if (!(ratingValue instanceof Integer)) {                    L.e("Provided NPS widget 'rating' field is not an integer, result can't be reported");                    return;                }                int ratingValI = (int) ratingValue;                if (ratingValI < 0 || ratingValI > 10) {                    L.e("Provided NPS widget 'rating' value is out of bounds of the required value '[0;10]', it is probably an error");                }                if (!widgetResult.containsKey("comment")) {                    L.w("Provided NPS widget result does not have a 'comment' field");                }            } else if (widgetInfo.type == FeedbackWidgetType.survey) {            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                if (!widgetResult.containsKey("rating")) {                    L.e("Provided Rating widget result does not have a 'rating' field, result can't be reported");                    return;                }                Object ratingValue = widgetResult.get("rating");                if (!(ratingValue instanceof Integer)) {                    L.e("Provided Rating widget 'rating' field is not an integer, result can't be reported");                    return;                }                int ratingValI = (int) ratingValue;                if (ratingValI < 1 || ratingValI > 5) {                    L.e("Provided Rating widget 'rating' value is out of bounds of the required value '[1;5]', it is probably an error");                }            }        }        if (widgetData == null) {            L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetInfo is 'null', no validation will be done");        } else {            String idInData = widgetData.optString("_id");            if (!widgetInfo.widgetId.equals(idInData)) {                L.w("[ModuleFeedback] id in widget info does not match the id in widget data");            }            String typeInData = widgetData.optString("type");            if (widgetInfo.type == FeedbackWidgetType.nps) {                if (!"nps".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [nps]");                }            } else if (widgetInfo.type == FeedbackWidgetType.survey) {                if (!"survey".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [survey]");                }            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                if (!"rating".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [rating]");                }            }        }        final String usedEventKey;        if (widgetInfo.type == FeedbackWidgetType.nps) {            usedEventKey = NPS_EVENT_KEY;        } else if (widgetInfo.type == FeedbackWidgetType.survey) {            usedEventKey = SURVEY_EVENT_KEY;        } else if (widgetInfo.type == FeedbackWidgetType.rating) {            usedEventKey = RATING_EVENT_KEY;        } else {            usedEventKey = "";        }        Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", cachedAppVersion);        segm.put("widget_id", widgetInfo.widgetId);        if (widgetResult == null) {            segm.put("closed", "1");        } else {            segm.putAll(widgetResult);        }        eventProvider.recordEventInternal(usedEventKey, segm, 1, 0, 0, null, null);    }    private void presentFeedbackWidgetNameIDorTag(@NonNull Context context, @NonNull FeedbackWidgetType type, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {        getAvailableFeedbackWidgetsInternal(new RetrieveFeedbackWidgets() {            @Override public void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error) {                if (error != null) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, Failed to retrieve feedback widget list, [" + error + "]");                    return;                }                if (retrievedWidgets.isEmpty()) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widgets available");                    return;                }                CountlyFeedbackWidget selectedWidget = null;                for (CountlyFeedbackWidget widget : retrievedWidgets) {                    if (widget.type == type) {                        if (!nameIDorTag.isEmpty()) {                            if (widget.widgetId.equals(nameIDorTag) || widget.name.equals(nameIDorTag)) {                                selectedWidget = widget;                                break;                            }                            for (String tag : widget.tags) {                                if (tag.equals(nameIDorTag)) {                                    selectedWidget = widget;                                    break;                                }                            }                        } else {                            selectedWidget = widget;                            break;                        }                    }                }                if (selectedWidget == null) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widget found with the provided nameIDorTag or type");                    return;                }                presentFeedbackWidgetInternal(selectedWidget, context, null, devCallback);            }        });    }    @Override    void initFinished(@NonNull CountlyConfig config) {    }    @Override    void halt() {        feedbackInterface = null;    }    public class Feedback {        public void getAvailableFeedbackWidgets(@Nullable RetrieveFeedbackWidgets callback) {            synchronized (_cly) {                L.i("[Feedback] Trying to retrieve feedback widget list");                getAvailableFeedbackWidgetsInternal(callback);            }        }        public void presentFeedbackWidget(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable Context context, @Nullable String closeButtonText, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] Trying to present feedback widget in an alert dialog");                presentFeedbackWidgetInternal(widgetInfo, context, closeButtonText, devCallback);            }        }        public void getFeedbackWidgetData(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable RetrieveFeedbackWidgetData callback) {            synchronized (_cly) {                L.i("[Feedback] Trying to retrieve feedback widget data");                getFeedbackWidgetDataInternal(widgetInfo, callback);            }        }        public void reportFeedbackWidgetManually(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {            synchronized (_cly) {                L.i("[Feedback] Trying to report feedback widget manually");                reportFeedbackWidgetManuallyInternal(widgetInfo, widgetData, widgetResult);            }        }        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag) {            presentNPS(context, nameIDorTag, null);        }        public void presentNPS(@NonNull Context context) {            presentNPS(context, "");        }        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag) {            presentSurvey(context, nameIDorTag, null);        }        public void presentSurvey(@NonNull Context context) {            presentSurvey(context, "");        }        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag) {            presentRating(context, nameIDorTag, null);        }        public void presentRating(@NonNull Context context) {            presentRating(context, "");        }        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentNPS, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.nps, nameIDorTag, devCallback);            }        }        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentSurvey, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.survey, nameIDorTag, devCallback);            }        }        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentRating, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.rating, nameIDorTag, devCallback);            }        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.json.JSONException;import org.json.JSONObject;public class ModuleUserProfile extends ModuleBase {    static final String NAME_KEY = "name";    static final String USERNAME_KEY = "username";    static final String EMAIL_KEY = "email";    static final String ORG_KEY = "organization";    static final String PHONE_KEY = "phone";    static final String PICTURE_KEY = "picture";    static final String PICTURE_PATH_KEY = "picturePath";    static final String GENDER_KEY = "gender";    static final String BYEAR_KEY = "byear";    static final String CUSTOM_KEY = "custom";    String[] namedFields = { NAME_KEY, USERNAME_KEY, EMAIL_KEY, ORG_KEY, PHONE_KEY, PICTURE_KEY, PICTURE_PATH_KEY, GENDER_KEY, BYEAR_KEY };    boolean isSynced = true;    UserProfile userProfileInterface;    String name;    String username;    String email;    String org;    String phone;    String picture;    static String picturePath;    String gender;    Map<String, Object> custom;    Map<String, JSONObject> customMods;    int byear = 0;    ModuleUserProfile(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleUserProfile] Initialising");        userProfileInterface = new UserProfile();    }    String getDataForRequest() {        if (!isSynced) {            isSynced = true;            final JSONObject json = toJSON();            if (json != null) {                String result = json.toString();                try {                    result = java.net.URLEncoder.encode(result, "UTF-8");                    if (result != null && !result.equals("")) {                        result = "&user_details=" + result;                        if (picturePath != null) {                            result += "&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");                        }                    } else {                        result = "";                        if (picturePath != null) {                            result += "&user_details&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");                        }                    }                } catch (UnsupportedEncodingException ignored) {                }                if (result != null) {                    return result;                }            }        }        return "";    }    protected JSONObject toJSON() {        final JSONObject json = new JSONObject();        try {            if (name != null) {                if (name.equals("")) {                    json.put(NAME_KEY, JSONObject.NULL);                } else {                    json.put(NAME_KEY, name);                }            }            if (username != null) {                if (username.equals("")) {                    json.put(USERNAME_KEY, JSONObject.NULL);                } else {                    json.put(USERNAME_KEY, username);                }            }            if (email != null) {                if (email.equals("")) {                    json.put(EMAIL_KEY, JSONObject.NULL);                } else {                    json.put(EMAIL_KEY, email);                }            }            if (org != null) {                if (org.equals("")) {                    json.put(ORG_KEY, JSONObject.NULL);                } else {                    json.put(ORG_KEY, org);                }            }            if (phone != null) {                if (phone.equals("")) {                    json.put(PHONE_KEY, JSONObject.NULL);                } else {                    json.put(PHONE_KEY, phone);                }            }            if (picture != null) {                if (picture.equals("")) {                    json.put(PICTURE_KEY, JSONObject.NULL);                } else {                    json.put(PICTURE_KEY, picture);                }            }            if (gender != null) {                if (gender.equals("")) {                    json.put(GENDER_KEY, JSONObject.NULL);                } else {                    json.put(GENDER_KEY, gender);                }            }            if (byear != 0) {                if (byear > 0) {                    json.put(BYEAR_KEY, byear);                } else {                    json.put(BYEAR_KEY, JSONObject.NULL);                }            }            JSONObject ob;            if (custom != null) {                UtilsInternalLimits.truncateSegmentationValues(custom, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleUserProfile] toJSON", _cly.L);                ob = new JSONObject(custom);            } else {                ob = new JSONObject();            }            if (customMods != null) {                for (Map.Entry<String, JSONObject> entry : customMods.entrySet()) {                    ob.put(entry.getKey(), entry.getValue());                }            }            json.put(CUSTOM_KEY, ob);        } catch (JSONException e) {            L.w("[UserData] Got exception converting an UserData to JSON", e);        }        return json;    }    void fromJSON(final JSONObject json) {        if (json != null) {            name = json.optString(NAME_KEY, null);            username = json.optString(USERNAME_KEY, null);            email = json.optString(EMAIL_KEY, null);            org = json.optString(ORG_KEY, null);            phone = json.optString(PHONE_KEY, null);            picture = json.optString(PICTURE_KEY, null);            gender = json.optString(GENDER_KEY, null);            byear = json.optInt(BYEAR_KEY, 0);            if (!json.isNull(CUSTOM_KEY)) {                JSONObject customJson;                try {                    customJson = json.getJSONObject(CUSTOM_KEY);                    if (customJson.length() == 0) {                        custom = null;                    } else {                        custom = new HashMap<>(customJson.length());                        Iterator<String> nameItr = customJson.keys();                        while (nameItr.hasNext()) {                            final String key = nameItr.next();                            if (!customJson.isNull(key)) {                                custom.put(key, customJson.getString(key));                            }                        }                    }                } catch (JSONException e) {                    L.w("[ModuleUserProfile] Got exception converting an Custom Json to Custom User data", e);                }            }        }    }    void modifyCustomData(String key, Object value, String mod) {        try {            if (!(value instanceof Double || value instanceof Integer || value instanceof String)) {                L.w("[ModuleUserProfile] modifyCustomDataCommon, provided an unsupported type for 'value'");                return;            }            Object valueAdded;            String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] modifyCustomData");            if (value instanceof String) {                valueAdded = UtilsInternalLimits.truncateValueSize((String) value, _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] modifyCustomData");            } else if (UtilsInternalLimits.isSupportedDataType(value)) {                valueAdded = value;            } else {                L.w("[ModuleUserProfile] modifyCustomData, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], mod: [" + mod + "], omitting call");                return;            }            if (customMods == null) {                customMods = new HashMap<>();            }            JSONObject ob;            if (!mod.equals("$pull") && !mod.equals("$push") && !mod.equals("$addToSet")) {                ob = new JSONObject();                ob.put(mod, valueAdded);            } else {                if (customMods.containsKey(truncatedKey)) {                    ob = customMods.get(truncatedKey);                } else {                    ob = new JSONObject();                }                ob.accumulate(mod, valueAdded);            }            customMods.put(truncatedKey, ob);            isSynced = false;        } catch (JSONException e) {            e.printStackTrace();        }    }    void setPropertiesInternal(@NonNull Map<String, Object> data) {        if (data.isEmpty()) {            L.w("[ModuleUserProfile] setPropertiesInternal, no data was provided");            return;        }        Map<String, String> dataNamedFields = new HashMap<>();        Map<String, Object> dataCustomFields = new HashMap<>();        for (Map.Entry<String, Object> entry : data.entrySet()) {            String key = entry.getKey();            Object value = entry.getValue();            if (value == null) {                L.w("[ModuleUserProfile] setPropertiesInternal, provided value for key [" + key + "] is 'null'");                continue;            }            boolean isNamed = false;            if (value instanceof String) {                if (key.equals(PICTURE_PATH_KEY) || key.equals(PICTURE_KEY)) {                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSizePicture, _cly.L, "[ModuleUserProfile] setPropertiesInternal");                } else {                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] setPropertiesInternal");                }            }            for (String namedField : namedFields) {                if (namedField.equals(key)) {                    isNamed = true;                    dataNamedFields.put(key, value.toString());                    break;                }            }            if (!isNamed) {                String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] setPropertiesInternal");                if (UtilsInternalLimits.isSupportedDataType(value)) {                    dataCustomFields.put(truncatedKey, value);                } else {                    L.w("[ModuleUserProfile] setPropertiesInternal, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], omitting call");                }            }        }        setData(dataNamedFields);        if (custom == null) {            custom = new HashMap<>();        }        custom.putAll(dataCustomFields);        isSynced = false;    }    public void setData(Map<String, String> data) {        if (data.containsKey(ModuleUserProfile.NAME_KEY)) {            name = data.get(ModuleUserProfile.NAME_KEY);        }        if (data.containsKey(ModuleUserProfile.USERNAME_KEY)) {            username = data.get(ModuleUserProfile.USERNAME_KEY);        }        if (data.containsKey(ModuleUserProfile.EMAIL_KEY)) {            email = data.get(ModuleUserProfile.EMAIL_KEY);        }        if (data.containsKey(ModuleUserProfile.ORG_KEY)) {            org = data.get(ModuleUserProfile.ORG_KEY);        }        if (data.containsKey(ModuleUserProfile.PHONE_KEY)) {            phone = data.get(ModuleUserProfile.PHONE_KEY);        }        if (data.containsKey(ModuleUserProfile.PICTURE_PATH_KEY)) {            picturePath = data.get(ModuleUserProfile.PICTURE_PATH_KEY);        }        if (picturePath != null) {            File sourceFile = new File(picturePath);            if (!sourceFile.isFile()) {                L.w("[UserData] Provided Picture path file [" + picturePath + "] can not be opened");                picturePath = null;            }        }        if (data.containsKey(ModuleUserProfile.PICTURE_KEY)) {            picture = data.get(ModuleUserProfile.PICTURE_KEY);        }        if (data.containsKey(ModuleUserProfile.GENDER_KEY)) {            gender = data.get(ModuleUserProfile.GENDER_KEY);        }        if (data.containsKey(ModuleUserProfile.BYEAR_KEY)) {            try {                byear = Integer.parseInt(data.get(ModuleUserProfile.BYEAR_KEY));            } catch (NumberFormatException e) {                L.w("[UserData] Incorrect byear number format");                byear = 0;            }        }    }    void saveInternal() {        L.d("[ModuleUserProfile] saveInternal");        String cachedUserData = getDataForRequest();        if (cachedUserData.isEmpty()) {            L.d("[ModuleUserProfile] saveInternal, no user data to save");            return;        }        _cly.moduleRequestQueue.sendEventsIfNeeded(true);        requestQueueProvider.sendUserData(cachedUserData);        clearInternal();    }    void clearInternal() {        L.d("[ModuleUserProfile] clearInternal");        name = null;        username = null;        email = null;        org = null;        phone = null;        picture = null;        picturePath = null;        gender = null;        custom = null;        customMods = null;        byear = 0;        isSynced = true;    }    @Override    void initFinished(@NonNull final CountlyConfig config) {        if (config.providedUserProperties != null) {            L.i("[ModuleUserProfile] Custom user properties were provided during init [" + config.providedUserProperties.size() + "]");            setPropertiesInternal(config.providedUserProperties);            saveInternal();        }    }    @Override    void halt() {        userProfileInterface = null;    }    public class UserProfile {        public void increment(String key) {            synchronized (_cly) {                modifyCustomData(key, 1, "$inc");            }        }        public void incrementBy(String key, int value) {            synchronized (_cly) {                modifyCustomData(key, value, "$inc");            }        }        public void multiply(String key, int value) {            synchronized (_cly) {                modifyCustomData(key, value, "$mul");            }        }        public void saveMax(String key, int value) {            synchronized (_cly) {                modifyCustomData(key, value, "$max");            }        }        public void saveMin(String key, int value) {            synchronized (_cly) {                modifyCustomData(key, value, "$min");            }        }        public void setOnce(String key, String value) {            synchronized (_cly) {                modifyCustomData(key, value, "$setOnce");            }        }        public void push(String key, String value) {            synchronized (_cly) {                modifyCustomData(key, value, "$push");            }        }        public void pushUnique(String key, String value) {            synchronized (_cly) {                modifyCustomData(key, value, "$addToSet");            }        }        public void pull(String key, String value) {            synchronized (_cly) {                modifyCustomData(key, value, "$pull");            }        }        public void setProperty(String key, Object value) {            synchronized (_cly) {                L.i("[UserProfile] Calling 'setProperty'");                Map<String, Object> data = new HashMap<>();                data.put(key, value);                setPropertiesInternal(data);            }        }        public void setProperties(Map<String, Object> data) {            synchronized (_cly) {                L.i("[UserProfile] Calling 'setProperties'");                if (data == null) {                    L.i("[UserProfile] Provided data can not be 'null'");                    return;                }                setPropertiesInternal(data);            }        }        public void save() {            synchronized (_cly) {                L.i("[UserProfile] Calling 'save'");                saveInternal();            }        }        public void clear() {            synchronized (_cly) {                L.i("[UserProfile] Calling 'clear'");                clearInternal();            }        }    }}package ly.count.android.sdk;import androidx.test.ext.junit.runners.AndroidJUnit4;import java.util.Map;import org.json.JSONException;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mockito;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.verifyZeroInteractions;@RunWith(AndroidJUnit4.class)public class ModuleConsentTests {    protected static final String[] usedFeatureNames = {        Countly.CountlyFeatureNames.sessions,        Countly.CountlyFeatureNames.events,        Countly.CountlyFeatureNames.views,        Countly.CountlyFeatureNames.location,        Countly.CountlyFeatureNames.crashes,        Countly.CountlyFeatureNames.attribution,        Countly.CountlyFeatureNames.users,        Countly.CountlyFeatureNames.push,        Countly.CountlyFeatureNames.starRating,        Countly.CountlyFeatureNames.remoteConfig,        Countly.CountlyFeatureNames.apm,        Countly.CountlyFeatureNames.feedback,        Countly.CountlyFeatureNames.clicks,        Countly.CountlyFeatureNames.scrolls,        Countly.CountlyFeatureNames.content,    };    @Before    public void setUp() {    }    @After    public void tearDown() {    }    Countly helperCreateAndInitCountly() {        return null;    }    @Test    public void usingValidFeatureList() {        Assert.assertEquals(usedFeatureNames.length, ModuleConsent.validFeatureNames.length);        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertEquals(usedFeatureNames[a], ModuleConsent.validFeatureNames[a]);        }    }    @Test    public void enableConsentWithoutConsentGiven() {        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[a]));        }    }    @Test    public void enableConsentGiveAll() {        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, usedFeatureNames, null));        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));        }    }    @Test    public void enableConsentRemoveAfter() {        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, usedFeatureNames, null));        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));        }        mCountly.consent().removeConsentAll();        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[a]));        }        mCountly.consent().giveConsentAll();        for (int a = 0; a < usedFeatureNames.length; a++) {            Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[a]));        }    }    @Test    public void checkIfConsentProviderSet() {        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));        for (ModuleBase module : mCountly.modules) {            Assert.assertEquals(mCountly.moduleConsent, module.consentProvider);        }        Assert.assertEquals(mCountly.moduleConsent, mCountly.connectionQueue_.consentProvider);        Assert.assertEquals(mCountly.moduleConsent, mCountly.config_.consentProvider);    }    @Test    public void checkSettingConsentAfterInit() {        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null));        Assert.assertFalse(mCountly.moduleConsent.consentProvider.anyConsentGiven());        for (int a = 0; a < usedFeatureNames.length; a++) {            mCountly.consent().giveConsent(new String[] { usedFeatureNames[a] });            for (int b = 0; b < usedFeatureNames.length; b++) {                if (b <= a) {                    Assert.assertTrue(mCountly.consent().getConsent(usedFeatureNames[b]));                } else {                    Assert.assertFalse(mCountly.consent().getConsent(usedFeatureNames[b]));                }            }        }        Assert.assertTrue(mCountly.moduleConsent.consentProvider.anyConsentGiven());    }    @Test    public void validateFeatureNames() {        Assert.assertEquals("sessions", Countly.CountlyFeatureNames.sessions);        Assert.assertEquals("events", Countly.CountlyFeatureNames.events);        Assert.assertEquals("views", Countly.CountlyFeatureNames.views);        Assert.assertEquals("location", Countly.CountlyFeatureNames.location);        Assert.assertEquals("crashes", Countly.CountlyFeatureNames.crashes);        Assert.assertEquals("attribution", Countly.CountlyFeatureNames.attribution);        Assert.assertEquals("users", Countly.CountlyFeatureNames.users);        Assert.assertEquals("push", Countly.CountlyFeatureNames.push);        Assert.assertEquals("star-rating", Countly.CountlyFeatureNames.starRating);        Assert.assertEquals("apm", Countly.CountlyFeatureNames.apm);        Assert.assertEquals("feedback", Countly.CountlyFeatureNames.feedback);        Assert.assertEquals("remote-config", Countly.CountlyFeatureNames.remoteConfig);        Assert.assertEquals("scrolls", Countly.CountlyFeatureNames.scrolls);        Assert.assertEquals("clicks", Countly.CountlyFeatureNames.clicks);    }    @Test    public void initTimeNoConsentRequiredRQ() {        RequestQueueProvider rqp = mock(RequestQueueProvider.class);        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(false, null, null, rqp));        verifyZeroInteractions(rqp);    }    @Test    public void initTimeNoConsentGivenRQ() throws JSONException {        RequestQueueProvider rqp = mock(RequestQueueProvider.class);        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, null, null, rqp));        Assert.assertEquals(2, Mockito.mockingDetails(rqp).getInvocations().size());        TestUtils.verifyLocationValuesInRQMock(1, true, null, null, null, null, rqp);        TestUtils.verifyConsentValuesInRQMock(1, new String[] {}, usedFeatureNames, rqp);    }    @Test    public void initTimeSetConsentRQ_2() throws JSONException {        RequestQueueProvider rqp = mock(RequestQueueProvider.class);        String[] initialConsent = { Countly.CountlyFeatureNames.clicks, Countly.CountlyFeatureNames.push, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback };        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp));        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);        TestUtils.verifyLocationValuesInRQMockDisabled(rqp);    }    @Test    public void initTimeSetConsentRQ_3() throws JSONException {        RequestQueueProvider rqp = mock(RequestQueueProvider.class);        String[] initialConsent = { Countly.CountlyFeatureNames.clicks, Countly.CountlyFeatureNames.push, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback, Countly.CountlyFeatureNames.location };        Countly mCountly = new Countly().init(TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp));        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);        TestUtils.verifyLocationValuesInRQMockNotGiven(rqp);    }    @Test    public void initTimeSetConsentRQ_4() throws JSONException {        RequestQueueProvider rqp = mock(RequestQueueProvider.class);        String[] initialConsent = { Countly.CountlyFeatureNames.attribution, Countly.CountlyFeatureNames.starRating, Countly.CountlyFeatureNames.users, Countly.CountlyFeatureNames.feedback, Countly.CountlyFeatureNames.location };        CountlyConfig cc = TestUtils.createConsentCountlyConfig(true, initialConsent, null, rqp);        cc.setLocation("qw", "Bston ", "123.9009", "qwe890");        Countly mCountly = new Countly().init(cc);        TestUtils.verifyConsentValuesInRQMock(1, initialConsent, TestUtils.getReminderConsent(initialConsent), rqp);        TestUtils.verifyLocationValuesInRQMockValues(cc.locationCountyCode, cc.locationCity, cc.locationLocation, cc.locationIpAddress, rqp);    }    protected static void validateConsentRequest(String deviceId, int idx, boolean[] consents) {        Map<String, Object> consentsMap =            TestUtils.map("sessions", consents[0], "crashes", consents[1], "users", consents[2], "push", consents[3], "feedback", consents[4], "scrolls", consents[5], "remote-config", consents[6], "attribution", consents[7], "clicks", consents[8], "location", consents[9], "star-rating",                consents[10], "events", consents[11], "views", consents[12], "apm", consents[13], "content", consents[14]);        TestUtils.validateRequest(deviceId, TestUtils.map("consent", consentsMap), idx);    }    protected static void validateAllConsentRequest(String deviceId, int idx) {        validateConsentRequest(deviceId, idx, new boolean[] { true, true, true, true, true, true, true, true, true, true, true, true, true, true, true });    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.Map;import org.json.JSONException;import org.json.JSONObject;public class ModuleAttribution extends ModuleBase {    Attribution attributionInterface;    ModuleAttribution(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleAttribution] Initialising");        attributionInterface = new ModuleAttribution.Attribution();    }    void recordDirectAttributionInternal(@Nullable String campaignType, @Nullable String campaignData) {        L.d("[ModuleAttribution] recordDirectAttributionInternal, campaign id:[" + campaignType + "], user id:[" + campaignData + "]");        if (campaignType == null || campaignType.isEmpty()) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, provided campaign type value is not valid. Execution will be aborted.");            return;        }        if (campaignData == null || campaignData.isEmpty()) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, provided campaign data value is not valid. Execution will be aborted.");            return;        }        if (!campaignType.equals("countly") && !campaignType.equals("_special_test")) {            L.w("[ModuleAttribution] recordDirectAttributionInternal, recording direct attribution with a type other than 'countly' is currently not supported. Execution will be aborted.");            return;        }        if (campaignType.equals("_special_test")) {            reportSpecialTestAttribution(campaignData);        }        if (campaignType.equals("countly")) {            reportLegacyInstallAttribution(campaignData);        }    }    void reportLegacyInstallAttribution(@NonNull String campaignData) {        JSONObject jObj;        try {            jObj = new JSONObject(campaignData);        } catch (JSONException e) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, recording direct attribution data is not in the correct format. Execution will be aborted.");            return;        }        if (!jObj.has("cid")) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, direct attribution can't be recorded because the data does not contain the 'cid' value. Execution will be aborted.");            return;        }        String campaignId = null;        try {            campaignId = jObj.getString("cid");            if (campaignId.isEmpty()) {                L.e("[ModuleAttribution] recordDirectAttributionInternal, 'cid' value can't be empty string. Execution will be aborted.");                return;            }        } catch (JSONException e) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, encountered issue while accessing 'cid'. Execution will be aborted.");            return;        }        String campaignUserId = null;        try {            if (jObj.has("cuid")) {                campaignUserId = jObj.getString("cuid");                if (campaignUserId.isEmpty()) {                    L.w("[ModuleAttribution] recordDirectAttributionInternal, 'cuid' value can't be empty string. value will be ignored.");                    campaignUserId = null;                }            }        } catch (JSONException e) {            L.e("[ModuleAttribution] recordDirectAttributionInternal, encountered issue while accessing 'cuid'. Execution will be aborted.");            return;        }        requestQueueProvider.sendDirectAttributionLegacy(campaignId, campaignUserId);    }    void reportSpecialTestAttribution(@NonNull String attributionData) {        requestQueueProvider.sendDirectAttributionTest(attributionData);    }    void recordIndirectAttributionInternal(@Nullable Map<String, String> attributionId) {        L.d("[ModuleAttribution] recordIndirectAttributionInternal, attribution id:[" + attributionId + "]");        if (attributionId == null || attributionId.isEmpty()) {            L.e("[ModuleAttribution] recordIndirectAttributionInternal, provided id values are not valid. Execution will be aborted.");            return;        }        JSONObject jObj = new JSONObject();        for (Map.Entry<String, String> entry : attributionId.entrySet()) {            String key = entry.getKey();            String value = entry.getValue();            if (key == null || key.isEmpty()) {                L.e("[ModuleAttribution] recordIndirectAttributionInternal, provided key is not valid [" + key + "].");                continue;            }            if (value == null || value.isEmpty()) {                L.e("[ModuleAttribution] recordIndirectAttributionInternal, for the key[" + key + "] the provided value is not valid [" + value + "].");                continue;            }            try {                jObj.putOpt(key, value);            } catch (JSONException e) {                L.e("[ModuleAttribution] recordIndirectAttributionInternal, an issue happened while trying to add a value: " + e.toString());            }        }        if (jObj.length() == 0) {            L.e("[ModuleAttribution] recordIndirectAttributionInternal, no valid attribution values were provided");            return;        }        String attributionObj = jObj.toString();        requestQueueProvider.sendIndirectAttribution(attributionObj);    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (config.iaAttributionValues != null) {            if (config.iaAttributionValues.isEmpty()) {                L.e("[ModuleAttribution] provided attribution ID for indirect attribution is empty string.");            } else {                recordIndirectAttributionInternal(config.iaAttributionValues);            }        }        if (config.daCampaignData != null || config.daCampaignType != null) {            if (config.daCampaignType == null || config.daCampaignType.isEmpty()) {                L.e("[ModuleAttribution] Can't record direct attribution can't be recorded with an invalid campaign id.");            } else {                if (config.daCampaignData != null && config.daCampaignData.isEmpty()) {                    L.e("[ModuleAttribution] For direct attribution the provided Campaign user ID can't be empty string.");                }                recordDirectAttributionInternal(config.daCampaignType, config.daCampaignData);            }        }    }    @Override    public void halt() {        attributionInterface = null;    }    public class Attribution {        public void recordDirectAttribution(String campaignType, String campaignData) {            synchronized (_cly) {                L.i("[Attribution] calling 'recordCampaign'");                recordDirectAttributionInternal(campaignType, campaignData);            }        }        public void recordIndirectAttribution(Map<String, String> attributionValues) {            synchronized (_cly) {                L.i("[Attribution] calling 'recordIndirectAttribution'");                recordIndirectAttributionInternal(attributionValues);            }        }    }}package ly.count.android.sdk;import android.annotation.SuppressLint;import android.content.Context;import android.content.SharedPreferences;import android.provider.Settings;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.UUID;public class ModuleDeviceId extends ModuleBase implements OpenUDIDProvider, DeviceIdProvider {    boolean exitTempIdAfterInit = false;    boolean cleanupTempIdAfterInit = false;    ly.count.android.sdk.DeviceId deviceIdInstance;    DeviceId deviceIdInterface;    ModuleDeviceId(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleDeviceId] Initialising");        boolean customIDWasProvided = config.deviceID != null;        if (config.temporaryDeviceIdEnabled && !customIDWasProvided) {            config.deviceID = ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId;        }        deviceIdInstance = new ly.count.android.sdk.DeviceId(config.deviceID, config.storageProvider, L, this);        config.deviceIdProvider = this;        boolean temporaryDeviceIdIsCurrentlyEnabled = deviceIdInstance.isTemporaryIdModeEnabled();        L.d("[ModuleDeviceId] [TemporaryDeviceId] Temp ID should be enabled[" + config.temporaryDeviceIdEnabled + "] Currently enabled: [" + temporaryDeviceIdIsCurrentlyEnabled + "]");        if (temporaryDeviceIdIsCurrentlyEnabled && customIDWasProvided) {            L.d("[ModuleDeviceId] [TemporaryDeviceId] Decided we have to exit temporary device ID mode, mode enabled: [" + config.temporaryDeviceIdEnabled + "], custom Device ID Set: [" + customIDWasProvided + "]");            exitTempIdAfterInit = true;        } else {            if (!temporaryDeviceIdIsCurrentlyEnabled) {                cleanupTempIdAfterInit = true;            }        }        deviceIdInterface = new DeviceId();    }    void replaceTempIDWithRealIDinRQ(@NonNull String targetDeviceId) {        String[] storedRequests = storageProvider.getRequests();        String temporaryIdTag = "&device_id=" + ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId;        String newIdTag = "&device_id=" + targetDeviceId;        boolean foundOne = false;        for (int a = 0; a < storedRequests.length; a++) {            if (storedRequests[a].contains(temporaryIdTag)) {                L.d("[ModuleDeviceId] [exitTemporaryIdMode] Found a tag to replace in: [" + storedRequests[a] + "]");                storedRequests[a] = storedRequests[a].replace(temporaryIdTag, newIdTag);                foundOne = true;            }        }        if (foundOne) {            storageProvider.replaceRequests(storedRequests);        }    }    void exitTemporaryIdMode(@NonNull String deviceId) {        L.d("[ModuleDeviceId] Calling exitTemporaryIdMode");        if (!_cly.isInitialized()) {            throw new IllegalStateException("init must be called before exitTemporaryIdMode");        }        deviceIdInstance.changeToCustomId(deviceId);        _cly.moduleConfiguration.fetchConfigFromServer();        replaceTempIDWithRealIDinRQ(deviceId);        _cly.moduleRemoteConfig.RCAutomaticDownloadTrigger(false);        _cly.requestQueue().attemptToSendStoredRequests();        _cly.moduleHealthCheck.sendHealthCheck();    }    void changeDeviceIdWithoutMergeInternal(@NonNull String deviceId) {        if (isTemporaryIdEnabled() && deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {            return;        }        if (deviceIdInstance.getCurrentId().equals(deviceId)) {            L.w("[ModuleDeviceId] changeDeviceIdWithoutMergeInternal, We are attempting to change the device ID to the same ID, request will be ignored");            return;        }        if (isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {            exitTemporaryIdMode(deviceId);            return;        }        _cly.moduleRequestQueue.sendEventsIfNeeded(true);        _cly.moduleUserProfile.saveInternal();        _cly.moduleRemoteConfig.clearAndDownloadAfterIdChange();        if (!_cly.moduleSessions.manualSessionControlEnabled) {            _cly.moduleSessions.endSessionInternal();         }        _cly.moduleConsent.removeConsentAllInternal(ModuleConsent.ConsentChangeSource.DeviceIDChangedNotMerged);        if (deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {            deviceIdInstance.enterTempIDMode();        } else {            deviceIdInstance.changeToCustomId(deviceId);        }        _cly.moduleRatings.clearAutomaticStarRatingSessionCountInternal();        _cly.notifyDeviceIdChange(true);    }    void changeDeviceIdWithMergeInternal(@NonNull String deviceId) {        if (deviceId.isEmpty()) {            L.e("changeDeviceIdWithMergeInternal, provided device ID can't be empty string");            return;        }        if (deviceIdInstance.getCurrentId().equals(deviceId)) {            L.w("[ModuleDeviceId] changeDeviceIdWithMergeInternal, We are attempting to change the device ID to the same ID, request will be ignored");            return;        }        if (isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {            if (deviceId.equals(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId)) {                L.w("[ModuleDeviceId, changeDeviceId] About to enter temporary ID mode when already in it");                return;            }            exitTemporaryIdMode(deviceId);        } else {            _cly.moduleRemoteConfig.clearAndDownloadAfterIdChange();            requestQueueProvider.changeDeviceId(deviceId, deviceIdInstance.getCurrentId());            deviceIdInstance.changeToCustomId(deviceId);            _cly.notifyDeviceIdChange(false);        }    }    private void setIDInternal(String newDeviceID) {        if (Utils.isNullOrEmpty(newDeviceID)) {            L.w("[ModuleDeviceId] setID, Empty id passed to setID method");            return;        }        if (deviceIdInstance.getCurrentId() != null && deviceIdInstance.getCurrentId().equals(newDeviceID)) {            L.w("[ModuleDeviceId] setID, Same id passed to setID method, ignoring");            return;        }        DeviceIdType currentType = deviceIdInstance.getType();        if (currentType.equals(DeviceIdType.DEVELOPER_SUPPLIED)) {            changeDeviceIdWithoutMergeInternal(newDeviceID);        } else {            changeDeviceIdWithMergeInternal(newDeviceID);        }    }    @Override    public void initFinished(@NonNull CountlyConfig config) {        if (exitTempIdAfterInit) {            L.i("[ModuleDeviceId, initFinished] Exiting temp ID at the end of init");            exitTemporaryIdMode(config.deviceID);        } else if (cleanupTempIdAfterInit) {            L.i("[ModuleDeviceId, initFinished] Cleaning up potentially left temp ID requests in queue");            String storedDevId = getDeviceId();            if (storedDevId != null && !storedDevId.isEmpty()) {                replaceTempIDWithRealIDinRQ(storedDevId);            } else {                L.w("[ModuleDeviceId, initFinished] Can't cleanup RQ, device ID is either null or empty [" + storedDevId + "]");            }        }    }    @Override    void halt() {    }    public final static String PREF_KEY = "openudid";    public final static String PREFS_NAME = "openudid_prefs";    @SuppressLint("HardwareIds")    @Override @NonNull public String getOpenUDID() {        String retrievedID;        SharedPreferences mPreferences = _cly.context_.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);        retrievedID = mPreferences.getString(PREF_KEY, null);        if (retrievedID == null)         {            Countly.sharedInstance().L.d("[OpenUDID] Generating openUDID");            retrievedID = Settings.Secure.getString(_cly.context_.getContentResolver(), Settings.Secure.ANDROID_ID);            if (retrievedID == null || retrievedID.equals("9774d56d682e549c") || retrievedID.length() < 15) {                retrievedID = UUID.randomUUID().toString();            }            final SharedPreferences.Editor e = mPreferences.edit();            e.putString(PREF_KEY, retrievedID);            e.apply();        }        Countly.sharedInstance().L.d("[OpenUDID] ID: " + retrievedID);        return retrievedID;    }    @Override public @Nullable String getDeviceId() {        return deviceIdInstance.getCurrentId();    }    @Override public boolean isTemporaryIdEnabled() {        return deviceIdInstance.isTemporaryIdModeEnabled();    }    @Override public @NonNull ly.count.android.sdk.DeviceId getDeviceIdInstance() {        return deviceIdInstance;    }    public class DeviceId {        public void changeWithoutMerge(@Nullable String deviceId) {            synchronized (_cly) {                L.d("[DeviceId] Calling 'changeDeviceIdWithoutMerge'");                if (deviceId == null) {                    L.e("[DeviceId] changeDeviceIdWithoutMerge, provided device ID value was 'null'. Request will be ignored");                    return;                }                changeDeviceIdWithoutMergeInternal(deviceId);            }        }        public void changeWithMerge(@Nullable String deviceId) {            synchronized (_cly) {                L.d("[DeviceId] Calling 'changeDeviceIdWithMerge'");                if (deviceId == null) {                    L.e("[DeviceId] changeDeviceIdWithMerge, provided device ID value was 'null'. Request will be ignored");                    return;                }                changeDeviceIdWithMergeInternal(deviceId);            }        }        public String getID() {            synchronized (_cly) {                L.d("[DeviceId] Calling 'getDeviceID'");                return getDeviceId();            }        }        public void setID(String newDeviceID) {            synchronized (_cly) {                L.d("[DeviceId] Calling 'setID'");                setIDInternal(newDeviceID);            }        }        public DeviceIdType getType() {            synchronized (_cly) {                L.d("[DeviceId] Calling 'getDeviceIDType'");                return deviceIdInstance.getType();            }        }        public void enableTemporaryIdMode() {            synchronized (_cly) {                L.i("[DeviceId] Calling 'enableTemporaryIdMode'");                changeDeviceIdWithoutMergeInternal(ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId);            }        }    }}package ly.count.android.sdk;import android.annotation.SuppressLint;import android.os.Build;import android.util.Log;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class PerformanceCounterCollector {    HashMap<String, Double> perfCounter = new HashMap<String, Double>();    public void Clear() {        perfCounter.clear();    }    public void TrackCounterTimeNs(String key, long valueNs) {        TrackCounter(key, valueNs / 1_000_000_000.0);    }    public void TrackCounter(String key, double value) {        assert Utils.isNotNullOrEmpty(key);        if (value < 0) {            Log.w("Countly", "Problem, we should only log positive values");        }        Double retrievedValue = perfCounter.get(key);        if (retrievedValue == null) {            retrievedValue = 0.0;        }        retrievedValue += value;        perfCounter.put(key, retrievedValue);    }    public String ReturnResults() {        List<String> entries = new ArrayList<>(perfCounter.size());        for (Map.Entry<String, Double> entry : perfCounter.entrySet()) {            String key = entry.getKey();            Double value = entry.getValue();            @SuppressLint("DefaultLocale")            String strValue = String.format("%.6f", value);            entries.add(key + " - " + strValue + "\n");        }        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {            entries.sort(String::compareTo);        }        StringBuilder res = new StringBuilder();        for (String s : entries) {            res.append(s);        }        return res.toString();    }}