package free.rm.skytube.businessobjects.db;
import android.content.Context;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.util.Pair;
import java.util.Collections;
import java.util.List;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.YouTube.POJOs.ChannelView;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.VideoBlocker;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.model.Status;
import free.rm.skytube.gui.businessobjects.views.ChannelSubscriber;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class DatabaseTasks {
    private static final String TAG = DatabaseTasks.class.getSimpleName();
    private DatabaseTasks() {}
    public static Maybe<PersistentChannel> getChannelInfo(@NonNull Context context,
                                                          @NonNull ChannelId channelId,
                                                          boolean staleAcceptable) {
        return Maybe.fromCallable(() -> getChannelOrRefresh(context, channelId, staleAcceptable))
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> {
                    Log.e(TAG, "Error: " + throwable.getMessage(), throwable);
                    final String msg = (throwable.getCause() != null ? throwable.getCause() : throwable).getMessage();
                    final String toastMsg = msg != null ?
                            context.getString(R.string.could_not_get_channel_detailed, msg) :
                            context.getString(R.string.could_not_get_channel);
                    Toast.makeText(context, toastMsg, Toast.LENGTH_LONG).show();
                })
                .subscribeOn(Schedulers.io());
    }
    public static PersistentChannel getChannelOrRefresh(Context context, ChannelId channelId, boolean staleAcceptable) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        final SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
        PersistentChannel persistentChannel = db.getCachedChannel(channelId);
        final boolean needsRefresh;
        if (persistentChannel == null || TextUtils.isEmpty(persistentChannel.channel().getTitle())) {
            needsRefresh = true;
        } else if (staleAcceptable) {
            needsRefresh = false;
        } else {
            needsRefresh = persistentChannel.channel().getLastCheckTime() < System.currentTimeMillis() - (24 * 60 * 60 * 1000L);
        }
        if (needsRefresh && SkyTubeApp.isConnected(context)) {
            try {
                return NewPipeService.get().getChannelDetails(channelId, persistentChannel);
            } catch (NewPipeException newPipeException) {
                if (persistentChannel != null && persistentChannel.status() != Status.OK) {
                    Log.e(TAG, "Channel is blocked/terminated - and kept that way: "+ persistentChannel+", message:"+newPipeException.getMessage());
                    return persistentChannel;
                }
                throw newPipeException;
            }
        }
        return persistentChannel;
    }
    public static Single<List<ChannelView>> getSubscribedChannelView(Context context, @Nullable View progressBar,
                                                                     @Nullable String searchText) {
        final boolean sortChannelsAlphabetically = SkyTubeApp.getPreferenceManager()
                .getBoolean(SkyTubeApp.getStr(R.string.pref_key_subscriptions_alphabetical_order), false);
        if (progressBar != null) {
            progressBar.setVisibility(View.VISIBLE);
        }
        return Single.fromCallable(() -> new VideoBlocker().filterChannels(SubscriptionsDb.getSubscriptionsDb()
                .getSubscribedChannelsByText(searchText, sortChannelsAlphabetically)))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(list -> {
                    if (progressBar != null) {
                        progressBar.setVisibility(View.INVISIBLE);
                    }
                }).onErrorReturn(error -> {
                    Log.e(TAG, "Error: " + error.getMessage(), error);
                    String msg = context.getString(R.string.could_not_get_channel_detailed, error.getMessage());
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
                    return Collections.emptyList();
                });
    }
    public static Disposable isVideoBookmarked(@NonNull String videoId, @NonNull Menu menu) {
        return BookmarksDb.getBookmarksDb().isVideoBookmarked(videoId)
                .subscribe(videoIsBookmarked -> {
                    menu.findItem(R.id.bookmark_video).setVisible(!videoIsBookmarked);
                    menu.findItem(R.id.unbookmark_video).setVisible(videoIsBookmarked);
                });
    }
    public static void updateDownloadedVideoMenu(@NonNull YouTubeVideo video, @NonNull Menu menu) {
        final MenuItem downloadVideo = menu.findItem(R.id.download_video);
        downloadVideo.setVisible(false);
        if (video != null) {
            DownloadedVideosDb.getVideoDownloadsDb().isVideoDownloaded(video.getVideoId()).subscribe(isDownloaded -> {
                SkyTubeApp.uiThread();
                if (!isDownloaded) {
                    downloadVideo.setVisible(true);
                }
            });
        }
    }
    public static Disposable isVideoWatched(@NonNull String videoId, @NonNull Menu menu) {
        return PlaybackStatusDb.getPlaybackStatusDb().getVideoWatchedStatusAsync(videoId)
                .subscribe(videoStatus -> {
                    boolean videoIsWatched = videoStatus != null && videoStatus.isFullyWatched();
                    menu.findItem(R.id.mark_watched).setVisible(!videoIsWatched);
                    menu.findItem(R.id.mark_unwatched).setVisible(videoIsWatched);
                });
    }
    public static Single<Pair<PersistentChannel, DatabaseResult>> subscribeToChannel(boolean subscribeToChannel,
                                                            @Nullable ChannelSubscriber subscribeButton,
                                                            @NonNull Context context,
                                                            @NonNull ChannelId channelId,
                                                            boolean displayToastMessage) {
        return Single.fromCallable(() -> {
            PersistentChannel channel = DatabaseTasks.getChannelOrRefresh(context, channelId, true);
            SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
            final DatabaseResult result;
            if (subscribeToChannel) {
                result = db.subscribe(channel, channel.channel().getYouTubeVideos());
            } else {
                result = db.unsubscribe(channel);
            }
            return Pair.create(channel, result);
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(databaseResultPair -> {
                    YouTubeChannel channel = databaseResultPair.first.channel();
                    if (databaseResultPair.second == DatabaseResult.SUCCESS) {
                        SkyTubeApp.getSettings().setRefreshSubsFeedFromCache(true);
                        if (subscribeToChannel) {
                            if (subscribeButton != null)
                                subscribeButton.setSubscribedState(true);
                            channel.setUserSubscribed(true);
                            EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.SUBSCRIPTION_LIST_CHANGED);
                            if (displayToastMessage) {
                                Toast.makeText(context, R.string.subscribed, Toast.LENGTH_LONG).show();
                            }
                        } else {
                            if (subscribeButton != null)
                                subscribeButton.setSubscribedState(false);
                            channel.setUserSubscribed(false);
                            EventBus.getInstance().notifyChannelRemoved(channel.getChannelId());
                            if (displayToastMessage) {
                                Toast.makeText(context, R.string.unsubscribed, Toast.LENGTH_LONG).show();
                            }
                        }
                    } else if (databaseResultPair.second == DatabaseResult.NOT_MODIFIED) {
                        if (subscribeToChannel) {
                            Toast.makeText(context, R.string.channel_already_subscribed, Toast.LENGTH_LONG).show();
                        }
                    } else {
                        String err = String.format(SkyTubeApp.getStr(R.string.error_unable_to_subscribe), channel.getId());
                        Toast.makeText(context, err, Toast.LENGTH_LONG).show();
                    }
                });
    }
    public static Completable completableUnsubscribeFromAllChannels() {
        return Completable.fromAction(() ->
                SubscriptionsDb.getSubscriptionsDb().unsubscribeFromAllChannels())
                .subscribeOn(Schedulers.io());
    }
}
package free.rm.skytube.businessobjects.YouTube.POJOs;
import java.util.Objects;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.model.Status;
public final class PersistentChannel {
    final YouTubeChannel channel;
    final long channelPk;
    final Long subscriptionPk;
    final Status status;
    public PersistentChannel(YouTubeChannel channel, long channelPk, Long subscriptionPk, Status status) {
        this.channel = Objects.requireNonNull(channel, "channel");
        this.channelPk = channelPk;
        this.subscriptionPk = subscriptionPk;
        this.status = status;
    }
    public YouTubeChannel channel() {
        return channel;
    }
    public Status status() {
        return status;
    }
    public ChannelId getChannelId() {
        return channel.getChannelId();
    }
    public long channelPk() {
        return channelPk;
    }
    public Long subscriptionPk() {
        return subscriptionPk;
    }
    public boolean isSubscribed() {
        return subscriptionPk != null;
    }
    public PersistentChannel with(YouTubeChannel newInstance) {
        newInstance.setUserSubscribed(isSubscribed());
        return new PersistentChannel(newInstance, channelPk, subscriptionPk, status);
    }
    public PersistentChannel withSubscriptionPk(Long newSubscriptionPk) {
        return new PersistentChannel(channel, channelPk, newSubscriptionPk, status);
    }
}
package free.rm.skytube.businessobjects.YouTube;
import com.google.api.client.util.DateTime;
import com.google.api.services.youtube.YouTube;
import com.google.api.services.youtube.model.SearchListResponse;
import com.google.api.services.youtube.model.SearchResult;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeAPI;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeAPIKey;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
public class GetChannelVideosFull extends GetYouTubeVideos {
	private ChannelId channelId;
	private boolean filterSubscribedVideos;
	private YouTube.Search.List videosList = null;
	private static final Long	MAX_RESULTS = 45L;
	@Override
	public void init() throws IOException {
		videosList = YouTubeAPI.create().search().list("id");
		videosList.setFields("items(id/videoId), nextPageToken");
		videosList.setKey(YouTubeAPIKey.get().getYouTubeAPIKey());
		videosList.setType("video");
		videosList.setSafeSearch("none");
		videosList.setMaxResults(MAX_RESULTS);
		videosList.setOrder("date");
		nextPageToken = null;
	}
	@Override
	public void resetKey() {
		videosList.setKey(YouTubeAPIKey.get().getYouTubeAPIKey());
	}
	@Override
	public List<CardData> getNextVideos() {
		setLastException(null);
		List<CardData> videosList = null;
		if (!noMoreVideoPages()) {
			try {
				this.videosList.setPageToken(nextPageToken);
				SearchListResponse searchResponse = this.videosList.execute();
				List<SearchResult> searchResultList = searchResponse.getItems();
				if (searchResultList != null) {
					videosList = getVideosList(searchResultList);
				}
				nextPageToken = searchResponse.getNextPageToken();
				if (nextPageToken == null)
					noMoreVideoPages = true;
			} catch (IOException ex) {
				setLastException(ex);
				Logger.e(this, "Error has occurred while getting Featured Videos:" + ex.getMessage(), ex);
			}
		}
		return videosList;
	}
	private List<CardData> getVideosList(List<SearchResult> searchResultList) throws IOException {
		List<String> videoIds = new ArrayList<>(searchResultList.size());
		for (SearchResult res : searchResultList) {
			videoIds.add(res.getId().getVideoId());
		}
		return getVideoListFromIds(videoIds);
	}
	public void setChannelQuery(ChannelId channelId, boolean filterSubscribedVideos) {
		this.channelId = channelId;
		this.filterSubscribedVideos = filterSubscribedVideos;
		if (videosList != null) {
			videosList.setChannelId(channelId.getRawId());
		}
	}
	@Override
	public void setQuery(String query) {
		setChannelQuery(new ChannelId(query), false);
	}
	public void setPublishedAfter(long timeInMs) {
		if (videosList != null) {
			videosList.setPublishedAfter(new DateTime(timeInMs));
		}
	}
	private List<CardData> getVideoListFromIds(List<String> videoIds) throws IOException {
		if (videoIds != null && !videoIds.isEmpty() && channelId != null && filterSubscribedVideos) {
			final Set<String> videosByChannel = SubscriptionsDb.getSubscriptionsDb().getSubscribedChannelVideosByChannel(channelId);
			videoIds.removeAll(videosByChannel);
		}
		return impGetVideoListFromIds(videoIds);
	}
	private List<CardData> impGetVideoListFromIds(List<String> videoIds) throws IOException {
		if (videoIds == null || videoIds.isEmpty()) {
			return Collections.emptyList();
		}
		return getVideoListFromIdsWithAPI(videoIds);
	}
	private List<CardData> getWithNewPipe(List<String> videoIds) {
		NewPipeService newPipe = NewPipeService.get();
		List<CardData> result = new ArrayList<>(videoIds.size());
		for (String id : videoIds) {
			try {
				result.add(newPipe.getDetails(id));
			} catch (ExtractionException | IOException e) {
				Logger.e(this, "Unable to fetch "+id+", error:"+ e.getMessage(), e);
			}
		}
		return result;
	}
	private List<CardData> getVideoListFromIdsWithAPI(List<String> videoIds) throws IOException {
		final StringBuilder videoIdsStr = new StringBuilder();
		try {
			for (String id : videoIds) {
				videoIdsStr.append(id);
				videoIdsStr.append(',');
			}
			if (videoIdsStr.length() > 0) {
				videoIdsStr.setLength(videoIdsStr.length() - 1);
			}
			GetVideosDetailsByIDs getVideo = new GetVideosDetailsByIDs();
			getVideo.init(videoIdsStr.toString());
			Logger.i(this, "getVideoList light from %s id, video ids: %s", videoIds.size(), videoIdsStr);
			List<CardData> cards = getVideo.getNextVideos();
			if (cards == null || cards.isEmpty()) {
				Logger.e(this, "Unable to fetch with API, use Newpipe,ids="+videoIdsStr);
				return getWithNewPipe(videoIds);
			}
			return cards;
		} catch (IOException e) {
			Logger.e(this, "Unable to fetch with API, revert to newpipe:"+e.getMessage()+",ids="+videoIdsStr, e);
			setLastException(e);
			return getWithNewPipe(videoIds);
		}
	}
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import java.util.Objects;
import free.rm.skytube.app.Utils;
public class ChannelId {
    private final String id;
    public ChannelId(String id) {
        this.id = Utils.removeChannelIdPrefix(Objects.requireNonNull(id, "rawId is null"));
    }
    public String getRawId() {
        return id;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ChannelId channelId = (ChannelId) o;
        return Objects.equals(id, channelId.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    @Override
    public String toString() {
        return "ChannelId{'" + id + '\'' + '}';
    }
    public String toURL() {
        return String.format("https:
    }
}
package free.rm.skytube.businessobjects.YouTube.POJOs;
import android.content.Context;
import android.widget.Toast;
import androidx.core.util.Pair;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.services.youtube.linkHandler.YoutubeChannelLinkHandlerFactory;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.Utils;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.VideoBlocker;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.ChannelFilteringDb;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class YouTubeChannel extends CardData implements Serializable {
	private String bannerUrl;
	private String totalSubscribers;
	private long subscriberCount;
	private boolean isUserSubscribed;
	private long	lastVisitTime;
	private long    lastCheckTime;
	private long    lastVideoTime;
	private Integer categoryId;
	private final List<YouTubeVideo> youTubeVideos = new ArrayList<>();
	private final List<String> tags;
	public YouTubeChannel() {
		tags = Collections.emptyList();
	}
	public YouTubeChannel(String id, String title) {
		this();
		this.id = id;
		this.title = title;
	}
	public YouTubeChannel(String id, String title, String description, String thumbnailUrl,
						  String bannerUrl, long subscriberCount, boolean isUserSubscribed, long lastVisitTime, long lastCheckTime,
						  Integer categoryId, List<String> tags) {
		this.id = id;
		this.title = title;
		this.description = description;
		this.thumbnailUrl = thumbnailUrl;
		this.bannerUrl = bannerUrl;
		this.subscriberCount = subscriberCount;
		this.totalSubscribers = getFormattedSubscribers(subscriberCount);
		this.isUserSubscribed = isUserSubscribed;
		this.lastVisitTime = lastVisitTime;
		this.lastCheckTime = lastCheckTime;
		this.categoryId = categoryId;
		this.tags = tags;
	}
	private static String getFormattedSubscribers(long subscriberCount) {
		return String.format(SkyTubeApp.getStr(R.string.total_subscribers),subscriberCount);
	}
	public ChannelId getChannelId() {
		return new ChannelId(id);
	}
	public String getBannerUrl() {
		return bannerUrl;
	}
	public String getTotalSubscribers() {
		return totalSubscribers;
	}
	public boolean isUserSubscribed() {
		return isUserSubscribed;
	}
	public long getSubscriberCount() {
		return subscriberCount;
	}
	public long getLastCheckTime() { return lastCheckTime; }
	public Integer getCategoryId() {
		return categoryId;
	}
	public void setCategoryId(Integer categoryId) {
		this.categoryId = categoryId;
	}
	public void setUserSubscribed(boolean userSubscribed) {
		isUserSubscribed = userSubscribed;
	}
    public Disposable updateLastVisitTime() {
        return SubscriptionsDb.getSubscriptionsDb().updateLastVisitTimeAsync(getChannelId()).subscribe(timestamp -> {
            lastVisitTime = timestamp;
            if (lastVisitTime < 0) {
                Logger.e(YouTubeChannel.this, "Unable to update channel's last visit time.  ChannelID=" + id);
            }
        });
    }
	public long getLastVisitTime() {
		return lastVisitTime;
	}
	public long getLastVideoTime() {
		return lastVideoTime;
	}
    public void setLastVideoTime(long lastVideoTime) {
        this.lastVideoTime = lastVideoTime;
    }
	public List<String> getTags() {
		return tags;
	}
	public void addYouTubeVideo(YouTubeVideo video) {
		if(!youTubeVideos.contains(video)) {
			youTubeVideos.add(video);
		}
	}
	public List<YouTubeVideo> getYouTubeVideos() {
		return youTubeVideos;
	}
	public Single<Boolean> blockChannel() {
		return blockChannel(true);
	}
	public Single<Boolean> blockChannel(boolean displayToastMessage) {
		return DatabaseTasks.subscribeToChannel(false,
						null, SkyTubeApp.getContext(), getChannelId(), false)
				.flatMap(result -> {
					if (SkyTubeApp.getSettings().isChannelDenyListEnabled()) {
						return dennyChannel(displayToastMessage);
					} else {
						return removeAllowedChannel(displayToastMessage);
					}
				})
				.observeOn(AndroidSchedulers.mainThread());
	}
	public Single<Boolean> unblockChannel() {
		return unblockChannel(true);
	}
    public Single<Boolean> unblockChannel(boolean displayToastMessage) {
        return (SkyTubeApp.getSettings().isChannelDenyListEnabled() ? removeDeniedChannel(displayToastMessage) : allowChannel(displayToastMessage)).observeOn(AndroidSchedulers.mainThread());
    }
	private Single<Boolean> dennyChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().denyChannel(id, title))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklisted : R.string.channel_blacklist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	private Single<Boolean> allowChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().allowChannel(id, title))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklisted : R.string.channel_blacklist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	private Single<Boolean> removeAllowedChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().removeAllowList(id))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_unwhitelist_success : R.string.channel_unwhitelist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	private Single<Boolean> removeDeniedChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().removeDenyList(id))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklist_updated : R.string.channel_blacklist_update_failure,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	public String getChannelUrl() {
		return getChannelId().toURL();
	}
}
package free.rm.skytube.app;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.ActivityNotFoundException;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Looper;
import android.os.StrictMode;
import android.os.SystemClock;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.ArrayRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationChannelCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.res.ResourcesCompat;
import androidx.core.graphics.ColorUtils;
import androidx.core.net.ConnectivityManagerCompat;
import androidx.multidex.MultiDexApplication;
import androidx.preference.PreferenceManager;
import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import org.ocpsoft.prettytime.PrettyTime;
import org.schabi.newpipe.extractor.exceptions.ReCaptchaException;
import java.io.IOException;
import java.net.SocketException;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.businessobjects.FeedUpdaterReceiver;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.gui.activities.MainActivity;
import free.rm.skytube.gui.businessobjects.YouTubePlayer;
import free.rm.skytube.gui.fragments.ChannelBrowserFragment;
import free.rm.skytube.gui.fragments.FragmentNames;
import free.rm.skytube.gui.fragments.PlaylistVideosFragment;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.exceptions.UndeliverableException;
import io.reactivex.rxjava3.plugins.RxJavaPlugins;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class SkyTubeApp extends MultiDexApplication {
	private static SkyTubeApp skyTubeApp = null;
	private Settings settings;
	private FragmentNames names;
	private static final String TAG = "SkyTubeApp";
	public static final String KEY_SUBSCRIPTIONS_LAST_UPDATED = "SkyTubeApp.KEY_SUBSCRIPTIONS_LAST_UPDATED";
	public static final String NEW_VIDEOS_NOTIFICATION_CHANNEL = "free.rm.skytube.NEW_VIDEOS_NOTIFICATION_CHANNEL";
	public static final int NEW_VIDEOS_NOTIFICATION_CHANNEL_ID = 1;
	@Override
	public void onCreate() {
		super.onCreate();
		this.settings = new Settings(this);
		this.settings.migrate();
		this.names = new FragmentNames(this);
		skyTubeApp = this;
		setupRxJava();
		preloadPrettyTime();
		if (BuildConfig.DEBUG) {
			StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
					.detectDiskReads()
					.detectDiskWrites()
					.detectCustomSlowCalls()
					.detectNetwork()   
					.penaltyLog()
					.build());
			StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
					.detectLeakedSqlLiteObjects()
					.detectLeakedClosableObjects()
					.penaltyLog()
					.build());
		}
		initChannels();
	}
	private void setupRxJava() {
		RxJavaPlugins.setErrorHandler(e -> {
			if (e instanceof UndeliverableException) {
				e = e.getCause();
			}
			if ((e instanceof IOException) || (e instanceof SocketException)) {
				return;
			}
			if (e instanceof InterruptedException) {
				return;
			}
			if ((e instanceof NullPointerException) || (e instanceof IllegalArgumentException)) {
				Thread.currentThread().getUncaughtExceptionHandler()
						.uncaughtException(Thread.currentThread(), e);
				return;
			}
			if (e instanceof IllegalStateException) {
				Thread.currentThread().getUncaughtExceptionHandler()
						.uncaughtException(Thread.currentThread(), e);
				return;
			}
			Log.e(TAG, "Undeliverable exception received, not sure what to do" + e.getMessage(), e);
		});
	}
	private static void preloadPrettyTime() {
		Completable.fromAction(() -> new PrettyTime().format(LocalDate.of(2021, 2, 23)))
				.subscribeOn(Schedulers.io())
				.onErrorReturn(exc -> {
					Log.e(TAG, "Unable to initialize PrettyTime, because: " + exc.getMessage(), exc);
					return "";
				})
				.subscribe();
	}
	@RequiresApi(api = Build.VERSION_CODES.M)
	private static void uiThreadImpl() {
		if (!Looper.getMainLooper().isCurrentThread()) {
			throw new RuntimeException("Expected to be executing in UI!");
		}
	}
	public static void uiThread() {
		if (BuildConfig.DEBUG) {
			if (Build.VERSION.SDK_INT >= 29) {
				uiThreadImpl();
			} else {
				Log.i(TAG, "Expected to be UI thread : " + Thread.currentThread().getName() + " [" + Build.VERSION.SDK_INT + ']');
			}
		}
	}
	@RequiresApi(api = Build.VERSION_CODES.M)
	private static void nonUiThreadImpl() {
		if (Looper.getMainLooper().isCurrentThread()) {
			throw new RuntimeException("Expected to be NOT blocking the UI!");
		}
	}
	public static void nonUiThread() {
		if (BuildConfig.DEBUG) {
			if (Build.VERSION.SDK_INT >= 29) {
				nonUiThreadImpl();
			} else {
				Log.i(TAG, "Expected to be non-UI thread : " + Thread.currentThread().getName() + " [" + Build.VERSION.SDK_INT + ']');
			}
		}
	}
	public static String getStr(int stringResId) {
		return skyTubeApp.getString(stringResId);
	}
	public static String[] getStringArray(@ArrayRes int stringArrayResId) {
		return skyTubeApp.getStrArray(stringArrayResId);
	}
	public String[] getStrArray(@ArrayRes int stringArrayResId) {
		return getResources().getStringArray(stringArrayResId);
	}
	public static List<String> getStringArrayAsList(@ArrayRes int stringArrayResId) {
		return Arrays.asList(getStringArray(stringArrayResId));
	}
	public static SharedPreferences getPreferenceManager() {
		return PreferenceManager.getDefaultSharedPreferences(skyTubeApp);
	}
	public static float getDimension(int dimensionId) {
		return skyTubeApp.getResources().getDimension(dimensionId);
	}
	public static int getColorEx(int colorId) {
		return ResourcesCompat.getColor(skyTubeApp.getResources(), colorId, null);
	}
	public static Context getContext() {
		return skyTubeApp.getBaseContext();
	}
	public static FragmentNames getFragmentNames() {
		return skyTubeApp.names;
	}
	public static void restartApp() {
		Context context = getContext();
		PackageManager packageManager = context.getPackageManager();
		Intent intent = packageManager.getLaunchIntentForPackage(context.getPackageName());
		ComponentName componentName = intent.getComponent();
		Intent mainIntent = Intent.makeRestartActivityTask(componentName);
		context.startActivity(mainIntent);
		System.exit(0);
	}
	public static boolean isTablet() {
		return getContext().getResources().getBoolean(R.bool.is_tablet);
	}
	public static boolean isActiveNetworkMetered() {
		return ConnectivityManagerCompat.isActiveNetworkMetered(ContextCompat.getSystemService(skyTubeApp,
				ConnectivityManager.class));
	}
	public static NetworkInfo getNetworkInfo(@NonNull Context context){
		return ContextCompat.getSystemService(context, ConnectivityManager.class).getActiveNetworkInfo();
	}
	public static boolean isConnected(@NonNull Context context){
		NetworkInfo info = getNetworkInfo(context);
		return (info != null && info.isConnected());
	}
	private void initChannels() {
		final NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
		final NotificationChannelCompat notificationChannel = new NotificationChannelCompat
				.Builder(NEW_VIDEOS_NOTIFICATION_CHANNEL, NotificationManagerCompat.IMPORTANCE_LOW)
				.setName(getString(R.string.notification_channel_feed_title))
				.setLightsEnabled(true)
				.setLightColor(ColorUtils.compositeColors(0xFFFF0000, 0xFFFF0000))
				.setVibrationEnabled(true)
				.build();
		notificationManager.createNotificationChannel(notificationChannel);
	}
	public static void setFeedUpdateInterval(int interval) {
		Intent alarm = new Intent(getContext(), FeedUpdaterReceiver.class);
		PendingIntent pendingIntent = PendingIntent.getBroadcast(getContext(), 0, alarm, PendingIntent.FLAG_CANCEL_CURRENT);
		AlarmManager alarmManager = ContextCompat.getSystemService(getContext(), AlarmManager.class);
		if(interval > 0) {
			alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime()+interval, interval, pendingIntent);
		}
	}
	public static Settings getSettings() {
		return skyTubeApp.settings;
	}
	public Settings getAppSettings() {
		return settings;
	}
	public static void notifyUserOnError(@NonNull Context ctx, @Nullable Throwable throwable) {
		if (throwable == null) {
			return;
		}
        if (throwable instanceof ReCaptchaException) {
            handleRecaptchaException(ctx, (ReCaptchaException) throwable);
            return;
        }
		final String message;
		if (throwable instanceof GoogleJsonResponseException) {
			GoogleJsonResponseException exception = (GoogleJsonResponseException) throwable;
			List<GoogleJsonError.ErrorInfo> errors = exception.getDetails().getErrors();
			if (errors != null && !errors.isEmpty()) {
				message =  "Server error:" + errors.get(0).getMessage()+ ", reason: "+ errors.get(0).getReason();
			} else {
				message = exception.getDetails().getMessage();
			}
		} else {
			message = throwable.getMessage();
		}
		if (message != null) {
			Log.e(TAG, "Error: "+message);
			String toastText = message;
			if(message.contains("resolve host")) {
				toastText = "No internet connection available";
			}
			if(message.contains("JavaScript player")) {
				return; 
			}
			Toast.makeText(ctx, toastText, Toast.LENGTH_LONG).show();
		}
	}
    private static void handleRecaptchaException(Context context, ReCaptchaException reCaptchaException) {
        String url = reCaptchaException.getUrl().replace("&pbj=1", "").replace("pbj=1&", "").replace("?pbj=1", "");
        Log.e(TAG, "Error: " + reCaptchaException.getMessage() + " url: " + url, reCaptchaException);
        Toast.makeText(context, R.string.recaptcha_challenge_requested, Toast.LENGTH_LONG).show();
        viewInBrowser(url, context);
        return;
    }
	public static void shareUrl(@NonNull Context context, String url) {
		Intent intent = new Intent(android.content.Intent.ACTION_SEND);
		intent.setType("text/plain");
		intent.putExtra(android.content.Intent.EXTRA_TEXT, url);
		context.startActivity(Intent.createChooser(intent, context.getString(R.string.share_via)));
	}
	public static void copyUrl(@NonNull Context context, String text, String url) {
		ClipData clip = ClipData.newPlainText(text, url);
		ContextCompat.getSystemService(context, ClipboardManager.class).setPrimaryClip(clip);
		Toast.makeText(context, R.string.url_copied_to_clipboard, Toast.LENGTH_SHORT).show();
	}
	public static ContentId getUrlFromIntent(@NonNull final Context ctx, final Intent intent) {
		if (Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null) {
			return parseUrl(ctx, intent.getData().toString(), true);
		}
		return null;
	}
	public static ContentId parseUrl(@NonNull Context context, String url, boolean showErrorIfNotValid) {
		try {
			ContentId id = NewPipeService.get().getContentId(url);
			if (id == null && showErrorIfNotValid) {
				showInvalidUrlToast(context, url);
			}
			return id;
		} catch (RuntimeException e) {
			SkyTubeApp.notifyUserOnError(context, e);
			return null;
		}
	}
	private static void showInvalidUrlToast(@NonNull Context context, String url) {
		String message = String.format(context.getString(R.string.error_invalid_url), url);
		Toast.makeText(context, message, Toast.LENGTH_LONG).show();
	}
	public static void openUrl(Context ctx, String url, boolean useExternalBrowser) {
		ContentId content = parseUrl(ctx, url, !useExternalBrowser);
		if (openContent(ctx, content)) {
			return;
		} else {
			if (useExternalBrowser) {
				viewInBrowser(url, ctx);
			}
		}
	}
	public static boolean openContent(Context ctx, ContentId content) {
		if (content == null) {
			return false;
		}
		switch (content.getType()) {
			case STREAM: {
				YouTubePlayer.launch(content, ctx);
				break;
			}
			case CHANNEL: {
				SkyTubeApp.launchChannel(new ChannelId(content.getId()), ctx);
				break;
			}
			case PLAYLIST: {
				YouTubeTasks.getPlaylist(ctx, content.getId())
						.subscribe(playlist -> launchPlaylist(playlist, ctx));
				break;
			}
			default:
				return false;
		}
		return true;
	}
	public static void launchChannel(ChannelId channelId, Context context) {
		if (channelId != null) {
			DatabaseTasks.getChannelInfo(context, channelId, true)
					.subscribe(youTubeChannel -> launchChannel(youTubeChannel.channel(), context));
		}
	}
	public static void launchChannel(YouTubeChannel youTubeChannel, Context context) {
		Intent i = new Intent(context, MainActivity.class);
		i.setAction(MainActivity.ACTION_VIEW_CHANNEL);
		i.putExtra(ChannelBrowserFragment.CHANNEL_OBJ, youTubeChannel);
		context.startActivity(i);
	}
	public static void launchPlaylist(final YouTubePlaylist playlist, final Context context) {
		Intent playlistIntent = new Intent(context, MainActivity.class);
		playlistIntent.setAction(MainActivity.ACTION_VIEW_PLAYLIST);
		playlistIntent.putExtra(PlaylistVideosFragment.PLAYLIST_OBJ, playlist);
		context.startActivity(playlistIntent);
	}
	public static void viewInBrowser(String url, final Context context) {
		Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
		browserIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		try {
			context.startActivity(browserIntent);
		} catch (ActivityNotFoundException e) {
			showInvalidUrlToast(context, url);
			Log.e(TAG, "Activity not found for " + url + ", error:" + e.getMessage(), e);
		}
	}
}
package free.rm.skytube.businessobjects.YouTube.POJOs;
import android.app.DownloadManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Environment;
import android.view.Menu;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.core.content.FileProvider;
import com.google.api.services.youtube.model.Channel;
import com.google.api.services.youtube.model.Thumbnail;
import com.google.api.services.youtube.model.Video;
import com.google.api.services.youtube.model.VideoSnippet;
import com.google.api.services.youtube.model.VideoStatistics;
import org.ocpsoft.prettytime.PrettyTime;
import org.schabi.newpipe.extractor.stream.Stream;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import org.schabi.newpipe.extractor.stream.VideoStream;
import java.io.File;
import java.io.Serializable;
import java.math.BigInteger;
import java.time.Duration;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.Locale;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.StreamSelectionPolicy;
import free.rm.skytube.businessobjects.FileDownloader;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeUtils;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import free.rm.skytube.businessobjects.db.BookmarksDb;
import free.rm.skytube.businessobjects.db.DatabaseResult;
import free.rm.skytube.businessobjects.db.DownloadedVideosDb;
import free.rm.skytube.businessobjects.interfaces.GetDesiredStreamListener;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Single;
import static free.rm.skytube.app.SkyTubeApp.getContext;
import static free.rm.skytube.app.SkyTubeApp.getStr;
public class YouTubeVideo extends CardData implements Serializable {
	private YouTubeChannel channel;
	private Long likeCountNumber;
	private Long dislikeCountNumber;
	private int thumbsUpPercentage;
	private String duration;
	private int durationInSeconds = -1;
	private String viewsCount;
	private BigInteger viewsCountInt;
	private transient ZonedDateTime publishDate;
	private String thumbnailMaxResUrl;
	private String language;
	private boolean isLiveStream;
	private Integer categoryId;
	public YouTubeVideo(Video video) throws IllegalArgumentException {
		this.id = video.getId();
		VideoSnippet snippet = video.getSnippet();
		if (snippet == null) {
			throw new IllegalArgumentException("Missing snippet in "+video);
		}
		this.title = snippet.getTitle();
		this.channel = new YouTubeChannel(snippet.getChannelId(), snippet.getChannelTitle());
		setPublishTimestamp(snippet.getPublishedAt().getValue());
		setPublishTimestampExact(true);
		if (snippet.getThumbnails() != null) {
			Thumbnail thumbnail = snippet.getThumbnails().getHigh();
			if (thumbnail != null) {
				this.thumbnailUrl = thumbnail.getUrl();
			}
			thumbnail = snippet.getThumbnails().getMaxres();
			if (thumbnail != null) {
				this.thumbnailMaxResUrl = thumbnail.getUrl();
			}
		}
		this.language = snippet.getDefaultAudioLanguage() != null ? snippet.getDefaultAudioLanguage()
				: (snippet.getDefaultLanguage());
		this.description = snippet.getDescription();
		if (video.getContentDetails() != null) {
			setDuration(video.getContentDetails().getDuration());
			setIsLiveStream();
			setDurationInSeconds(video.getContentDetails().getDuration());
		}
		VideoStatistics statistics = video.getStatistics();
		if (statistics != null) {
			setLikeDislikeCount(statistics.getLikeCount() != null ? statistics.getLikeCount().longValue() : null, statistics.getDislikeCount() != null ? statistics.getDislikeCount().longValue() : null);
			setViewCount(statistics.getViewCount());
		}
	}
	public void setCategoryId(Integer categoryId) {
		this.categoryId = categoryId;
	}
	public Integer getCategoryId() {
		return categoryId;
	}
	public void setViewCount(BigInteger viewsCountInt) {
		this.viewsCountInt = viewsCountInt;
		this.viewsCount = String.format(getStr(R.string.views), viewsCountInt);
	}
        public YouTubeVideo(String id, String title, String description, long durationInSeconds,
							YouTubeChannel channel, long viewCount, Instant publishDate,
							boolean publishDateExact, String thumbnailUrl) {
            this.id = id;
            this.title = title;
            this.description = description;
            setDurationInSeconds((int) durationInSeconds);
            if (viewCount >= 0) {
                setViewCount(BigInteger.valueOf(viewCount));
            }
            if (publishDate != null) {
                setPublishTimestamp(publishDate.toEpochMilli());
            }
            setPublishTimestampExact(publishDateExact);
            this.thumbnailMaxResUrl = thumbnailUrl;
            this.thumbnailUrl = thumbnailUrl;
            this.channel = channel;
            this.thumbsUpPercentage = -1;
        }
        public VideoId getVideoId() {
            return new VideoId(id, getVideoUrl(), null);
        }
	public void setLikeDislikeCount(Long likedCountInt, Long dislikedCountInt) {
		this.thumbsUpPercentage = -1;
		final Long likes = filterNegative(likedCountInt);
		final Long dislikes = filterNegative(dislikedCountInt);
		if (likes != null && dislikes != null) {
			long likedCount = likes;
			long dislikedCount = dislikes;
			long totalVoteCount = likedCount + dislikedCount;	
			if (totalVoteCount != 0) {
				this.thumbsUpPercentage = (int) Math.round((double)likedCount*100/totalVoteCount);
			}
		}
		this.likeCountNumber = likes;
		this.dislikeCountNumber = dislikes;
	}
	private static Long filterNegative(Long value) {
		if (value != null && value.longValue() < 0) {
			return null;
		}
		return value;
	}
	private void setIsLiveStream() {
		if (duration.equals("0:00")) {
			isLiveStream = true;
			duration = getStr(R.string.LIVE);
			setPublishTimestamp(Instant.now().toEpochMilli());
		} else {
			isLiveStream = false;
		}
	}
	public YouTubeChannel getChannel() {
		return channel;
	}
	public void setChannel(YouTubeChannel channel) {
		this.channel = channel;
	}
    public String getSafeChannelId() {
        return channel != null ? channel.getChannelId().getRawId() : null;
    }
    public String getSafeChannelName() {
        return channel != null ? channel.getTitle() : null;
    }
	public ChannelId getChannelId() {
		return channel.getChannelId();
	}
	public String getChannelName() {
		return channel.getTitle();
	}
	public boolean isThumbsUpPercentageSet() {
		return (thumbsUpPercentage >= 0);
	}
	public int getThumbsUpPercentage() {
		return thumbsUpPercentage;
	}
	public String getThumbsUpPercentageStr() {
		return thumbsUpPercentage >= 0 ? thumbsUpPercentage + "%" : null;
	}
	public String getLikeCount() {
		if (likeCountNumber != null) {
			return String.format(Locale.getDefault(), "%,d", likeCountNumber);
		}
		return null;
	}
	public Long getLikeCountNumber() {
		return likeCountNumber;
	}
	public String getDislikeCount() {
		if (dislikeCountNumber != null) {
			return String.format(Locale.getDefault(), "%,d", dislikeCountNumber);
		}
		return null;
	}
	public Long getDislikeCountNumber() {
		return dislikeCountNumber;
	}
	public String getDuration() {
		return duration;
	}
	public int getDurationInSeconds() {
		return durationInSeconds;
	}
	private void setDuration(String duration) {
		this.duration = VideoDuration.toHumanReadableString(duration);
	}
	public String getViewsCount() {
		return viewsCount;
	}
	public BigInteger getViewsCountInt() {
		return viewsCountInt;
	}
	public void setDurationInSeconds(String durationInSeconds) {
		this.durationInSeconds = (int) Duration.parse(durationInSeconds).toMillis() / 1000;
	}
	public void setDurationInSeconds(int durationInSeconds) {
		this.durationInSeconds = durationInSeconds;
		this.duration = VideoDuration.toHumanReadableString(durationInSeconds);
	}
	public YouTubeVideo updatePublishTimestampFromDate() {
		if (this.publishTimestamp == null) {
			if (this.publishDate != null) {
				setPublishTimestamp(this.publishDate.toInstant().toEpochMilli());
			}
		}
		return this;
	}
	public String getThumbnailMaxResUrl() {
		return thumbnailMaxResUrl;
	}
	public String getVideoUrl() {
		return String.format("https:
	}
	public String getLanguage() {
		return language;
	}
	public boolean isLiveStream() {
		return isLiveStream;
	}
    public Single<Boolean> bookmarkVideo(Context context) {
        return bookmarkVideo(context, null);
    }
    public Single<Boolean> bookmarkVideo(Context context, Menu menu) {
        return BookmarksDb.getBookmarksDb().bookmarkAsync(this)
                .map(result -> {
                    Toast.makeText(context,
                            getBookmarkMessage(result),
                            Toast.LENGTH_LONG).show();
                    if (result.isPositive() && menu != null) {
                        menu.findItem(R.id.bookmark_video).setVisible(false);
                        menu.findItem(R.id.unbookmark_video).setVisible(true);
                    }
                    return result.isPositive();
        });
    }
	static int getBookmarkMessage(@NonNull DatabaseResult result) {
		switch (result) {
			case ERROR: return R.string.video_bookmarked_error;
			case NOT_MODIFIED: return R.string.video_already_bookmarked;
			case SUCCESS: return R.string.video_bookmarked;
		}
		throw new IllegalStateException("Result "+ result);
	}
	static int getUnBookmarkMessage(@NonNull DatabaseResult result) {
		switch (result) {
			case ERROR: return R.string.video_unbookmarked_error;
			case NOT_MODIFIED: return R.string.video_was_not_bookmarked;
			case SUCCESS: return R.string.video_unbookmarked;
		}
		throw new IllegalStateException("Result "+ result);
	}
    public Single<Boolean> unbookmarkVideo(Context context, Menu menu) {
        return BookmarksDb.getBookmarksDb().unbookmarkAsync(getVideoId())
                .map(result -> {
                    Toast.makeText(context,
                            getUnBookmarkMessage(result),
                            Toast.LENGTH_LONG).show();
                    if (result.isPositive() && menu != null) {
                        menu.findItem(R.id.bookmark_video).setVisible(true);
                        menu.findItem(R.id.unbookmark_video).setVisible(false);
                    }
                    return result.isPositive();
                });
    }
	public void shareVideo(Context context) {
		SkyTubeApp.shareUrl(context, getVideoUrl());
	}
	public void copyUrl(Context context) {
		SkyTubeApp.copyUrl(context, "Video URL", getVideoUrl());
	}
	public void updateFromStreamInfo(StreamInfo streamInfo) {
		final Long like = filterNegative(streamInfo.getLikeCount());
		final Long dislike = filterNegative(streamInfo.getDislikeCount());
		this.setLikeDislikeCount(like != null ? like : likeCountNumber, dislike != null ? dislike : dislikeCountNumber);
		final Long views = filterNegative(streamInfo.getViewCount());
		if (views != null) {
			this.setViewCount(BigInteger.valueOf(views));
		}
		this.setDescription(NewPipeUtils.filterHtml(streamInfo.getDescription()));
	}
	public Completable downloadVideo(final Context context) {
		return DownloadedVideosDb.getVideoDownloadsDb().isVideoDownloaded(YouTubeVideo.this.getVideoId())
				.flatMapCompletable((downloadedVideo) -> {
			if (downloadedVideo) {
				return Completable.complete();
			} else {
				return YouTubeTasks.getDesiredStream(this, new GetDesiredStreamListener() {
					@Override
					public void onGetDesiredStream(StreamInfo streamInfo, YouTubeVideo video) {
						final Settings settings = SkyTubeApp.getSettings();
						StreamSelectionPolicy selectionPolicy = settings.getDesiredVideoResolution(true);
						StreamSelectionPolicy.StreamSelection streamSelection = selectionPolicy.select(streamInfo);
						if (streamSelection != null) {
							VideoStream videoStream = streamSelection.getVideoStream();
							downloadTheVideo(videoStream, settings);
						} else {
							Toast.makeText(context, selectionPolicy.getErrorMessage(context), Toast.LENGTH_LONG).show();
						}
					}
					private void downloadTheVideo(Stream stream, Settings settings) {
						new VideoDownloader()
								.setRemoteFileUrl(stream.getUrl())
								.setDirType(Environment.DIRECTORY_MOVIES)
								.setTitle(getTitle())
								.setDescription(getStr(R.string.video) + "  " + getChannelName())
								.setOutputFileName(getId() + " - " + getTitle())
								.setOutputDirectoryName(getChannelName())
								.setParentDirectory(settings.getDownloadParentFolder())
								.setOutputFileExtension(stream.getFormat().suffix)
								.setAllowedOverRoaming(false)
								.setAllowedNetworkTypesFlags(DownloadManager.Request.NETWORK_WIFI | DownloadManager.Request.NETWORK_MOBILE)
								.displayPermissionsActivity(context);
					}
					@Override
					public void onGetDesiredStreamError(Throwable throwable) {
						Logger.e(YouTubeVideo.this, "Stream error: " + throwable.getMessage(), throwable);
						Context context = getContext();
						Toast.makeText(context,
								String.format(context.getString(R.string.video_download_stream_error), getTitle()),
								Toast.LENGTH_LONG).show();
					}
				});
			}
		});
	}
	public Single<DownloadedVideosDb.Status> playVideoExternally(Context context) {
		return DownloadedVideosDb.getVideoDownloadsDb().getDownloadedFileStatus(context, getVideoId()).map(fileStatus -> {
			if (fileStatus.getLocalVideoFile() != null) {
				Uri uri;
				File file = fileStatus.getLocalVideoFile();
				try {
					uri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + ".provider", file);
				} catch (Exception e) {
					Logger.e(YouTubeVideo.this, "Error accessing path: " + file + ", message:" + e.getMessage(), e);
					uri = fileStatus.getUri();
				}
				Intent intent = new Intent(Intent.ACTION_VIEW, uri);
				intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
				context.startActivity(intent);
			} else {
				Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getVideoUrl()));
				context.startActivity(browserIntent);
			}
			return fileStatus;
		});
	}
	private class VideoDownloader extends FileDownloader implements Serializable {
		@Override
		public void onFileDownloadStarted() {
			Toast.makeText(getContext(),
					String.format(getContext().getString(R.string.starting_video_download), getTitle()),
					Toast.LENGTH_LONG).show();
		}
        @Override
        public void onFileDownloadCompleted(boolean success, Uri localFileUri) {
            if (success) {
                DownloadedVideosDb.getVideoDownloadsDb().add(YouTubeVideo.this, localFileUri, null)
                    .doOnSuccess(saveSucceeded -> {
                        showToast(saveSucceeded);
                    }).doOnError(err -> {
                        SkyTubeApp.notifyUserOnError(getContext(), err);
                    }).subscribe();
            } else {
                showToast(false);
            }
        }
        private void showToast(boolean success) {
            Toast.makeText(getContext(),
                    String.format(getContext().getString(success ? R.string.video_downloaded : R.string.video_download_stream_error), getTitle()),
                    Toast.LENGTH_LONG).show();
        }
        @Override
        public void onDownloadStartFailed(String downloadName, final RuntimeException runtimeException) {
            Toast.makeText(getContext(),
                    String.format(getContext().getString(R.string.download_failed_because), downloadName, runtimeException.getMessage()),
                    Toast.LENGTH_LONG).show();
        }
        @Override
        public void onExternalStorageNotAvailable() {
            Toast.makeText(getContext(),
                    R.string.external_storage_not_available,
                    Toast.LENGTH_LONG).show();
        }
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import android.util.Log;
import androidx.annotation.NonNull;
import com.github.skytube.components.httpclient.OkHttpDownloader;
import org.json.JSONException;
import org.json.JSONObject;
import org.schabi.newpipe.extractor.NewPipe;
import org.schabi.newpipe.extractor.ServiceList;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.channel.ChannelExtractor;
import org.schabi.newpipe.extractor.channel.tabs.ChannelTabExtractor;
import org.schabi.newpipe.extractor.channel.tabs.ChannelTabs;
import org.schabi.newpipe.extractor.comments.CommentsExtractor;
import org.schabi.newpipe.extractor.downloader.Response;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.exceptions.ReCaptchaException;
import org.schabi.newpipe.extractor.feed.FeedExtractor;
import org.schabi.newpipe.extractor.kiosk.KioskExtractor;
import org.schabi.newpipe.extractor.kiosk.KioskList;
import org.schabi.newpipe.extractor.linkhandler.LinkHandler;
import org.schabi.newpipe.extractor.linkhandler.LinkHandlerFactory;
import org.schabi.newpipe.extractor.linkhandler.ListLinkHandler;
import org.schabi.newpipe.extractor.linkhandler.ListLinkHandlerFactory;
import org.schabi.newpipe.extractor.localization.ContentCountry;
import org.schabi.newpipe.extractor.localization.DateWrapper;
import org.schabi.newpipe.extractor.localization.Localization;
import org.schabi.newpipe.extractor.playlist.PlaylistExtractor;
import org.schabi.newpipe.extractor.search.SearchExtractor;
import org.schabi.newpipe.extractor.stream.StreamExtractor;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import org.schabi.newpipe.extractor.subscription.SubscriptionExtractor;
import org.schabi.newpipe.extractor.utils.Utils;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
public class NewPipeService {
    private static NewPipeService instance;
    private final StreamingService streamingService;
    private final Settings settings;
    final static boolean DEBUG_LOG = false;
    static class ChannelWithExtractor {
        final YouTubeChannel channel;
        final ChannelExtractor extractor;
        ChannelWithExtractor(YouTubeChannel channel, ChannelExtractor extractor) {
            this.channel = channel;
            this.extractor = extractor;
        }
        ListLinkHandler findListLinkHandler(String name) throws ParsingException {
            return extractor.getTabs().stream()
                .filter(linkHandler -> {
                    List<String> filters = linkHandler.getContentFilters();
                    return filters != null && filters.contains(name);
                }).findAny().orElse(null);
        }
        ChannelTabExtractor findChannelTab(String name) throws ParsingException {
            ListLinkHandler listLinkHandler = findListLinkHandler(name);
            if(listLinkHandler != null) {
                try {
                    return instance.streamingService.getChannelTabExtractor(listLinkHandler);
                } catch (ExtractionException e) {
                    Logger.e(instance, "findChannelTab (" + name + ") : " + listLinkHandler + ", err:" + e.getMessage(), e);
                    return null;
                }
            }
            return null;
        }
        ChannelTabExtractor findVideosTab() throws ParsingException {
            return findChannelTab(ChannelTabs.VIDEOS);
        }
        ChannelTabExtractor findPlaylistTab() throws ParsingException {
            return findChannelTab(ChannelTabs.PLAYLISTS);
        }
    }
    @FunctionalInterface
    interface ParserCall<X> {
        X get() throws ParsingException;
    }
    public NewPipeService(StreamingService streamingService, Settings settings) {
        this.streamingService = streamingService;
        this.settings = settings;
    }
    private StreamInfo getStreamInfoByUrl(String videoUrl) throws IOException, ExtractionException {
        return StreamInfo.getInfo(streamingService, videoUrl);
    }
    public ContentId getVideoId(String url) throws ParsingException {
        if (url == null) {
            return null;
        }
        return parse(streamingService.getStreamLHFactory(), url, StreamingService.LinkType.STREAM);
    }
    public ContentId getContentId(String url) {
        if (url == null) {
            return null;
        }
        ContentId id;
        id = parse(streamingService.getStreamLHFactory(), url, StreamingService.LinkType.STREAM);
        if (id != null) {
            return id;
        }
        id = parse(streamingService.getChannelLHFactory(), url, StreamingService.LinkType.CHANNEL);
        if (id != null) {
            return id;
        }
        id = parse(streamingService.getPlaylistLHFactory(), url, StreamingService.LinkType.PLAYLIST);
        return id;
    }
    private ContentId parse(LinkHandlerFactory handlerFactory, String url, StreamingService.LinkType type) {
        if (handlerFactory != null) {
            try {
                String id = handlerFactory.getId(url);
                String canonicalUrl = handlerFactory.getUrl(id);
                if (type == StreamingService.LinkType.STREAM) {
                    return new VideoId(id, canonicalUrl, parseTimeStamp(url));
                } else {
                    return new ContentId(id, handlerFactory.getUrl(id), type);
                }
            } catch (ParsingException pe) {
                return null;
            }
        }
        return null;
    }
    private Integer parseTimeStamp(String url) {
        try {
            String time = Utils.getQueryValue(new URL(url), "t");
            if (time != null) {
                return Integer.parseInt(time);
            }
        } catch (MalformedURLException|NumberFormatException e) {
        }
        return null;
    }
    public StreamInfo getStreamInfoByVideoId(String videoId) throws ExtractionException, IOException {
        return getStreamInfoByUrl(getVideoUrl(videoId));
    }
    private List<YouTubeVideo> getChannelVideos(ChannelId channelId) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        VideoPagerWithChannel pager = getChannelPager(channelId);
        List<YouTubeVideo> result = pager.getNextPageAsVideosAndUpdateChannel(null).channel().getYouTubeVideos();
        Logger.i(this, "getChannelVideos for %s(%s)  -> %s videos", pager.getChannel().getTitle(), channelId, result.size());
        return result;
    }
    private List<YouTubeVideo> getFeedVideos(String channelId) throws ExtractionException, IOException, NewPipeException {
        SkyTubeApp.nonUiThread();
        final String url = getListLinkHandler(channelId).getUrl();
        final FeedExtractor feedExtractor = streamingService.getFeedExtractor(url);
        if (feedExtractor == null) {
            Logger.i(this, "getFeedExtractor doesn't return anything for %s -> %s", channelId, url);
            return null;
        }
        feedExtractor.fetchPage();
        return new VideoPagerWithChannel(streamingService, feedExtractor, createInternalChannelFromFeed(feedExtractor)).getNextPageAsVideos();
    }
    public List<YouTubeVideo> getVideosFromFeedOrFromChannel(ChannelId channelId) throws NewPipeException {
        try {
            SkyTubeApp.nonUiThread();
            List<YouTubeVideo> videos = getFeedVideos(channelId.getRawId());
            if (videos != null) {
                return videos;
            }
        } catch (IOException | ExtractionException | RuntimeException | NewPipeException e) {
            Logger.e(this, "Unable to get videos from a feed " + channelId + " : "+ e.getMessage(), e);
        }
        return getChannelVideos(channelId);
    }
    public VideoPager getTrending() throws NewPipeException {
        try {
            KioskList kiosks = streamingService.getKioskList();
            KioskExtractor kex = kiosks.getDefaultKioskExtractor();
            kex.fetchPage();
            return new VideoPager(streamingService, kex);
        } catch (ExtractionException | IOException e) {
            throw new NewPipeException("Unable to get 'trending' list:" + e.getMessage(), e);
        }
    }
    public VideoPagerWithChannel getChannelPager(ChannelId channelId) throws NewPipeException {
        try {
            Logger.e(this, "fetching channel info: "+ channelId);
            ChannelWithExtractor channelExtractor = getChannelWithExtractor(channelId);
            return new VideoPagerWithChannel(streamingService, channelExtractor.findVideosTab(), channelExtractor.channel);
        } catch (ParsingException | RuntimeException e) {
            throw new NewPipeException("Getting videos for " + channelId + " fails:" + e.getMessage(), e);
        }
    }
    public ChannelWithExtractor getChannelWithExtractor(ChannelId channelId) throws NewPipeException {
        try {
            ChannelExtractor channelExtractor = getChannelExtractor(channelId);
            YouTubeChannel channel = createInternalChannel(channelExtractor);
            return new ChannelWithExtractor(channel, channelExtractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting playlists for " + channelId + " fails:" + e.getMessage(), e);
        }
    }
    public PlaylistPager getPlaylistPager(String playlistId) throws NewPipeException {
        try {
            ListLinkHandler playlistLinkHandler = getPlaylistHandler(playlistId);
            PlaylistExtractor playlistExtractor = streamingService.getPlaylistExtractor(playlistLinkHandler);
            playlistExtractor.fetchPage();
            return new PlaylistPager(streamingService, playlistExtractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting playlists for " + playlistId + " fails:" + e.getMessage(), e);
        }
    }
    public CommentPager getCommentPager(String videoId) throws NewPipeException {
        try {
            final ListLinkHandler linkHandler = streamingService.getCommentsLHFactory().fromId(videoId);
            final CommentsExtractor commentsExtractor = streamingService.getCommentsExtractor(linkHandler);
            return new CommentPager(streamingService, commentsExtractor);
        } catch (ExtractionException | RuntimeException | IOException e) {
            throw new NewPipeException("Getting comments for " + videoId + " fails:" + e.getMessage(), e);
        }
    }
    public PersistentChannel getChannelDetails(ChannelId channelId, PersistentChannel persistentChannel) throws NewPipeException {
        Logger.i(this, "Fetching channel details for " + channelId);
        VideoPagerWithChannel pager = getChannelPager(channelId);
        try {
            return pager.getNextPageAsVideosAndUpdateChannel(persistentChannel);
        } catch (NewPipeException e) {
            Logger.e(this, "Unable to retrieve videos for "+channelId+", error: "+e.getMessage(), e);
            throw e;
        }
    }
    private YouTubeChannel createInternalChannelFromFeed(FeedExtractor extractor) throws ParsingException {
        return new YouTubeChannel(extractor.getId(), extractor.getName(), null,
                null, null, -1, false, 0, System.currentTimeMillis(), null, Collections.emptyList());
    }
    private YouTubeChannel createInternalChannel(ChannelExtractor extractor) throws ParsingException {
        return new YouTubeChannel(
                extractor.getId(),
                extractor.getName(),
                NewPipeUtils.filterHtml(extractor.getDescription()),
                callParser(() -> NewPipeUtils.getThumbnailUrl(extractor.getAvatars()), null),
                callParser(() -> NewPipeUtils.getThumbnailUrl(extractor.getBanners()), null),
                callParser(() -> extractor.getSubscriberCount(), -1L),
                false,
                0,
                System.currentTimeMillis(),
                null,
                extractor.getTags());
    }
    private <X> X callParser(ParserCall<X> parser, X defaultValue) {
        try {
            return parser.get();
        } catch (NullPointerException | ParsingException e) {
            Logger.e(this, "Unable to parse: " + parser + ", error: " + e.getMessage(), e);
            return defaultValue;
        }
    }
    private ChannelExtractor getChannelExtractor(ChannelId channelId)
            throws ExtractionException, IOException {
        ChannelExtractor channelExtractor = streamingService
                .getChannelExtractor(getListLinkHandler(Objects.requireNonNull(channelId, "channelId").getRawId()));
        channelExtractor.fetchPage();
        return channelExtractor;
    }
    private ListLinkHandler getListLinkHandler(String channelId) throws ParsingException {
        ListLinkHandlerFactory channelLHFactory = streamingService.getChannelLHFactory();
        try {
            return channelLHFactory.fromUrl(channelId);
        } catch (ParsingException p) {
            if (DEBUG_LOG) {
                Logger.d(this, "Unable to parse channel url=%s", channelId);
            }
        }
        if (channelId.startsWith("channel/") || channelId.startsWith("c/") || channelId.startsWith("user/")) {
            return channelLHFactory.fromId(channelId);
        }
        return channelLHFactory.fromId("channel/" + channelId);
    }
    private ListLinkHandler getPlaylistHandler(String playlistId) throws ParsingException {
        ListLinkHandlerFactory factory = streamingService.getPlaylistLHFactory();
        try {
            return factory.fromUrl(playlistId);
        } catch (Exception parsingException) {
            Logger.i(instance, "PlaylistId '"+playlistId+"' is not an url:"+ parsingException.getMessage());
            return factory.fromId(playlistId);
        }
    }
    public YouTubeVideo getDetails(String videoId) throws ExtractionException, IOException {
        SkyTubeApp.nonUiThread();
        LinkHandler url = streamingService.getStreamLHFactory().fromId(videoId);
        StreamExtractor extractor = streamingService.getStreamExtractor(url);
        extractor.fetchPage();
        DateInfo uploadDate = new DateInfo(extractor.getUploadDate());
        Logger.i(this, "getDetails for %s -> %s %s", videoId, url.getUrl(), uploadDate);
        long viewCount;
        try {
            viewCount = extractor.getViewCount();
        } catch (NumberFormatException|ParsingException e) {
            Logger.e(this, "Unable to get view count for " + url.getUrl()+", error: "+e.getMessage(), e);
            viewCount = 0;
        }
        YouTubeVideo video = new YouTubeVideo(extractor.getId(), extractor.getName(), NewPipeUtils.filterHtml(extractor.getDescription()),
                extractor.getLength(), new YouTubeChannel(extractor.getUploaderUrl(), extractor.getUploaderName()),
                viewCount, uploadDate.instant, uploadDate.exact, NewPipeUtils.getThumbnailUrl(extractor.getThumbnails()));
        try {
            video.setLikeDislikeCount(extractor.getLikeCount(), getDislikeCount(extractor, videoId));
        } catch (ParsingException pe) {
            Logger.e(this, "Unable get like count for " + url.getUrl() + ", created at " + uploadDate + ", error:" + pe.getMessage(), pe);
            video.setLikeDislikeCount(null, null);
        }
        return video;
    }
    private Long getDislikeCount(StreamExtractor extractor, String id) {
        try {
            long dislikeCount = extractor.getDislikeCount();
            if (dislikeCount >= 0) {
                return dislikeCount;
            }
        } catch (ParsingException e) {
            Logger.e(this, "Unable get dislike count for " + extractor.getLinkHandler().getUrl() + ", error:" + e.getMessage(), e);
        }
        return getDislikeCountFromApi(id);
    }
    public Long getDislikeCountFromApi(String videoId)  {
        if (settings.isUseDislikeApi()) {
            String url = "https:
            try {
                Logger.i(this, "fetching dislike count for "+ url);
                OkHttpDownloader downloader = OkHttpDownloader.getInstance();
                Response response = downloader.get(url);
                int responseCode = response.responseCode();
                if (responseCode != 200) {
                    Logger.e(this, "ResponseCode " + responseCode + " for " + url);
                    return null;
                }
                JSONObject jsonObject = new JSONObject(response.responseBody());
                Logger.i(this, "for "+ url +" -> "+jsonObject);
                return jsonObject.getLong("dislikes");
            } catch (IOException | JSONException | ReCaptchaException e) {
                Logger.e(this, "getDislikeCount: error: " + e.getMessage() + " for url:" + url, e);
            }
        } else {
            Logger.i(this, "Like fetching disabled for " + videoId);
        }
        return null;
    }
    static class DateInfo {
        boolean exact;
        Instant instant;
        public DateInfo(DateWrapper uploadDate) {
            if (uploadDate != null) {
                instant = uploadDate.offsetDateTime().toInstant();
                exact = !uploadDate.isApproximation();
            } else {
                instant = null;
                exact = false;
            }
        }
        private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        @NonNull
        @Override
        public String toString() {
            try {
                return "[time= " + dtf.format(instant) + ",exact=" + exact + ']';
            } catch (Exception e){
                return "[incorrect time= " + instant + " ,exact=" + exact + ']';
            }
        }
    }
    static String getThumbnailUrl(String id) {
        return "https:
    }
    public VideoPager getSearchResult(String query) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        try {
            SearchExtractor extractor = streamingService.getSearchExtractor(query);
            extractor.fetchPage();
            return new VideoPager(streamingService, extractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting search result for " + query + " fails:" + e.getMessage(), e);
        }
    }
    private String getVideoUrl(String videoId) throws ParsingException {
        return streamingService.getStreamLHFactory().getUrl(videoId);
    }
    public synchronized static NewPipeService get() {
        if (instance == null) {
            getHttpDownloader();
            instance = new NewPipeService(ServiceList.YouTube, SkyTubeApp.getSettings());
        }
        return instance;
    }
    public SubscriptionExtractor createSubscriptionExtractor() {
        return streamingService.getSubscriptionExtractor();
    }
    public static OkHttpDownloader getHttpDownloader() {
        OkHttpDownloader downloader = OkHttpDownloader.getInstance();
        downloader.setApiUserAgent("SkyTube-Android-" + BuildConfig.VERSION_CODE);
        if (NewPipe.getDownloader() == null) {
            NewPipe.init(downloader, Localization.DEFAULT, toContentCountry(SkyTubeApp.getSettings().getPreferredContentCountry()));
        }
        return downloader;
    }
    private static ContentCountry toContentCountry(String countryCode){
        if (countryCode == null || countryCode.isEmpty()) {
            return ContentCountry.DEFAULT;
        } else {
            return new ContentCountry(countryCode);
        }
    }
    public static void setCountry(String countryCodeStr) {
        getHttpDownloader();
        final ContentCountry contentCountry = toContentCountry(countryCodeStr);
        Log.i("NewPipeService", "set preferred content country to " + contentCountry);
        NewPipe.setPreferredContentCountry(contentCountry);
    }
}
package free.rm.skytube.gui.businessobjects;
import android.Manifest;
import android.app.Activity;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Environment;
import android.text.SpannableString;
import android.text.util.Linkify;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.text.util.LinkifyCompat;
import androidx.fragment.app.Fragment;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.afollestad.materialdialogs.MaterialDialog;
import com.obsez.android.lib.filechooser.ChooserDialog;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.subscription.SubscriptionExtractor;
import org.schabi.newpipe.extractor.subscription.SubscriptionItem;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import free.rm.skytube.gui.businessobjects.preferences.BackupDatabases;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class SubscriptionsBackupsManager {
    private final Activity activity;
    private final Fragment fragment;
    private static final int EXT_STORAGE_PERM_CODE_BACKUP = 1950;
    private static final int EXT_STORAGE_PERM_CODE_IMPORT = 1951;
    private static final int IMPORT_SUBSCRIPTIONS_READ_CODE = 42;
    private static final String TAG = SubscriptionsBackupsManager.class.getSimpleName();
    private boolean isUnsubsribeAllChecked = false;
    private final CompositeDisposable compositeDisposable = new CompositeDisposable();
    public SubscriptionsBackupsManager(Activity activity, Fragment fragment) {
        this.activity = activity;
        this.fragment = fragment;
    }
    private static class Result {
        private final  List<MultiSelectListPreferenceItem> newChannels;
        private final boolean noChannelFound;
        private Result(final List<MultiSelectListPreferenceItem> newChannels, final boolean noChannelFound) {
            this.newChannels = newChannels;
            this.noChannelFound = noChannelFound;
        }
    }
    public void clearBackgroundTasks() {
        compositeDisposable.clear();
    }
    public void backupDatabases() {
        if (hasAccessToExtStorage(EXT_STORAGE_PERM_CODE_BACKUP)) {
            Toast.makeText(activity, R.string.databases_backing_up, Toast.LENGTH_SHORT).show();
            compositeDisposable.add(
                    Single.fromCallable(() -> new BackupDatabases().backupDbsToSdCard())
                            .subscribeOn(Schedulers.io())
                            .observeOn(AndroidSchedulers.mainThread())
                            .onErrorReturn(throwable -> {
                                Log.e(TAG, "Unable to backup the databases...", throwable);
                                return "";
                            })
                            .subscribe(backupPath -> {
                                String message = (!backupPath.isEmpty()) ?
                                        String.format(activity.getString(R.string.databases_backup_success),
                                                backupPath) :
                                        activity.getString(R.string.databases_backup_fail);
                                new AlertDialog.Builder(activity)
                                        .setMessage(message)
                                        .setNeutralButton(R.string.ok, null)
                                        .show();
                            })
            );
        }
    }
    public void displayFilePicker() {
        displayFilePicker(true);
    }
    private void displayFilePicker(final boolean importDb) {
        if (!hasAccessToExtStorage(importDb ? EXT_STORAGE_PERM_CODE_IMPORT : IMPORT_SUBSCRIPTIONS_READ_CODE))
            return;
        ChooserDialog dialog = new ChooserDialog(activity)
                .withStartFile((importDb ? Environment.getExternalStorageDirectory()
                        : Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS))
                        .getAbsolutePath())
                .displayPath(true)
                .withChosenListener((file, dirFile) -> {
                    if (importDb)
                        displayImportDbsBackupWarningMsg(file);
                    else {
                        Uri uri = Uri.fromFile(new File(file));
                        parseWithNewPipe(uri);
                    }
                })
                .withOnCancelListener(DialogInterface::cancel);
        if(importDb) {
            dialog.withFilter(false, false, "skytube");
        } else {
            dialog.withFilterRegex(false, false, ".*(json|xml|subscription_manager|zip|csv)$");
        }
        dialog.build().show();
    }
    private boolean hasAccessToExtStorage(int permissionRequestCode) {
        boolean hasAccessToExtStorage = true;
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            fragment.requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                    permissionRequestCode);
            hasAccessToExtStorage = false;
        }
        return hasAccessToExtStorage;
    }
    private void displayImportDbsBackupWarningMsg(final String backupFilePath) {
        new AlertDialog.Builder(activity)
                        .setMessage(R.string.databases_import_warning_message)
                        .setPositiveButton(R.string.continue_, (dialog, which) -> importDatabases(backupFilePath))
                        .setNegativeButton(R.string.cancel, null)
                        .show();
    }
    private void importDatabases(String backupFilePath) {
        Toast.makeText(activity, R.string.databases_importing, Toast.LENGTH_SHORT).show();
        compositeDisposable.add(
                Single.fromCallable(() -> {
                    BackupDatabases backupDatabases = new BackupDatabases();
                    backupDatabases.importBackupDb(backupFilePath);
                    return true;
                })
                        .subscribeOn(Schedulers.io())
                        .observeOn(AndroidSchedulers.mainThread())
                        .onErrorReturn(throwable -> {
                            Log.e(TAG, "Unable to import the databases...", throwable);
                            return false;
                        })
                        .subscribe(successfulImport -> {
                            SkyTubeApp.getSettings().updateFeedsLastUpdateTime(null);
                            new AlertDialog.Builder(activity)
                                    .setCancelable(false)
                                    .setMessage(successfulImport ? R.string.databases_import_success : R.string.databases_import_fail)
                                    .setNeutralButton(R.string.restart, (dialog, which) -> SkyTubeApp.restartApp())
                                    .show();
                        })
        );
    }
    private void parseWithNewPipe(Uri uri) {
        parseWithNewPipeBackground(uri)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(result -> {
                    importChannels(result.newChannels, result.noChannelFound);
                });
    }
    private Single<Result> parseWithNewPipeBackground(Uri uri) {
        return Single.fromCallable(() -> {
            SubscriptionExtractor extractor = NewPipeService.get().createSubscriptionExtractor();
            String extension = getExtension(uri);
            if (extractor != null && extension != null) {
                Log.i(TAG, "Parsing with " + extractor + " : " + uri);
                try (InputStream input = activity.getContentResolver().openInputStream(uri)) {
                    if ("csv".equals(extension) || "json".equals(extension) || "zip".equals(extension)) {
                        List<SubscriptionItem> items = extractor.fromInputStream(input, extension);
                        return importChannels(items);
                    }
                } catch (IOException | ExtractionException e) {
                    Log.e(TAG, "Unable to extract subscriptions: " + e.getMessage(), e);
                    SkyTubeApp.notifyUserOnError(activity, e);
                }
            }
            Log.i(TAG, "Parsing with old code : "+ uri.toString());
            return parseImportedSubscriptions(uri);
        });
    }
    private Result importChannels(final List<SubscriptionItem> items) {
        List<MultiSelectListPreferenceItem> result = new ArrayList();
        NewPipeService newPipeService = NewPipeService.get();
        SubscriptionsDb subscriptionsDb = SubscriptionsDb.getSubscriptionsDb();
        for (SubscriptionItem item : items){
            String url = item.getUrl();
            ContentId contentId = newPipeService.getContentId(url);
            if (contentId != null && contentId.getType() == StreamingService.LinkType.CHANNEL && !subscriptionsDb.isUserSubscribedToChannel(new ChannelId(contentId.getId()))) {
                result.add(new MultiSelectListPreferenceItem(contentId.getId(), item.getName()));
            }
        }
        return new Result(result, items.isEmpty());
    }
    private String getExtension(Uri uri) {
        String name = uri.toString().toLowerCase(Locale.ROOT);
        int lastDot = name.lastIndexOf('.');
        if (lastDot >= 0) {
            return name.substring(lastDot + 1);
        }
        return "";
    }
    private Result parseImportedSubscriptions(Uri uri) {
        ArrayList<MultiSelectListPreferenceItem> channels;
        String uriString = uri.toString();
        int lastIndexOf = uriString.lastIndexOf(".");
        if (lastIndexOf > 0 && uriString.substring(lastIndexOf).equalsIgnoreCase("xml")) {
            channels = parseChannelsXML(uri);
        } else {
            channels = parseChannelsJson(uri);
        }
        ArrayList<MultiSelectListPreferenceItem> newChannels = new ArrayList<>();
        for (MultiSelectListPreferenceItem channel : channels) {
            if (channel.id != null && !SubscriptionsDb.getSubscriptionsDb().isUserSubscribedToChannel(new ChannelId(channel.id))) {
                newChannels.add(channel);
            }
        }
        return new Result(newChannels, channels.isEmpty());
    }
    private void importChannels(List<MultiSelectListPreferenceItem> newChannels, boolean noChannelFound) {
        if(newChannels.size() > 0) {
            new MultiSelectListPreferenceDialog(activity, newChannels)
                    .title(R.string.import_subscriptions)
                    .positiveText(R.string.import_subscriptions)
                    .onPositive((dialog, which) -> {
                        List<MultiSelectListPreferenceItem> channelsToSubscribeTo = new ArrayList<>();
                        for(MultiSelectListPreferenceItem channel: newChannels) {
                            if(channel.isChecked)
                                channelsToSubscribeTo.add(channel);
                        }
                        if (isUnsubsribeAllChecked) {
                            compositeDisposable.add(DatabaseTasks.completableUnsubscribeFromAllChannels().andThen(
                                    subscribeToImportedChannels(channelsToSubscribeTo)
                            ).subscribe());
                        } else {
                            compositeDisposable.add(subscribeToImportedChannels(channelsToSubscribeTo).subscribe());
                        }
                    })
                    .negativeText(R.string.cancel)
                    .build()
                    .show();
        } else {
            new AlertDialog.Builder(activity)
                    .setMessage(noChannelFound ? R.string.no_channels_found : R.string.no_new_channels_found)
                    .setNeutralButton(R.string.ok, null)
                    .show();
        }
    }
    private ArrayList<MultiSelectListPreferenceItem> parseChannelsJson(Uri uri) {
        JsonArray jsonArray;
        final ArrayList<MultiSelectListPreferenceItem> channels = new ArrayList<>();
        try {
            InputStreamReader fileReader = new InputStreamReader(activity.getContentResolver().openInputStream(uri));
            jsonArray = JsonParser.parseReader(fileReader).getAsJsonArray();
            fileReader.close();
        } catch (IOException e) {
            Logger.e(this, "An error occurred while reading the file", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
            return channels;
        }
        for (JsonElement obj : jsonArray) {
            JsonObject snippet = obj.getAsJsonObject().getAsJsonObject("snippet");
            if (snippet == null) {
                continue;
            }
            JsonPrimitive channelName = snippet.getAsJsonPrimitive("title");
            JsonObject resourceId = snippet.getAsJsonObject("resourceId");
            if (resourceId == null) {
                continue;
            }
            JsonPrimitive channelId = resourceId.getAsJsonPrimitive("channelId");
            if (channelId != null && channelName != null) {
                channels.add(new MultiSelectListPreferenceItem(channelId.getAsString(), channelName.getAsString()));
            }
        }
        return channels;
    }
    private ArrayList<MultiSelectListPreferenceItem> parseChannelsXML(Uri uri) {
        final ArrayList<MultiSelectListPreferenceItem> channels = new ArrayList<>();
        Pattern channelPattern = Pattern.compile(".*channel_id=([^&]+)");
        Matcher matcher;
        try {
            XmlPullParserFactory xmlFactoryObject = XmlPullParserFactory.newInstance();
            XmlPullParser parser = xmlFactoryObject.newPullParser();
            parser.setInput(activity.getContentResolver().openInputStream(uri), null);
            int event = parser.getEventType();
            while (event != XmlPullParser.END_DOCUMENT) {
                String name = parser.getName();
                switch (event) {
                    case XmlPullParser.START_TAG:
                        break;
                    case XmlPullParser.END_TAG:
                        if (name.equals("outline")) {
                            String xmlUrl = parser.getAttributeValue(null, "xmlUrl");
                            if (xmlUrl != null) {
                                matcher = channelPattern.matcher(xmlUrl);
                                if (matcher.matches()) {
                                    String channelId = matcher.group(1);
                                    String channelName = parser.getAttributeValue(null, "title");
                                    channels.add(new MultiSelectListPreferenceItem(channelId, channelName));
                                }
                            }
                        }
                        break;
                }
                event = parser.next();
            }
        } catch (IOException e) {
            Logger.e(this, "An error occurred while reading the file", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
        } catch (XmlPullParserException e) {
            Logger.e(this, "An error occurred while attempting to parse the XML file uploaded", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
        }
        return channels;
    }
    public void displayImportSubscriptionsFromYouTubeDialog() {
        SpannableString msg = new SpannableString(activity.getText(R.string.import_subscriptions_description));
        LinkifyCompat.addLinks(msg, Linkify.WEB_URLS);
        new SkyTubeMaterialDialog(activity)
                .title(R.string.import_subscriptions)
                .content(msg)
                .positiveText(R.string.select_sub_file)
                .checkBoxPromptRes(R.string.unsubscribe_from_all_current_sibbed_channels, false, (compoundButton, b) -> isUnsubsribeAllChecked = true)
                .onPositive((dialog, which) -> displayFilePicker(false))
                .build()
                .show();
    }
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if(requestCode == IMPORT_SUBSCRIPTIONS_READ_CODE && resultCode == Activity.RESULT_OK) {
            if (data != null) {
                Uri uri = data.getData();
                parseImportedSubscriptions(uri);
            }
        }
    }
    private @NonNull Single<Object[]> subscribeToImportedChannels(final List<MultiSelectListPreferenceItem> channels) {
        return Single.fromCallable(() -> {
            final MaterialDialog dialog = new MaterialDialog.Builder(activity)
                    .content(R.string.subscribing_to_channels)
                    .progress(true, 0)
                    .build();
            dialog.show();
            return dialog;
        }).subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(Schedulers.io())
                .map(dialog -> {
                    SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
                    int success = 0;
                    for (MultiSelectListPreferenceItem selectedItem : channels) {
                        try {
                            ChannelId channelId = new ChannelId(selectedItem.id);
                            PersistentChannel channelInfo = DatabaseTasks.getChannelOrRefresh(activity, channelId, true);
                            if (!channelInfo.isSubscribed()) {
                                db.subscribe(channelInfo, Collections.emptyList());
                                success += 1;
                            }
                        } catch (NewPipeException newPipeException) {
                            Log.e(TAG, "Error: " + newPipeException.getMessage(), newPipeException);
                        }
                    }
                    return new Object[] { dialog, success };
                })
                .observeOn(AndroidSchedulers.mainThread())
                .map(inputs -> {
                    ((MaterialDialog) inputs[0]).dismiss();
                    int totalChannelsSubscribedTo = (Integer) inputs[1];
                    EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.SUBSCRIPTION_LIST_CHANGED);
                    Toast.makeText(activity,
                            String.format(SkyTubeApp.getStr(R.string.subscriptions_to_channels_imported), totalChannelsSubscribedTo),
                            Toast.LENGTH_SHORT).show();
                    SkyTubeApp.getSettings().setRefreshSubsFeedFull(true);
                    ActivityCompat.recreate(activity);
                    return inputs;
                });
    }
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        if (requestCode == EXT_STORAGE_PERM_CODE_BACKUP) {
            if (grantResults.length > 0  &&  grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                backupDatabases();
            } else {
                Toast.makeText(activity, R.string.databases_backup_fail, Toast.LENGTH_LONG).show();
            }
        }
        else if (requestCode == EXT_STORAGE_PERM_CODE_IMPORT) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                displayFilePicker();
            }
            else {
                Toast.makeText(activity, R.string.databases_import_fail, Toast.LENGTH_LONG).show();
            }
        }
        else if (requestCode == IMPORT_SUBSCRIPTIONS_READ_CODE)
        {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                displayFilePicker(false);
            }
            else {
                Toast.makeText(activity, R.string.failed_to_import_subscriptions, Toast.LENGTH_LONG).show();
            }
        }
    }
}
package free.rm.skytube.businessobjects.YouTube;
import java.util.Objects;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoPager;
public class NewPipePlaylistVideos extends NewPipeVideos {
    private String playlistId;
    @Override
    public void setQuery(String query) {
        this.playlistId = Objects.requireNonNull(query, "query missing");
    }
    @Override
    protected VideoPager createNewPager() throws NewPipeException {
        return NewPipeService.get().getPlaylistPager(Objects.requireNonNull(playlistId, "playlistId missing"));
    }
}
package free.rm.skytube.businessobjects.Sponsorblock;
import android.content.Context;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.ColorRes;
import androidx.annotation.NonNull;
import androidx.annotation.StringRes;
import org.json.JSONArray;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import free.rm.skytube.R;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class SBTasks {
    private static final String TAG = SBTasks.class.getSimpleName();
    public static class LabelAndColor{
        public final @ColorRes int color;
        public final @StringRes int label;
        LabelAndColor(@ColorRes int color, @StringRes int label) {
            this.color = color;
            this.label = label;
        }
    }
    private static final Map<String, LabelAndColor> categoryMapping;
    static {
        Map<String, LabelAndColor> colors = new HashMap();
        colors.put("sponsor", new LabelAndColor(R.color.sponsorblock_category_sponsor, R.string.sponsorblock_category_sponsor));
        colors.put("selfpromo", new LabelAndColor(R.color.sponsorblock_category_selfpromo, R.string.sponsorblock_category_selfpromo));
        colors.put("interaction", new LabelAndColor(R.color.sponsorblock_category_interaction, R.string.sponsorblock_category_interaction));
        colors.put("music_offtopic", new LabelAndColor(R.color.sponsorblock_category_music_offtopic, R.string.sponsorblock_category_music_offtopic));
        colors.put("intro", new LabelAndColor(R.color.sponsorblock_category_intro, R.string.sponsorblock_category_intro));
        colors.put("outro", new LabelAndColor(R.color.sponsorblock_category_outro, R.string.sponsorblock_category_outro));
        colors.put("preview", new LabelAndColor(R.color.sponsorblock_category_preview, R.string.sponsorblock_category_preview));
        colors.put("filler", new LabelAndColor(R.color.sponsorblock_category_filler, R.string.sponsorblock_category_filler));
        categoryMapping = Collections.unmodifiableMap(colors);
    }
    public static LabelAndColor getLabelAndColor(String category) {
        return categoryMapping.get(category);
    }
    public static Iterable<Map.Entry<String, LabelAndColor>> getAllCategories() {
        return categoryMapping.entrySet();
    }
    public static Maybe<SBVideoInfo> retrieveSponsorblockSegmentsCtx(@NonNull Context context, @NonNull VideoId videoId) {
        return Maybe.fromCallable(() -> retrieveSponsorblockSegmentsBk(videoId))
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> {
                    Log.e(TAG, "Error: " + throwable.getMessage(), throwable);
                    final String msg = (throwable.getCause() != null ? throwable.getCause() : throwable).getMessage();
                    final String toastMsg = context.getString(R.string.could_not_get_sponsorblock, msg);
                    Toast.makeText(context, toastMsg, Toast.LENGTH_LONG).show();
                })
                .subscribeOn(Schedulers.io());
    }
    public static SBVideoInfo retrieveSponsorblockSegmentsBk(@NonNull VideoId videoId) {
        Set<String> filterList = SkyTubeApp.getSettings().getSponsorblockCategories();
        if(filterList.size() == 0) return null; 
        SkyTubeApp.nonUiThread();
        StringBuilder query = new StringBuilder("[");
        for(String filterCategory : filterList) {
            query.append("%22" + filterCategory + "%22,");
        }
        query.setLength(query.length() - 1); 
        query.append("]");
        String apiUrl = "https:
        Log.d(TAG, "ApiUrl: " + apiUrl);
        try {
            JSONArray sponsorblockInfo = NewPipeService.getHttpDownloader().getJSONArray(apiUrl);
            return new SBVideoInfo(sponsorblockInfo);
        } catch(Exception e) {
            Log.w(TAG, "Failed retrieving Sponsorblock info: ", e);
            return null;
        }
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import org.schabi.newpipe.extractor.StreamingService;
public final class VideoId extends ContentId {
    final Integer timestamp;
    public VideoId(String id, String canonicalUrl, Integer timestamp) {
        super(id, canonicalUrl, StreamingService.LinkType.STREAM);
        this.timestamp = timestamp;
    }
    public Integer getTimestamp() {
        return timestamp;
    }
    @Override
    public String toString() {
        return "VideoId{" +
                "id='" + id + '\'' +
                ", canonicalUrl='" + canonicalUrl + '\'' +
                ", timestamp=" + timestamp +
                '}';
    }
    public static VideoId create(String id) {
        return new VideoId(id, String.format("https:
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import org.schabi.newpipe.extractor.InfoItem;
import org.schabi.newpipe.extractor.ListExtractor;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.channel.ChannelInfoItem;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.linkhandler.LinkHandlerFactory;
import org.schabi.newpipe.extractor.playlist.PlaylistInfoItem;
import org.schabi.newpipe.extractor.stream.StreamInfoItem;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
public class VideoPager extends Pager<InfoItem, CardData> {
    private final Set<String> seenVideos = new HashSet<>();
    public VideoPager(StreamingService streamingService, ListExtractor<? extends InfoItem> channelExtractor) {
        super(streamingService, channelExtractor);
    }
    @Override
    protected List<CardData> extract(ListExtractor.InfoItemsPage<? extends InfoItem> page) throws NewPipeException {
        List<CardData> result = new ArrayList<>(page.getItems().size());
        if (NewPipeService.DEBUG_LOG) {
            Logger.d(this, "extract from %s, items: %s", page, page.getItems().size());
        }
        int repeatCounter = 0;
        int unexpected = 0;
        for (InfoItem infoItem : page.getItems()) {
            if (infoItem instanceof StreamInfoItem) {
                String id = getId(streamLinkHandler, infoItem.getUrl());
                StreamInfoItem streamInfo = (StreamInfoItem) infoItem;
                if (seenVideos.contains(id)) {
                    repeatCounter++;
                } else {
                    seenVideos.add(id);
                    result.add(convert(streamInfo, id));
                }
            } else if (infoItem instanceof PlaylistInfoItem) {
                PlaylistInfoItem playlistInfoItem = (PlaylistInfoItem) infoItem;
                result.add(convert(playlistInfoItem, getId(playlistLinkHandler, infoItem.getUrl())));
            } else if (infoItem instanceof ChannelInfoItem) {
                ChannelInfoItem channelInfoItem = (ChannelInfoItem) infoItem;
                result.add(convert(channelInfoItem));
            } else {
                Logger.i(this, "Unexpected item %s, type:%s", infoItem, infoItem.getClass());
                unexpected ++;
            }
        }
        if (NewPipeService.DEBUG_LOG) {
            Logger.d(this, "From the requested %s, number of duplicates: %s, wrong types: %s", page.getItems().size(), repeatCounter, unexpected);
        }
        return result;
    }
    private String getId(LinkHandlerFactory handler, String url) throws NewPipeException {
        try {
            return handler.getId(url);
        } catch (ParsingException e) {
            throw new NewPipeException("Unable to convert " + url + " with " + handler, e);
        }
    }
    public List<YouTubeVideo> getNextPageAsVideos() throws NewPipeException {
        List<CardData> cards = getNextPage();
        List<YouTubeVideo> result = new ArrayList<>(cards.size());
        for (CardData cardData: cards) {
            if (cardData instanceof YouTubeVideo) {
                result.add((YouTubeVideo) cardData);
            }
        }
        return result;
    }
    protected YouTubeVideo convert(StreamInfoItem item, String id) {
        NewPipeService.DateInfo date = new NewPipeService.DateInfo(item.getUploadDate());
        if (NewPipeService.DEBUG_LOG) {
            Logger.i(this, "item %s, title=%s at %s", id, item.getName(), date);
        }
        YouTubeChannel ch = new YouTubeChannel(item.getUploaderUrl(), item.getUploaderName());
        return new YouTubeVideo(id, item.getName(), null, item.getDuration(), ch,
                item.getViewCount(), date.instant, date.exact, NewPipeService.getThumbnailUrl(id));
    }
    private CardData convert(PlaylistInfoItem playlistInfoItem, String id) {
        return new YouTubePlaylist(id, playlistInfoItem.getName(), "", null, playlistInfoItem.getStreamCount(), NewPipeUtils.getThumbnailUrl(playlistInfoItem),
                null);
    }
    private CardData convert(ChannelInfoItem channelInfoItem) {
        String url = channelInfoItem.getUrl();
        String id = getId(url);
        return new YouTubeChannel(id, channelInfoItem.getName(), channelInfoItem.getDescription(), NewPipeUtils.getThumbnailUrl(channelInfoItem), null,
                channelInfoItem.getSubscriberCount(), false, -1, System.currentTimeMillis(), null, Collections.emptyList());
    }
    private String getId(String url) {
        try {
            return channelLinkHandler.getId(url);
        } catch (ParsingException p) {
            Logger.e(this, "Unable to parse channel url "+ url, p);
            return url;
        }
    }
}
package free.rm.skytube.gui.businessobjects.updates;
import android.util.Log;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Objects;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
public class UpdatesChecker {
	private URL		latestApkUrl;
	private String	latestApkVersion;
	private String	releaseNotes;
	private final boolean	fetchReleaseNotes;
	private final String	currentVersionNumber;
	private boolean updatesAvailable;
	private static String TAG = UpdatesChecker.class.getSimpleName();
	UpdatesChecker(boolean fetchReleaseNotes, String	currentVersionNumber) {
		this.fetchReleaseNotes = fetchReleaseNotes;
		this.currentVersionNumber = currentVersionNumber;
	}
	public void checkForUpdates() {
		updatesAvailable = false;
		boolean oss = BuildConfig.FLAVOR.equalsIgnoreCase("oss");
		boolean snapshot = BuildConfig.BUILD_TYPE.equalsIgnoreCase("snapshot");
		if ((oss || snapshot) && !fetchReleaseNotes) {
			if (oss) {
				Log.d(TAG, "OSS version - will not be checking for updates.");
			} else if (snapshot) {
				Log.d(TAG, "Snapshot version - build by Github - will not be checking for updates.");
			}
		} else {
			try {
				JSONObject json = NewPipeService.getHttpDownloader().getJSONObject(BuildConfig.SKYTUBE_UPDATES_URL);
				latestApkVersion = getLatestVersionNumber(json);
				releaseNotes = getReleaseNotes(json);
				Log.d(TAG, "CURRENT_VER: " + currentVersionNumber);
				Log.d(TAG, "REMOTE_VER: " + latestApkVersion);
				if (!oss) {
					if (!Objects.equals(currentVersionNumber, latestApkVersion)) {
						this.latestApkUrl = getLatestApkUrl(json);
						updatesAvailable = latestApkUrl != null;
						Log.d(TAG, "Update available.  APK_URL: " + latestApkUrl);
					} else {
						Log.d(TAG, "Not updating.");
					}
				}
			} catch (Throwable e) {
				Log.e(TAG, "An error has occurred while checking for updates", e);
			}
		}
	}
	public URL getLatestApkUrl() {
		return latestApkUrl;
	}
	public String getLatestApkVersion() {
		return latestApkVersion;
	}
	public String getReleaseNotes() {
		return releaseNotes;
	}
	public boolean isUpdateAvailable() {
		return updatesAvailable;
	}
	private String getLatestVersionNumber(JSONObject json) throws JSONException {
		return json.getString("tag_name").substring(1);
	}
	private String getReleaseNotes(JSONObject json) throws JSONException {
		return json.getString("body");
	}
	private URL getLatestApkUrl(JSONObject json) throws JSONException, MalformedURLException {
		JSONArray assets = json.getJSONArray("assets");
		for (int i=0; i < assets.length();i ++) {
			JSONObject asset = assets.getJSONObject(i);
			String name = asset.getString("name");
			if (name != null) {
				if (name.toLowerCase().startsWith("skytube-" + BuildConfig.FLAVOR + "-")) {
					return new URL(asset.getString("browser_download_url"));
				}
			}
		}
		return null;
	}
}
 package free.rm.skytube.businessobjects.YouTube;
import java.util.Objects;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoPager;
public class NewPipeChannelVideos extends NewPipeVideos {
    private ChannelId channelId;
    public void setQuery(String query) {
        this.channelId = new ChannelId(query);
    }
    @Override
    protected VideoPager createNewPager() throws NewPipeException {
        return NewPipeService.get().getChannelPager(Objects.requireNonNull(channelId, "channelId missing"));
    }
}
package free.rm.skytube.gui.fragments.preferences;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.text.InputType;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.preference.Preference;
import androidx.preference.PreferenceFragmentCompat;
import com.afollestad.materialdialogs.MaterialDialog;
import org.schabi.newpipe.extractor.ServiceList;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.channel.ChannelInfo;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.AsyncTaskParallel;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.ChannelFilteringDb;
import free.rm.skytube.gui.businessobjects.MultiSelectListPreferenceDialog;
import free.rm.skytube.gui.businessobjects.MultiSelectListPreferenceItem;
import free.rm.skytube.gui.businessobjects.SkyTubeMaterialDialog;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
public class VideoBlockerPreferenceFragment extends PreferenceFragmentCompat {
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	@Override
	public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
		addPreferencesFromResource(R.xml.preference_video_blocker);
		final Preference channelBlacklistPreference = findPreference(getString(R.string.pref_key_channel_blacklist));
		final Preference channelWhitelistPreference = findPreference(getString(R.string.pref_key_channel_whitelist));
		initChannelFilteringPreferences(channelBlacklistPreference, channelWhitelistPreference);
		findPreference(getString(R.string.pref_key_enable_video_blocker)).setOnPreferenceChangeListener((preference, newValue) -> {
			Toast.makeText(getActivity(), R.string.setting_updated, Toast.LENGTH_LONG).show();
			return true;
		});
		findPreference(getString(R.string.pref_key_channel_filter_method)).setOnPreferenceChangeListener((preference, newValue) -> {
			initChannelFilteringPreferences((String) newValue, channelBlacklistPreference, channelWhitelistPreference);
			Toast.makeText(getActivity(), R.string.setting_updated, Toast.LENGTH_LONG).show();
			return true;
		});
		final Preference.OnPreferenceChangeListener settingUpdatesPreferenceChange = (preference, newValue) -> {
			Toast.makeText(getActivity(), R.string.setting_updated, Toast.LENGTH_LONG).show();
			return true;
		};
		findPreference(getString(R.string.pref_key_preferred_region)).setOnPreferenceChangeListener(settingUpdatesPreferenceChange);
		findPreference(getString(R.string.pref_key_preferred_languages)).setOnPreferenceClickListener(preference -> {
			new PreferredLanguageDialog(getActivity()).show();
			return true;
		});
		findPreference(getString(R.string.pref_key_lang_detection_video_filtering)).setOnPreferenceChangeListener(settingUpdatesPreferenceChange);
		findPreference(getString(R.string.pref_key_low_views_filter)).setOnPreferenceChangeListener(settingUpdatesPreferenceChange);
		findPreference(getString(R.string.pref_key_dislikes_filter)).setOnPreferenceChangeListener(settingUpdatesPreferenceChange);
	}
	private void initChannelFilteringPreferences(Preference channelBlacklistPreference, Preference channelWhitelistPreference) {
		final String channelFilter = SkyTubeApp.getPreferenceManager().getString(getString(R.string.pref_key_channel_filter_method), getString(R.string.channel_blacklisting_filtering));
		initChannelFilteringPreferences(channelFilter, channelBlacklistPreference, channelWhitelistPreference);
	}
	private void initChannelFilteringPreferences(String channelFilter, Preference channelBlacklistPreference, Preference channelWhitelistPreference) {
		if (channelFilter.equals(getString(R.string.channel_blacklisting_filtering))) {
			initChannelBlacklistingPreference(channelBlacklistPreference);
			channelBlacklistPreference.setEnabled(true);
			channelWhitelistPreference.setEnabled(false);
		} else if (channelFilter.equals(getString(R.string.channel_whitelisting_filtering))) {
			initChannelWhitelistingPreference(channelWhitelistPreference);
			channelBlacklistPreference.setEnabled(false);
			channelWhitelistPreference.setEnabled(true);
		} else {
			Logger.e(this, "Unknown channel filtering preference", channelFilter);
		}
		EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.SUBSCRIPTION_LIST_CHANGED);
	}
	private void initChannelBlacklistingPreference(final Preference channelBlacklistPreference) {
		channelBlacklistPreference.setOnPreferenceClickListener(preference -> {
			new DenyChannelsDialog(getActivity()).show();
			return true;
		});
	}
	private void initChannelWhitelistingPreference(final Preference channelWhitelistPreference) {
		channelWhitelistPreference.setOnPreferenceClickListener(preference -> {
			new AllowChannelsDialog(getActivity()).show();
			return true;
		});
	}
	private class PreferredLanguageDialog extends MultiSelectListPreferenceDialog {
		public PreferredLanguageDialog(@NonNull Context context) {
			super(context);
			setItems(getLanguagesAvailable());
			title(R.string.pref_title_preferred_languages);
			onPositive((dialog, which) -> {
				final Set<String> preferredLangIsoCodes = getSelectedItemsIds();
				if (preferredLangIsoCodes.size() > 0) {
					SharedPreferences sharedPref = SkyTubeApp.getPreferenceManager();
					SharedPreferences.Editor editor = sharedPref.edit();
					editor.putStringSet(getString(R.string.pref_key_preferred_languages), getSelectedItemsIds());
					editor.apply();
					Toast.makeText(getActivity(), R.string.preferred_lang_updated, Toast.LENGTH_LONG).show();
				} else {
					Toast.makeText(getActivity(), R.string.no_preferred_lang_selected, Toast.LENGTH_LONG).show();
				}
			});
		}
		private List<MultiSelectListPreferenceItem> getLanguagesAvailable() {
			List<MultiSelectListPreferenceItem> languagesAvailable = getLanguagesList();
			Set<String>                         preferredLanguages = getPreferredLanguages();
			for (MultiSelectListPreferenceItem language : languagesAvailable) {
				language.isChecked = preferredLanguages.contains(language.id);
			}
			return languagesAvailable;
		}
		private List<MultiSelectListPreferenceItem> getLanguagesList() {
			String[] languagesNames = getResources().getStringArray(R.array.languages_names);
			String[] languagesIsoCodes = getResources().getStringArray(R.array.languages_iso639_codes);
			List<MultiSelectListPreferenceItem> languageAvailableList = new ArrayList<>();
			if (BuildConfig.DEBUG  &&  (languagesNames.length != languagesIsoCodes.length)) {
				throw new AssertionError("languages names array is NOT EQUAL to languages ISO codes array.");
			}
			for (int i = 0;  i < languagesNames.length;  i++) {
				languageAvailableList.add(new MultiSelectListPreferenceItem(languagesIsoCodes[i], languagesNames[i]));
			}
			return languageAvailableList;
		}
		private Set<String> getPreferredLanguages() {
			SharedPreferences pref = SkyTubeApp.getPreferenceManager();
			return pref.getStringSet(getString(R.string.pref_key_preferred_languages), getDefaultPreferredLanguages());
		}
		private Set<String> getDefaultPreferredLanguages() {
			String[] languagesIsoCodes = getResources().getStringArray(R.array.languages_iso639_codes);
			return new HashSet<>(Arrays.asList(languagesIsoCodes));
		}
	}
	private class DenyChannelsDialog extends MultiSelectListPreferenceDialog {
		public DenyChannelsDialog(@NonNull Context context) {
			super(context);
			setItems(ChannelFilteringDb.getChannelFilteringDb().getDeniedChannels());
			title(R.string.pref_title_channel_blacklist);
			positiveText(R.string.unblock);
			onPositive((dialog, which) -> {
				final List<MultiSelectListPreferenceItem> channels = getSelectedItems();
				if (channels != null  &&  !channels.isEmpty()) {
					final boolean success = ChannelFilteringDb.getChannelFilteringDb().removeDenyList(channels);
					Toast.makeText(getActivity(),
							success ? R.string.channel_blacklist_updated : R.string.channel_blacklist_update_failure,
							Toast.LENGTH_LONG)
							.show();
				}
				dialog.dismiss();
			});
		}
	}
	private class AllowChannelsDialog extends MultiSelectListPreferenceDialog implements OnGetChannelInfoListener {
		public AllowChannelsDialog(@NonNull Context context) {
			super(context);
			setItems(ChannelFilteringDb.getChannelFilteringDb().getAllowedChannels());
			autoDismiss(false);
			title(R.string.pref_title_channel_whitelist);
			positiveText(R.string.block);
			onPositive((dialog, which) -> {
				compositeDisposable.add(
						toYouTubeChannelList(getSelectedItems())
								.flatMapSingle(channel -> channel.blockChannel(false))
								.reduce((blockChannel1, blockChannel2) -> blockChannel1 && blockChannel2)
								.subscribeOn(Schedulers.io())
								.observeOn(AndroidSchedulers.mainThread())
								.subscribe(success ->
										Toast.makeText(getActivity(),
												success ? R.string.channel_unwhitelist_success
														: R.string.channel_unwhitelist_failure,
												Toast.LENGTH_LONG).show()
								)
				);
				dialog.dismiss();
			});
			neutralText(R.string.add);
			onNeutral((dialog, which) -> displayInputChannelUrlDialog());
		}
		private Flowable<YouTubeChannel> toYouTubeChannelList(final List<MultiSelectListPreferenceItem> channels) {
			return Flowable.fromIterable(channels)
					.map(channel -> new YouTubeChannel(channel.id, channel.text));
		}
		private void displayInputChannelUrlDialog() {
			new SkyTubeMaterialDialog(getActivity())
					.autoDismiss(true)
					.content(R.string.input_channel_url)
					.positiveText(R.string.add)
					.inputType(InputType.TYPE_TEXT_VARIATION_URI)
					.input("https:
					.show();
		}
		@Override
		public void onChannelInfo(MultiSelectListPreferenceItem channel) {
			if (channel != null  &&  channel.id != null  &&  !channel.id.isEmpty()) {
				if (!addItem(channel)) {
					Toast.makeText(getActivity(), R.string.channel_already_whitelisted, Toast.LENGTH_LONG).show();
				} else {
					final boolean success = ChannelFilteringDb.getChannelFilteringDb().allowChannel(channel.id, channel.text);
					Toast.makeText(getActivity(),
							success ? R.string.channel_whitelist_updated : R.string.channel_whitelist_update_failure,
							Toast.LENGTH_LONG)
							.show();
				}
			}
		}
	}
	private class GetChannelIdFromUrlTask extends AsyncTaskParallel<Void, Void, MultiSelectListPreferenceItem> {
		private String                      channelUrl;
		private OnGetChannelInfoListener    onGetChannelInfoListener;
		private MaterialDialog              getChannelInfoDialog;
		public GetChannelIdFromUrlTask(String channelUrl, OnGetChannelInfoListener onGetChannelInfoListener) {
			this.channelUrl = channelUrl;
			this.onGetChannelInfoListener = onGetChannelInfoListener;
		}
		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			getChannelInfoDialog = new SkyTubeMaterialDialog(getActivity())
					.progress(true, 0)
					.content(R.string.please_wait)
					.positiveText("")
					.negativeText("")
					.show();
		}
		@Override
		protected MultiSelectListPreferenceItem doInBackground(Void... v) {
			MultiSelectListPreferenceItem channel = null;
			try {
				NewPipeService.get();
				StreamingService youtubeService = ServiceList.YouTube;
				ChannelInfo channelInfo = ChannelInfo.getInfo(youtubeService, channelUrl);
				channel = new MultiSelectListPreferenceItem(channelInfo.getId(), channelInfo.getName(), false);
			} catch (Exception tr) {
				lastException = tr;
				Logger.e(this, "An error occurred while getting channel ID", tr);
			}
			return channel;
		}
		@Override
		protected void onPostExecute(MultiSelectListPreferenceItem channel) {
			super.onPostExecute(channel);
			onGetChannelInfoListener.onChannelInfo(channel);
			getChannelInfoDialog.dismiss();
			getChannelInfoDialog = null;
		}
	}
	private interface OnGetChannelInfoListener {
		void onChannelInfo(MultiSelectListPreferenceItem channel);
	}
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import org.schabi.newpipe.extractor.InfoItem;
import org.schabi.newpipe.extractor.ListExtractor;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.playlist.PlaylistExtractor;
import java.util.List;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
public class PlaylistPager extends VideoPager {
    private YouTubePlaylist playlist;
    private final PlaylistExtractor playlistExtractor;
    public PlaylistPager(StreamingService streamingService, PlaylistExtractor playlistExtractor) {
        super(streamingService, playlistExtractor);
        this.playlistExtractor = playlistExtractor;
    }
    @Override
    protected List<CardData> extract(ListExtractor.InfoItemsPage<? extends InfoItem> page) throws NewPipeException {
        if (playlist == null) {
            try {
                String uploaderUrl = playlistExtractor.getUploaderUrl();
                String channelId = uploaderUrl != null ? getStreamingService().getChannelLHFactory().fromUrl(uploaderUrl).getId() : null;
                playlist = new YouTubePlaylist(
                        playlistExtractor.getId(),
                        playlistExtractor.getName(),
                        "" ,
                        null ,
                        playlistExtractor.getStreamCount(),
                        NewPipeUtils.getThumbnailUrl(playlistExtractor.getThumbnails()),
                        new YouTubeChannel(channelId, playlistExtractor.getUploaderName())
                );
            } catch (ParsingException e) {
                e.printStackTrace();
            }
        }
        return super.extract(page);
    }
    public YouTubePlaylist getPlaylist() {
        return playlist;
    }
}
package free.rm.skytube.gui.fragments.preferences;
import android.content.SharedPreferences;
import android.content.res.XmlResourceParser;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatDelegate;
import androidx.core.os.LocaleListCompat;
import androidx.core.util.Pair;
import androidx.preference.ListPreference;
import androidx.preference.Preference;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
public class VideoPlayerPreferenceFragment extends BasePreferenceFragment {
	@Override
	public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
		addPreferencesFromResource(R.xml.preference_video_player);
		if (BuildConfig.FLAVOR.equals("oss")) {
			final ListPreference    videoPlayersListPref = getPreferenceManager().findPreference(getString(R.string.pref_key_choose_player));
			final CharSequence[]    videoPlayersList = videoPlayersListPref.getEntries();
			CharSequence[]          modifiedVideoPlayersList = Arrays.copyOf(videoPlayersList, videoPlayersList.length - 1);
			videoPlayersListPref.setEntries(modifiedVideoPlayersList);
		}
		Preference creditsPref = findPreference(getString(R.string.pref_key_switch_volume_and_brightness));
		creditsPref.setOnPreferenceClickListener(preference -> {
			SkyTubeApp.getSettings().showTutorialAgain();
			return true;
		});
		configureCountrySelector();
		configureLanguageSelector();
	}
    private List<String> getLanguages() {
        List<String> result = new ArrayList<>();
        try {
            XmlResourceParser xpp = getResources().getXml(R.xml._generated_res_locale_config);
            while (xpp.getEventType() != XmlPullParser.END_DOCUMENT) {
                if (xpp.getEventType() == XmlPullParser.START_TAG) {
                    if ("locale".equals(xpp.getName()) && xpp.getAttributeCount() > 0 && "name".equals(xpp.getAttributeName(0))) {
                        result.add(xpp.getAttributeValue(0));
                    }
                }
                xpp.next();
            }
            Logger.i(this, "Language list:"+result);
        } catch(XmlPullParserException|IOException e) {
            Logger.e(this, "Unable to parse locale config: "+e.getMessage(), e);
        }
        return result;
    }
    private static Comparator<Pair<String, String>> ENGLISH_COMPARATOR = Comparator.comparing(pair -> "en".equals(pair.first) ? 0 : 1);
    private static Comparator<Pair<String, String>> COMPARATOR = ENGLISH_COMPARATOR.thenComparing(pair -> pair.second);
    private void configureLanguageSelector() {
        ListPreference languageSelector = findPreference(getString(R.string.pref_key_app_language));
        List<String> languages = getLanguages();
        LocaleListCompat localeListCompat = AppCompatDelegate.getApplicationLocales();
        Locale defaultLocale = localeListCompat.isEmpty() ? Locale.getDefault() : localeListCompat.get(0);
        Logger.i(this, "Default locale: " + defaultLocale + " -> language:" + defaultLocale.getLanguage());
        List<Pair<String, String>> languageWithCodes = languages.stream()
                .map(code -> Pair.create(code, new Locale(code).getDisplayLanguage(defaultLocale)))
                .sorted(COMPARATOR)
                .collect(Collectors.toList());
        int size = languageWithCodes.size();
        String[] localeCodes = new String[size];
        String[] localeNames = new String[size];
        for (int i = 0;i<size;i++) {
            Pair<String, String> locale = languageWithCodes.get(i);
            localeNames[i] = locale.second;
            localeCodes[i] = locale.first;
        }
        languageSelector.setEntries(localeNames);
        languageSelector.setEntryValues(localeCodes);
        languageSelector.setValue(defaultLocale.getLanguage());
    }
	private void configureCountrySelector() {
		ListPreference countrySelector = findPreference(getString(R.string.pref_key_default_content_country));
		String[] countryCodes = SkyTubeApp.getStringArray(R.array.country_codes);
		String[] countryNames = SkyTubeApp.getStringArray(R.array.country_names);
		countrySelector.setEntryValues(countryCodes);
		String[] countryNamesWithSystemDefault = new String[countryNames.length];
		System.arraycopy(countryNames, 1, countryNamesWithSystemDefault, 1, countryNames.length - 1);
		countryNamesWithSystemDefault[0] = getString(R.string.system_default_country);
		countrySelector.setEntries(countryNamesWithSystemDefault);
	}
	@Override
	public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
		Logger.i(this, "onSharedPreferenceChanged %s - key: %s", sharedPreferences, key);
		if (getString(R.string.pref_key_default_content_country).equals(key)) {
			String newCountry = sharedPreferences.getString(key, null);
			NewPipeService.setCountry(newCountry);
			EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.CONTENT_COUNTRY);
		}
		if (getString(R.string.pref_key_app_language).equals(key)) {
			String newLanguage = sharedPreferences.getString(key, null);
			LocaleListCompat appLocale = LocaleListCompat.forLanguageTags(newLanguage);
			AppCompatDelegate.setApplicationLocales(appLocale);
		}
	}
}
package free.rm.skytube.gui.businessobjects.adapters;
import android.content.Context;
import android.graphics.Color;
import android.os.AsyncTask;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.Toast;
import androidx.annotation.NonNull;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import com.mikepenz.iconics.IconicsColor;
import com.mikepenz.iconics.IconicsDrawable;
import com.mikepenz.iconics.IconicsSize;
import com.mikepenz.iconics.typeface.library.materialdesigniconic.MaterialDesignIconic;
import org.schabi.newpipe.extractor.comments.CommentsInfoItem;
import org.schabi.newpipe.extractor.stream.Description;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import free.rm.skytube.R;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.AsyncTaskParallel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.CommentPager;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeUtils;
import free.rm.skytube.databinding.CommentBinding;
import free.rm.skytube.gui.businessobjects.views.Linker;
public class CommentsAdapter extends BaseExpandableListAdapter {
    private CommentPager commentThreadPager;
    private GetCommentsTask getCommentsTask = null;
    private ExpandableListView expandableListView;
    private View commentsProgressBar;
    private View noVideoCommentsView;
    private View disabledCommentsView;
    private LayoutInflater layoutInflater;
    private Context context;
    private IconicsDrawable heartedIcon;
    private IconicsDrawable pinnedIcon;
    private Linker.CurrentActivity currentActivity;
    private Map<String, List<CommentsInfoItem>> replyMap = new HashMap<>();
    private Set<String> currentlyFetching = new HashSet<>();
    private static final String TAG = CommentsAdapter.class.getSimpleName();
    public CommentsAdapter(Context context, Linker.CurrentActivity currentActivity, String videoId, ExpandableListView expandableListView, View commentsProgressBar, View noVideoCommentsView, View disabledCommentsView) {
        this.context = context;
        this.currentActivity = currentActivity;
        this.heartedIcon = new IconicsDrawable(context)
                .icon(MaterialDesignIconic.Icon.gmi_favorite)
                .color(IconicsColor.colorInt(Color.RED))
                .size(IconicsSize.TOOLBAR_ICON_SIZE)
				.padding(IconicsSize.TOOLBAR_ICON_PADDING);
        this.pinnedIcon = new IconicsDrawable(context)
                .icon(MaterialDesignIconic.Icon.gmi_pin)
                .color(IconicsColor.colorInt(Color.RED))
                .size(IconicsSize.TOOLBAR_ICON_SIZE)
				.padding(IconicsSize.TOOLBAR_ICON_PADDING);
        try {
            this.commentThreadPager = NewPipeService.get().getCommentPager(videoId);
            this.expandableListView = expandableListView;
            this.expandableListView.setAdapter(this);
            this.expandableListView.setOnGroupClickListener((parent, v, groupPosition, id) -> true);
            this.commentsProgressBar = commentsProgressBar;
            this.noVideoCommentsView = noVideoCommentsView;
            this.disabledCommentsView = disabledCommentsView;
            this.layoutInflater = LayoutInflater.from(expandableListView.getContext());
            this.getCommentsTask = new GetCommentsTask();
            this.getCommentsTask.execute();
        } catch (Exception e) {
            Log.e(TAG, "fetching comments failed for  " + videoId + " - " + e.getMessage(), e);
            SkyTubeApp.notifyUserOnError(context, e);
        }
    }
    @Override
    public int getGroupCount() {
        return commentThreadPager != null ? commentThreadPager.getCommentCount() : 0;
    }
    @Override
    public int getChildrenCount(int groupPosition) {
        if (commentThreadPager != null) {
            CommentsInfoItem comment = commentThreadPager.getComment(groupPosition);
            if (comment != null && comment.getReplyCount() > 0) {
                return (replyMap.get(comment.getCommentId()) != null) ? comment.getReplyCount() : 0;
            }
        }
        return 0;
    }
    @Override
    public Object getGroup(int groupPosition) {
        return commentThreadPager != null ? commentThreadPager.getComment(groupPosition) : 0;
    }
    @Override
    public Object getChild(int groupPosition, int childPosition) {
        return getComment(groupPosition, childPosition);
    }
    @Override
    public long getGroupId(int groupPosition) {
        return groupPosition;
    }
    @Override
    public long getChildId(int groupPosition, int childPosition) {
        return (groupPosition * 1024) + childPosition;
    }
    @Override
    public boolean hasStableIds() {
        return true;
    }
    @Override
    public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
        CommentsInfoItem comment = commentThreadPager.getComment(groupPosition);
        final CommentViewHolder viewHolder = getCommentViewHolder(convertView, parent);
        if (comment != null) {
            viewHolder.updateInfo(comment, true, groupPosition);
        }
        if (groupPosition == getGroupCount() - 1) {
            synchronized (this) {
                if (this.getCommentsTask == null) {
                    Log.w(TAG, "Getting next page of comments...");
                    this.getCommentsTask = new GetCommentsTask();
                    this.getCommentsTask.execute();
                }
            }
        }
        if (isExpanded) {
            ensureRepliesLoaded(comment);
        }
        return viewHolder.getView();
    }
    private synchronized void ensureRepliesLoaded(CommentsInfoItem comment) {
        if (replyMap.get(comment.getCommentId()) == null && comment.getReplies() != null) {
            new GetReplies().executeInParallel(comment);
        }
    }
    private synchronized void addReplies(CommentsInfoItem comment, List<CommentsInfoItem> newReplies) {
        List<CommentsInfoItem> replies = replyMap.get(comment.getCommentId());
        if (replies == null) {
            replies = new ArrayList<>();
            replyMap.put(comment.getCommentId(), replies);
        }
        replies.addAll(newReplies);
    }
    @Override
    public View getChildView(int groupPosition, int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {
        Log.d(TAG, "getChildView " + groupPosition + " " + childPosition + " lastChild=" + isLastChild);
        CommentsInfoItem comment = getComment(groupPosition, childPosition);
        final CommentViewHolder viewHolder = getCommentViewHolder(convertView, parent);
        if (comment != null) {
            viewHolder.updateInfo(comment, false, groupPosition);
        }
        return viewHolder.getView();
    }
    private synchronized CommentsInfoItem getComment(int idx, int childIdx) {
        CommentsInfoItem parent = commentThreadPager.getComment(idx);
        if (parent == null) {
            return null;
        }
        List<CommentsInfoItem> replies = replyMap.get(parent.getCommentId());
        if (replies != null && 0 <= childIdx) {
            int currentReplyListSize = replies.size();
            if (currentReplyListSize < parent.getReplyCount() && currentReplyListSize - 5 <= childIdx) {
                synchronized (currentlyFetching) {
                    if (parent.getReplies() != null && currentlyFetching.add(parent.getCommentId())) {
                        Log.i(TAG, String.format("Fetching more replies for %s - currentReplyListSize: %s, childIdx: %s - %s", parent.getCommentId(), currentReplyListSize, childIdx, parent.getReplyCount()));
                        new GetReplies().executeInParallel(parent);
                    } else {
                        Log.i(TAG, String.format("No reply fetch for %s - currentReplyListSize: %s, childIdx: %s", parent.getCommentId(), currentReplyListSize, childIdx));
                    }
                }
            }
            if (childIdx < currentReplyListSize) {
                return replies.get(childIdx);
            }
        }
        return null;
    }
    protected void removeFromCurrentlyFetching(CommentsInfoItem item) {
        synchronized (currentlyFetching) {
            currentlyFetching.remove(item.getCommentId());
        }
    }
    @Override
    public boolean isChildSelectable(int groupPosition, int childPosition) {
        return false;
    }
    private @NonNull CommentViewHolder getCommentViewHolder(View convertView, ViewGroup parent) {
        if (convertView != null) {
            Object tag = convertView.getTag();
            if (tag instanceof CommentViewHolder) {
                return (CommentViewHolder) tag;
            }
        }
        final View row = layoutInflater.inflate(R.layout.comment, parent, false);
        final CommentViewHolder viewHolder = new CommentViewHolder(CommentBinding.bind(row));
        row.setTag(viewHolder);
        return viewHolder;
    }
    private class CommentViewHolder {
        private final CommentBinding binding;
        protected CommentViewHolder(CommentBinding binding) {
            this.binding = binding;
        }
        public View getView() {
            return binding.getRoot();
        }
        protected void updateInfo(final CommentsInfoItem comment, boolean isTopLevelComment, final int groupPosition) {
            binding.heartedView.setImageDrawable(heartedIcon);
            binding.pinnedView.setImageDrawable(pinnedIcon);
            binding.heartedView.setVisibility(comment.isHeartedByUploader() ? View.VISIBLE : View.GONE);
            binding.pinnedView.setVisibility(comment.isPinned() ? View.VISIBLE : View.GONE);
            binding.commentPaddingView.setVisibility(isTopLevelComment ? View.GONE : View.VISIBLE);
            binding.authorTextView.setText(comment.getUploaderName());
            Linker.configure(binding.commentTextView, currentActivity);
            Linker.setTextAndLinkify(binding.commentTextView, getCommentText(comment));
            binding.commentDateTextView.setText(comment.getTextualUploadDate());
            binding.commentUpvotesTextView.setText(String.valueOf(comment.getLikeCount()));
            Glide.with(context)
                    .load(NewPipeUtils.getThumbnailUrl(comment))
                    .apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
                    .into(binding.commentThumbnailImageView);
            binding.commentThumbnailImageView.setOnClickListener(view -> {
                if (comment.getUploaderUrl() != null) {
                    SkyTubeApp.launchChannel(new ChannelId(comment.getUploaderUrl()), context);
                }
            });
            ViewGroup.LayoutParams lp = binding.commentThumbnailImageView.getLayoutParams();
            lp.width = (int) SkyTubeApp.getDimension(isTopLevelComment ? R.dimen.top_level_comment_thumbnail_width : R.dimen.child_comment_thumbnail_width);
            if (isTopLevelComment && comment.getReplyCount() > 0) {
                binding.viewAllRepliesTextView.setVisibility(View.VISIBLE);
                binding.getRoot().setOnClickListener(viewReplies -> {
                    if (expandableListView.isGroupExpanded(groupPosition)) {
                        binding.viewAllRepliesTextView.setText(R.string.view_replies);
                        expandableListView.collapseGroup(groupPosition);
                    } else {
                        binding.viewAllRepliesTextView.setText(R.string.hide_replies);
                        expandableListView.expandGroup(groupPosition);
                    }
                });
            } else {
                binding.viewAllRepliesTextView.setVisibility(View.GONE);
            }
        }
    }
    private static String getCommentText(CommentsInfoItem infoItem) {
        Description description = infoItem.getCommentText();
        return description != null ? description.getContent() : "";
    }
    private class GetReplies extends AsyncTaskParallel<CommentsInfoItem, Void, List<String>> {
        @Override
        protected List<String> doInBackground(CommentsInfoItem... repliesFor) {
            List<String> ids = new ArrayList<>(repliesFor.length);
            for (CommentsInfoItem item : repliesFor) {
                try {
                    List<CommentsInfoItem> replies = commentThreadPager.getPageAndExtract(item.getReplies());
                    addReplies(item, replies);
                    if (commentThreadPager.isHasNextPage()) {
                        item.setReplies(commentThreadPager.getNextPageInfo());
                    } else {
                        item.setReplies(null);
                    }
                    ids.add(item.getCommentId());
                } catch (NewPipeException e) {
                    lastException = e;
                    Log.e(TAG, "Unable to get replies " + item + " -> " + e.getMessage(), e);
                } finally {
                    removeFromCurrentlyFetching(item);
                }
            }
            return ids;
        }
        @Override
        protected void onPostExecute(List<String> commentsInfoItems) {
            if (!commentsInfoItems.isEmpty()) {
                CommentsAdapter.this.notifyDataSetChanged();
            }
            super.onPostExecute(commentsInfoItems);
        }
        @Override
        protected void showErrorToUi() {
            if (lastException != null) {
                Toast.makeText(CommentsAdapter.this.context, lastException.getMessage(), Toast.LENGTH_LONG).show();
            }
        }
    }
    private class GetCommentsTask extends AsyncTask<Void, Void, List<CommentsInfoItem>> {
        @Override
        protected void onPreExecute() {
            commentsProgressBar.setVisibility(View.VISIBLE);
            noVideoCommentsView.setVisibility(View.GONE);
        }
        @Override
        protected List<CommentsInfoItem> doInBackground(Void... params) {
            return commentThreadPager.getSafeNextPage();
        }
        @Override
        protected void onPostExecute(List<CommentsInfoItem> newComments) {
            SkyTubeApp.notifyUserOnError(expandableListView.getContext(), commentThreadPager.getLastException());
            if (newComments != null) {
                if (newComments.size() > 0) {
                    CommentsAdapter.this.notifyDataSetChanged();
                }
                if (commentThreadPager.isCommentsDisabled() && disabledCommentsView != null) {
                    disabledCommentsView.setVisibility(View.VISIBLE);
                } else if (commentThreadPager.getCommentCount() == 0) {
                    noVideoCommentsView.setVisibility(View.VISIBLE);
                }
            }
            commentsProgressBar.setVisibility(View.GONE);
            getCommentsTask = null;
        }
    }
    public static BaseExpandableListAdapter createAdapter(Context context, Linker.CurrentActivity currentActivity, String videoId, ExpandableListView expandableListView, View commentsProgressBar, View noVideoCommentsView, View disabledCommentsView) {
        if (SkyTubeApp.getSettings().isUseNewPipe()) {
            return new CommentsAdapter(context, currentActivity, videoId, expandableListView, commentsProgressBar, noVideoCommentsView, disabledCommentsView);
        } else {
            return new LegacyCommentsAdapter(context, videoId, expandableListView, commentsProgressBar, noVideoCommentsView);
        }
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import org.schabi.newpipe.extractor.ListExtractor;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.comments.CommentsExtractor;
import org.schabi.newpipe.extractor.comments.CommentsInfoItem;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class CommentPager extends Pager<CommentsInfoItem, CommentsInfoItem> {
    private Boolean disabledComments;
    private final List<CommentsInfoItem> allComments = new ArrayList<>();
    private final CommentsExtractor commentsExtractor;
    private Integer commentCount;
    CommentPager(StreamingService streamingService, CommentsExtractor commentsExtractor) throws ExtractionException, IOException {
        super(streamingService, commentsExtractor);
        this.commentsExtractor = commentsExtractor;
    }
    @Override
    protected List<CommentsInfoItem> process(ListExtractor.InfoItemsPage<? extends CommentsInfoItem> page) throws NewPipeException, ExtractionException {
        this.commentCount = commentsExtractor.getCommentsCount();
        this.disabledComments = commentsExtractor.isCommentsDisabled();
        List<CommentsInfoItem> result = super.process(page);
        allComments.addAll(result);
        return new ArrayList<>(result);
    }
    @Override
    protected List<CommentsInfoItem> extract(ListExtractor.InfoItemsPage<? extends CommentsInfoItem> page) throws ExtractionException {
        return (List<CommentsInfoItem>) page.getItems();
    }
    public CommentsInfoItem getComment(int idx) {
        return 0 <= idx && idx < allComments.size() ? allComments.get(idx) : null;
    }
    public boolean isCommentsDisabled() {
        return disabledComments != null ? disabledComments : false;
    }
    public int getCommentCount() {
        return commentCount != null ? commentCount.intValue() : -1;
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import androidx.annotation.Nullable;
import org.schabi.newpipe.extractor.InfoItem;
import org.schabi.newpipe.extractor.ListExtractor;
import org.schabi.newpipe.extractor.Page;
import org.schabi.newpipe.extractor.channel.tabs.ChannelTabExtractor;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.playlist.PlaylistInfoItem;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
public class GetPlaylistsForChannel implements YouTubeTasks.ChannelPlaylistFetcher {
    static class Paging {
        private final YouTubeChannel channel;
        @Nullable private final ChannelTabExtractor extractor;
        private Page nextPage;
        private boolean firstPage = false;
        Paging(YouTubeChannel channel, ChannelTabExtractor extractor) {
            this.channel = channel;
            this.extractor = extractor;
        }
        private synchronized List<InfoItem> getNextPage() throws ExtractionException, IOException {
            if (extractor == null) {
                return Collections.emptyList();
            }
            extractor.fetchPage();
            if (firstPage) {
                if (Page.isValid(nextPage)) {
                    ListExtractor.InfoItemsPage<InfoItem> res = extractor.getPage(nextPage);
                    nextPage = res.getNextPage();
                    return res.getItems();
                } else {
                    return Collections.emptyList();
                }
            } else {
                ListExtractor.InfoItemsPage<InfoItem> res = extractor.getInitialPage();
                firstPage = true;
                nextPage = res.getNextPage();
                return res.getItems();
            }
        }
        private List<YouTubePlaylist> getNextPlaylists() throws ExtractionException, IOException {
            List<InfoItem> infoItems = getNextPage();
            return infoItems.stream()
                    .filter(PlaylistInfoItem.class::isInstance)
                    .map(PlaylistInfoItem.class::cast).map(item ->
                    new YouTubePlaylist(item.getUrl(), item.getName(), "", null, item.getStreamCount(), NewPipeUtils.getThumbnailUrl(item),
                            channel)
            ).collect(Collectors.toList());
        }
    }
    private final YouTubeChannel channel;
    private Paging paging;
    public GetPlaylistsForChannel(YouTubeChannel channel) {
        this.channel = channel;
    }
    @Override
    public void reset() {
        paging = null;
    }
    @Override
    public YouTubeChannel getChannel() {
        return channel;
    }
    @Override
    public List<YouTubePlaylist> getNextPlaylists() throws IOException, ExtractionException, NewPipeException {
        return getPaging().getNextPlaylists();
    }
    private synchronized Paging getPaging() throws NewPipeException, ParsingException {
        SkyTubeApp.nonUiThread();
        if (paging == null) {
            NewPipeService.ChannelWithExtractor cwe = NewPipeService.get().getChannelWithExtractor(channel.getChannelId());
            paging = new Paging(cwe.channel, cwe.findPlaylistTab());
        }
        return paging;
    }
}
package free.rm.skytube.businessobjects.YouTube;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoPager;
public class NewPipeVideoBySearch extends NewPipeVideos {
    private String query;
    @Override
    public void setQuery(String query) {
        this.query = query;
    }
    @Override
    protected VideoPager createNewPager() throws NewPipeException {
        return NewPipeService.get().getSearchResult(query);
    }
}
package free.rm.skytube.businessobjects.YouTube;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.exceptions.AccountTerminatedException;
import org.schabi.newpipe.extractor.exceptions.ContentNotAvailableException;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.exceptions.ReCaptchaException;
import java.io.IOException;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.Utils;
import free.rm.skytube.businessobjects.VideoCategory;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeAPIKey;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.YouTube.newpipe.PlaylistPager;
import free.rm.skytube.businessobjects.db.LocalChannelTable;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import free.rm.skytube.businessobjects.interfaces.GetDesiredStreamListener;
import free.rm.skytube.businessobjects.model.Status;
import free.rm.skytube.gui.businessobjects.adapters.PlaylistsGridAdapter;
import free.rm.skytube.gui.businessobjects.adapters.VideoGridAdapter;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Scheduler;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
import io.reactivex.rxjava3.subjects.CompletableSubject;
import static free.rm.skytube.app.SkyTubeApp.getContext;
public class YouTubeTasks {
    private static final String TAG = YouTubeTasks.class.getSimpleName();
    private static final Scheduler scheduler = Schedulers.from(Executors.newFixedThreadPool(4));
    public interface ChannelPlaylistFetcher {
        void reset();
        YouTubeChannel getChannel();
        List<YouTubePlaylist> getNextPlaylists() throws IOException, ExtractionException, NewPipeException;
    }
    private YouTubeTasks() { }
    public static Single<Integer> refreshAllSubscriptions(Context context, @Nullable Consumer<List<ChannelId>> subscriptionListConsumer, @Nullable Consumer<Integer> newVideosFound) {
        Single<List<ChannelId>>  subscriptionList = SubscriptionsDb.getSubscriptionsDb().getSubscribedChannelIdsAsync();
        if (subscriptionListConsumer!= null) {
            subscriptionList = subscriptionList.observeOn(AndroidSchedulers.mainThread())
                    .doOnSuccess(list -> subscriptionListConsumer.accept(list))
                    .observeOn(Schedulers.io());
        }
        return subscriptionList
                .flatMap(channelIds -> refreshSubscriptions(channelIds, newVideosFound))
                .doOnError(error -> {
                    SkyTubeApp.notifyUserOnError(context, error);
                })
                .doOnSuccess(changed -> {
                    Log.i("YouTubeTasks", "refreshAllSubscriptions: " + changed);
                    SkyTubeApp.getSettings().updateFeedsLastUpdateTime();
                });
    }
    private static Single<Integer> refreshSubscriptions(@NonNull List<ChannelId> channelIds, @Nullable Consumer<Integer> newVideosFound) {
        if (SkyTubeApp.getSettings().isUseNewPipe() || !YouTubeAPIKey.get().isUserApiKeySet()) {
            return YouTubeTasks.getBulkSubscriptionVideos(channelIds, newVideosFound);
        } else {
            return YouTubeTasks.getSubscriptionVideos(channelIds, newVideosFound);
        }
    }
    public static Maybe<List<YouTubePlaylist>> getChannelPlaylists(@NonNull Context ctx,
                                                                   @NonNull ChannelPlaylistFetcher channelPlaylistFetcher,
                                                                   @NonNull PlaylistsGridAdapter playlistsGridAdapter,
                                                                   boolean shouldReset) {
        if (shouldReset) {
            channelPlaylistFetcher.reset();
            playlistsGridAdapter.clearList();
        }
        return Single.fromCallable(channelPlaylistFetcher::getNextPlaylists)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> {
                    Log.e(TAG, "Error:" + throwable.getLocalizedMessage(), throwable);
                    SkyTubeApp.notifyUserOnError(ctx, throwable);
                })
                .doOnSuccess(playlistsGridAdapter::appendList)
                .onErrorComplete();
    }
    private static Single<Integer> getBulkSubscriptionVideos(@NonNull List<ChannelId> channelIds, @Nullable Consumer<Integer> newVideosFound) {
        final SubscriptionsDb subscriptionsDb = SubscriptionsDb.getSubscriptionsDb();
        final AtomicBoolean changed = new AtomicBoolean(false);
        final AtomicReference<ReCaptchaException> recaptcha = new AtomicReference<>();
        return Flowable.fromIterable(channelIds)
                .flatMapSingle(channelId ->
                        Single.fromCallable(() -> {
                            SkyTubeApp.nonUiThread();
                            if (recaptcha.get() != null) {
                                Log.i(TAG, "Re-captcha needed, done for now");
                                return 0;
                            }
                            Map<String, Long> alreadyKnownVideos = subscriptionsDb.getSubscribedChannelVideosByChannelToTimestamp(channelId);
                            List<YouTubeVideo> newVideos = fetchVideos(subscriptionsDb, alreadyKnownVideos, channelId);
                            List<YouTubeVideo> detailedList = new ArrayList<>();
                            if (!newVideos.isEmpty()) {
                                PersistentChannel dbChannel = subscriptionsDb.getCachedChannel(channelId);
                                for (YouTubeVideo vid : newVideos) {
                                    YouTubeVideo details;
                                    try {
                                        details = NewPipeService.get().getDetails(vid.getId());
                                        if (vid.getPublishTimestampExact()) {
                                            details.setPublishTimestamp(vid.getPublishTimestamp());
                                            details.setPublishTimestampExact(vid.getPublishTimestampExact());
                                        }
                                        details.setChannel(dbChannel.channel());
                                        detailedList.add(details);
                                    } catch (ReCaptchaException reCaptchaException) {
                                        recaptcha.set(reCaptchaException);
                                        Log.e(TAG, String.format("ReCaptcha error: %s, open %s to solve", reCaptchaException.getMessage(), reCaptchaException.getUrl()));
                                        return 0;
                                    } catch (ExtractionException | IOException e) {
                                        String errorMsg = String.format("Error during parsing video page for id=%s, channel: %s - name: '%s' msg:%s", vid.getId(), vid.getSafeChannelId(), vid.getSafeChannelName(), e.getMessage());
                                        Log.e(TAG, errorMsg, e);
                                    }
                                }
                                changed.compareAndSet(false, true);
                                subscriptionsDb.saveChannelVideos(detailedList, dbChannel, true);
                            }
                            return detailedList.size();
                        })
                                .subscribeOn(scheduler)
                                .observeOn(AndroidSchedulers.mainThread())
                                .doOnSuccess(newYouTubeVideos -> {
                                    if (newVideosFound != null) {
                                        newVideosFound.accept(newYouTubeVideos);
                                    }
                                    EventBus.getInstance().notifyChannelNewVideos(channelId, newYouTubeVideos);
                                })
                )
                .collect(Collectors.summingInt(Integer::intValue))
                .map(result -> {
                    ReCaptchaException reCaptchaException = recaptcha.get();
                    if (reCaptchaException != null) {
                        throw reCaptchaException;
                    }
                    return result;
                }).subscribeOn(Schedulers.io());
    }
    private static List<YouTubeVideo> fetchVideos(@NonNull SubscriptionsDb subscriptionsDb,
                                                  @NonNull Map<String, Long> alreadyKnownVideos,
                                                  @NonNull ChannelId channelId) {
        try {
            List<YouTubeVideo> videos = NewPipeService.get().getVideosFromFeedOrFromChannel(channelId);
            videos.removeIf(video -> {
                Long storedTs = alreadyKnownVideos.get(video.getId());
                if (storedTs != null && Boolean.TRUE.equals(video.getPublishTimestampExact()) && !storedTs.equals(video.getPublishTimestamp())) {
                    subscriptionsDb.setPublishTimestamp(video);
                    Log.i(TAG, String.format("Updating publish timestamp for %s - %s with %s",
                            video.getId(), video.getTitle(), new Date(video.getPublishTimestamp())));
                }
                return storedTs != null;
            });
            return videos;
        } catch (NewPipeException e) {
            handleNewPipeException(channelId, e);
            return Collections.emptyList();
        }
    }
    private static void handleNewPipeException(@NonNull ChannelId channelId, @NonNull NewPipeException e) {
        if (e.getCause() instanceof AccountTerminatedException) {
            Log.e(TAG, "Account terminated for "+ channelId +" error: "+e.getMessage(), e);
            SubscriptionsDb.getSubscriptionsDb().setChannelState(channelId, Status.ACCOUNT_TERMINATED);
        } else if (e.getCause() instanceof ContentNotAvailableException) {
            Log.e(TAG, "Channel doesn't exists "+ channelId +" error: "+e.getMessage(), e);
            SubscriptionsDb.getSubscriptionsDb().setChannelState(channelId, Status.NOT_EXISTS);
        } else {
            Log.e(TAG, "Error during fetching channel page for " + channelId + ",msg:" + e.getMessage(), e);
        }
    }
    private static Single<List<YouTubeVideo>> getChannelVideos(@NonNull ChannelId channelId,
                                                            @Nullable Long publishedAfter,
                                                            boolean filterSubscribedVideos,
                                                            @Nullable Consumer<Integer> newVideosFound) {
        if (!YouTubeAPIKey.get().isUserApiKeySet()) {
            throw new IllegalStateException("Only valid if custom YouTube key is set!");
        }
        final SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
        return Single.fromCallable(() -> {
            final GetChannelVideosFull getChannelVideosInterface = new GetChannelVideosFull();
            getChannelVideosInterface.init();
            getChannelVideosInterface.setPublishedAfter(publishedAfter != null
                    ? publishedAfter : ZonedDateTime.now().minusMonths(1).toInstant().toEpochMilli());
            getChannelVideosInterface.setChannelQuery(channelId, filterSubscribedVideos);
            return getChannelVideosInterface.getNextVideos();
        })
                .onErrorReturnItem(Collections.emptyList())
                .map(videos -> {
                    List<YouTubeVideo> realVideos = new ArrayList<>(videos.size());
                    for (CardData cd : videos) {
                        if (cd instanceof YouTubeVideo) {
                            realVideos.add((YouTubeVideo) cd);
                        }
                    }
                    PersistentChannel channel = db.getCachedChannel(channelId);
                    db.saveChannelVideos(realVideos, channel, true);
                    return realVideos;
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(newYouTubeVideos -> {
                    if (newVideosFound != null) {
                        newVideosFound.accept(newYouTubeVideos.size());
                    }
                    EventBus.getInstance().notifyChannelNewVideos(channelId, newYouTubeVideos.size());
                })
                .doOnError(throwable ->
                    Toast.makeText(getContext(),
                        String.format(getContext().getString(R.string.could_not_get_videos),
                        db.getCachedChannel(channelId).channel().getTitle()),
                        Toast.LENGTH_LONG).show()
                );
    }
    public static Single<YouTubePlaylist> getPlaylist(@NonNull Context context, @NonNull String playlistId) {
        return Single.fromCallable(() -> {
            final PlaylistPager pager = NewPipeService.get().getPlaylistPager(playlistId);
            final List<YouTubeVideo> firstPage = pager.getNextPageAsVideos();
            return pager.getPlaylist();
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> SkyTubeApp.notifyUserOnError(context, throwable));
    }
    private static Single<Integer> getSubscriptionVideos(@NonNull List<ChannelId> channelIds, @Nullable Consumer<Integer> newVideosFound) {
        final Long publishedAfter = SkyTubeApp.getSettings().getFeedsLastUpdateTime();
        final AtomicBoolean changed = new AtomicBoolean(false);
        return Flowable.fromIterable(channelIds)
            .flatMapSingle(channelId ->
                YouTubeTasks.getChannelVideos(channelId, publishedAfter, true, newVideosFound)
                    .doOnSuccess(videos -> {
                        if (!videos.isEmpty()) {
                            changed.compareAndSet(false, true);
                        }
                        EventBus.getInstance().notifyChannelNewVideos(channelId, videos.size());
                    })
                    .doOnError(throwable ->
                        Log.e(TAG, "Interrupt in semaphore.acquire:" + throwable.getMessage(), throwable)
                    )
                )
                .collect(Collectors.summingInt(videos -> videos.size()))
                .subscribeOn(Schedulers.io());
    }
    public static Single<String> getVideoDescription(@NonNull YouTubeVideo youTubeVideo) {
        return Single.fromCallable(() -> {
            if (youTubeVideo.getDescription() != null) {
                return youTubeVideo.getDescription();
            }
            final YouTubeVideo freshDetails = NewPipeService.get().getDetails(youTubeVideo.getId());
            youTubeVideo.setDescription(freshDetails.getDescription());
            youTubeVideo.setLikeDislikeCount(freshDetails.getLikeCountNumber(), freshDetails.getDislikeCountNumber());
            return youTubeVideo.getDescription();
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .onErrorReturn(throwable -> {
                    Log.e(TAG, "Unable to get video details, where id=" + youTubeVideo.getId(), throwable);
                    return SkyTubeApp.getStr(R.string.error_get_video_desc);
                });
    }
    public static Maybe<YouTubeVideo> getVideoDetails(@NonNull Context context,
                                                      @NonNull ContentId content) {
        return Maybe.fromCallable(() -> NewPipeService.get().getDetails(content.getId()))
                .subscribeOn(Schedulers.io())
                .map(video -> {
                    Log.i(TAG, "Update video :" + video.getTitle() +
                            " - like:" + video.getLikeCountNumber() + " dislike:" + video.getDislikeCountNumber() + " view : "+video.getViewsCountInt());
                    SubscriptionsDb.getSubscriptionsDb().updateVideo(video);
                    return video;
                })
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> {
                    Log.e(TAG, "Unable to get video details, where id=" + content, throwable);
                    SkyTubeApp.notifyUserOnError(context, throwable);
                })
                .onErrorComplete();
    }
    public static Maybe<YouTubeVideo> getVideoDetails(@NonNull Context context,
                                                      @NonNull Intent intent) {
        final ContentId content = SkyTubeApp.getUrlFromIntent(context, intent);
        Utils.isTrue(content.getType() == StreamingService.LinkType.STREAM, "Content is a video:"+content);
        return getVideoDetails(context, content);
    }
    public static Completable getDesiredStream(@NonNull YouTubeVideo youTubeVideo,
                                                    @NonNull GetDesiredStreamListener listener) {
        return Single.fromCallable(() -> NewPipeService.get().getStreamInfoByVideoId(youTubeVideo.getId()))
                .subscribeOn(Schedulers.io())
                .doOnError(listener::onGetDesiredStreamError)
                .onErrorComplete()
                .map(streamInfo -> {
                    youTubeVideo.updateFromStreamInfo(streamInfo);
                    SubscriptionsDb.getSubscriptionsDb().updateVideo(youTubeVideo);
                    return streamInfo;
                })
                .observeOn(AndroidSchedulers.mainThread())
                .flatMapCompletable(streamInfo -> {
                    listener.onGetDesiredStream(streamInfo, youTubeVideo);
                    return CompletableSubject.create();
                });
    }
    public static Maybe<Long> getDislikeCountFromApi(@NonNull String videoId) {
        return Maybe.fromCallable(() -> NewPipeService.get().getDislikeCountFromApi(videoId))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread());
    }
    public static Maybe<List<CardData>> getYouTubeVideos(@NonNull GetYouTubeVideos getYouTubeVideos,
                                                         @NonNull VideoGridAdapter videoGridAdapter,
                                                         @Nullable SwipeRefreshLayout swipeRefreshLayout,
                                                         boolean clearList) {
        getYouTubeVideos.resetKey();
        final YouTubeChannel channel = videoGridAdapter.getYouTubeChannel();
        final Context context = videoGridAdapter.getContext();
        if (swipeRefreshLayout != null) {
            swipeRefreshLayout.setRefreshing(true);
        }
        final boolean subscriptionFeedVideos = videoGridAdapter.getCurrentVideoCategory() == VideoCategory.SUBSCRIPTIONS_FEED_VIDEOS;
        return Maybe.fromCallable(() -> {
            final List<CardData> videosList;
            if (clearList && subscriptionFeedVideos) {
                final int currentSize = videoGridAdapter.getItemCount();
                List<CardData> result = new ArrayList<>(currentSize);
                boolean hasNew;
                do {
                    final List<CardData> nextVideos = getYouTubeVideos.getNextVideos();
                    hasNew = !nextVideos.isEmpty();
                    result.addAll(nextVideos);
                } while(result.size() < currentSize && hasNew);
                videosList = result;
            } else {
                videosList = getYouTubeVideos.getNextVideos();
            }
            if (videosList != null) {
                final List<CardData> filteredVideos;
                if (videoGridAdapter.getCurrentVideoCategory().isVideoFilteringEnabled()) {
                    filteredVideos = new VideoBlocker().filter(videosList);
                } else {
                    filteredVideos = videosList;
                }
                if (channel != null && channel.isUserSubscribed()) {
                    for (CardData video : filteredVideos) {
                        if (video instanceof YouTubeVideo) {
                            channel.addYouTubeVideo((YouTubeVideo) video);
                        }
                    }
                    SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
                    PersistentChannel persistentChannel = db.getCachedChannel(channel.getChannelId());
                    db.saveChannelVideos(channel.getYouTubeVideos(), persistentChannel, false);
                }
                return filteredVideos;
            } else {
                return Collections.<CardData>emptyList();
            }
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(error -> {
                    SkyTubeApp.notifyUserOnError(context, error);
                })
                .doOnSuccess(videosList -> {
                    SkyTubeApp.notifyUserOnError(context, getYouTubeVideos.getLastException());
                    if (clearList) {
                        videoGridAdapter.clearList();
                    }
                    videoGridAdapter.appendList(videosList);
                    videoGridAdapter.notifyVideoGridUpdated();
                })
                .doOnTerminate(() -> {
                    if(swipeRefreshLayout != null) {
                        swipeRefreshLayout.setRefreshing(false);
                    }
                });
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import androidx.annotation.Nullable;
import org.schabi.newpipe.extractor.InfoItem;
import org.schabi.newpipe.extractor.ListExtractor;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.stream.StreamInfoItem;
import java.util.List;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
public class VideoPagerWithChannel extends VideoPager {
    private final YouTubeChannel channel;
    public VideoPagerWithChannel(StreamingService streamingService, ListExtractor<? extends InfoItem> channelExtractor, YouTubeChannel channel) {
        super(streamingService, channelExtractor);
        this.channel = channel;
    }
    public YouTubeChannel getChannel() {
        return channel;
    }
    @Override
    protected YouTubeVideo convert(StreamInfoItem item, String id) {
        NewPipeService.DateInfo date = new NewPipeService.DateInfo(item.getUploadDate());
        if (NewPipeService.DEBUG_LOG) {
            Logger.d(this, "item %s, title=%s at %s", id, item.getName(), date);
        }
        YouTubeChannel ch = channel != null ? channel : new YouTubeChannel(item.getUploaderUrl(), item.getUploaderName());
        return new YouTubeVideo(id, item.getName(), null, item.getDuration(), ch,
                item.getViewCount(), date.instant, date.exact, NewPipeService.getThumbnailUrl(id));
    }
    public PersistentChannel getNextPageAsVideosAndUpdateChannel(@Nullable PersistentChannel persistentChannel) throws NewPipeException {
        List<YouTubeVideo> videos = getNextPageAsVideos();
        channel.getYouTubeVideos().addAll(videos);
        long lastPublish = videos.stream().mapToLong(YouTubeVideo::getPublishTimestamp).max().orElse(0);
        channel.setLastVideoTime(lastPublish);
        channel.setUserSubscribed(persistentChannel != null ? persistentChannel.isSubscribed() : false);
        return SubscriptionsDb.getSubscriptionsDb().cacheChannel(persistentChannel, channel);
    }
}
package free.rm.skytube.app;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Environment;
import androidx.annotation.StringRes;
import androidx.preference.PreferenceManager;
import java.io.File;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import free.rm.skytube.R;
import free.rm.skytube.app.enums.Policy;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.VideoStream.VideoQuality;
import free.rm.skytube.businessobjects.YouTube.VideoStream.VideoResolution;
import free.rm.skytube.gui.fragments.MainFragment;
import free.rm.skytube.gui.fragments.SubscriptionsFeedFragment;
public class Settings {
    private final SkyTubeApp app;
    private static final String TUTORIAL_COMPLETED = "YouTubePlayerActivity.TutorialCompleted";
    private static final String LATEST_RELEASE_NOTES_DISPLAYED = "Settings.LATEST_RELEASE_NOTES_DISPLAYED";
    private static final String FLAG_REFRESH_FEED_FROM_CACHE = "SubscriptionsFeedFragment.FLAG_REFRESH_FEED_FROM_CACHE";
    private static final String FLAG_REFRESH_FEED_FULL = "SubscriptionsFeedFragment.FLAG_REFRESH_FEED_FULL";
    private static final int    REFRESH_TIME_HOURS = 3;
    private static final long   REFRESH_TIME_IN_MS = REFRESH_TIME_HOURS * (1000L*3600L);
    Settings(SkyTubeApp app) {
        this.app = app;
    }
    void migrate() {
        SharedPreferences sharedPreferences = getSharedPreferences();
        migrate(sharedPreferences, "pref_preferred_resolution", R.string.pref_key_maximum_res);
        migrate(sharedPreferences, "pref_preferred_resolution_mobile", R.string.pref_key_maximum_res_mobile);
        migrate(sharedPreferences, "pref_key_video_preferred_resolution", R.string.pref_key_video_download_maximum_resolution);
        setDefault(sharedPreferences, R.string.pref_key_video_quality, VideoQuality.BEST_QUALITY.name());
        setDefault(sharedPreferences, R.string.pref_key_video_quality_for_downloads, VideoQuality.BEST_QUALITY.name());
        setDefault(sharedPreferences, R.string.pref_key_video_quality_on_mobile, VideoQuality.LEAST_BANDWITH.name());
        setDefault(sharedPreferences, R.string.pref_key_use_newer_formats, Build.VERSION.SDK_INT > 16);
        setDefault(sharedPreferences, R.string.pref_key_playback_speed, "1.0");
        Set<String> defaultTabs = new HashSet<>();
        defaultTabs.add(MainFragment.FEATURED_VIDEOS_FRAGMENT);
        setDefault(sharedPreferences, R.string.pref_key_hide_tabs, defaultTabs);
        setDefault(sharedPreferences, R.string.pref_key_default_tab_name, MainFragment.MOST_POPULAR_VIDEOS_FRAGMENT);
    }
    private void migrate(SharedPreferences sharedPreferences, String oldKey, @StringRes int newKey) {
        String oldValue = sharedPreferences.getString(oldKey, null);
        if (oldValue != null) {
            String newKeyStr = app.getString(newKey);
            Logger.i(this, "Migrate %s : %s into %s", oldKey, oldValue, newKeyStr);
            final SharedPreferences.Editor editor = sharedPreferences.edit();
            editor.putString(newKeyStr, oldValue);
            editor.remove(oldKey);
            editor.commit();
        }
    }
    private void setDefault(SharedPreferences sharedPreferences, @StringRes int key, Object defaultValue) {
        String keyStr = app.getString(key);
        if (!sharedPreferences.contains(keyStr)) {
            final SharedPreferences.Editor editor = sharedPreferences.edit();
            Logger.i(this, "Set default %s to %s", keyStr, defaultValue);
            if (defaultValue instanceof String) {
                editor.putString(keyStr, (String) defaultValue);
            } else if (defaultValue instanceof Boolean) {
                editor.putBoolean(keyStr, (Boolean) defaultValue);
            } else if (defaultValue instanceof Set) {
                editor.putStringSet(keyStr, (Set<String>) defaultValue);
            } else {
                throw new IllegalArgumentException("Default value is " + defaultValue + " for " + keyStr);
            }
            editor.commit();
        }
    }
    public String getStr(int stringResId) {
        return app.getString(stringResId);
    }
    public Set<String> getSponsorblockCategories() {
        String[] defaultFilterList = SkyTubeApp.getStringArray(R.array.sponsorblock_filtering_list_default_values);
        Set<String> filterList = SkyTubeApp.getPreferenceManager().getStringSet("pref_key_sponsorblock_category_list", new HashSet<String>(Arrays.asList(defaultFilterList)));
        return filterList;
    }
    public boolean isSponsorblockEnabled() {
        return SkyTubeApp.getPreferenceManager().getBoolean("pref_key_enable_sponsorblock", false);
    }
    public boolean isUseDislikeApi() {
        return getPreference(R.string.pref_key_use_dislike_api, false);
    }
    public boolean isDownloadToSeparateFolders() {
        return getPreference(R.string.pref_key_download_to_separate_directories,false);
    }
    public Set<String> getHiddenTabs() {
        return getPreference(R.string.pref_key_hide_tabs, Collections.emptySet());
    }
    public Policy getWarningMeteredPolicy() {
        String currentValue = getSharedPreferences().getString(getStr(R.string.pref_key_mobile_network_usage_policy),
                getStr(R.string.pref_metered_network_usage_value_ask));
        return Policy.valueOf(currentValue.toUpperCase());
    }
    public String getPreferredContentCountry() {
        String defaultCountryCode = Locale.getDefault().getCountry();
        String code = getPreference(R.string.pref_key_default_content_country, "");
        Logger.i(this, "Default country code is %s - app selection: %s", defaultCountryCode, code);
        return (code != null && !code.isEmpty()) ? code : defaultCountryCode;
    }
    public boolean isPlaybackStatusEnabled() {
        return !getPreference(R.string.pref_key_disable_playback_status, false);
    }
    public StreamSelectionPolicy getDesiredVideoResolution(boolean forDownload, boolean onMetered) {
        SharedPreferences prefs = getSharedPreferences();
        String maxKey = SkyTubeApp.getStr(forDownload ? R.string.pref_key_video_download_maximum_resolution : R.string.pref_key_maximum_res);
        String maxResIdValue = prefs.getString(maxKey, Integer.toString(VideoResolution.DEFAULT_VIDEO_RES_ID));
        String minKey = SkyTubeApp.getStr(forDownload ? R.string.pref_key_video_download_minimum_resolution : R.string.pref_key_minimum_res);
        String minResIdValue = prefs.getString(minKey, null);
        String qualityKey = SkyTubeApp.getStr(forDownload ? R.string.pref_key_video_quality_for_downloads : R.string.pref_key_video_quality);
        String qualityValue = prefs.getString(qualityKey, null);
        if (onMetered) {
            maxResIdValue = prefs.getString(SkyTubeApp.getStr(R.string.pref_key_maximum_res_mobile), maxResIdValue);
            minResIdValue = prefs.getString(SkyTubeApp.getStr(R.string.pref_key_minimum_res_mobile), minResIdValue);
            qualityValue = prefs.getString(SkyTubeApp.getStr(R.string.pref_key_video_quality_on_mobile), qualityValue);
        }
        VideoResolution maxResolution = VideoResolution.videoResIdToVideoResolution(maxResIdValue);
        VideoResolution minResolution = VideoResolution.videoResIdToVideoResolution(minResIdValue);
        VideoQuality quality = VideoQuality.valueOf(qualityValue);
        boolean useNewFormats = prefs.getBoolean(SkyTubeApp.getStr(R.string.pref_key_use_newer_formats), false);
        return new StreamSelectionPolicy(!forDownload && useNewFormats, maxResolution, minResolution, quality);
    }
    public StreamSelectionPolicy getDesiredVideoResolution(boolean forDownload) {
        return getDesiredVideoResolution(forDownload, SkyTubeApp.isActiveNetworkMetered());
    }
    public boolean isDisableSearchHistory() {
        return getSharedPreferences().getBoolean(SkyTubeApp.getStr(R.string.pref_key_disable_search_history), false);
    }
    public int getFeedUpdaterInterval() {
        return Integer.parseInt(getPreference(R.string.pref_key_feed_notification, "0"));
    }
    public void setWarningMobilePolicy(Policy warnPolicy) {
        setPreference(R.string.pref_key_mobile_network_usage_policy, warnPolicy.name().toLowerCase());
    }
    public boolean isDisableGestures() {
        return getPreference(R.string.pref_key_disable_screen_gestures, false);
    }
    public boolean isEnableVideoBlocker() {
        return getPreference(R.string.pref_key_enable_video_blocker, true);
    }
    public boolean isChannelDenyListEnabled() {
        final String defValue = getStr(R.string.channel_blacklisting_filtering);
        final String channelFilter = getPreference(R.string.pref_key_channel_filter_method, defValue);
        return channelFilter.equals(defValue);
    }
    public void setDisableGestures(boolean disableGestures) {
        setPreference(R.string.pref_key_disable_screen_gestures, disableGestures);
    }
    public boolean isSwitchVolumeAndBrightness() {
        return getPreference(R.string.pref_key_switch_volume_and_brightness, false);
    }
    public void setRefreshSubsFeedFromCache(boolean flag) {
        setPreference(FLAG_REFRESH_FEED_FROM_CACHE, flag);
    }
    public boolean isRefreshSubsFeedFromCache() {
        return getPreference(FLAG_REFRESH_FEED_FROM_CACHE, false);
    }
    public void setRefreshSubsFeedFull(boolean flag) {
        setPreference(FLAG_REFRESH_FEED_FULL, flag);
    }
    public boolean isRefreshSubsFeedFull() {
        return getPreference(FLAG_REFRESH_FEED_FULL, false);
    }
    public boolean isFullRefreshTimely() {
        Long subscriptionsLastUpdated = getFeedsLastUpdateTime();
        if (subscriptionsLastUpdated == null) {
            return true;
        }
        long threeHoursAgo = System.currentTimeMillis() - REFRESH_TIME_IN_MS;
        return subscriptionsLastUpdated <= threeHoursAgo;
    }
    public boolean wasTutorialDisplayedBefore() {
        boolean wasTutorialDisplayedBefore = getPreference(TUTORIAL_COMPLETED, false);
        setPreference(TUTORIAL_COMPLETED, true);
        return wasTutorialDisplayedBefore;
    }
    public void showTutorialAgain() {
        setPreference(TUTORIAL_COMPLETED, false);
    }
    public Long getFeedsLastUpdateTime() {
        long l = getSharedPreferences().getLong(SkyTubeApp.KEY_SUBSCRIPTIONS_LAST_UPDATED, -1);
        return (l != -1)  ?  l  :  null;
    }
    public void updateFeedsLastUpdateTime() {
        updateFeedsLastUpdateTime(System.currentTimeMillis());
    }
    public void updateFeedsLastUpdateTime(Long dateTimeInMs) {
        setPreference(SkyTubeApp.KEY_SUBSCRIPTIONS_LAST_UPDATED, dateTimeInMs != null ? dateTimeInMs : -1);
    }
    public void setDownloadFolder(String dir) {
        setPreference(R.string.pref_key_video_download_folder, dir);
    }
    public String getDownloadFolder(String defaultValue) {
        return getPreference(R.string.pref_key_video_download_folder, defaultValue);
    }
    public File getDownloadParentFolder() {
        String parentDirectory = getDownloadFolder(null);
        return parentDirectory != null ? new File(parentDirectory) : Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
    }
    private void setPreference(@StringRes int resId, boolean value) {
        setPreference(getStr(resId), value);
    }
    private void setPreference(String key, boolean value) {
        final SharedPreferences.Editor editor = getSharedPreferences().edit();
        editor.putBoolean(key, value);
        editor.apply();
    }
    private void setPreference(String preferenceName, Long value) {
        final SharedPreferences.Editor editor = getSharedPreferences().edit();
        editor.putLong(preferenceName, value);
        editor.apply();
    }
    private void setPreference(String preferenceName, String value) {
        final SharedPreferences.Editor editor = getSharedPreferences().edit();
        editor.putString(preferenceName, value);
        editor.apply();
    }
    private void setPreference(@StringRes int resId, String value) {
        setPreference(getStr(resId), value);
    }
    private String getPreference(@StringRes int resId, String defaultValue) {
        return getSharedPreferences().getString(SkyTubeApp.getStr(resId), defaultValue);
    }
    private boolean getPreference(@StringRes int resId, boolean defaultValue) {
        return getSharedPreferences().getBoolean(SkyTubeApp.getStr(resId), defaultValue);
    }
    private boolean getPreference(String preference, boolean defaultValue) {
        return getSharedPreferences().getBoolean(preference, defaultValue);
    }
    private Set<String> getPreference(@StringRes int resId, Set<String> defaultValue) {
        return getSharedPreferences().getStringSet(SkyTubeApp.getStr(resId), defaultValue);
    }
    private SharedPreferences getSharedPreferences() {
        return PreferenceManager.getDefaultSharedPreferences(app) ;
    }
    public String getDisplayedReleaseNoteTag() {
        return getSharedPreferences().getString(LATEST_RELEASE_NOTES_DISPLAYED, "");
    }
    public void setDisplayedReleaseNoteTag(String newValue) {
        setPreference(LATEST_RELEASE_NOTES_DISPLAYED, newValue);
    }
    public boolean isUseNewPipe() {
        return getPreference(R.string.pref_use_default_newpipe_backend, true);
    }
    public float getDefaultPlaybackSpeed() {
        try {
            return Float.parseFloat(getPreference(R.string.pref_key_playback_speed, "1.0"));
        } catch (NumberFormatException nfe) {
            return 1.0F;
        }
    }
}
package free.rm.skytube.businessobjects.YouTube.newpipe;
import free.rm.skytube.businessobjects.YouTube.NewPipeVideos;
public class NewPipeTrendingItems extends NewPipeVideos {
    @Override
    protected VideoPager createNewPager() throws NewPipeException {
        return NewPipeService.get().getTrending();
    }
}