/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.internal.RelationshipLength;
import org.neo4j.cypherdsl.core.internal.RelationshipTypes;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/RelationshipPattern.html">RelationshipPattern</a>.
 *
 * @author Michael J. Simons
 * @author Philipp Tölle
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Relationship extends RelationshipPattern, PropertyContainer, ExposesProperties<Relationship>,
	ExposesPatternLengthAccessors<Relationship> {
	/**
	 * While the direction in the schema package is centered around the node, the direction here is the direction between two nodes.
	 *
	 * @since 1.0
	 */
	@API(status = INTERNAL, since = "1.0")
	enum Direction {
		/**
		 * Left to right
		 */
		LTR("-", "->"),
		/**
		 * Right to left
		 */
		RTL("<-", "-"),
		/**
		 * None
		 */
		UNI("-", "-");
		Direction(String symbolLeft, String symbolRight) {
			this.symbolLeft = symbolLeft;
			this.symbolRight = symbolRight;
		}
		private final String symbolLeft;
		private final String symbolRight;
		/**
		 * @return The symbol to render on the left side of the relationship types.
		 */
		@API(status = INTERNAL)
		public String getSymbolLeft() {
			return symbolLeft;
		}
		/**
		 * @return The symbol to render on the right side of the relationship types.
		 */
		@API(status = INTERNAL)
		public String getSymbolRight() {
			return symbolRight;
		}
	}
	/**
	 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/RelationshipDetail.html">RelationshipDetail</a>.
	 */
	@API(status = STABLE, since = "1.0")
	final class Details implements Visitable {
		/**
		 * The direction between the nodes of the relationship.
		 */
		private final Direction direction;
		@SuppressWarnings("squid:S3077") // Symbolic name is unmodifiable
		private volatile SymbolicName symbolicName;
		private final RelationshipTypes types;
		private final RelationshipLength length;
		private final Properties properties;
		private final Where innerPredicate;
		static Details create(Direction direction, SymbolicName symbolicName, String... types) {
			List<String> listOfTypes = Arrays.stream(types)
				.filter(type -> !(type == null || type.isEmpty())).toList();
			return create(direction, symbolicName, 	listOfTypes.isEmpty()  ? null : RelationshipTypes.of(types));
		}
		static Details create(Direction direction, SymbolicName symbolicName, RelationshipTypes types) {
			return new Details(direction, symbolicName, types, null, null, null);
		}
		private Details(Direction direction,
			SymbolicName symbolicName,
			RelationshipTypes types,
			RelationshipLength length,
			Properties properties,
			Where innerPredicate
		) {
			this.direction = Optional.ofNullable(direction).orElse(Direction.UNI);
			this.symbolicName = symbolicName;
			this.types = types;
			this.length = length;
			this.properties = properties;
			this.innerPredicate = innerPredicate;
		}
		/**
		 * Internal helper method indicating whether the details have content or not.
		 *
		 * @return true if any of the details are filled
		 */
		public boolean hasContent() {
			return this.symbolicName != null || this.types != null || this.length != null || this.properties != null;
		}
		Details named(SymbolicName newSymbolicName) {
			Assertions.notNull(newSymbolicName, "Symbolic name is required.");
			return new Details(this.direction, newSymbolicName, this.types, this.length, this.properties, this.innerPredicate);
		}
		Details with(Properties newProperties) {
			return new Details(this.direction, this.symbolicName, this.types, this.length, newProperties, this.innerPredicate);
		}
		Details unbounded() {
			return new Details(this.direction, this.symbolicName, this.types, RelationshipLength.unbounded(), this.properties, this.innerPredicate);
		}
		Details inverse() {
			if (this.direction == Direction.UNI) {
				return this;
			}
			return new Details(this.direction == Direction.LTR ? Direction.RTL : Direction.LTR, null, this.types, this.length, this.properties, this.innerPredicate);
		}
		Details where(Expression predicate) {
			return new Details(this.direction, this.symbolicName, this.types, this.length, this.properties, Where.from(predicate));
		}
		Details min(Integer minimum) {
			if (minimum == null && (this.length == null || this.length.getMinimum() == null)) {
				return this;
			}
			RelationshipLength newLength = Optional.ofNullable(this.length)
				.map(l -> RelationshipLength.of(minimum, l.getMaximum()))
				.orElseGet(() -> RelationshipLength.of(minimum, null));
			return new Details(this.direction, this.symbolicName, this.types, newLength, properties, this.innerPredicate);
		}
		Details max(Integer maximum) {
			if (maximum == null && (this.length == null || this.length.getMaximum() == null)) {
				return this;
			}
			RelationshipLength newLength = Optional.ofNullable(this.length)
				.map(l -> RelationshipLength.of(l.getMinimum(), maximum))
				.orElseGet(() -> RelationshipLength.of(null, maximum));
			return new Details(this.direction, this.symbolicName, this.types, newLength, properties, this.innerPredicate);
		}
		/**
		 * @return The direction of the relationship.
		 */
		@API(status = INTERNAL)
		public Direction getDirection() {
			return direction;
		}
		Optional<SymbolicName> getSymbolicName() {
			return Optional.ofNullable(symbolicName);
		}
		SymbolicName getRequiredSymbolicName() {
			SymbolicName requiredSymbolicName = this.symbolicName;
			if (requiredSymbolicName == null) {
				synchronized (this) {
					requiredSymbolicName = this.symbolicName;
					if (requiredSymbolicName == null) {
						this.symbolicName = SymbolicName.unresolved();
						requiredSymbolicName = this.symbolicName;
					}
				}
			}
			return requiredSymbolicName;
		}
		/**
		 * @return The relationship types being matched.
		 */
		@API(status = INTERNAL)
		public List<String> getTypes() {
			return types == null ? List.of() : List.copyOf(types.getValues());
		}
		/**
		 * @return The properties of this relationship.
		 */
		@API(status = INTERNAL)
		public Properties getProperties() {
			return properties;
		}
		@Override
		public void accept(Visitor visitor) {
			visitor.enter(this);
			Visitable.visitIfNotNull(this.symbolicName, visitor);
			Visitable.visitIfNotNull(this.types, visitor);
			Visitable.visitIfNotNull(this.length, visitor);
			Visitable.visitIfNotNull(this.properties, visitor);
			Visitable.visitIfNotNull(this.innerPredicate, visitor);
			visitor.leave(this);
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	/**
	 * @return the left-hand side of this relationship
	 */
	Node getLeft();
	/**
	 * The details containing the types, properties and cardinality.
	 *
	 * @return A wrapper around the details of this relationship.
	 */
	@NotNull @Contract(pure = true)
	Details getDetails();
	/**
	 * @return the right-hand side of this relationship
	 */
	@NotNull @Contract(pure = true)
	Node getRight();
	/**
	 * {@return the quantifier of this relationship if any}
	 */
	@Nullable @Contract(pure = true)
	QuantifiedPathPattern.Quantifier getQuantifier();
	/**
	 * Creates a copy of this relationship with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new relationship.
	 */
	@NotNull @Contract(pure = true)
	Relationship named(String newSymbolicName);
	/**
	 * Creates a copy of this relationship with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new relationship.
	 */
	@NotNull @Contract(pure = true)
	Relationship named(SymbolicName newSymbolicName);
	/**
	 * Creates a new relationship, inverting the direction but keeping the semantics intact
	 * ({@code (a) --> (b)} becomes {@code (b) <-- (a)}).
	 * A symbolic name will be removed from this relationship if any, as the it wouldn't be the same pattern to match
	 * against.
	 *
	 * @return the new relationship
	 */
	@NotNull @Contract(pure = true)
	Relationship inverse();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.internal;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Arrays;
import java.util.List;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/RelationshipDetail.html#RelationshipTypes">RelationshipTypes</a>
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
public final class RelationshipTypes implements Visitable {
	private final List<String> values;
	/**
	 * Creates a new holder for relationship types from a set of raw strings
	 *
	 * @param types The types to be included in this value holder
	 * @return A new value holder
	 */
	public static RelationshipTypes of(String... types) {
		List<String> listOfTypes = Arrays.stream(types)
			.filter(type -> !(type == null || type.isEmpty()))
			.toList();
		return new RelationshipTypes(listOfTypes);
	}
	private RelationshipTypes(List<String> values) {
		this.values = values;
	}
	/**
	 * @return the list of types. The types are not escaped and must be escaped prior to rendering.
	 */
	public List<String> getValues() {
		return values;
	}
	@Override
	public String toString() {
		return "RelationshipTypes{values=" + values + '}';
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.LinkedList;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Represents a chain of relationships. The chain is meant to be in order and the right node of an element is related to
 * the left node of the next element.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class RelationshipChain implements RelationshipPattern, ExposesPatternLengthAccessors<RelationshipChain> {
	private final LinkedList<Relationship> relationships;
	static RelationshipChain create(Relationship firstElement) {
		return new RelationshipChain(firstElement);
	}
	private RelationshipChain(Relationship firstElement) {
		this.relationships = new LinkedList<>();
		this.relationships.add(firstElement);
	}
	private RelationshipChain(List<Relationship> firstElements, Relationship lastElement) {
		this.relationships = new LinkedList<>(firstElements);
		this.relationships.add(lastElement);
	}
	private RelationshipChain(List<Relationship> elements) {
		this.relationships = new LinkedList<>(elements);
	}
	RelationshipChain add(Relationship element) {
		Assertions.notNull(element, "Elements of a relationship chain must not be null.");
		return new RelationshipChain(this.relationships, element);
	}
	RelationshipChain replaceLast(Relationship element) {
		Assertions.notNull(element, "Elements of a relationship chain must not be null.");
		RelationshipChain newChain = new RelationshipChain(this.relationships);
		newChain.relationships.removeLast();
		newChain.relationships.add(element);
		return newChain;
	}
	@NotNull
	@Override
	public RelationshipChain relationshipTo(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipTo(other, types));
	}
	@NotNull
	@Override
	public RelationshipChain relationshipFrom(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipFrom(other, types));
	}
	@NotNull
	@Override
	public RelationshipChain relationshipBetween(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipBetween(other, types));
	}
	/**
	 * Replaces the last element of this chains with a copy of the relationship with the new symbolic name.
	 *
	 * @param newSymbolicName The new symbolic name to use
	 * @return A new chain
	 */
	@NotNull
	@Override
	public RelationshipChain named(String newSymbolicName) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.named(newSymbolicName));
	}
	/**
	 * Replaces the last element of this chains with a copy of the relationship with the new symbolic name.
	 *
	 * @param newSymbolicName The new symbolic name to use
	 * @return A new chain
	 * @since 2021.1.1
	 */
	@NotNull
	@Override
	public RelationshipChain named(SymbolicName newSymbolicName) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.named(newSymbolicName));
	}
	@NotNull
	@Override
	public RelationshipChain where(@Nullable Expression predicate) {
		if (predicate == null) {
			return this;
		}
		var lastElement = this.relationships.getLast();
		return this.replaceLast((Relationship) lastElement.where(predicate));
	}
	@NotNull
	@Override
	public RelationshipPattern quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		if (quantifier == null) {
			return this;
		}
		var lastElement = this.relationships.getLast();
		return this.replaceLast((Relationship) lastElement.quantifyRelationship(quantifier));
	}
	@NotNull
	@Override
	public QuantifiedPathPattern quantify(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		return QuantifiedPathPattern.of(this, newQuantifier);
	}
	/**
	 * Changes the length of the last element of this chain to an unbounded pattern.
	 *
	 * @return A new chain
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain unbounded() {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.unbounded());
	}
	/**
	 * Changes the length of the last element of this chain to a new minimum length
	 *
	 * @param minimum the new minimum
	 * @return A new chain
	 */
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain min(Integer minimum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.min(minimum));
	}
	/**
	 * Changes the length of the last element of this chain to a new maximum length
	 *
	 * @param maximum the new maximum
	 * @return A new chain
	 */
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain max(Integer maximum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.max(maximum));
	}
	/**
	 * Changes the length of the last element of this chain
	 *
	 * @param minimum the new minimum
	 * @param maximum the new maximum
	 * @return A new chain
	 */
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain length(Integer minimum, Integer maximum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.length(minimum, maximum));
	}
	/**
	 * Adds properties to the last element of this chain.
	 *
	 * @param newProperties the new properties (can be {@literal null} to remove exiting properties).
	 * @return A new chain
	 */
	@NotNull @Contract(pure = true)
	public RelationshipChain properties(MapExpression newProperties) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.withProperties(newProperties));
	}
	/**
	 * Adds properties to the last element of this chain.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}.
	 * @return A new chain
	 */
	@NotNull @Contract(pure = true)
	public RelationshipChain properties(Object... keysAndValues) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.withProperties(keysAndValues));
	}
	@NotNull
	@Override
	public Condition asCondition() {
		return RelationshipPatternCondition.of(this);
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Node lastNode = null;
		for (Relationship relationship : relationships) {
			visitor.enter(relationship);
			relationship.getLeft().accept(visitor);
			relationship.getDetails().accept(visitor);
			Visitable.visitIfNotNull(relationship.getQuantifier(), visitor);
			visitor.leave(relationship);
			lastNode = relationship.getRight();
		}
		Visitable.visitIfNotNull(lastNode, visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
/**
 * A shared, public interface for  {@link Relationship relationships} and {@link RelationshipChain chains of relationships}.
 * This interface reassembles the <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/RelationshipPattern.html">RelationshipPattern</a>.
 * <p>
 * This interface can be used synonymous with the concept of a <a href="https://neo4j.com/docs/cypher-manual/4.0/clauses/where/#query-where-patterns">Path Pattern</a>.
 *
 * @author Michael J. Simons
 * @soundtrack Mine &amp; Fatoni - Alle Liebe nachträglich
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface RelationshipPattern extends PatternElement, ExposesRelationships<RelationshipChain> {
	/**
	 * Turns the pattern into a named chain of relationships.
	 *
	 * @param name The name to be used.
	 * @return A named relationship that can be chained with more relationship definitions.
	 */
	@NotNull @CheckReturnValue
	ExposesRelationships<RelationshipChain> named(String name);
	/**
	 * Turns the pattern into a named chain of relationships.
	 *
	 * @param name The name to be used.
	 * @return A named relationship that can be chained with more relationship definitions.
	 */
	@NotNull @CheckReturnValue
	ExposesRelationships<RelationshipChain> named(SymbolicName name);
	/**
	 * Transform this pattern into a condition. All names of the patterns must be known upfront in the final statement,
	 * as PatternExpressions are not allowed to introduce new variables.
	 *
	 * @return A condition based on this pattern.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	Condition asCondition();
	/**
	 * Quantifies the relationship.
	 *
	 * @param quantifier the quantifier to use
	 * @return a quantified relationship
	 * @since 2023.9.0
	 */
	@NotNull @Contract(pure = true)
	default PatternElement quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		throw new UnsupportedOperationException();
	}
	/**
	 * Quantifies the pattern.
	 *
	 * @param quantifier the quantifier to use
	 * @return a quantified path pattern
	 * @since 2023.9.0
	 */
	@NotNull @Contract(pure = true)
	default PatternElement quantify(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		throw new UnsupportedOperationException();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * This interface is used to derive new relationship patterns from existing {@link Relationship relationships} or {@link RelationshipChain chains of relationships}
 * with new lengths (min, max or unbounded) configured.
 *
 * @author Michael J. Simons
 * @param <T> The type of the patterns whose lengths can be adjusted.
 * @since 2021.2.3
 */
@API(status = STABLE, since = "2021.2.3")
public interface ExposesPatternLengthAccessors<T extends RelationshipPattern> {
	/**
	 * Creates a new relationship pattern with an unbound length minimum length
	 *
	 * @return the new relationship
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	T unbounded();
	/**
	 * Creates a new relationship pattern with a new minimum length
	 *
	 * @param minimum the new minimum
	 * @return the new relationship
	 */
	@NotNull @Contract(pure = true)
	T min(Integer minimum);
	/**
	 * Creates a new relationship pattern with a new maximum length
	 *
	 * @param maximum the new maximum
	 * @return the new relationship
	 */
	@NotNull @Contract(pure = true)
	T max(Integer maximum);
	/**
	 * Creates a new relationship pattern with a new length
	 *
	 * @param minimum the new minimum
	 * @param maximum the new maximum
	 * @return the new relationship
	 */
	@NotNull @Contract(pure = true)
	T length(Integer minimum, Integer maximum);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * Interface for implementations that accepts {@link Visitor visitors}.
 *
 * @author Michael Simons
 * @see Visitor
 * @since 1.0
 */
public interface Visitable {
	/**
	 * A helper method that presents the {@code visitor} to the {@code visitable} if the visitable is not null.
	 * Not meant to be overridden.
	 *
	 * @param visitable The visitable to visit if not null
	 * @param visitor   The visitor to use
	 */
	static void visitIfNotNull(Visitable visitable, Visitor visitor) {
		if (visitable != null) {
			visitable.accept(visitor);
		}
	}
	/**
	 * Accept a {@link Visitor} visiting this {@link Visitable} and its nested {@link Visitable}s if applicable.
	 *
	 * @param visitor the visitor to notify, must not be {@literal null}.
	 */
	default void accept(Visitor visitor) {
		visitor.enter(this);
		visitor.leave(this);
	}
	/**
	 * Most {@link Visitable visitables} will render themselves into a Cypher fragment preceded with the actual classname.
	 * The representation however is not cached - in contrast to the ones for full statements. Using {@code toString}
	 * is recommended for debugging purposes mainly, and not for production use.
	 * <p>
	 * The concrete classname has been prepended to help debugging and actually to discourage using fragments to build queries
	 * without explicitly rendering them, either as statement or going through the renderer on purpose.
	 *
	 * @return A string representation of this visitable formatted as {@literal Classname{cypher=value}}
	 */
	String toString();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.Map;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * A container that exposes methods to add properties with values to nodes or relationships.
 *
 * @author Michael J. Simons
 * @param <T> type of the object holding the specified properties
 * @soundtrack Daft Punk - Homework
 * @since 1.1
 */
public interface ExposesProperties<T extends ExposesProperties<?> & PropertyContainer> {
	/**
	 * Creates a copy of this property container with additional properties.
	 * Creates a property container without properties when no properties are passed to this method.
	 *
	 * @param newProperties the new properties (can be {@literal null} to remove exiting properties).
	 * @return The new property container.
	 */
	@NotNull @Contract(pure = true)
	T withProperties(MapExpression newProperties);
	/**
	 * Creates a copy of this property container with additional properties.
	 * Creates a property container without properties when no properties are passed to this method.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}.
	 * @return The new property container.
	 */
	@NotNull @Contract(pure = true)
	T withProperties(Object... keysAndValues);
	/**
	 * Creates a copy of this property container with additional properties.
	 *
	 * @param newProperties A map with the new properties
	 * @return The new property container.
	 */
	@NotNull @Contract(pure = true)
	T withProperties(Map<String, Object> newProperties);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.utils;
import java.util.Arrays;
import java.util.Objects;
import org.apiguardian.api.API;
/**
 * Assertions used throughout the Cypher-DSL. Mostly copied over from {@literal org.springframework.util.Assert}. Thanks
 * to the original authors: Keith Donald, Juergen Hoeller, Sam Brannen, Colin Sampaleanu and Rob Harrop.
 * Not supported for external use in any way.
 *
 * @since 2020.0.0
 */
@API(status = API.Status.INTERNAL, since = "2020.0.0")
public final class Assertions {
	/**
	 * Assert that the given String contains valid text content; that is, it must not
	 * be {@code null} and must contain at least one non-whitespace character.
	 * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
	 *
	 * @param text    the String to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the text does not contain valid text content
	 */
	public static void hasText(String text, String message) {
		if (!Strings.hasText(text)) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert a boolean expression, throwing an {@code IllegalArgumentException}
	 * if the expression evaluates to {@code false}.
	 * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than zero");</pre>
	 *
	 * @param expression a boolean expression
	 * @param message    the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if {@code expression} is {@code false}
	 */
	public static void isTrue(boolean expression, String message) {
		if (!expression) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that an object is not {@code null}.
	 * <pre class="code">Assert.notNull(clazz, "The class must not be null");</pre>
	 *
	 * @param object  the object to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object is {@code null}
	 */
	public static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that the provided object is an instance of the provided class.
	 * <pre class="code">Assert.instanceOf(Foo.class, foo, "Foo expected");</pre>
	 *
	 * @param type    the type to check against
	 * @param obj     the object to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object is not an instance of type
	 */
	public static void isInstanceOf(Class<?> type, Object obj, String message) {
		notNull(type, "Type to check against must not be null");
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that an array contains elements; that is, it must not be
	 * {@code null} and must contain at least one element.
	 * <pre class="code">Assert.notEmpty(array, "The array must contain elements");</pre>
	 *
	 * @param array   the array to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object array is {@code null} or contains no elements
	 */
	public static void notEmpty(Object[] array, String message) {
		if (isEmpty(array)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static boolean isEmpty(Object[] array) {
		return array == null || array.length == 0 || Arrays.stream(array).allMatch(Objects::isNull);
	}
	private Assertions() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.utils.LRUCache;
/**
 * A symbolic name to identify nodes, relationships and aliased items.
 * <p>
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/SchemaName.html">SchemaName</a>
 * <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/SymbolicName.html">SymbolicName</a>
 * <p>
 * While OpenCypher extends the <a href="https://unicode.org/reports/tr31/">UNICODE IDENTIFIER AND PATTERN SYNTAX</a>
 * with some characters, this DSL uses the same identifier Java itself uses for simplicity and until otherwise needed.
 *
 * @author Michael J. Simons
 * @author Andreas Berger
 * @since 1.0
 */
@API(status = Status.EXPERIMENTAL, since = "1.0")
public final class SymbolicName implements Expression, IdentifiableElement {
	private static final Map<String, SymbolicName> CACHE = Collections.synchronizedMap(new LRUCache<>(32));
	static SymbolicName of(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return CACHE.computeIfAbsent(name, SymbolicName::new);
	}
	static SymbolicName unsafe(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return new SymbolicName(name);
	}
	static SymbolicName unresolved() {
		return new SymbolicName(null);
	}
	private final String value;
	private SymbolicName(String value) {
		this.value = value;
	}
	/**
	 * @return The value of this symbolic name.
	 */
	@API(status = INTERNAL)
	public String getValue() {
		return value;
	}
	/**
	 * Creates a new symbolic name by concatenating {@code otherValue} to this names value.
	 * Returns {@literal this} if {@code otherValue} is empty.
	 *
	 * @param otherValue The value to concat.
	 * @return A new symbolic name
	 */
	@NotNull @Contract(pure = true)
	public SymbolicName concat(String otherValue) {
		Assertions.notNull(otherValue, "Value to concat must not be null.");
		if (otherValue.isEmpty()) {
			return this;
		}
		return SymbolicName.of(this.value + otherValue);
	}
	/**
	 * A list will never be a valid entry for a map projection, so this convenient method prevents trying to create one
	 * from a list of objects. It will delegate to {@link #project(Object...)} with the content of the list.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public MapProjection project(List<Object> entries) {
		return project(entries.toArray());
	}
	/**
	 * Creates a map projection based on this node. The node needs a symbolic name for this to work.
	 * <p>
	 * Entries of type {@code String} in {@code entries} followed by an {@link Expression} will be treated as map keys
	 * pointing to the expression in the projection, {@code String} entries alone will be treated as property lookups on the node.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public MapProjection project(Object... entries) {
		return MapProjection.create(this, entries);
	}
	@Override
	public String toString() {
		return value != null ? RendererBridge.render(this) : "Unresolved SymbolicName";
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		// Unresolved values are only equal to themselves
		if (value == null) {
			return false;
		}
		SymbolicName that = (SymbolicName) o;
		return value.equals(that.value);
	}
	@Override
	public int hashCode() {
		return value == null ? super.hashCode() : Objects.hash(value);
	}
	@NotNull
	@Override
	public Expression asExpression() {
		return this;
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.parser;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypher.internal.ast.factory.ASTFactory;
import org.neo4j.cypher.internal.ast.factory.ASTFactory.NULL;
import org.neo4j.cypher.internal.parser.common.ast.factory.AccessType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ActionType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CallInTxsOnErrorBehaviourType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ConstraintType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CreateIndexTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.HintIndexType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParameterType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserCypherTypeName;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserNormalForm;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserTrimSpecification;
import org.neo4j.cypher.internal.parser.common.ast.factory.ScopeType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ShowCommandFilterTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.SimpleEither;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.Clause;
import org.neo4j.cypherdsl.core.Clauses;
import org.neo4j.cypherdsl.core.Cypher;
import org.neo4j.cypherdsl.core.ExposesRelationships;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.Finish;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.MapProjection;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.NamedPath;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.PatternElement;
import org.neo4j.cypherdsl.core.Property;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.RelationshipPattern;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.StringLiteral;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * An implementation of Neo4j's {@link ASTFactory} that creates Cypher-DSL AST elements that can be used for creating
 * conditions, patterns to match etc.
 *
 * @author Michael J. Simons
 * @since 2021.3.0
 */
@API(status = INTERNAL, since = "2021.3.0")
final class CypherDslASTFactory implements ASTFactory<
	Statements,
	Statement,
	Statement,
	Clause,
	Finish,
	Return,
	Expression,
	List<Expression>,
	SortItem,
	PatternElement,
	NodeAtom,
	PathAtom,
	PathLength,
	Clause,
	Expression,
	Expression,
	Expression,
	Hint,
	Expression,
	LabelExpression,
	Expression,
	Parameter<?>,
	Expression,
	Property,
	Expression,
	Clause,
	Statement,
	Statement,
	Statement,
	Clause,
	Where,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	InputPosition,
	EntityType,
	QuantifiedPathPattern.Quantifier,
	PatternAtom,
	DatabaseName,
	NULL,
	NULL,
	PatternElement> {
	private static CypherDslASTFactory instanceFromDefaultOptions;
	static CypherDslASTFactory getInstance(Options options) {
		CypherDslASTFactory instance;
		if (options != null && !options.areDefault()) {
			instance = new CypherDslASTFactory(options);
		} else {
			instance = instanceFromDefaultOptions;
			if (instance == null) {
				synchronized (CypherDslASTFactory.class) {
					instance = instanceFromDefaultOptions;
					if (instance == null) {
						instanceFromDefaultOptions = new CypherDslASTFactory(Optional.ofNullable(options).orElseGet(Options::defaultOptions));
						instance = instanceFromDefaultOptions;
					}
				}
			}
		}
		return instance;
	}
	private final Options options;
	private CypherDslASTFactory(Options options) {
		this.options = options;
	}
	private String[] computeFinalLabelList(LabelParsedEventType event, List<StringPos<InputPosition>> inputLabels) {
		return inputLabels == null ? new String[0] : this.options.getLabelFilter()
			.apply(event, inputLabels.stream().map(v -> v.string).toList())
			.toArray(new String[0]);
	}
	private Optional<String[]> computeFinalLabelList(LabelParsedEventType event, LabelExpression inputLabels) {
		if (inputLabels == null) {
			return Optional.of(new String[0]);
		}
		if (inputLabels.type() == LabelExpression.Type.COLON_CONJUNCTION || (inputLabels.type() == LabelExpression.Type.LEAF && inputLabels.value() != null)) {
			return Optional.of(this.options.getLabelFilter()
				.apply(event, inputLabels.value())
				.toArray(new String[0]));
		}
		return Optional.empty();
	}
	private String[] computeFinalTypeList(TypeParsedEventType event, LabelExpression inputTypes) {
		if (inputTypes == null) {
			return new String[0];
		}
		if ((inputTypes.negated() && inputTypes.value().size() > 1) || inputTypes.type() == LabelExpression.Type.CONJUNCTION) {
			throw new UnsupportedOperationException("Expressions for relationship types are not supported in Cypher-DSL");
		}
		List<String> types = new ArrayList<>();
		traverseTypeExpression(types, inputTypes);
		return this.options.getTypeFilter()
			.apply(event, types)
			.toArray(new String[0]);
	}
	void traverseTypeExpression(List<String> types, LabelExpression expression) {
		if (expression.type() == LabelExpression.Type.LEAF || expression.type() == LabelExpression.Type.COLON_DISJUNCTION) {
			types.addAll(expression.value());
		} else {
			traverseTypeExpression(types, expression.lhs());
			traverseTypeExpression(types, expression.rhs());
		}
	}
	static void isInstanceOf(Class<?> type, Object obj, String message) {
		if (type == null) {
			throw new IllegalArgumentException("Type to check against must not be null");
		}
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	private <T extends Expression> T applyCallbacksFor(ExpressionCreatedEventType type, T newExpression) {
		return applyCallbacksFor(type, List.of(newExpression)).get(0);
	}
	@SuppressWarnings("unchecked")
	private <T extends Expression> List<T> applyCallbacksFor(ExpressionCreatedEventType type, List<T> expressions) {
		var callbacks = this.options.getOnNewExpressionCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return expressions;
		}
		var chainedCallbacks = callbacks.stream().reduce(Function.identity(), Function::andThen);
		return expressions.stream().map(e -> (T) chainedCallbacks.apply(e)).toList();
	}
	@SuppressWarnings("unchecked")
	private <T extends Visitable> T applyCallbacksFor(InvocationCreatedEventType type, T newExpression) {
		var callbacks = this.options.getOnNewInvocationCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return newExpression;
		}
		Visitable result = newExpression;
		for (UnaryOperator<Visitable> callback : callbacks) {
			result = callback.apply(result);
		}
		return (T) result;
	}
	private static SymbolicName assertSymbolicName(@Nullable Expression v) {
		if (v == null) {
			return null;
		}
		isInstanceOf(SymbolicName.class, v,  "An invalid type has been generated where a SymbolicName was required. Generated type was " + v.getClass().getName());
		return (SymbolicName) v;
	}
	@Override
	public Statements statements(List<Statement> statements) {
		return new Statements(statements);
	}
	@Override
	public Statement newSingleQuery(InputPosition p, List<Clause> clauses) {
		return newSingleQuery(clauses);
	}
	@Override
	public Statement newSingleQuery(List<Clause> clauses) {
		return Statement.of(clauses);
	}
	@Override
	public Statement newUnion(InputPosition p, Statement lhs, Statement rhs, boolean all) {
		if (all) {
			return Cypher.unionAll(lhs, rhs);
		} else {
			return Cypher.union(lhs, rhs);
		}
	}
	@Override
	public Clause directUseClause(InputPosition p, DatabaseName databaseName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause functionUseClause(InputPosition p, Expression function) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Finish newFinishClause(InputPosition p) {
		return Finish.create();
	}
	public List<Expression> newReturnItems(InputPosition p, boolean returnAll, List<Expression> returnItems) {
		var finalReturnItems = returnItems;
		if (returnAll) {
			finalReturnItems = Stream.concat(Stream.of(Cypher.asterisk()), finalReturnItems.stream()).toList();
		}
		if (finalReturnItems.isEmpty()) {
			if (!returnAll) {
				throw new IllegalArgumentException("Cannot return nothing.");
			}
			finalReturnItems = Collections.singletonList(Cypher.asterisk());
		}
		return finalReturnItems;
	}
	@Override
	public Return newReturnClause(InputPosition p, boolean distinct, List<Expression> returnItems, List<SortItem> sortItems,
		InputPosition orderPos, Expression skip, InputPosition skipPosition, Expression limit,
		InputPosition limitPosition) {
		return options.getReturnClauseFactory().apply(new ReturnDefinition(distinct, returnItems, sortItems, skip, limit));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, Expression v) {
		var s = assertSymbolicName(v);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e.as(s));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, int eStartOffset, int eEndOffset) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e);
	}
	@Override
	public SortItem orderDesc(InputPosition p, Expression e) {
		return e.descending();
	}
	@Override
	public SortItem orderAsc(InputPosition p, Expression e) {
		return e.ascending();
	}
	@Override
	public Clause withClause(InputPosition p, Return returnClause, Where where) {
		return Clauses.with(returnClause, where);
	}
	@Override
	public Clause matchClause(InputPosition p, boolean optional, NULL matchMode, List<PatternElement> patternElements, InputPosition patternPos, List<Hint> hints, Where whereIn) {
		var patternElementCallbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MATCH, List.of());
		List<PatternElement> openForTransformation = new ArrayList<>();
		for (PatternElement patternElement : patternElements) {
			if (patternElement instanceof NodeAtom nodeAtom) {
				openForTransformation.add(nodeAtom.value());
			} else {
				openForTransformation.add(patternElement);
			}
		}
		var transformedPatternElements = transformIfPossible(patternElementCallbacks, openForTransformation);
		return options.getMatchClauseFactory().apply(new MatchDefinition(optional, transformedPatternElements, whereIn, hints));
	}
	private List<PatternElement> transformIfPossible(List<UnaryOperator<PatternElement>> callbacks,
		List<PatternElement> patternElements) {
		if (callbacks.isEmpty()) {
			return patternElements;
		}
		@SuppressWarnings("squid:S4276") // The function is needed due to the assigment below
		var transformer = Function.<PatternElement>identity();
		for (UnaryOperator<PatternElement> callback : callbacks) {
			transformer = transformer.andThen(callback);
		}
		return patternElements.stream().map(transformer)
			.filter(Objects::nonNull)
			.toList();
	}
	@Override
	public Hint usingIndexHint(InputPosition p, Expression v, String labelOrRelType, List<String> properties,
		boolean seekOnly, HintIndexType indexType) {
		// We build nodes here. As of now, the node isn't used anyway, but only the label
		// will be used down further the AST.
		// It is easier than introduce a new common abstraction of label and relationship type (probably
		// in line with the decision made for the parser)
		var node = Cypher.node(labelOrRelType).named(assertSymbolicName(v));
		return Hint.useIndexFor(seekOnly, properties.stream().map(node::property).toArray(Property[]::new));
	}
	@Override
	public Hint usingJoin(InputPosition p, List<Expression> joinVariables) {
		return Hint.useJoinOn(joinVariables.stream().map(CypherDslASTFactory::assertSymbolicName).toArray(SymbolicName[]::new));
	}
	@Override
	public Hint usingScan(InputPosition p, Expression v, String label) {
		var s = assertSymbolicName(v);
		// Same note applies as with usingIndexHint in regard to relationships
		return Hint.useScanFor(Cypher.node(label).named(s));
	}
	@Override
	public Clause createClause(InputPosition p, List<PatternElement> patternElements) {
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_CREATE, List.of());
		return Clauses.create(transformIfPossible(callbacks, patternElements.stream().map(v -> v instanceof NodeAtom n ? n.value() : v).toList()));
	}
	@Override
	public Clause insertClause(InputPosition p, List<PatternElement> patternElements) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause setClause(InputPosition p, List<Expression> setItems) {
		return Clauses.set(setItems);
	}
	@Override
	public Operation setProperty(Property property, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, property.to(value));
	}
	@Override
	public Expression setDynamicProperty(Expression dynamicProperty, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, Cypher.set(dynamicProperty, value));
	}
	@Override
	public Operation setVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_VARIABLE, Cypher.set(v, value));
	}
	@Override
	public Operation addAndSetVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_ADD_AND_SET_VARIABLE, Cypher.mutate(v, value));
	}
	@Override
	public Expression setLabels(Expression v, List<StringPos<InputPosition>> values, List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_SET, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_LABELS, Cypher.setLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause removeClause(InputPosition p, List<Expression> removeItems) {
		return Clauses.remove(removeItems);
	}
	@Override
	public Expression removeProperty(Property property) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, property);
	}
	@Override
	public Expression removeDynamicProperty(Expression dynamicProperty) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, dynamicProperty);
	}
	@Override
	public Expression removeLabels(Expression v, List<StringPos<InputPosition>> values,
		List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_REMOVE, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_LABELS, Cypher.removeLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause deleteClause(InputPosition p, boolean detach, List<Expression> expressions) {
		return Clauses.delete(detach, applyCallbacksFor(ExpressionCreatedEventType.ON_DELETE_ITEM, expressions));
	}
	@Override
	public Clause unwindClause(InputPosition p, Expression e, Expression v) {
		return Clauses.unwind(e, assertSymbolicName(v));
	}
	@Override
	public Clause mergeClause(InputPosition p, PatternElement patternElementIn, List<Clause> setClauses,
		List<MergeActionType> actionTypes, List<InputPosition> positions) {
		var patternElement = patternElementIn instanceof NodeAtom n ? n.value() : patternElementIn;
		var mergeActions = new ArrayList<MergeAction>();
		if (setClauses != null && !setClauses.isEmpty() && actionTypes != null && !actionTypes.isEmpty()) {
			var iteratorClauses = setClauses.iterator();
			var iteratorTypes = actionTypes.iterator();
			while (iteratorClauses.hasNext() && iteratorTypes.hasNext()) {
				var type = iteratorTypes.next();
				switch (type) {
					case OnCreate ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_CREATE, (Set) iteratorClauses.next()));
					case OnMatch ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_MATCH, (Set) iteratorClauses.next()));
					default -> throw new IllegalArgumentException("Unsupported MergeActionType: " + type);
				}
			}
		}
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MERGE, List.of());
		return Clauses.merge(transformIfPossible(callbacks, List.of(patternElement)), mergeActions);
	}
	@Override
	public Clause callClause(InputPosition p, InputPosition namespacePosition, InputPosition procedureNamePosition,
		InputPosition procedureResultPosition, List<String> namespace, String name, List<Expression> arguments,
		boolean yieldAll, List<Expression> resultItems, Where where, boolean optional) {
		var intermediateResult = Clauses.callClause(namespace, name, arguments,
			yieldAll && resultItems == null ? List.of(Cypher.asterisk()) : resultItems, where);
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional call clause");
		}
		return applyCallbacksFor(InvocationCreatedEventType.ON_CALL, intermediateResult);
	}
	@Override
	public Expression callResultItem(InputPosition p, String name, Expression alias) {
		var finalName = Cypher.name(name);
		if (alias != null) {
			return finalName.as(assertSymbolicName(alias));
		}
		return finalName;
	}
	@Override
	public PatternElement patternWithSelector(NULL aNull, PatternElement patternPart) {
		return null;
	}
	@Override
	public PatternElement namedPattern(Expression v, PatternElement patternElement) {
		return Cypher.path(assertSymbolicName(v)).definedBy(patternElement);
	}
	@Override
	public PatternElement shortestPathPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the shortestPath function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.SHORTEST_PATH, patternElement));
	}
	@Override
	public PatternElement allShortestPathsPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the allShortestPaths function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.ALL_SHORTEST_PATHS, patternElement));
	}
	@Override
	public PatternElement pathPattern(PatternElement patternElement) {
		return patternElement;
	}
	@Override
	public PatternElement insertPathPattern(List<PatternAtom> patternAtoms) {
		throw new UnsupportedOperationException();
	}
	static class PatternJuxtaposition extends TypedSubtree<PatternElement> implements PatternElement {
		PatternJuxtaposition(Collection<PatternElement> children) {
			super(children);
		}
		@Override
		public String separator() {
			return " ";
		}
	}
	static class PatternList extends TypedSubtree<PatternElement> implements PatternElement {
		PatternList(Collection<PatternElement> children) {
			super(children);
		}
	}
	@SuppressWarnings("squid:S3776") // Yep, it's complex
	@Override
	public PatternElement patternElement(List<PatternAtom> atoms) {
		if (atoms.isEmpty()) {
			throw new IllegalArgumentException(
				"Cannot create a PatternElement from an empty list of patterns.");
		}
		if (atoms.size() == 1 && atoms.get(0) instanceof ParenthesizedPathPatternAtom atom) {
			return atom.asPatternElement();
		}
		List<PatternElement> patternElements = new ArrayList<>();
		NodeAtom lastNodeAtom = null;
		PathAtom lastPathAtom = null;
		ExposesRelationships<?> relationshipPattern = null;
		List<PatternElement> patternList = null;
		for (PatternAtom atom : atoms) {
			if (atom instanceof ParenthesizedPathPatternAtom specificAtom) {
				if (lastNodeAtom != null) {
					patternElements.add(lastNodeAtom.value());
				}
				if (relationshipPattern != null) {
					patternElements.add((PatternElement) relationshipPattern);
				}
				if (patternList != null) {
					patternElements.add(new PatternList(patternList));
				}
				lastNodeAtom = null;
				lastPathAtom = null;
				relationshipPattern = null;
				patternList = null;
				patternElements.add(specificAtom.asPatternElement());
			} else if (atom instanceof NodeAtom nodeAtom) {
				if (relationshipPattern != null) {
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
				} else if (lastNodeAtom == null) {
					lastNodeAtom = nodeAtom;
				} else {
					relationshipPattern = lastNodeAtom.value();
					lastNodeAtom = null;
					// Will be added to the pattern elements either on the occurrence of a parenthesized pattern or
					// after iterating all atoms.
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
					if ((lastPathAtom.getDirection() == Relationship.Direction.RTL || patternList != null)
						&& options.isAlwaysCreateRelationshipsLTR()) {
						if (patternList == null) {
							patternList = new ArrayList<>();
						}
						patternList.add(((PatternElement) relationshipPattern));
						relationshipPattern = null;
						lastNodeAtom = nodeAtom;
					}
				}
			} else if (atom instanceof PathAtom pathAtom) {
				lastPathAtom = pathAtom;
			}
		}
		if (relationshipPattern == null && patternList != null && patternList.size() == 1 && patternList.get(0) instanceof RelationshipPattern singleListItem) {
			relationshipPattern = singleListItem;
			patternList = null;
		}
		if (relationshipPattern != null) {
			patternElements.add((PatternElement) relationshipPattern);
		} else if (patternList != null) {
			patternElements.add(new PatternList(patternList));
		} else if (lastNodeAtom != null) {
			patternElements.add(lastNodeAtom.value());
		}
		return patternElements.size() == 1 ? patternElements.get(0) : new PatternJuxtaposition(patternElements);
	}
	@Override
	public NULL anyPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL anyShortestPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allShortestPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL shortestGroupsSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NodeAtom nodePattern(InputPosition p, Expression v, LabelExpression labels, Expression properties, Expression predicate) {
		Node node;
		if (labels == null) {
			node = Cypher.anyNode();
		} else {
			var finalLabels = computeFinalLabelList(LabelParsedEventType.ON_NODE_PATTERN, labels);
			node = finalLabels.map(l -> {
				var primaryLabel = l[0];
				var additionalLabels = Arrays.stream(l).skip(1).toList();
				return Cypher.node(primaryLabel, additionalLabels);
			}).orElseGet(() -> Cypher.node(labels));
		}
		if (v != null) {
			node = node.named(assertSymbolicName(v));
		}
		if (properties != null) {
			node = node.withProperties((MapExpression) properties);
		}
		if (predicate != null) {
			node = (Node) node.where(predicate);
		}
		return new NodeAtom(node);
	}
	@Override
	public PathAtom relationshipPattern(InputPosition p, boolean left, boolean right, Expression v, LabelExpression relTypes, PathLength pathLength, Expression properties, Expression predicate) {
		return PathAtom.of(assertSymbolicName(v), pathLength, left, right,
			computeFinalTypeList(TypeParsedEventType.ON_RELATIONSHIP_PATTERN, relTypes), (MapExpression) properties,
			relTypes != null && relTypes.negated(), predicate);
	}
	@Override
	public PathLength pathLength(InputPosition p, InputPosition pMin, InputPosition pMax, String minLength,
		String maxLength) {
		return PathLength.of(minLength, maxLength);
	}
	@Override
	public QuantifiedPathPattern.Quantifier intervalPathQuantifier(InputPosition p, InputPosition posLowerBound, InputPosition posUpperBound, String lowerBound, String upperBound) {
		return QuantifiedPathPattern.interval(lowerBound == null ? null : Integer.parseInt(lowerBound), upperBound == null ? null : Integer.parseInt(upperBound));
	}
	@Override
	public QuantifiedPathPattern.Quantifier fixedPathQuantifier(InputPosition p, InputPosition valuePos, String value) {
		throw new UnsupportedOperationException();
	}
	@Override
	public QuantifiedPathPattern.Quantifier plusPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.plus();
	}
	@Override
	public QuantifiedPathPattern.Quantifier starPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.star();
	}
	@Override
	public NULL repeatableElements(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL differentRelationships(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public PatternAtom parenthesizedPathPattern(InputPosition p, PatternElement internalPattern, Expression where, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return new ParenthesizedPathPatternAtom((RelationshipPattern) internalPattern, pathPatternQuantifier, where);
	}
	@Override
	public PatternAtom quantifiedRelationship(PathAtom rel, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return rel.withQuantifier(pathPatternQuantifier);
	}
	@Override
	public Clause loadCsvClause(InputPosition p, boolean headers, Expression source, Expression v,
		String fieldTerminator) {
		isInstanceOf(StringLiteral.class, source, "Only string literals are supported as source for the LOAD CSV clause.");
		return Clauses.loadCSV(headers, (StringLiteral) source, assertSymbolicName(v), fieldTerminator);
	}
	@Override
	public Clause foreachClause(InputPosition p, Expression v, Expression list, List<Clause> objects) {
		return Clauses.forEach(assertSymbolicName(v), list, objects);
	}
	@Override
	public Clause subqueryClause(InputPosition p, Statement subquery, NULL inTransactions, boolean scopeAll,
		boolean hasScope, List<Expression> expressions, boolean optional) {
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional subquery clause");
		}
		return Clauses.callClause(subquery);
	}
	@Override
	public NULL subqueryInTransactionsParams(InputPosition p, NULL batchParams, NULL concurrencyParams,
		NULL errorParams, NULL reportParams) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause yieldClause(InputPosition p, boolean returnAll, List<Expression> expressions,
		InputPosition returnItemsPosition, List<SortItem> orderBy, InputPosition orderPos, Expression skip,
		InputPosition skipPosition, Expression limit, InputPosition limitPosition, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showIndexClause(InputPosition p, ShowCommandFilterTypes indexType, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showConstraintClause(InputPosition p, ShowCommandFilterTypes constraintType, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showProcedureClause(InputPosition p, boolean currentUser, String user, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showFunctionClause(InputPosition p, ShowCommandFilterTypes functionType, boolean currentUser,
		String user, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement useGraph(Statement command, Clause useGraph) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRoles(InputPosition p, boolean withUsers, boolean showAll, Clause yieldExpr,
		Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokeRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createUser(InputPosition p, boolean replace, boolean ifNotExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		List<NULL> nulls, List<NULL> systemAuthAttributes) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameUser(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromUserName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toUserName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement setOwnPassword(InputPosition p, Expression currentPassword, Expression newPassword) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL auth(String provider, List<NULL> nulls, InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL authId(InputPosition s, Expression id) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL password(InputPosition p, Expression password, boolean encrypted) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL passwordChangeRequired(InputPosition p, boolean changeRequired) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		boolean removeHome, List<NULL> nulls, List<NULL> systemAuthAttributes, boolean removeAllAuth,
		List<Expression> removeAuths) {
		throw new UnsupportedOperationException();
	}
	@Override public Expression passwordExpression(Parameter<?> password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression passwordExpression(InputPosition s, InputPosition e, String password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUsers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where,
		boolean withAuth) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showCurrentUser(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showSupportedPrivileges(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAllPrivileges(InputPosition p, boolean asCommand, boolean asRevoke, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRolePrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUserPrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement denyPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokePrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege, boolean revokeGrant, boolean revokeDeny) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") // The database options are quite different options than ours ;)
	public Statement createDatabase(InputPosition p, boolean replace, DatabaseName databaseName, boolean ifNotExists,
		NULL aNull, SimpleEither<Map<String, Expression>, Parameter<?>> options,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries,
		SimpleEither<Integer, Parameter<?>> topologySecondaries) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createCompositeDatabase(InputPosition p, boolean replace, DatabaseName compositeDatabaseName,
		boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> databaseOptions, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, boolean composite,
		boolean aliasAction, boolean dumpData, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") // The database options are quite different options than ours ;)
	@Override
	public Statement alterDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, AccessType accessType,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries, SimpleEither<Integer, Parameter<?>> topologySecondaries,
		Map<String, Expression> options, java.util.Set<String> optionsToRemove, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showDatabase(InputPosition p, NULL scope, Clause yieldExpr, Return returnWithoutGraph,
		Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement startDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement stopDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseScope(InputPosition p, DatabaseName databaseName, boolean isDefault, boolean isHome) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropAlias(InputPosition p, DatabaseName aliasName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAliases(InputPosition p, DatabaseName aliasName, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void addDeprecatedIdentifierUnicodeNotification(InputPosition p, Character character, String identifier) {
	}
	@Override
	public NULL wait(boolean wait, long seconds) {
		throw new UnsupportedOperationException();
	}
	@Override
	public DatabaseName databaseName(InputPosition p, List<String> names) {
		if (names.isEmpty()) {
			throw new IllegalArgumentException("No database name");
		}
		if (names.size() == 1) {
			return new DatabaseName(Cypher.literalOf(names.get(0)));
		}
		return new DatabaseName(Cypher.literalOf(names));
	}
	@Override
	public DatabaseName databaseName(Parameter<?> param) {
		return new DatabaseName(param);
	}
	@Override
	public Statement createLocalDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRemoteDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterLocalDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterRemoteDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression newVariable(InputPosition p, String name) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_VARIABLE, Cypher.name(name));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, Expression v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(v));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, String v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(Cypher.name(v)));
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, Expression v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, String v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@NotNull
	Parameter<?> parameterFromSymbolicName(Expression v) {
		var symbolicName = assertSymbolicName(v);
		if (symbolicName == null) {
			return Cypher.anonParameter(Cypher.literalNull());
		}
		var name = symbolicName.getValue();
		return options.getParameterValues().containsKey(name) ? Cypher.parameter(name, options.getParameterValues().get(name)) : Cypher.parameter(name);
	}
	@Override
	public Expression newDouble(InputPosition p, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Double.parseDouble(image)));
	}
	@Override
	public Expression newDecimalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image) * (negated ? -1 : 1)));
	}
	@Override public Expression newHexInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0x", ""), 16) * (negated ? -1 : 1)));
	}
	@Override public Expression newOctalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0o", ""), 8) * (negated ? -1 : 1)));
	}
	@Override
	public Expression newString(InputPosition start, InputPosition end, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(image));
	}
	@Override
	public Expression newTrueLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalTrue());
	}
	@Override
	public Expression newFalseLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalFalse());
	}
	@Override
	public Expression newInfinityLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, InfinityLiteral.INSTANCE);
	}
	@Override
	public Expression newNaNLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, NaNLiteral.INSTANCE);
	}
	@Override
	public Expression newNullLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalNull());
	}
	@Override
	public Expression listLiteral(InputPosition p, List<Expression> values) {
		return Cypher.listOf(values.toArray(new Expression[0]));
	}
	@Override
	public MapExpression mapLiteral(InputPosition p, List<StringPos<InputPosition>> keys, List<Expression> values) {
		Object[] keysAndValues = new Object[keys.size() * 2];
		int i = 0;
		Iterator<Expression> valueIterator = values.iterator();
		for (StringPos<InputPosition> key : keys) {
			keysAndValues[i++] = key.string;
			keysAndValues[i++] = valueIterator.next();
		}
		return options.isCreateSortedMaps() ? Cypher.sortedMapOf(keysAndValues) : Cypher.mapOf(keysAndValues);
	}
	@Override
	public Property property(Expression subject, StringPos<InputPosition> propertyKeyName) {
		return subject.property(propertyKeyName.string);
	}
	@Override
	public Expression or(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().or(rhs.asCondition());
	}
	@Override
	public Expression xor(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().xor(rhs.asCondition());
	}
	@Override
	public Expression and(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().and(rhs.asCondition());
	}
	@Override
	public LabelExpression labelConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.and(rhs);
	}
	@Override
	public LabelExpression labelDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.or(rhs);
	}
	@Override
	public LabelExpression labelNegation(InputPosition p, LabelExpression e, boolean containsIs) {
		return e.negate();
	}
	@Override
	public LabelExpression labelWildcard(InputPosition p, boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression labelLeaf(InputPosition p, String e, EntityType entityType, boolean containsIs) {
		return new LabelExpression(e);
	}
	@Override
	public LabelExpression labelColonConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_CONJUNCTION);
	}
	@Override
	public LabelExpression labelColonDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_DISJUNCTION);
	}
	@NotNull
	private static LabelExpression colonJunjction(LabelExpression lhs, LabelExpression rhs, LabelExpression.Type colonDisjunction) {
		List<String> value = new ArrayList<>();
		value.addAll(lhs.value());
		value.addAll(rhs.value());
		return new LabelExpression(colonDisjunction, false, value, null, null);
	}
	@Override
	public Expression labelExpressionPredicate(Expression subject, LabelExpression exp) {
		if (!(subject instanceof SymbolicName symbolicName)) {
			throw new IllegalArgumentException("Expected an symbolic name to create a label based expression predicate!");
		} else {
			List<String> values = new ArrayList<>();
			LabelExpression current = exp;
			while (current != null) {
				values.addAll(current.value());
				current = current.rhs();
			}
			return Cypher.hasLabelsOrType(symbolicName, values.toArray(String[]::new));
		}
	}
	@Override
	public Expression ands(List<Expression> exprs) {
		return exprs.stream().reduce(Cypher.noCondition(), (l, r) -> l.asCondition().and(r.asCondition()));
	}
	@Override
	public Expression not(InputPosition p, Expression e) {
		return e.asCondition().not();
	}
	@Override
	public Expression plus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.add(rhs);
	}
	@Override
	public Expression minus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.subtract(rhs);
	}
	@Override
	public Expression concatenate(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.concat(rhs);
	}
	@Override
	public Expression multiply(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.multiply(rhs);
	}
	@Override
	public Expression divide(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.divide(rhs);
	}
	@Override
	public Expression modulo(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.remainder(rhs);
	}
	@Override
	public Expression pow(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.pow(rhs);
	}
	@Override public Expression unaryPlus(Expression e) {
		return Cypher.plus(e);
	}
	@Override
	public Expression unaryPlus(InputPosition inputPosition, Expression expression) {
		return Cypher.plus(expression);
	}
	@Override
	public Expression unaryMinus(InputPosition inputPosition, Expression expression) {
		return Cypher.minus(expression);
	}
	@Override
	public Expression eq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.eq(rhs);
	}
	@Override
	public Expression neq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression neq2(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression lte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lte(rhs);
	}
	@Override
	public Expression gte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gte(rhs);
	}
	@Override
	public Expression lt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lt(rhs);
	}
	@Override
	public Expression gt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gt(rhs);
	}
	@Override
	public Expression regeq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.matches(rhs);
	}
	@Override
	public Expression startsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.startsWith(rhs);
	}
	@Override
	public Expression endsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.endsWith(rhs);
	}
	@Override
	public Expression contains(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.contains(rhs);
	}
	@Override
	public Expression in(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.in(rhs);
	}
	@Override
	public Expression isNull(InputPosition p, Expression e) {
		return e.isNull();
	}
	@Override
	public Expression isNotNull(InputPosition p, Expression e) {
		return e.isNotNull();
	}
	@Override
	public Expression isTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression listLookup(Expression list, Expression index) {
		return Cypher.valueAt(list, index);
	}
	@Override
	public Expression listSlice(InputPosition p, Expression list, Expression start, Expression end) {
		return Cypher.subList(list, start, end);
	}
	@Override
	public Expression newCountStar(InputPosition p) {
		return Cypher.count(Cypher.asterisk());
	}
	@Override
	public Expression functionInvocation(InputPosition p, InputPosition functionNamePosition, List<String> namespace,
		String name, boolean distinct, List<Expression> arguments, boolean calledFromUseClause) {
		String[] parts = new String[namespace.size() + 1];
		for (int i = 0; i < namespace.size(); i++) {
			parts[i] = namespace.get(i);
		}
		parts[parts.length - 1] = name;
		var expression = Cypher.call(parts).withArgs(arguments.toArray(Expression[]::new)).asFunction(distinct);
		return applyCallbacksFor(InvocationCreatedEventType.ON_INVOCATION, expression);
	}
	@Override
	public Expression listComprehension(InputPosition p, Expression v, Expression list, Expression where,
		Expression projection) {
		var in = Cypher.listWith(assertSymbolicName(v)).in(list);
		if (where != null) {
			var ongoingComprehension = in.where(where.asCondition());
			if (projection != null) {
				return ongoingComprehension.returning(projection);
			}
			return ongoingComprehension.returning();
		}
		return in.returning(projection);
	}
	@Override
	public Expression patternComprehension(InputPosition p, InputPosition relationshipPatternPosition, Expression v, PatternElement patternElement,
		Expression where, Expression projection) {
		PatternComprehension.OngoingDefinitionWithoutReturn ongoingDefinitionWithPattern;
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			if (v != null) {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(Cypher.path(assertSymbolicName(v)).definedBy(relationshipPattern));
			} else {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(relationshipPattern);
			}
		} else if (patternElement instanceof NamedPath namedPath) {
			ongoingDefinitionWithPattern = Cypher.listBasedOn(namedPath);
		} else {
			throw new IllegalArgumentException(
				"Cannot build a pattern comprehension around " + patternElement.getClass().getSimpleName());
		}
		if (where != null) {
			ongoingDefinitionWithPattern = ((PatternComprehension.OngoingDefinitionWithPattern) ongoingDefinitionWithPattern)
				.where(where.asCondition());
		}
		return ongoingDefinitionWithPattern.returning(projection);
	}
	@Override
	public Expression reduceExpression(InputPosition p, Expression acc, Expression accExpr, Expression v,
		Expression list, Expression innerExpr) {
		var variable = assertSymbolicName(v);
		if (variable == null) {
			throw new IllegalArgumentException("A variable to be reduced must be present.");
		}
		return Cypher.reduce(variable)
			.in(list)
			.map(innerExpr)
			.accumulateOn(assertSymbolicName(acc))
			.withInitialValueOf(accExpr);
	}
	@Override
	public Expression allExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "all(...) requires a WHERE predicate");
		return Cypher.all(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression anyExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "any(...) requires a WHERE predicate");
		return Cypher.any(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression noneExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "none(...) requires a WHERE predicate");
		return Cypher.none(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression singleExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "single(...) requires a WHERE predicate");
		return Cypher.single(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression normalizeExpression(InputPosition p, Expression i, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression trimFunction(InputPosition inputPosition, ParserTrimSpecification parserTrimSpecification,
		Expression expression, Expression expression1) {
		var call = switch (parserTrimSpecification) {
			case BOTH -> Cypher.call("trim");
			case LEADING -> Cypher.call("ltrim");
			case TRAILING -> Cypher.call("rtrim");
		};
		return call.withArgs(
				expression == null ? new Expression[] {expression1} : new Expression[] {expression1, expression})
			.asFunction();
	}
	@Override
	public Expression patternExpression(InputPosition p, PatternElement patternElement) {
		if (patternElement instanceof ExpressionAsPatternElementWrapper wrapper) {
			return wrapper.getExpression();
		}
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			return new PatternElementAsExpressionWrapper(relationshipPattern);
		}
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression existsExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.exists(patternElements, where);
		} else {
			return Cypher.exists(q);
		}
	}
	@Override
	public Expression countExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.count(patternElements, where);
		} else {
			return Cypher.count(q);
		}
	}
	@Override
	public Expression collectExpression(InputPosition inputPosition, Statement statement) {
		return Cypher.collect(statement);
	}
	@Override
	public Expression mapProjection(InputPosition p, Expression v, List<Expression> items) {
		return options.isCreateSortedMaps() ?
			MapProjection.sorted(assertSymbolicName(v), items.toArray(new Object[0])) :
			MapProjection.create(assertSymbolicName(v), items.toArray(new Object[0]));
	}
	@Override
	public Expression mapProjectionLiteralEntry(StringPos<InputPosition> property, Expression value) {
		return KeyValueMapEntry.create(property.string, value);
	}
	@Override
	public Expression mapProjectionProperty(StringPos<InputPosition> property) {
		return PropertyLookup.forName(property.string);
	}
	@Override
	public Expression mapProjectionVariable(Expression v) {
		return v;
	}
	@Override
	public Expression mapProjectionAll(InputPosition p) {
		return Cypher.asterisk();
	}
	@Override
	public Expression caseExpression(InputPosition p, Expression e, List<Expression> whens, List<Expression> thens,
		Expression elze) {
		if (whens != null && thens != null && whens.size() != thens.size()) {
			throw new IllegalArgumentException("Cannot combine lists of whens with a different sized list of thens.");
		}
		var aCase = Cypher.caseExpression(e);
		if (whens != null && thens != null) {
			var iteratorWhens = whens.iterator();
			var iteratorThens = thens.iterator();
			while (iteratorWhens.hasNext() && iteratorThens.hasNext()) {
				aCase = aCase.when(iteratorWhens.next()).then(iteratorThens.next());
			}
			if (elze != null) {
				return ((Case.CaseEnding) aCase).elseDefault(elze);
			}
			return aCase;
		}
		return aCase;
	}
	@Override
	public InputPosition inputPosition(int offset, int line, int column) {
		return new InputPosition(offset, line, column);
	}
	@Override
	public EntityType nodeType() {
		return EntityType.NODE;
	}
	@Override
	public EntityType relationshipType() {
		return EntityType.RELATIONSHIP;
	}
	@Override
	public EntityType nodeOrRelationshipType() {
		return EntityType.LOLWHAT;
	}
	@Override
	public Where whereClause(InputPosition p, Expression optionalWhere) {
		return Where.from(optionalWhere);
	}
	@Override
	public NULL subqueryInTransactionsBatchParameters(InputPosition p, Expression batchSize) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsConcurrencyParameters(InputPosition p, Expression concurrency) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsErrorParameters(InputPosition p, CallInTxsOnErrorBehaviourType onErrorBehaviour) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsReportParameters(InputPosition p, Expression v) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause orderBySkipLimitClause(InputPosition inputPosition, List<SortItem> list, InputPosition pos1,
		Expression expression, InputPosition pos2, Expression expression1, InputPosition pos3) {
		return null;
	}
	@Override
	public Clause showTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause terminateTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showSettingsClause(InputPosition p, SimpleEither<List<String>, Expression> names, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause turnYieldToWith(Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createConstraint(InputPosition p, ConstraintType constraintType, boolean replace,
		boolean ifNotExists, SimpleEither<StringPos<InputPosition>, Parameter<?>> constraintName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties, ParserCypherTypeName propertyType,
		SimpleEither<Map<String, Expression>, Parameter<?>> constraintOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropConstraint(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createLookupIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> functionName, Expression functionParameter,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions, CreateIndexTypes indexType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createFulltextIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		List<StringPos<InputPosition>> labels, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropIndex(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRole(InputPosition p, boolean replace,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRole, boolean ifNotExists, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRoleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toRoleName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilege(InputPosition p, NULL aNull, NULL aNull2, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL dbmsPrivilege(InputPosition p, NULL aNull, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL loadPrivilege(InputPosition inputPosition, SimpleEither<String, Parameter<?>> simpleEither,
		SimpleEither<String, Parameter<?>> simpleEither1, boolean b) {
		return null;
	}
	@Override
	public NULL graphPrivilege(InputPosition inputPosition, NULL aNull, NULL aNull2, NULL aNull3, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL privilegeAction(ActionType action) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL propertiesResource(InputPosition p, List<String> property) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPropertiesResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelsResource(InputPosition p, List<String> label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL noResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelQualifier(InputPosition p, String label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL relationshipQualifier(InputPosition p, String relationshipType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL elementQualifier(InputPosition p, String name) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allElementsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL patternQualifier(List<NULL> list, Expression expression, Expression expression2) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allRelationshipsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allDatabasesQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> userQualifier(List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allUsersQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> functionQualifier(InputPosition p, List<String> functions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> procedureQualifier(InputPosition p, List<String> procedures) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> settingQualifier(InputPosition inputPosition, List<String> list) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL graphScope(InputPosition inputPosition, List<DatabaseName> graphNames, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilegeScope(InputPosition inputPosition, List<DatabaseName> list, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression dynamicLabelLeaf(InputPosition p, Expression e, EntityType entityType, boolean all,
		boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement enableServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<String, Parameter<?>> newName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showServers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement deallocateServers(InputPosition p, boolean dryRun, List<SimpleEither<String, Parameter<?>>> serverNames) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement reallocateDatabases(InputPosition p, boolean dryRun) {
		throw new UnsupportedOperationException();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Visitable implementing hints. See {@link ExposesHints}.
 *
 * @author Michael J. Simons
 * @soundtrack Pearl Jam - Vitalogy
 * @since 2021.0.0
 */
public final class Hint implements Visitable {
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	private enum Type implements Visitable {
		INDEX, INDEX_SEEK, SCAN, JOIN_ON;
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	private static final class IndexReference implements Visitable {
		private final SymbolicName symbolicName;
		private final NodeLabel optionalLabel;
		IndexReference(SymbolicName symbolicName) {
			this(symbolicName, null);
		}
		IndexReference(SymbolicName symbolicName, NodeLabel optionalLabel) {
			this.symbolicName = symbolicName;
			this.optionalLabel = optionalLabel;
		}
		boolean pointsToSameContainer(SymbolicName otherSymbolicName, NodeLabel otherLabel) {
			return this.symbolicName.equals(otherSymbolicName) && Objects.equals(this.optionalLabel, otherLabel);
		}
		@Override
		public void accept(Visitor visitor) {
			visitor.enter(this);
			this.symbolicName.accept(visitor);
			Visitable.visitIfNotNull(this.optionalLabel, visitor);
			visitor.leave(this);
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	private static final class IndexReferences extends TypedSubtree<IndexReference> {
		IndexReferences(List<IndexReference> indexReferences) {
			super(indexReferences);
		}
	}
	/**
	 * Internal helper class to wrap up the properties used inside an index.
	 */
	private static final class IndexProperties extends TypedSubtree<SymbolicName> implements ProvidesAffixes {
		IndexProperties(List<SymbolicName> properties) {
			super(properties);
		}
		@Override
		public Optional<String> getPrefix() {
			return Optional.of("(");
		}
		@Override
		public Optional<String> getSuffix() {
			return Optional.of(")");
		}
	}
	/**
	 * Creates an index hint. Mostly useful when building elements outside the fluent DSL.
	 *
	 * @param seek       Set to true to use the index for seeks only
	 * @param properties The properties to use in the index, must know their container
	 * @return A hint
	 * @since 2021.2.3
	 */
	public static Hint useIndexFor(boolean seek, Property... properties) {
		Assertions.notEmpty(properties, "Cannot use an index without properties!");
		List<SymbolicName> deferencedProperties = new ArrayList<>();
		IndexReference indexReference = null;
		for (Property property : properties) {
			Named container = property.getContainer();
			Assertions.notNull(container, "Cannot use a property without a reference to a container inside an index hint.");
			Assertions.isTrue(property.getNames().size() == 1,
				"One single property is required. Nested properties are not supported.");
			NodeLabel label;
			if (container instanceof Node node) {
				List<NodeLabel> labels = node.getLabels();
				Assertions.isTrue(labels.size() == 1, "Exactly one label is required to define the index.");
				label = labels.get(0);
			} else if (container instanceof Relationship relationship) {
				List<String> types = relationship.getDetails().getTypes();
				Assertions.isTrue(types.size() == 1, "Exactly one type is required to define the index.");
				label = new NodeLabel(types.get(0));
			} else {
				throw new IllegalArgumentException("A property index can only be used for Nodes or Relationships.");
			}
			SymbolicName symbolicName = container.getRequiredSymbolicName();
			if (indexReference == null) {
				indexReference = new IndexReference(symbolicName, label);
			} else if (!indexReference.pointsToSameContainer(symbolicName, label)) {
				throw new IllegalStateException(
					"If you want to use more than one index on different nodes you must use multiple `USING INDEX` statements.");
			}
			deferencedProperties.add(property.getNames().get(0).getPropertyKeyName());
		}
		return new Hint(seek ? Type.INDEX_SEEK : Type.INDEX, Collections.singletonList(indexReference),
			new IndexProperties(deferencedProperties));
	}
	/**
	 * Creates an index scan hint. Mostly useful when building elements outside the fluent DSL.
	 *
	 * @param node The node who's label and name should be used to define the scan hint
	 * @return A hint
	 * @since 2021.2.3
	 */
	public static Hint useScanFor(Node node) {
		Assertions.notNull(node, "Cannot apply a SCAN hint without a node.");
		List<NodeLabel> labels = node.getLabels();
		Assertions.isTrue(labels.size() == 1, "Exactly one label is required for a SCAN hint.");
		return new Hint(Type.SCAN,
			Collections.singletonList(new IndexReference(node.getRequiredSymbolicName(), labels.get(0))),
			null);
	}
	/**
	 * Creates a join hint on one or more symbolic names.
	 *
	 * @param name The names that are supposed to provide the join point
	 * @return A hint
	 * @since 2021.2.3
	 */
	public static Hint useJoinOn(SymbolicName... name) {
		Assertions.notEmpty(name, "At least one name is required to define a JOIN hint.");
		return new Hint(Type.JOIN_ON, Arrays.stream(name).map(IndexReference::new).toList(), null);
	}
	private final Type type;
	private final IndexReferences indexReferences;
	private final IndexProperties optionalProperties;
	private Hint(Type type, List<IndexReference> indexReferences, IndexProperties optionalProperties) {
		this.type = type;
		this.indexReferences = new IndexReferences(indexReferences);
		this.optionalProperties = optionalProperties;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.type.accept(visitor);
		this.indexReferences.accept(visitor);
		Visitable.visitIfNotNull(this.optionalProperties, visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.internal;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * Expresses the length of a relationship.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
public final class RelationshipLength implements Visitable {
	private final Integer minimum;
	private final Integer maximum;
	private final boolean unbounded;
	/**
	 * Creates an unbounded {@link RelationshipLength}.
	 *
	 * @return The new length definition
	 */
	public static RelationshipLength unbounded() {
		return new RelationshipLength(null, null);
	}
	/**
	 * Creates a {@link RelationshipLength} with given minimum and maximum values.
	 *
	 * @param minimum Minimum length
	 * @param maximum Maximum length
	 * @return The new length definition
	 */
	public static RelationshipLength of(Integer minimum, Integer maximum) {
		return new RelationshipLength(minimum, maximum);
	}
	private RelationshipLength(Integer minimum, Integer maximum) {
		this.minimum = minimum;
		this.maximum = maximum;
		this.unbounded = minimum == null && maximum == null;
	}
	/**
	 * @return Minimum number of hops to match.
	 */
	@API(status = INTERNAL)
	public Integer getMinimum() {
		return minimum;
	}
	/**
	 * @return Maximum number of hops to match.
	 */
	@API(status = INTERNAL)
	public Integer getMaximum() {
		return maximum;
	}
	/**
	 * @return True if neither minimum nor maximum number of hops are set.
	 */
	@API(status = INTERNAL)
	public boolean isUnbounded() {
		return unbounded;
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/NodePattern.html">NodePattern</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Node extends PatternElement, PropertyContainer, ExposesProperties<Node>, ExposesRelationships<Relationship> {
	/**
	 * @return The labels associated with this {@link Node}
	 */
	@NotNull @Contract(pure = true)
	List<NodeLabel> getLabels();
	/**
	 * Creates a copy of this node with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new node.
	 */
	@NotNull @Contract(pure = true)
	Node named(String newSymbolicName);
	/**
	 * Creates a copy of this node with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new node.
	 */
	@NotNull @Contract(pure = true)
	Node named(SymbolicName newSymbolicName);
	/**
	 * A condition that checks for the presence of labels on a node.
	 *
	 * @param labelsToQuery A list of labels to query
	 * @return A condition that checks whether this node has all the labels to query
	 */
	@NotNull @Contract(pure = true)
	Condition hasLabels(String... labelsToQuery);
	/**
	 * A condition that checks for the presence of a label expression on a node
	 * @since 2024.3.0
	 */
	@NotNull @Contract(pure = true)
	Condition hasLabels(LabelExpression labels);
	/**
	 * Creates a new condition whether this node is equal to {@literal otherNode}.
	 *
	 * @param otherNode The node to compare this node to.
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isEqualTo(Node otherNode);
	/**
	 * Creates a new condition whether this node is not equal to {@literal otherNode}.
	 *
	 * @param otherNode The node to compare this node to.
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNotEqualTo(Node otherNode);
	/**
	 * Creates a new condition based on this node whether it is null.
	 *
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNull();
	/**
	 * Creates a new condition based on this node whether it is not null.
	 *
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNotNull();
	/**
	 * Creates a new sort item of this node in descending order.
	 *
	 * @return A sort item.
	 */
	@NotNull @Contract(pure = true)
	SortItem descending();
	/**
	 * Creates a new sort item of this node in ascending order.
	 *
	 * @return A sort item.
	 */
	@NotNull @Contract(pure = true)
	SortItem ascending();
	/**
	 * Creates an alias for this node.
	 *
	 * @param alias The alias to use.
	 * @return The aliased expression.
	 */
	@NotNull @Contract(pure = true)
	AliasedExpression as(String alias);
	/**
	 * @return A new function invocation returning the internal id of this node.
	 * @deprecated Use {@link #elementId}
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2022.6.0")
	@SuppressWarnings({ "DeprecatedIsStillUsed", "squid:S1133" }) // The deprecation warning on any client code calling this is actually the point.
	FunctionInvocation internalId();
	/**
	 * @return A new function invocation returning the element id of this node.
	 * @since 2022.6.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default FunctionInvocation elementId() {
		return Functions.elementId(this);
	}
	/**
	 * @return A new function invocation returning the labels of this node.
	 */
	@NotNull @Contract(pure = true)
	FunctionInvocation labels();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * An expression can be used in many places, i.e. in return statements, pattern elements etc.
 *
 * @author Michael J. Simons
 * @author Aakash Sorathiya
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Expression extends Visitable, PropertyAccessor {
	/**
	 * Creates a condition that checks whether this {@code expression} includes all elements of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAll(Expression rhs) {
		return Conditions.includesAll(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} includes any element of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAny(Expression rhs) {
		return Conditions.includesAny(this, rhs);
	}
	/**
	 * Creates an expression with an alias. This expression does not track which or how many aliases have been created.
	 *
	 * @param alias The alias to use
	 * @return An aliased expression.
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(String alias) {
		Assertions.hasText(alias, "The alias may not be null or empty.");
		return new AliasedExpression(this, alias);
	}
	/**
	 * This creates a {@literal size(e)} expression from this expression. The Cypher output will semantically only be valid
	 * when this refers to a list
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">size(list)</a>)
	 * or when the expression is a string
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">size() applied to string</a>).
	 * <p>
	 * Any other expression will produce Cypher that is either deprecated in Neo4j &ge; 4.4 or not supported at all.
	 *
	 * @return The size of this expression (Either the number of items in a list or the number of characters in a string expression).
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Expression size() {
		return Functions.size(this);
	}
	/**
	 * Takes the {@link #size()} expresssions and compares it for equality with the parameter {@code expectedSize}. The
	 * same restrictions as with {@link #size()} apply.
	 * @param expectedSize The expected size
	 * @return A condition
	 * @see #size()
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition hasSize(Expression expectedSize) {
		return Functions.size(this).isEqualTo(expectedSize);
	}
	/**
	 * Reuse an existing symbolic name to alias this expression
	 *
	 * @param alias A symbolic name
	 * @return An aliased expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(SymbolicName alias) {
		Assertions.notNull(alias, "The alias may not be null.");
		return as(alias.getValue());
	}
	/**
	 * Transform this expression into a condition.
	 *
	 * @return this expression as a condition. Will return the same instance if it is already a condition.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	default Condition asCondition() {
		return this instanceof Condition condition ? condition : new ExpressionCondition(this);
	}
	/**
	 * Creates a {@code lhs = rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEqualTo(Expression rhs) {
		return Conditions.isEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition eq(Expression rhs) {
		return isEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs <> rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotEqualTo(Expression rhs) {
		return Conditions.isNotEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isNotEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition ne(Expression rhs) {
		return isNotEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs < rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lt(Expression rhs) {
		return Conditions.lt(this, rhs);
	}
	/**
	 * Creates a {@code lhs <= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lte(Expression rhs) {
		return Conditions.lte(this, rhs);
	}
	/**
	 * Creates a {@code lhs > rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gt(Expression rhs) {
		return Conditions.gt(this, rhs);
	}
	/**
	 * Creates a {@code lhs >= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gte(Expression rhs) {
		return Conditions.gte(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal true}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isTrue() {
		return Conditions.isEqualTo(this, Cypher.literalTrue());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal false}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isFalse() {
		return Conditions.isEqualTo(this, Cypher.literalFalse());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(Expression expression) {
		return Conditions.matches(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches the given {@code pattern}.
	 *
	 * @param pattern The pattern to match
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(String pattern) {
		return Conditions.matches(this, Cypher.literalOf(pattern));
	}
	/**
	 * Creates a condition that checks whether this {@code expression} starts with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition startsWith(Expression expression) {
		return Conditions.startsWith(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} contains that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition contains(Expression expression) {
		return Conditions.contains(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} ends with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition endsWith(Expression expression) {
		return Conditions.endsWith(this, expression);
	}
	/**
	 * Creates an expression concatenating two string or list expressions.
	 *
	 * @param expression The expression to concat to this expression.
	 * @return A new expression.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation concat(Expression expression) {
		return Operations.concat(this, expression);
	}
	/**
	 * Creates a {@code +} operation of this (the augend) and the {@code addend}.
	 *
	 * @param addend The addend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation add(Expression addend) {
		return Operations.add(this, addend);
	}
	/**
	 * Creates a {@code -} operation of this (the minuend) and the {@code subtrahend}.
	 *
	 * @param subtrahend The subtrahend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation subtract(Expression subtrahend) {
		return Operations.subtract(this, subtrahend);
	}
	/**
	 * Creates a {@code *} operation of this (the multiplier) and the {@code multiplicand}.
	 *
	 * @param multiplicand The multiplicand
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation multiply(Expression multiplicand) {
		return Operations.multiply(this, multiplicand);
	}
	/**
	 * Creates a {@code /} operation of this (the divisor) and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation divide(Expression dividend) {
		return Operations.divide(this, dividend);
	}
	/**
	 * Returns the remainder of this value and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation remainder(Expression dividend) {
		return Operations.remainder(this, dividend);
	}
	/**
	 * Returns the power of n of this value.
	 *
	 * @param n power to raise this {@code Expression} to.
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation pow(Expression n) {
		return Operations.pow(this, n);
	}
	/**
	 * Creates a {@code IS NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNull() {
		return Conditions.isNull(this);
	}
	/**
	 * Creates a {@code IS NOT NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is not null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotNull() {
		return Conditions.isNotNull(this);
	}
	/**
	 * Creates a {@code IN} operation for this expression and that {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @param haystack The expression to search for this expression
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	default Condition in(Expression haystack) {
		return Comparison.create(this, Operator.IN, haystack);
	}
	/**
	 * Creates a condition that evaluates to true if this expression is empty.
	 *
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEmpty() {
		return Functions.size(this).isEqualTo(Cypher.literalOf(0L));
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in descending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem descending() {
		return SortItem.create(this, SortItem.Direction.DESC);
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in ascending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem ascending() {
		return SortItem.create(this, SortItem.Direction.ASC);
	}
	/**
	 * Creates a new sort item with the given direction.
	 *
	 * @param direction The direction to sort
	 * @return A new sort item.
	 * @since 2021.4.1
	 */
	@NotNull @Contract(pure = true)
	default SortItem sorted(SortItem.Direction direction) {
		return SortItem.create(this, direction);
	}
	@Override @NotNull
	default Property property(String... names) {
		return InternalPropertyImpl.create(this, names);
	}
	/**
	 * Creates a new {@link Property} associated with this property container. This property can be used as a lookup in
	 * other expressions. It does not add a value to the property.
	 * <p>
	 * The new {@link Property} object is a dynamic lookup, based on the {@code expression} passed to this method. The
	 * expression can be example another property, a function result or a Cypher parameter. A property defined in such a way will
	 * render as {@code p[expression]}.
	 * <p>
	 * Note: The property container does not track property creation and there is no possibility to enumerate all
	 * properties that have been created for this property container.
	 *
	 * @param lookup the expression that is evaluated to lookup this property.
	 * @return a new {@link Property} associated with this named container
	 * @since 2024.1.0
	 */
	@Override @NotNull
	default Property property(@NotNull Expression lookup) {
		return InternalPropertyImpl.create(this, lookup);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * Roughly corresponding to <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Match.html#Where">Where</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class Where implements Visitable {
	private final Condition condition;
	/**
	 * Creates a new {@literal WHERE}
	 *
	 * @param optionalWhere An optional expression that must be usable {@link Expression#asCondition() "as condition"}.
	 * @return A {@literal WHERE} expression or null when {@code optionalWhere} has been {@literal NULL}
	 * @since 2022.0.0
	 */
	@Nullable
	public static Where from(@Nullable Expression optionalWhere) {
		return optionalWhere == null ? null : new Where(optionalWhere.asCondition());
	}
	Where(Condition condition) {
		this.condition = condition;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.condition.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.renderer.Configuration;
import org.neo4j.cypherdsl.core.renderer.Dialect;
import org.neo4j.cypherdsl.core.renderer.GeneralizedRenderer;
import org.neo4j.cypherdsl.core.renderer.Renderer;
/**
 * A bridge to the renderer as a single entry point from core to the renderer infrastructure.
 *
 * @author Michael J. Simons
 * @since 2023.1.0
 */
class RendererBridge {
	private static final Configuration CONFIGURATION = Configuration.newConfig()
		.withDialect(Dialect.NEO4J_5)
		.alwaysEscapeNames(false).build();
	static String render(Visitable visitable) {
		String name;
		Class<? extends Visitable> clazz = visitable.getClass();
		if (clazz.isAnonymousClass()) {
			name = clazz.getName();
		} else {
			name = clazz.getSimpleName();
		}
		return "%s{cypher=%s}".formatted(name, Renderer.getRenderer(CONFIGURATION, GeneralizedRenderer.class).render(visitable));
	}
	private RendererBridge() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.querydsl.CypherContext;
import org.neo4j.cypherdsl.core.querydsl.ToCypherFormatStringVisitor;
import com.querydsl.core.BooleanBuilder;
import com.querydsl.core.types.Path;
import com.querydsl.core.types.Predicate;
/**
 * This is a utility class to turn a several Query-DSL {@link com.querydsl.core.types.Expression expressions} into something
 * the Cypher-DSL can understand. It can only be used when `com.querydsl:querydsl-core` is on the classpath. While we
 * try our best to translate as many expression as possible into syntactically correct Cypher, we don't provide any guarantees
 * that the expressions and conditions generated are semantically correct in the context of the final query generated.
 *
 * @author Michael J. Simons
 * @soundtrack Paul Kalkbrenner - Berlin Calling
 * @since 2021.1.0
 */
@API(status = INTERNAL, since = "2021.1.0")
@SuppressWarnings("unused")
@RegisterForReflection(allDeclaredConstructors = true)
final class QueryDSLAdapter implements ForeignAdapter<com.querydsl.core.types.Expression<?>> {
	private final com.querydsl.core.types.Expression<?> expression;
	QueryDSLAdapter(com.querydsl.core.types.Expression<?> expression) {
		this.expression = expression;
	}
	@Override
	@NotNull
	@SuppressWarnings("deprecation")
	public Condition asCondition() {
		if (!(expression instanceof Predicate)) {
			throw new IllegalArgumentException("Only Query-DSL predicates can be turned into Cypher-DSL's predicates.");
		}
		if (expression instanceof BooleanBuilder booleanBuilder && !booleanBuilder.hasValue()) {
			return Conditions.noCondition();
		}
		CypherContext context = new CypherContext();
		String formatString = expression.accept(ToCypherFormatStringVisitor.INSTANCE, context);
		return new ExpressionCondition(Cypher.raw(formatString, (Object[]) context.getExpressions()));
	}
	@Override
	@NotNull
	public Expression asExpression() {
		CypherContext context = new CypherContext();
		String formatString = expression.accept(ToCypherFormatStringVisitor.INSTANCE, context);
		return Cypher.raw(formatString, (Object[]) context.getExpressions());
	}
	@Override
	@NotNull
	public Node asNode() {
		if (!(expression instanceof Path<?> entityPath)) {
			throw new IllegalArgumentException("Only Query-DSL paths can be turned into nodes.");
		}
		return Cypher.node(entityPath.getRoot().getType().getSimpleName()).named(entityPath.getMetadata().getName());
	}
	@NotNull
	@Override
	public Relationship asRelationship() {
		throw new UnsupportedOperationException("Not yet implemented.");
	}
	@Override
	@NotNull
	public SymbolicName asName() {
		if (!(expression instanceof Path<?> entityPath)) {
			throw new IllegalArgumentException("Only Query-DSL paths can be turned into names.");
		}
		return Cypher.name(entityPath.getMetadata().getName());
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.FunctionInvocation.FunctionDefinition;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Represents a named path. A named path can be either a {@link RelationshipPattern} that has been assigned to a variable
 * as in {@code p := (a)-->(b)}, a call to functions known to return paths or an existing, symbolic name that might come
 * from an arbitrary procedure returning path elements.
 * <br>
 * <b>Note</b>: We cannot check a value that has been yielded from a procedure upfront to verify that it is a named
 * path. This is up to the caller.
 *
 * @author Michael J. Simons
 * @soundtrack Freddie Mercury - Never Boring
 * @since 1.1
 */
@API(status = STABLE, since = "1.1")
public final class NamedPath implements PatternElement, Named {
	/**
	 * The name of this path expression.
	 */
	private final SymbolicName name;
	/**
	 * The pattern defining this path.
	 */
	private final Visitable optionalPattern;
	static OngoingDefinitionWithName named(String name) {
		return named(SymbolicName.of(name));
	}
	static OngoingDefinitionWithName named(SymbolicName name) {
		Assertions.notNull(name, "A name is required");
		return new Builder(name);
	}
	static OngoingShortestPathDefinitionWithName named(String name, FunctionDefinition algorithm) {
		return new ShortestPathBuilder(SymbolicName.of(name), algorithm);
	}
	static OngoingShortestPathDefinitionWithName named(SymbolicName name, FunctionDefinition algorithm) {
		Assertions.notNull(name, "A name is required");
		return new ShortestPathBuilder(name, algorithm);
	}
	/**
	 * Partial path that has a name ({@code p = }).
	 */
	public interface OngoingDefinitionWithName {
		/**
		 * Create a new named path based on a {@link PatternElement} single node.
		 * If a {@link NamedPath} will be provided, it will get used directly.
		 *
		 * @param patternElement The PatternElement to be used in named path.
		 * @return A named path.
		 */
		@NotNull @Contract(pure = true)
		NamedPath definedBy(PatternElement patternElement);
		/**
		 * Create a new named path that references a given, symbolic name. No checks are done if the referenced name
		 * actually points to a path.
		 *
		 * @return A named path.
		 * @since 2020.1.4
		 */
		@NotNull @Contract(pure = true)
		NamedPath get();
	}
	/**
	 * Partial path that has a name ({@code p = }) and is based on a graph algorithm function.
	 */
	public interface OngoingShortestPathDefinitionWithName {
		/**
		 * Create a new named path based on a single relationship.
		 *
		 * @param relationship The relationship to be passed to {@code shortestPath}.
		 * @return A named path.
		 */
		NamedPath definedBy(Relationship relationship);
	}
	private record Builder(SymbolicName name) implements OngoingDefinitionWithName {
		@NotNull
		@Override
		public NamedPath definedBy(PatternElement pattern) {
			if (pattern instanceof NamedPath namedPath) {
				return namedPath;
			}
			return new NamedPath(name, pattern);
		}
		@NotNull
		@Override
		public NamedPath get() {
			return new NamedPath(name);
		}
	}
	private record ShortestPathBuilder(
		SymbolicName name, FunctionDefinition algorithm) implements OngoingShortestPathDefinitionWithName {
		@Override
		public NamedPath definedBy(Relationship relationship) {
			return new NamedPath(name, FunctionInvocation.create(algorithm, relationship));
		}
	}
	private NamedPath(SymbolicName name) {
		this.name = name;
		this.optionalPattern = null;
	}
	private NamedPath(SymbolicName name, PatternElement optionalPattern) {
		this.name = name;
		this.optionalPattern = optionalPattern;
	}
	private NamedPath(SymbolicName name, FunctionInvocation algorithm) {
		this.name = name;
		this.optionalPattern = algorithm;
	}
	@Override
	@NotNull
	public Optional<SymbolicName> getSymbolicName() {
		return Optional.of(name);
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.name.accept(visitor);
		if (optionalPattern != null) {
			Operator.ASSIGMENT.accept(visitor);
			this.optionalPattern.accept(visitor);
		}
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * Represents an adapter that allows to turn foreign expressions into Cypher-DSL {@link Expression expressions}.
 *
 * @author Michael J. Simons
 * @param <FE> The type of the foreign expression.
 * @soundtrack Paul Kalkbrenner - Berlin Calling
 * @since 2021.1.0
 */
@API(status = STABLE, since = "2021.1.0")
public interface ForeignAdapter<FE> {
	/**
	 * Adapts a foreign expression into a Cypher-DSL {@link Condition}. The memoized expression should be something  that
	 * can be evaluated into something boolean.
	 *
	 * @return A condition
	 * @throws IllegalArgumentException if the expression doesn't resolve into something boolean
	 */
	@NotNull @Contract(pure = true)
	Condition asCondition();
	/**
	 * Adapts a foreign expression into a Cypher-DSL {@link Expression}.
	 *
	 * @return A native expression
	 */
	@NotNull @Contract(pure = true)
	Expression asExpression();
	/**
	 * Adapts a foreign expression into a Cypher-DSL {@link Node}, that allows to address it further down in queries.
	 *
	 * @return A node
	 * @throws IllegalArgumentException if the expression doesn't describe something that can be used to describe a node
	 */
	@NotNull @Contract(pure = true)
	Node asNode();
	/**
	 * Adapts a foreign expression into a Cypher-DSL {@link Relationship}, that allows to address it further down in queries.
	 *
	 * @return A node
	 * @throws IllegalArgumentException if the expression doesn't describe something that can be used to describe a node
	 */
	@NotNull @Contract(pure = true)
	Relationship asRelationship();
	/**
	 * Adapts a foreign expression into a Cypher-DSL {@link SymbolicName}. The memoized expression should ideally be something
	 * that is named or resolves to an alias.
	 *
	 * @return A symbolic name
	 * @throws IllegalArgumentException if a name cannot be derived from the expression.
	 */
	@NotNull @Contract(pure = true)
	SymbolicName asName();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.lang.reflect.Array;
import java.net.URI;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.TimeZone;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ListComprehension.OngoingDefinitionWithVariable;
import org.neo4j.cypherdsl.core.Literal.UnsupportedLiteralException;
import org.neo4j.cypherdsl.core.PatternComprehension.OngoingDefinitionWithPattern;
import org.neo4j.cypherdsl.core.Statement.SingleQuery;
import org.neo4j.cypherdsl.core.Statement.UnionQuery;
import org.neo4j.cypherdsl.core.Statement.UseStatement;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingStandaloneCallWithoutArguments;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * The main entry point into the Cypher DSL.
 * The Cypher Builder API is intended for framework usage to produce Cypher statements required for database operations.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Andreas Berger
 * @author Ali Ince
 * @since 1.0
 */
@SuppressWarnings("unused") @API(status = STABLE, since = "1.0")
public final class Cypher {
	static final ResourceBundle MESSAGES = ResourceBundle.getBundle("org.neo4j.cypherdsl.core.messages");
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, String... additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, List<String> additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, String... additionalLabels) {
		return new InternalNodeImpl(null, primaryLabel, properties, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, Collection<String> additionalLabels) {
		return node(primaryLabel, properties, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * @return A node matching any node.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode() {
		return new InternalNodeImpl();
	}
	/**
	 * @param labelExpression required expression
	 * @return A node matching a label expression
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(LabelExpression labelExpression) {
		return new InternalNodeImpl(Objects.requireNonNull(labelExpression), null);
	}
	/**
	 * @return The {@code *} wildcard literal.
	 */
	@NotNull @Contract(pure = true)
	public static Asterisk asterisk() {
		return Asterisk.INSTANCE;
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(String symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(SymbolicName symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, String... names) {
		return property(name(containerName), names);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Collection<String> names) {
		return property(name(containerName), names.toArray(new String[] {}));
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, String... names) {
		return InternalPropertyImpl.create(expression, names);
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Collection<String> names) {
		return property(expression, names.toArray(new String[] {}));
	}
	/**
	 * Creates a dynamic lookup of a property for a symbolic name, most likely pointing to a property container like a
	 * node or a relationship. A dynamic property will be rendered as {@code p[expression]}.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param lookup        An expression to use as a dynamic lookup for properties of the container with the given name
	 * @return A new property
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Expression lookup) {
		return property(name(containerName), lookup);
	}
	/**
	 * Creates a dynamic lookup of a property on a arbitrary expression. A dynamic property will be rendered as
	 * {@code p[expression]}.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param lookup     An expression to use as a dynamic lookup for properties of the container the expression resolved to
	 * @return A new property.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Expression lookup) {
		return InternalPropertyImpl.create(expression, lookup);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(String name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(SymbolicName name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(String name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(SymbolicName name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Creates a new symbolic name.
	 *
	 * @param value The value of the symbolic name
	 * @return A new symbolic name
	 */
	@NotNull @Contract(pure = true)
	public static SymbolicName name(String value) {
		return SymbolicName.of(value);
	}
	/**
	 * Creates a new parameter placeholder. Existing $-signs will be removed.
	 *
	 * @param name The name of the parameter, must not be null
	 * @return The new parameter
	 */
	@NotNull @Contract(pure = true)
	public static Parameter<Object> parameter(String name) {
		return Parameter.create(name);
	}
	/**
	 * Creates a new parameter with the given {@code name} and a value bound to it.
	 * The value can be retrieved from the final statement build.
	 *
	 * @param name  The name of the parameter, must not be null
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> parameter(String name, T value) {
		return Parameter.create(name, value);
	}
	/**
	 * Creates a new anonymous parameter with a value bound to it. The value can be retrieved from the final statement build.
	 * The name will be available as soon as the statement has been rendered.
	 *
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> anonParameter(T value) {
		return Parameter.anon(value);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(PatternElement... pattern) {
		return Statement.builder().optionalMatch(pattern);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(
		Collection<? extends PatternElement> pattern) {
		return optionalMatch(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(PatternElement... pattern) {
		return Statement.builder().match(pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(Collection<? extends PatternElement> pattern) {
		return match(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2020.1.3
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
		return Statement.builder().match(optional, pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional,
		Collection<? extends PatternElement> pattern) {
		return match(optional, pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(PatternElement... pattern) {
		return Statement.builder().create(pattern);
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(Collection<? extends PatternElement> pattern) {
		return create(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} obviously cannot be used with patterns and needs its
	 * arguments to have an alias.
	 *
	 * @param variables One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(String... variables) {
		return Statement.builder().with(variables);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 *
	 * @param elements One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(IdentifiableElement... elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(String... identifiableElements) {
		return subqueryWith(Arrays.stream(identifiableElements).map(SymbolicName::of).toArray(SymbolicName[]::new));
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(IdentifiableElement... identifiableElements) {
		return Expressions.with(identifiableElements);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 * <p>
	 * This method takes both aliased and non-aliased expression. The later will produce only valid Cypher when used in
	 * combination with a correlated subquery via {@link Cypher#call(Statement)}.
	 *
	 * @param elements One ore more expressions.
	 * @return An ongoing with clause.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(
		Collection<IdentifiableElement> elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(PatternElement... pattern) {
		return Statement.builder().merge(pattern);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(Collection<? extends PatternElement> pattern) {
		return merge(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expression needs to be an expression
	 * evaluating to a list, otherwise the query will fail.
	 *
	 * @param expression The expression to unwind
	 * @return An ongoing {@code UNWIND}.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression expression) {
		return Statement.builder().unwind(expression);
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression... expressions) {
		return Statement.builder().unwind(Cypher.listOf(expressions));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Collection<? extends Expression> expressions) {
		return unwind(expressions.toArray(new Expression[] {}));
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @return A sort item, providing means to specify ascending or descending order
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression) {
		return SortItem.create(expression, null);
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @param direction  The direction to sort by. Defaults to {@link SortItem.Direction#UNDEFINED}.
	 * @return A sort item
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression, SortItem.Direction direction) {
		return SortItem.create(expression, direction);
	}
	/**
	 * Creates a map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression mapOf(Object... keysAndValues) {
		return MapExpression.create(false, keysAndValues);
	}
	/**
	 * Creates an alphabetically sorted map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression sortedMapOf(Object... keysAndValues) {
		return MapExpression.create(true, keysAndValues);
	}
	/**
	 * Creates a map of expression from a Java Map.
	 *
	 * @param map A map to be turned into a MapExpression
	 * @return A new map expression.
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression asExpression(Map<String, Object> map) {
		return MapExpression.create(map);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Expression... expressions) {
		return ListExpression.create(expressions);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Collection<? extends Expression> expressions) {
		return Cypher.listOf(expressions.toArray(new Expression[0]));
	}
	/**
	 * Creates a new {@link Literal Literal&lt;?&gt;} from the given {@code object}.
	 *
	 * @param object the object to represent.
	 * @param <T>    The type of the literal returned
	 * @return a new {@link Literal Literal&lt;?&gt;}.
	 * @throws UnsupportedLiteralException when the object cannot be represented as a literal
	 */
	@SuppressWarnings("unchecked")
	@NotNull @Contract(pure = true)
	public static <T> Literal<T> literalOf(Object object) {
		if (object == null) {
			return (Literal<T>) NullLiteral.INSTANCE;
		}
		if (object instanceof Literal<?>) {
			return (Literal<T>) object;
		}
		if (object instanceof CharSequence charSequence) {
			return (Literal<T>) new StringLiteral(charSequence);
		}
		if (object instanceof Character) {
			return (Literal<T>) new StringLiteral(String.valueOf(object));
		}
		if (object instanceof Number number) {
			return (Literal<T>) new NumberLiteral(number);
		}
		if (object instanceof TemporalAccessor temporalAccessor) {
			return (Literal<T>) new TemporalLiteral(temporalAccessor);
		}
		if (object instanceof Duration duration) {
			return (Literal<T>) DurationLiteral.of(duration);
		}
		if (object instanceof Period period) {
			return (Literal<T>) PeriodLiteral.of(period);
		}
		if (object instanceof Iterable || object.getClass().isArray()) {
			List<Literal<?>> elements = new ArrayList<>();
			Consumer<Object> handleElement = element -> {
				if (element instanceof Literal) {
					elements.add((Literal<?>) element);
				} else {
					try {
						elements.add(Cypher.literalOf(element));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in iterable.", element);
					}
				}
			};
			if (object.getClass().isArray()) {
				for (int i = 0; i < Array.getLength(object); i++) {
					handleElement.accept(Array.get(object, i));
				}
			} else {
				((Iterable<?>) object).forEach(handleElement);
			}
			ListLiteral listLiteral = new ListLiteral(elements);
			return (Literal<T>) listLiteral;
		}
		if (object instanceof Map) {
			Map<String, Literal<?>> map = new LinkedHashMap<>();
			BiConsumer<Object, Object> handleEntry = (key, value) -> {
				if (!(key instanceof CharSequence || key instanceof Character)) {
					throw new UnsupportedLiteralException(
						"Unsupported literal map key (not a string/char type).", key);
				}
				if (value instanceof Literal) {
					map.put(key.toString(), (Literal<?>) value);
				} else {
					try {
						map.put(key.toString(), Cypher.literalOf(value));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in map.", value);
					}
				}
			};
			((Map<?, ?>) object).forEach(handleEntry);
			MapLiteral mapLiteral = new MapLiteral(map);
			return (Literal<T>) mapLiteral;
		}
		if (object instanceof Boolean b) {
			return (Literal<T>) BooleanLiteral.of(b);
		}
		throw new UnsupportedLiteralException(object);
	}
	/**
	 * @return The {@literal true} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalTrue() {
		return BooleanLiteral.TRUE;
	}
	/**
	 * @return The {@literal false} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalFalse() {
		return BooleanLiteral.FALSE;
	}
	/**
	 * @return The {@literal null} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Void> literalNull() {
		return NullLiteral.INSTANCE;
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Statement... statements) {
		return unionImpl(false, statements);
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Collection<Statement> statements) {
		return union(statements.toArray(new Statement[] {}));
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Statement... statements) {
		return unionImpl(true, statements);
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Collection<Statement> statements) {
		return unionAll(statements.toArray(new Statement[] {}));
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The elements to return
	 * @return A buildable statement
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Expression... expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The expressions to return
	 * @return A buildable statement
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * Creates a list comprehension starting with a {@link Relationship} or a {@link RelationshipChain chain of relationships}.
	 *
	 * @param relationshipPattern The relationship pattern on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.0.0
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(RelationshipPattern relationshipPattern) {
		return PatternComprehension.basedOn(relationshipPattern);
	}
	/**
	 * Creates a list comprehension starting with a {@link NamedPath named path}.
	 *
	 * @param namedPath The named path on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.1.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(NamedPath namedPath) {
		return PatternComprehension.basedOn(namedPath);
	}
	/**
	 * Starts defining a {@link ListComprehension list comprehension}.
	 *
	 * @param variable The variable to which each element of the list is assigned.
	 * @return An ongoing definition of a list comprehension
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithVariable listWith(SymbolicName variable) {
		return ListComprehension.with(variable);
	}
	/**
	 * Escapes and quotes the {@code unquotedString} for safe usage in Neo4j-Browser and Shell.
	 *
	 * @param unquotedString An unquoted string
	 * @return A quoted string with special chars escaped.
	 */
	@NotNull @Contract(pure = true)
	public static String quote(String unquotedString) {
		return literalOf(unquotedString).asString();
	}
	/**
	 * @return generic case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression() {
		return Case.create(null);
	}
	/**
	 * @param expression initial expression for the simple case statement
	 * @return simple case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression(@Nullable Expression expression) {
		return Case.create(expression);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given {@literal procedureName}. That
	 * procedure name might be fully qualified - that is, including a namespace - or just a simple name.
	 *
	 * @param procedureName The procedure name of the procedure to call. Might be fully qualified.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String procedureName) {
		Assertions.hasText(procedureName, "The procedure name must not be null or empty.");
		return call(procedureName.split("\\."));
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String... namespaceAndProcedure) {
		return Statement.call(namespaceAndProcedure);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(Collection<String> namespaceAndProcedure) {
		return call(namespaceAndProcedure.toArray(new String[] {}));
	}
	/**
	 * Starts building a statement based on one subquery.
	 *
	 * @param subquery The statement representing the subquery
	 * @return A new ongoing read without any further conditions or returns.
	 * @neo4j.version 4.0.0
	 * @see ExposesSubqueryCall#call(Statement)
	 * @since 2020.1.2
	 */
	@Neo4jVersion(minimum = "4.0.0")
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere call(Statement subquery) {
		return Statement.builder().call(subquery);
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Integer start, Integer end) {
		return ListOperator.subList(targetExpression, Cypher.literalOf(start), Cypher.literalOf(end));
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Expression start, Expression end) {
		return ListOperator.subList(targetExpression, start, end);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Integer start) {
		return ListOperator.subListFrom(targetExpression, Cypher.literalOf(start));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Expression start) {
		return ListOperator.subListFrom(targetExpression, start);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Integer end) {
		return ListOperator.subListUntil(targetExpression, Cypher.literalOf(end));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Expression end) {
		return ListOperator.subListUntil(targetExpression, end);
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Integer index) {
		return valueAt(targetExpression, Cypher.literalOf(index));
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Expression index) {
		return ListOperator.valueAt(targetExpression, index);
	}
	/**
	 * Creates an expression from a raw string fragment. No validation is performed on it. If it is used as expression,
	 * you must make sure to define something that works as expression.
	 * <p>
	 * This method expects exactly one placeholder in the form of {@literal $E} for any argument passed with {@code mixedArgs}.
	 * <p>
	 * To use exactly the term {@literal $E} escape it like this: {@literal \$E}
	 *
	 * @param format    A raw Cypher string
	 * @param mixedArgs Args to the Cypher string
	 * @return An expression to reuse with the builder.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Expression raw(String format, Object... mixedArgs) {
		return RawLiteral.create(format, mixedArgs);
	}
	/**
	 * Starts building a statement from a raw Cypher string that might also have arguments as supported through {@link Cypher#raw(String, Object...)}.
	 * Use this method as your own risk and be aware that no checks are done on the Cypher.
	 *
	 * @param rawCypher the raw Cypher statement to call
	 * @param args      optional args that replace placeholders in the {@code rawCypher}
	 * @return Ongoing sub-query definition based on the raw Cypher statement.
	 * @since 2024.2.0
	 */
	public static ExposesSubqueryCall.BuildableSubquery callRawCypher(String rawCypher, Object... args) {
		return Statement.builder().callRawCypher(rawCypher, args);
	}
	/**
	 * Creates a {@code RETURN} clause from a raw Cypher expression created via {@link Cypher#raw(String, Object...)}.
	 * The expression maybe aliased but it must resolve to a raw element
	 *
	 * @param rawExpression Must be a plain raw or an aliased raw expression. To eventually render as valid Cypher, it must
	 *                      contain the {@code RETURN} keyword.
	 * @return A match that can be build now
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
		return Statement.builder().returningRaw(rawExpression);
	}
	/**
	 * The foreign adapter factory. Can only be used when `com.querydsl:querydsl-core` is on the class path. The object
	 * won't be modified after initialisation.
	 */
	@SuppressWarnings("squid:S3077")
	private static volatile ForeignAdapterFactory foreignAdapterFactory;
	/**
	 * Provides access to the foreign DSL adapter. Please make sure you have the necessary runtime dependencies on the class path,
	 * otherwise you will see some kind of {@link ClassNotFoundException} along various classes related to the foreign DSL.
	 *
	 * @param expression The expression that should be adapted
	 * @param <FE>       The type of the expression
	 * @return A foreign adapter
	 * @throws IllegalArgumentException in case the object cannot be adapter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <FE> ForeignAdapter<FE> adapt(FE expression) {
		ForeignAdapterFactory initializedForeignAdapterFactory = foreignAdapterFactory;
		if (initializedForeignAdapterFactory == null) {
			synchronized (Cypher.class) {
				initializedForeignAdapterFactory = foreignAdapterFactory;
				if (initializedForeignAdapterFactory == null) {
					foreignAdapterFactory = new ForeignAdapterFactory();
					initializedForeignAdapterFactory = foreignAdapterFactory;
				}
			}
		}
		return initializedForeignAdapterFactory.getAdapterFor(expression);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit. The default rate of the database will be used.
	 *
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit() {
		return usingPeriodicCommit(null);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit.
	 *
	 * @param rate The rate to be used. No checks are done on the rate, the database will verify valid values.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit(@Nullable Integer rate) {
		return LoadCSVStatementBuilder.usingPeriodicCommit(rate);
	}
	/**
	 * Starts building a {@code LOAD CSV}. No headers are assumed.
	 *
	 * @param from The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from) {
		return loadCSV(from, false);
	}
	/**
	 * Starts building a {@code LOAD CSV}.
	 *
	 * @param from        The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @param withHeaders Set to {@literal true} if the csv file contains header
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from, boolean withHeaders) {
		return LoadCSVStatementBuilder.loadCSV(from, withHeaders);
	}
	private static UnionQuery unionImpl(boolean unionAll, Statement... statements) {
		Assertions.isTrue(statements != null && statements.length >= 2, "At least two statements are required!");
		int i = 0;
		UnionQueryImpl existingUnionQuery = null;
		@SuppressWarnings("squid:S2259") // Really, we asserted it 4 lines above this one. Thank you, sonar.
		boolean isUnionQuery = statements[0] instanceof UnionQueryImpl;
		if (isUnionQuery) {
			existingUnionQuery = (UnionQueryImpl) statements[0];
			Assertions.isTrue(existingUnionQuery.isAll() == unionAll, "Cannot mix union and union all!");
			i = 1;
		}
		List<Statement> listOfQueries = new ArrayList<>();
		do {
			Assertions.isTrue(statements[i] instanceof SingleQuery || statements[i] instanceof ClausesBasedStatement,
				"Can only union single queries!");
			listOfQueries.add(statements[i]);
		} while (++i < statements.length);
		if (existingUnionQuery == null) {
			return UnionQueryImpl.create(unionAll, listOfQueries);
		} else {
			return existingUnionQuery.addAdditionalQueries(listOfQueries);
		}
	}
	/**
	 * Tries to format this expression into something human-readable. Not all expressions are supported
	 *
	 * @param expression An expression to format
	 * @return A human-readable string
	 * @throws IllegalArgumentException When the expression cannot be formatted
	 * @since 2021.3.2
	 */
	@SuppressWarnings("deprecation")
	public static String format(Expression expression) {
		return Expressions.format(expression);
	}
	/**
	 * Decorates the given statement by prepending a static {@literal USE} clause.
	 *
	 * @param target    The target. This might be a single database or a constituent of a composite database. This value
	 *                  will be escaped if necessary. If it contains a {@literal .}, both the first and second part will
	 *                  be escaped individually.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(String target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A parameter that must resolve to a Cypher string.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(Parameter<?> target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A string expression
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(StringLiteral target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database unless {@link Cypher#graphByName(Expression)} has
	 * already been used.
	 *
	 * @param target    The name of a variable pointing to the graph or constituent
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.4.0
	 */
	public static UseStatement use(Expression target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes all elements present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains all values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return An "includesAll" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAll(Expression lhs, Expression rhs) {
		return Conditions.includesAll(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes any element present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains any values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return A "not_includes" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAny(Expression lhs, Expression rhs) {
		return Conditions.includesAny(lhs, rhs);
	}
	/**
	 * @param relationshipPattern The pattern being evaluated in a condition
	 * @return A new condition matching the given pattern
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matching(RelationshipPattern relationshipPattern) {
		return Conditions.matching(relationshipPattern);
	}
	/**
	 * Creates a condition that matches if the right hand side is a regular expression that matches the the left hand side via
	 * {@code =~}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A "matches" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matches(Expression lhs, Expression rhs) {
		return Conditions.matches(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code =}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code <>}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "not equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isNotEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lt(Expression lhs, Expression rhs) {
		return Conditions.lt(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lte(Expression lhs, Expression rhs) {
		return Conditions.lte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gte(Expression lhs, Expression rhs) {
		return Conditions.gte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gt(Expression lhs, Expression rhs) {
		return Conditions.gt(lhs, rhs);
	}
	/**
	 * Negates the given condition.
	 *
	 * @param condition The condition to negate. Must not be null.
	 * @return The negated condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull Condition condition) {
		return Conditions.not(condition);
	}
	/**
	 * Negates the given pattern element: The pattern must not matched to be included in the result.
	 *
	 * @param pattern The pattern to negate. Must not be null.
	 * @return A condition that evaluates to true when the pattern does not match.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull RelationshipPattern pattern) {
		return Conditions.not(pattern);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} starts with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition startsWith(Expression lhs, Expression rhs) {
		return Conditions.startsWith(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} contains with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition contains(Expression lhs, Expression rhs) {
		return Conditions.contains(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} ends with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition endsWith(Expression lhs, Expression rhs) {
		return Conditions.endsWith(lhs, rhs);
	}
	/**
	 * Creates a placeholder condition which is not rendered in the final statement but is useful while chaining
	 * conditions together.
	 *
	 * @return A placeholder condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition noCondition() {
		return Conditions.noCondition();
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNull(Expression expression) {
		return Conditions.isNull(expression);
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is not {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotNull(Expression expression) {
		return Conditions.isNotNull(expression);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code isEmpty()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-isempty">isEmpty</a>.
	 * <p>
	 * The argument {@code e} must refer to an expression that evaluates to a list for {@code isEmpty()} to work
	 *
	 * @param expression An expression referring to a list
	 * @return A function call for {@code isEmpty()} for a list
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEmpty(Expression expression) {
		return Predicates.isEmpty(expression);
	}
	/**
	 * @return a condition that is always true.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isTrue() {
		return Conditions.isTrue();
	}
	/**
	 * @return a condition that is always false.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isFalse() {
		return Conditions.isFalse();
	}
	/**
	 * @param symbolicName  Reference to the entity that should be checked for labels or types
	 * @param labelsOrTypes the list of labels or types to check for
	 * @return A condition that checks whether a node has a set of given labels or a relationship a set of given types.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition hasLabelsOrType(SymbolicName symbolicName, String... labelsOrTypes) {
		return Conditions.hasLabelsOrType(symbolicName, labelsOrTypes);
	}
	/**
	 * Creates a {@literal COUNT} sub-query expressions from at least one pattern.
	 *
	 * @param requiredPattern One pattern is required
	 * @param patternElement  Optional pattern
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
		return Expressions.count(requiredPattern, patternElement);
	}
	/**
	 * Creates a {@literal COUNT} with an inner {@literal UNION} sub-query.
	 *
	 * @param union The union that will be the source of the {@literal COUNT} sub-query
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(UnionQuery union) {
		return Expressions.count(union);
	}
	/**
	 * Creates a {@literal COUNT} from a full statement, including  its filters and conditions. The statement may or may
	 * not have a {@literal RETURN} clause. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement The statement to be passed to {@code count{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return A counting sub-query.
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return Expressions.count(statement, imports);
	}
	/**
	 * Creates a {@literal COUNT} expression based on a list of pattern
	 *
	 * @param pattern the list of patterns that shall be counted
	 * @param where   an optional where-clause
	 * @return a count expression.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static CountExpression count(List<PatternElement> pattern, @Nullable Where where) {
		return Expressions.count(pattern, where);
	}
	/**
	 * Creates a {@literal COLLECT} subquery from a statement, including  its filters and conditions. The statement must
	 * return exactly one column. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement the statement to be passed to {@code COLLECT{}}
	 * @return a collecting sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	@NotNull public static Expression collect(Statement statement) {
		return Expressions.collect(statement);
	}
	/**
	 * @param expression Possibly named with a non-empty symbolic name.
	 * @return The name of the expression if the expression is named or the expression itself.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static <T extends Expression> Expression nameOrExpression(T expression) {
		return Expressions.nameOrExpression(expression);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(String[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(Named[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param node The node for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a node.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Node node) {
		return Functions.elementId(node);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param relationship The relationship for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a relationship.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Relationship relationship) {
		return Functions.elementId(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param node The node which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Node node) {
		return Functions.keys(node);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param relationship The relationship which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Relationship relationship) {
		return Functions.keys(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param expression The expressions which keys should be returned. Must resolve to a node, relationship or map.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Expression expression) {
		return Functions.keys(expression);
	}
	/**
	 * Creates a function invocation for {@code labels{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull Node node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a  function invocation for  {@code labels{}}.  The {@link SymbolicName  symbolic name} {@code  node} must
	 * point to a node. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull SymbolicName node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a function invocation for {@code type{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull Relationship relationship) {
		return Functions.type(relationship);
	}
	/**
	 * Creates a  function invocation for  {@code type{}}. The {@link  SymbolicName symbolic name}  {@code relationship}
	 * must point to a relationship. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull SymbolicName relationship) {
		return Functions.type(relationship);
	}
	/**
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #count(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(@NotNull Node node) {
		return Functions.count(node);
	}
	/**
	 * Creates a function invocation for the {@code count()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(Expression expression) {
		return Functions.count(expression);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 *
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #countDistinct(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(@NotNull Node node) {
		return Functions.countDistinct(node);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(Expression expression) {
		return Functions.countDistinct(expression);
	}
	/**
	 * Creates a function invocation for {@code properties())} on nodes.
	 *
	 * @param node The node who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Node node) {
		return Functions.properties(node);
	}
	/**
	 * Creates a function invocation for {@code properties())} on relationships.
	 *
	 * @param relationship The relationship who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Relationship relationship) {
		return Functions.properties(relationship);
	}
	/**
	 * Creates a function invocation for {@code properties())} on maps.
	 *
	 * @param map The map who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(MapExpression map) {
		return Functions.properties(map);
	}
	/**
	 * Creates a function invocation for the {@code coalesce()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce">coalesce</a>.
	 *
	 * @param expressions One or more expressions to be coalesced
	 * @return A function call for {@code coalesce}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coalesce(Expression... expressions) {
		return Functions.coalesce(expressions);
	}
	/**
	 * Creates a function invocation for the {@code left()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">left</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code left()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation left(Expression expression, Expression length) {
		return Functions.left(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code ltrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">ltrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code ltrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ltrim(@NotNull Expression expression) {
		return Functions.ltrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code replace()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">replace</a>.
	 *
	 * @param original An expression that returns a string
	 * @param search   An expression that specifies the string to be replaced in {@code original}.
	 * @param replace  An expression that specifies the replacement string.
	 * @return A function call for {@code replace()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation replace(Expression original, Expression search,
		Expression replace) {
		return Functions.replace(original, search, replace);
	}
	/**
	 * Creates a function invocation for the {@code reverse()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-reverse">reverse</a>.
	 *
	 * @param original An expression that returns a string
	 * @return A function call for {@code reverse()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation reverse(@NotNull Expression original) {
		return Functions.reverse(original);
	}
	/**
	 * Creates a function invocation for the {@code right()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">right</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code right()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation right(Expression expression, Expression length) {
		return Functions.right(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code rtrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-rtrim">rtrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code rtrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rtrim(@NotNull Expression expression) {
		return Functions.rtrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code substring()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-substring">rtrim</a>.
	 *
	 * @param original An expression resolving to a string
	 * @param start    An expression that returns a positive integer, denoting the position at which the substring will begin.
	 * @param length   An expression that returns a positive integer, denoting how many characters of original will be returned.
	 * @return A function call for {@code substring()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation substring(Expression original, Expression start,
		Expression length) {
		return Functions.substring(original, start, length);
	}
	/**
	 * Creates a function invocation for the {@code toLower()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toLower">toLower</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toLower(@NotNull Expression expression) {
		return Functions.toLower(expression);
	}
	/**
	 * Creates a function invocation for the {@code toUpper()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toUpper">toUpper</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toUpper(@NotNull Expression expression) {
		return Functions.toUpper(expression);
	}
	/**
	 * Creates a function invocation for the {@code trim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim">trim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code trim()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation trim(@NotNull Expression expression) {
		return Functions.trim(expression);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull Expression delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull String delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">a list</a></li>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">to a string</a></li>
	 * </ul>
	 *
	 * @param expression The expression who's size is to be returned
	 * @return A function call for {@code size()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(Expression expression) {
		return Functions.size(expression);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression">to a pattern expression</a></li>
	 * </ul>
	 *
	 * @param pattern The pattern for which {@code size()} should be invoked.
	 * @return A function call for {@code size()} for a pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(RelationshipPattern pattern) {
		return Functions.size(pattern);
	}
	/**
	 * Creates a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param expression The expression who's existence is to be evaluated
	 * @return A function call for {@code exists()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exists(Expression expression) {
		return Functions.exists(expression);
	}
	/**
	 * Creates a function invocation for the {@code distance()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance">exists</a>.
	 * Both points need to be in the same coordinate system.
	 *
	 * @param point1 Point 1
	 * @param point2 Point 2
	 * @return A function call for {@code distance()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation distance(@NotNull Expression point1,
		@NotNull Expression point2) {
		return Functions.distance(point1, point2);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameterMap The map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(MapExpression parameterMap) {
		return Functions.point(parameterMap);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 * <p>
	 * This generic expression variant is useful for referencing a point inside a parameter or another map.
	 *
	 * @param expression An expression resolving to a valid map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Expression expression) {
		return Functions.point(expression);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameter A parameter referencing a {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Parameter<?> parameter) {
		return Functions.point(parameter);
	}
	/**
	 * Convenience method for creating a 2d cartesian point
	 *
	 * @param x The x coordinate
	 * @param y The y coordinate
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cartesian(double x, double y) {
		return Functions.cartesian(x, y);
	}
	/**
	 * Convenience method for creating a 2d coordinate in the WGS 84 coordinate system
	 *
	 * @param longitude The longitude
	 * @param latitude  The latitude
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coordinate(double longitude, double latitude) {
		return Functions.coordinate(longitude, latitude);
	}
	/**
	 * Creates a function invocation for the {@code point.withinBBox} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-withinBBox">point.withinBBox</a>.
	 *
	 * @param point      The point to check
	 * @param lowerLeft  The lower left point of the bounding box (south-west coordinate)
	 * @param upperRight The upper right point of the bounding box (north-east coordinate)
	 * @return A function call for {@code point.withinBBox}
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return Functions.withinBBox(point, lowerLeft, upperRight);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avg(Expression expression) {
		return Functions.avg(expression);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avgDistinct(Expression expression) {
		return Functions.avgDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(@NotNull Named variable) {
		return Functions.collect(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(@NotNull Named variable) {
		return Functions.collectDistinct(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(Expression expression) {
		return Functions.collect(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(Expression expression) {
		return Functions.collectDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation max(Expression expression) {
		return Functions.max(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation maxDistinct(Expression expression) {
		return Functions.maxDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation min(Expression expression) {
		return Functions.min(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation minDistinct(Expression expression) {
		return Functions.minDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileCont(Expression expression,
		Number percentile) {
		return Functions.percentileCont(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileContDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileContDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDisc(Expression expression,
		Number percentile) {
		return Functions.percentileDisc(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDiscDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileDiscDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDev(Expression expression) {
		return Functions.stDev(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevDistinct(Expression expression) {
		return Functions.stDevDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevP(Expression expression) {
		return Functions.stDevP(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevPDistinct(Expression expression) {
		return Functions.stDevPDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sum(Expression expression) {
		return Functions.sum(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function  with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sumDistinct(Expression expression) {
		return Functions.sumDistinct(expression);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(Integer start, Integer end) {
		return Functions.range(start, end);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end) {
		return Functions.range(start, end);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end,
		Integer step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end, Expression step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code head()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-head">head</a>.
	 *
	 * @param expression A list from which the head element is returned
	 * @return A function call for {@code head()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation head(Expression expression) {
		return Functions.head(expression);
	}
	/**
	 * Creates a function invocation for the {@code last()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-last">last</a>.
	 *
	 * @param expression A list from which the last element is returned
	 * @return A function call for {@code last()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation last(Expression expression) {
		return Functions.last(expression);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param path The path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull NamedPath path) {
		return Functions.nodes(path);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes{}} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		return Functions.nodes(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param path The path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull NamedPath path) {
		return Functions.relationships(path);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		return Functions.relationships(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code startNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-startnode">startNode</a>.
	 *
	 * @param relationship The relationship for which the start node be retrieved
	 * @return A function call for {@code startNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation startNode(@NotNull Relationship relationship) {
		return Functions.startNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code endNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-endnode">endNode</a>.
	 *
	 * @param relationship The relationship for which the end node be retrieved
	 * @return A function call for {@code endNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation endNode(@NotNull Relationship relationship) {
		return Functions.endNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code date()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most simple form.
	 *
	 * @return A function call for {@code date()}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date() {
		return Functions.date();
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year  The year
	 * @param month The month
	 * @param day   The day
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation calendarDate(Integer year, Integer month,
		Integer day) {
		return Functions.calendarDate(year, month, day);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year      The year
	 * @param week      The optional week
	 * @param dayOfWeek The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation weekDate(Integer year, Integer week,
		Integer dayOfWeek) {
		return Functions.weekDate(year, week, dayOfWeek);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year         The year
	 * @param quarter      The optional week
	 * @param dayOfQuarter The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation quarterDate(Integer year, Integer quarter,
		Integer dayOfQuarter) {
		return Functions.quarterDate(year, quarter, dayOfQuarter);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year       The year
	 * @param ordinalDay The ordinal day of the year.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		return Functions.ordinalDate(year, ordinalDay);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code date({})}
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull MapExpression components) {
		return Functions.date(components);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull String temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull Expression temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime() {
		return Functions.datetime();
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		return Functions.datetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code datetime({})}
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull MapExpression components) {
		return Functions.datetime(components);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull String temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime() {
		return Functions.localdatetime();
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		return Functions.localdatetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localdatetime({})}
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		return Functions.localdatetime(components);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 *
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime() {
		return Functions.localtime();
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		return Functions.localtime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localtime({})}
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull MapExpression components) {
		return Functions.localtime(components);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull String temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time() {
		return Functions.time();
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull TimeZone timeZone) {
		return Functions.time(timeZone);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code time({})}
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull MapExpression components) {
		return Functions.time(components);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull String temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull Expression temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code duration({})}
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull MapExpression components) {
		return Functions.duration(components);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount A string representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull String temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount An expression representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code shortestPath({})}.
	 *
	 * @param relationship The relationship to be passed to {@code shortestPath}.
	 * @return A function call for {@code shortestPath({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation shortestPath(Relationship relationship) {
		return Functions.shortestPath(relationship);
	}
	/**
	 * Starts building a function invocation for {@code reduce({})}.
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition for a function call to {@code reduce({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Reduction.OngoingDefinitionWithVariable reduce(
		@NotNull SymbolicName variable) {
		return Functions.reduce(variable);
	}
	/**
	 * Creates a function invocation for {@code abs({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-abs">abs</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code abs({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation abs(@NotNull Expression expression) {
		return Functions.abs(expression);
	}
	/**
	 * Creates a function invocation for {@code ceil({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-ceil">ceil</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code ceil({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ceil(@NotNull Expression expression) {
		return Functions.ceil(expression);
	}
	/**
	 * Creates a function invocation for {@code floor({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-floor">floor</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code floor({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation floor(@NotNull Expression expression) {
		return Functions.floor(expression);
	}
	/**
	 * Creates a function invocation for {@code rand({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-rand">rand</a>.
	 *
	 * @return A function call for {@code rand({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rand() {
		return Functions.rand();
	}
	/**
	 * Creates a function invocation for {@code round({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-round">round</a>.
	 *
	 * @param value      The value to round
	 * @param expression Additional parameters, length must be 0, 1 or 2:
	 *                   First entry is the precision, second is the rounding mode
	 * @return A function call for {@code round({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation round(Expression value, Expression... expression) {
		return Functions.round(value, expression);
	}
	/**
	 * Creates a function invocation for {@code sign({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sign">sign</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sign({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sign(@NotNull Expression expression) {
		return Functions.sign(expression);
	}
	/**
	 * Creates a function invocation for {@code e({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-e">e</a>.
	 *
	 * @return A function call for {@code e({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation e() {
		return Functions.e();
	}
	/**
	 * Creates a function invocation for {@code exp({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-exp">exp</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code exp({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exp(@NotNull Expression expression) {
		return Functions.exp(expression);
	}
	/**
	 * Creates a function invocation for {@code log({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log">log</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log(@NotNull Expression expression) {
		return Functions.log(expression);
	}
	/**
	 * Creates a function invocation for {@code log10({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log10">log10</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log10({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log10(@NotNull Expression expression) {
		return Functions.log10(expression);
	}
	/**
	 * Creates a function invocation for {@code sqrt({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sqrt">sqrt</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sqrt({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sqrt(@NotNull Expression expression) {
		return Functions.sqrt(expression);
	}
	/**
	 * Creates a function invocation for {@code acos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-acos">acos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code acos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation acos(@NotNull Expression expression) {
		return Functions.acos(expression);
	}
	/**
	 * Creates a function invocation for {@code asin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-asin">asin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code asin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation asin(@NotNull Expression expression) {
		return Functions.asin(expression);
	}
	/**
	 * Creates a function invocation for {@code atan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan">atan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code atan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan(@NotNull Expression expression) {
		return Functions.atan(expression);
	}
	/**
	 * Creates a function invocation for {@code atan2({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan2">atan2</a>.
	 *
	 * @param y the y value of a point
	 * @param x the x value of a point
	 * @return A function call for {@code atan2({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan2(@NotNull Expression y,
		@NotNull Expression x) {
		return Functions.atan2(y, x);
	}
	/**
	 * Creates a function invocation for {@code cos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cos">cos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cos(@NotNull Expression expression) {
		return Functions.cos(expression);
	}
	/**
	 * Creates a function invocation for {@code cot({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cot">cot</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cot({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cot(@NotNull Expression expression) {
		return Functions.cot(expression);
	}
	/**
	 * Creates a function invocation for {@code degrees({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-degrees">degrees</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code degrees({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation degrees(@NotNull Expression expression) {
		return Functions.degrees(expression);
	}
	/**
	 * Creates a function invocation for {@code haversin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-haversin">haversin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code haversin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation haversin(@NotNull Expression expression) {
		return Functions.haversin(expression);
	}
	/**
	 * Creates a function invocation for {@code pi({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-pi">pi</a>.
	 *
	 * @return A function call for {@code pi({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation pi() {
		return Functions.pi();
	}
	/**
	 * Creates a function invocation for {@code radians({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-radians">radians</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code radians({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation radians(@NotNull Expression expression) {
		return Functions.radians(expression);
	}
	/**
	 * Creates a function invocation for {@code sin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sin">sin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sin(@NotNull Expression expression) {
		return Functions.sin(expression);
	}
	/**
	 * Creates a function invocation for {@code tan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-tan">tan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code tan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation tan(@NotNull Expression expression) {
		return Functions.tan(expression);
	}
	/**
	 * Creates a function invocation for {@code toInteger({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger">toInteger</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toInteger({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toInteger(@NotNull Expression expression) {
		return Functions.toInteger(expression);
	}
	/**
	 * Creates a function invocation for {@code toString({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring">toString</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toString({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toString(@NotNull Expression expression) {
		return Functions.toString(expression);
	}
	/**
	 * Creates a function invocation for {@code toStringOrNull({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toStringOrNull">toStringOrNull</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toStringOrNull({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		return Functions.toStringOrNull(expression);
	}
	/**
	 * Creates a function invocation for {@code toFloat({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tofloat">toFloat</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toFloat({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toFloat(@NotNull Expression expression) {
		return Functions.toFloat(expression);
	}
	/**
	 * Creates a function invocation for {@code toBoolean({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-toboolean">toBoolean</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toBoolean({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toBoolean(@NotNull Expression expression) {
		return Functions.toBoolean(expression);
	}
	/**
	 * Creates a function invocation for {@code linenumber({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code linenumber({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation linenumber() {
		return Functions.linenumber();
	}
	/**
	 * Creates a function invocation for {@code file({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code file({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation file() {
		return Functions.file();
	}
	/**
	 * Creates a function invocation for {@code randomUUID({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code randomUUID({})}.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation randomUUID() {
		return Functions.randomUUID();
	}
	/**
	 * Creates a function invocation for {@code length()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-length">length</a>.
	 *
	 * @param path The path for which the length should be retrieved
	 * @return A function call for {@code length()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation length(@NotNull NamedPath path) {
		return Functions.length(path);
	}
	/**
	 * Creates a function invocation for {@code graph.names()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names">graph.names</a>.
	 *
	 * @return A function call for {@code graph.names()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphNames() {
		return Functions.graphNames();
	}
	/**
	 * Creates a function invocation for {@code graph.propertiesByName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-propertiesByName">graph.propertiesByName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.propertiesByName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphPropertiesByName(Expression name) {
		return Functions.graphPropertiesByName(name);
	}
	/**
	 * Creates a function invocation for {@code graph.byName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-byname">graph.byName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.byName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphByName(
		Expression name) {
		return Functions.graphByName(name);
	}
	/**
	 * Create a new map projection with the given, mixed content
	 *
	 * @param name    The symbolic name of this project
	 * @param content The projected content
	 * @return A new map projection
	 * @since 2023.9.0
	 */
	public static MapProjection createProjection(SymbolicName name, Object... content) {
		return MapProjection.create(name, content);
	}
	/**
	 * Creates an unary minus operation.
	 *
	 * @param e The expression to which the unary minus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary minus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation minus(Expression e) {
		return Operations.minus(e);
	}
	/**
	 * Creates an unary plus operation.
	 *
	 * @param e The expression to which the unary plus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary plus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Expression plus(Expression e) {
		return Operations.plus(e);
	}
	@SuppressWarnings("deprecation")
	public static Operation concat(Expression op1, Expression op2) {
		return Operations.concat(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation add(Expression op1, Expression op2) {
		return Operations.add(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation subtract(Expression op1, Expression op2) {
		return Operations.subtract(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation multiply(Expression op1, Expression op2) {
		return Operations.multiply(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation divide(Expression op1, Expression op2) {
		return Operations.divide(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation remainder(Expression op1, Expression op2) {
		return Operations.remainder(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation pow(Expression op1, Expression op2) {
		return Operations.pow(op1, op2);
	}
	/**
	 * Creates a {@code =} operation. The left hand side should resolve to a property or to something which has labels
	 * or types to modify and the right hand side should either be new properties or labels.
	 *
	 * @param target The target that should be modified
	 * @param value  The new value of the target
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation set(Expression target, Expression value) {
		return Operations.set(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation mutate(Expression target, MapExpression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	public static Operation mutate(Expression target, Expression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates an operation adding one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the new labels
	 * @param label  The labels to be added
	 * @return A set operation
	 * @since 2023.9.0
	 */
	public static Operation setLabel(Node target, String... label) {
		return Operations.set(target, label);
	}
	/**
	 * Creates an operation removing one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the remove operation
	 * @param label  The labels to be removed
	 * @return A remove operation
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation removeLabel(Node target, String... label) {
		return Operations.remove(target, label);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param property The property to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one property
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(Property property) {
		return Predicates.exists(property);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param pattern The pattern to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(RelationshipPattern pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a>. The statement may or  may not have  a {@literal  RETURN} clause. It  must however not  contain any
	 * updates. While it  would render syntactically correct  Cypher, Neo4j does not support  updates inside existential
	 * sub-queries.
	 *
	 * @param statement The statement to be passed to {@code exists{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(Statement statement, IdentifiableElement... imports) {
		return Predicates.exists(statement, imports);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the pattern that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(PatternElement pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the list of patterns that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns and an optional {@link Where where-clause}.
	 *
	 * @param pattern the list of patterns that must exists
	 * @param where   an optional where-clause
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern, @Nullable Where where) {
		return Predicates.exists(pattern, where);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @see #all(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(String variable) {
		return Predicates.all(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code all()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(
		SymbolicName variable) {
		return Predicates.all(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @see #any(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(String variable) {
		return Predicates.any(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code any()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(
		SymbolicName variable) {
		return Predicates.any(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @see #none(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(String variable) {
		return Predicates.none(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code none()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(
		SymbolicName variable) {
		return Predicates.none(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @see #single(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(String variable) {
		return Predicates.single(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code single()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single">single</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(
		SymbolicName variable) {
		return Predicates.single(variable);
	}
	/**
	 * Not to be instantiated.
	 */
	private Cypher() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * @author Michael J. Simons
 * @since 1.0
 */
@FunctionalInterface
public interface Visitor {
	/**
	 * Enter a {@link Visitable}. Not all visitables will obey to the result
	 *
	 * @param segment the segment to visit.
	 */
	void enter(Visitable segment);
	/**
	 * A method that is used to pass control to some extent from the visitor to the {@link Visitable}. Not all visitables
	 * react to this, and we don't give any guarantees about which will. This method has been mainly introduced in parallel
	 * to {@link #enter(Visitable)} so that existing external implementations of {@link Visitor visitors} won't break.
	 *
	 * @param segment the segment to visit.
	 * @return A result indicating whether visitation of child elements should continue or not.
	 * @since 2022.3.0
	 */
	default EnterResult enterWithResult(Visitable segment) {
		enter(segment);
		return EnterResult.CONTINUE;
	}
	/**
	 * Leave a {@link Visitable}.
	 *
	 * @param segment the visited segment.
	 */
	default void leave(Visitable segment) {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.TimeZone;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Aggregates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Lists;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Predicates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Scalars;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Spatials;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Strings;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Factory methods for creating instances of {@link FunctionInvocation functions}.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Romain Rossi
 * @since 1.0
 */
final class Functions {
	/**
	 * Creates a function invocation for {@code id{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id">id</a>.
	 *
	 * @param node The node for which the internal id should be retrieved
	 * @return A function call for {@code id()} on a node.
	 * @deprecated see {@link #elementId(Node)} for a replacement. Neo4j the database will remove support for {@code id(n)}
	 * at some point.
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) // Yes, I promise, this will be removed at some point, but not yet.
	static FunctionInvocation id(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code id{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id">id</a>.
	 *
	 * @param relationship The relationship for which the internal id should be retrieved
	 * @return A function call for {@code id()} on a relationship.
	 * @deprecated see {@link #elementId(Relationship)} for a replacement. Neo4j the database will remove support for
	 * {@code id(n)} at some point.
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) // Yes, I promise, this will be removed at some point, but not yet.
	static FunctionInvocation id(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param node The node for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a node.
	 */
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param relationship The relationship for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a relationship.
	 */
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param node The node which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return keys(node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param relationship The relationship which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return keys(relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param expression The expressions which keys should be returned. Must resolve to a node, relationship or map.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Expression param = expression instanceof Named named ? named.getRequiredSymbolicName() : expression;
		return FunctionInvocation.create(Lists.KEYS, param);
	}
	/**
	 * Creates a function invocation for {@code labels{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return labels(node.getRequiredSymbolicName());
	}
	/**
	 * Creates a  function invocation for  {@code labels{}}.  The {@link SymbolicName  symbolic name} {@code  node} must
	 * point to a node. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.2.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull SymbolicName node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Lists.LABELS, node);
	}
	/**
	 * Creates a function invocation for {@code type{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return type(relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a  function invocation for  {@code type{}}. The {@link  SymbolicName symbolic name}  {@code relationship}
	 * must point to a relationship. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.2.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull SymbolicName relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.TYPE, relationship);
	}
	/**
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #count(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code count()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(Expression expression) {
		return FunctionInvocation.create(Aggregates.COUNT, expression);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 *
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #countDistinct(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COUNT, expression);
	}
	/**
	 * Creates a function invocation for {@code properties())} on nodes.
	 *
	 * @param node The node who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code properties())} on relationships.
	 *
	 * @param relationship The relationship who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code properties())} on maps.
	 *
	 * @param map The map who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(MapExpression map) {
		return FunctionInvocation.create(Scalars.PROPERTIES, map);
	}
	/**
	 * Creates a function invocation for the {@code coalesce()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce">coalesce</a>.
	 *
	 * @param expressions One or more expressions to be coalesced
	 * @return A function call for {@code coalesce}.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation coalesce(Expression... expressions) {
		return FunctionInvocation.create(Scalars.COALESCE, expressions);
	}
	/**
	 * Creates a function invocation for the {@code left()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">left</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code left()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation left(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.LEFT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	/**
	 * Creates a function invocation for the {@code ltrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">ltrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code ltrim()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ltrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.LTRIM, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code replace()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">replace</a>.
	 *
	 * @param original An expression that returns a string
	 * @param search   An expression that specifies the string to be replaced in {@code original}.
	 * @param replace  An expression that specifies the replacement string.
	 * @return A function call for {@code replace()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation replace(Expression original, Expression search, Expression replace) {
		return FunctionInvocation.create(Strings.REPLACE, expressionOrNullLit(original), expressionOrNullLit(search),
			expressionOrNullLit(replace));
	}
	/**
	 * Creates a function invocation for the {@code reverse()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-reverse">reverse</a>.
	 *
	 * @param original An expression that returns a string
	 * @return A function call for {@code reverse()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation reverse(@NotNull Expression original) {
		Assertions.notNull(original, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.REVERSE, expressionOrNullLit(original));
	}
	/**
	 * Creates a function invocation for the {@code right()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">right</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code right()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation right(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.RIGHT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	/**
	 * Creates a function invocation for the {@code rtrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-rtrim">rtrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code rtrim()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation rtrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.RTRIM, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code substring()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-substring">rtrim</a>.
	 *
	 * @param original An expression resolving to a string
	 * @param start    An expression that returns a positive integer, denoting the position at which the substring will begin.
	 * @param length   An expression that returns a positive integer, denoting how many characters of original will be returned.
	 * @return A function call for {@code substring()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation substring(Expression original, Expression start, Expression length) {
		Assertions.notNull(start, "start is required");
		if (length != null) {
			return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start, length);
		}
		return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start);
	}
	private static Expression expressionOrNullLit(Expression expression) {
		return expression == null ? Cypher.literalNull() : expression;
	}
	/**
	 * Creates a function invocation for the {@code toLower()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toLower">toLower</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toLower(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_LOWER, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code toUpper()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toUpper">toUpper</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toUpper(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_UPPER, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code trim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim">trim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code trim()} for one expression
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation trim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TRIM, expression);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull Expression delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return FunctionInvocation.create(Strings.SPLIT, expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull String delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return split(expression, Cypher.literalOf(delimiter));
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">a list</a></li>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">to a string</a></li>
	 * </ul>
	 *
	 * @param expression The expression who's size is to be returned
	 * @return A function call for {@code size()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(Expression expression) {
		return FunctionInvocation.create(Scalars.SIZE, expression);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression">to a pattern expression</a></li>
	 * </ul>
	 *
	 * @param pattern The pattern for which {@code size()} should be invoked.
	 * @return A function call for {@code size()} for a pattern
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(RelationshipPattern pattern) {
		return FunctionInvocation.create(Scalars.SIZE, pattern);
	}
	/**
	 * Creates a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param expression The expression who's existence is to be evaluated
	 * @return A function call for {@code exists()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation exists(Expression expression) {
		return FunctionInvocation.create(Predicates.EXISTS, expression);
	}
	/**
	 * Creates a function invocation for the {@code distance()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance">exists</a>.
	 * Both points need to be in the same coordinate system.
	 *
	 * @param point1 Point 1
	 * @param point2 Point 2
	 * @return A function call for {@code distance()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation distance(@NotNull Expression point1, @NotNull Expression point2) {
		Assertions.notNull(point1, "The distance function requires two points.");
		Assertions.notNull(point2, "The distance function requires two points.");
		return FunctionInvocation.create(Spatials.DISTANCE, point1, point2);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameterMap The map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(MapExpression parameterMap) {
		return point((Expression) parameterMap);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 * <p>
	 * This generic expression variant is useful for referencing a point inside a parameter or another map.
	 *
	 * @param expression An expression resolving to a valid map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Expression expression) {
		return FunctionInvocation.create(Spatials.POINT, expression);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameter A parameter referencing a {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Parameter<?> parameter) {
		return FunctionInvocation.create(Spatials.POINT, parameter);
	}
	/**
	 * Convenience method for creating a 2d cartesian point
	 *
	 * @param x The x coordinate
	 * @param y The y coordinate
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cartesian(double x, double y) {
		return point(Cypher.mapOf("x", Cypher.literalOf(x), "y", Cypher.literalOf(y)));
	}
	/**
	 * Convenience method for creating a 2d coordinate in the WGS 84 coordinate system
	 *
	 * @param longitude The longitude
	 * @param latitude  The latitude
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation coordinate(double longitude, double latitude) {
		return point(Cypher.mapOf("longitude", Cypher.literalOf(longitude), "latitude", Cypher.literalOf(latitude)));
	}
	/**
	 * Creates a function invocation for the {@code point.withinBBox} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-withinBBox">point.withinBBox</a>.
	 *
	 * @param point      The point to check
	 * @param lowerLeft  The lower left point of the bounding box (south-west coordinate)
	 * @param upperRight The upper right point of the bounding box (north-east coordinate)
	 * @return A function call for {@code point.withinBBox}
	 * @since 2022.7.3
	 */
	static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return FunctionInvocation.create(() -> "point.withinBBox", point, lowerLeft, upperRight);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation avg(Expression expression) {
		return FunctionInvocation.create(Aggregates.AVG, expression);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation avgDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.AVG, expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(Expression expression) {
		return FunctionInvocation.create(Aggregates.COLLECT, expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation max(Expression expression) {
		return FunctionInvocation.create(Aggregates.MAX, expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation maxDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MAX, expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation min(Expression expression) {
		return FunctionInvocation.create(Aggregates.MIN, expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation minDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MIN, expression);
	}
	private static void assertPercentileArguments(Aggregates builtIn, Expression expression, Number percentile) {
		Assertions
			.notNull(expression, "The numeric expression for " + builtIn.getImplementationName() + " is required.");
		Assertions.notNull(percentile, "The percentile for " + builtIn.getImplementationName() + " is required.");
		final double p = percentile.doubleValue();
		Assertions.isTrue(p >= 0D && p <= 1D,
			"The percentile for " + builtIn.getImplementationName() + " must be between 0.0 and 1.0.");
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileCont(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileContDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDisc(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDiscDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDev(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevP(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV_P, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevPDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV_P, expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sum(Expression expression) {
		return FunctionInvocation.create(Aggregates.SUM, expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function  with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sumDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.SUM, expression);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(Integer start, Integer end) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end));
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end) {
		return range(start, end, null);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end, Integer step) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end), Cypher.literalOf(step));
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end, Expression step) {
		Assertions.notNull(start, "The expression for range is required.");
		Assertions.notNull(end, "The expression for range is required.");
		if (step == null) {
			return FunctionInvocation.create(Lists.RANGE, start, end);
		} else {
			return FunctionInvocation.create(Lists.RANGE, start, end, step);
		}
	}
	/**
	 * Creates a function invocation for the {@code head()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-head">head</a>.
	 *
	 * @param expression A list from which the head element is returned
	 * @return A function call for {@code head()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation head(Expression expression) {
		return FunctionInvocation.create(Scalars.HEAD, expression);
	}
	/**
	 * Creates a function invocation for the {@code last()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-last">last</a>.
	 *
	 * @param expression A list from which the last element is returned
	 * @return A function call for {@code last()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation last(Expression expression) {
		return FunctionInvocation.create(Scalars.LAST, expression);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param path The path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes()} on a path.
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes{}} on a path represented by a symbolic name.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES, symbolicName);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param path The path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path represented by a symbolic name.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS, symbolicName);
	}
	/**
	 * Creates a function invocation for {@code startNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-startnode">startNode</a>.
	 *
	 * @param relationship The relationship for which the start node be retrieved
	 * @return A function call for {@code startNode()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation startNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.START_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	/**
	 * Creates a function invocation for {@code endNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-endnode">endNode</a>.
	 *
	 * @param relationship The relationship for which the end node be retrieved
	 * @return A function call for {@code endNode()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation endNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.END_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	/**
	 * Creates a function invocation for {@code date()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most simple form.
	 *
	 * @return A function call for {@code date()}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year  The year
	 * @param month The month
	 * @param day   The day
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation calendarDate(Integer year, Integer month, Integer day) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Assertions.notNull(month, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_MONTH_REQUIRED));
		Assertions.notNull(day, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_DAY_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher
			.mapOf("year", Cypher.literalOf(year), "month", Cypher.literalOf(month), "day", Cypher.literalOf(day)));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year      The year
	 * @param week      The optional week
	 * @param dayOfWeek The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation weekDate(Integer year, Integer week, Integer dayOfWeek) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (week == null ? 0 : 2) + (dayOfWeek == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (week != null) {
			parameters[i++] = "week";
			parameters[i++] = Cypher.literalOf(week);
		}
		if (dayOfWeek != null) {
			if (week == null) {
				throw new IllegalArgumentException("week is required when using dayOfWeek.");
			}
			parameters[i++] = "dayOfWeek";
			parameters[i] = Cypher.literalOf(dayOfWeek);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year         The year
	 * @param quarter      The optional week
	 * @param dayOfQuarter The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation quarterDate(Integer year, Integer quarter, Integer dayOfQuarter) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (quarter == null ? 0 : 2) + (dayOfQuarter == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (quarter != null) {
			parameters[i++] = "quarter";
			parameters[i++] = Cypher.literalOf(quarter);
		}
		if (dayOfQuarter != null) {
			parameters[i++] = "dayOfQuarter";
			parameters[i] = Cypher.literalOf(dayOfQuarter);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year       The year
	 * @param ordinalDay The ordinal day of the year.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (ordinalDay == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (ordinalDay != null) {
			parameters[i++] = "ordinalDay";
			parameters[i] = Cypher.literalOf(ordinalDay);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code date({})}
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, components);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.DATETIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code datetime({})}
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, components);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALDATETIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localdatetime({})}
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, components);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 *
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALTIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localtime({})}
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, components);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.TIME, timezoneMapLiteralOf(timeZone));
	}
	private static Expression timezoneMapLiteralOf(TimeZone timeZone) {
		return Cypher.mapOf("timezone", Cypher.literalOf(timeZone.getID()));
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code time({})}
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, components);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code duration({})}
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, components);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount A string representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull String temporalAmount) {
		Assertions.hasText(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, Cypher.literalOf(temporalAmount));
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount An expression representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		Assertions.notNull(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code shortestPath({})}.
	 *
	 * @param relationship The relationship to be passed to {@code shortestPath}.
	 * @return A function call for {@code shortestPath({})}.
	 * @since 2020.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation shortestPath(Relationship relationship) {
		return FunctionInvocation.create(Scalars.SHORTEST_PATH, relationship);
	}
	/**
	 * Starts building a function invocation for {@code reduce({})}.
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition for a function call to {@code reduce({})}.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static Reduction.OngoingDefinitionWithVariable reduce(@NotNull SymbolicName variable) {
		return Reduction.of(variable);
	}
	/**
	 * Creates a function invocation for {@code abs({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-abs">abs</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code abs({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation abs(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ABS, expression);
	}
	/**
	 * Creates a function invocation for {@code ceil({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-ceil">ceil</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code ceil({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ceil(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.CEIL, expression);
	}
	/**
	 * Creates a function invocation for {@code floor({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-floor">floor</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code floor({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation floor(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.FLOOR, expression);
	}
	/**
	 * Creates a function invocation for {@code rand({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-rand">rand</a>.
	 *
	 * @return A function call for {@code rand({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation rand() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RAND);
	}
	/**
	 * Creates a function invocation for {@code round({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-round">round</a>.
	 *
	 * @param value      The value to round
	 * @param expression Additional parameters, length must be 0, 1 or 2:
	 *                   First entry is the precision, second is the rounding mode
	 * @return A function call for {@code round({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation round(Expression value, Expression... expression) {
		if (expression == null || expression.length == 0) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value);
		} else if (expression.length == 1) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0]);
		} else if (expression.length == 2) {
			return FunctionInvocation
				.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0], expression[1]);
		} else {
			throw new IllegalArgumentException(
				"round() must be called with 1, 2 or 3 arguments (value, value + precision or value + precision + rounding mode.");
		}
	}
	/**
	 * Creates a function invocation for {@code sign({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sign">sign</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sign({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sign(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIGN, expression);
	}
	/**
	 * Creates a function invocation for {@code e({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-e">e</a>.
	 *
	 * @return A function call for {@code e({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation e() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.E);
	}
	/**
	 * Creates a function invocation for {@code exp({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-exp">exp</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code exp({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation exp(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.EXP, expression);
	}
	/**
	 * Creates a function invocation for {@code log({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log">log</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation log(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG, expression);
	}
	/**
	 * Creates a function invocation for {@code log10({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log10">log10</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log10({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation log10(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG10, expression);
	}
	/**
	 * Creates a function invocation for {@code sqrt({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sqrt">sqrt</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sqrt({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sqrt(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SQRT, expression);
	}
	/**
	 * Creates a function invocation for {@code acos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-acos">acos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code acos({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation acos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ACOS, expression);
	}
	/**
	 * Creates a function invocation for {@code asin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-asin">asin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code asin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation asin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ASIN, expression);
	}
	/**
	 * Creates a function invocation for {@code atan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan">atan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code atan({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN, expression);
	}
	/**
	 * Creates a function invocation for {@code atan2({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan2">atan2</a>.
	 *
	 * @param y the y value of a point
	 * @param x the x value of a point
	 * @return A function call for {@code atan2({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan2(@NotNull Expression y, @NotNull Expression x) {
		Assertions.notNull(y, "y is required.");
		Assertions.notNull(x, "x is required.");
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN2, y, x);
	}
	/**
	 * Creates a function invocation for {@code cos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cos">cos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cos({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COS, expression);
	}
	/**
	 * Creates a function invocation for {@code cot({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cot">cot</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cot({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cot(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COT, expression);
	}
	/**
	 * Creates a function invocation for {@code degrees({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-degrees">degrees</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code degrees({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation degrees(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.DEGREES, expression);
	}
	/**
	 * Creates a function invocation for {@code haversin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-haversin">haversin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code haversin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation haversin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.HAVERSIN, expression);
	}
	/**
	 * Creates a function invocation for {@code pi({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-pi">pi</a>.
	 *
	 * @return A function call for {@code pi({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation pi() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.PI);
	}
	/**
	 * Creates a function invocation for {@code radians({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-radians">radians</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code radians({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation radians(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RADIANS, expression);
	}
	/**
	 * Creates a function invocation for {@code sin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sin">sin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIN, expression);
	}
	/**
	 * Creates a function invocation for {@code tan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-tan">tan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code tan({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation tan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.TAN, expression);
	}
	/**
	 * Creates a function invocation for {@code toInteger({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger">toInteger</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toInteger({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toInteger(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_INTEGER, expression);
	}
	/**
	 * Creates a function invocation for {@code toString({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring">toString</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toString({})}.
	 * @since 2022.3.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toString(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_STRING, expression);
	}
	/**
	 * Creates a function invocation for {@code toStringOrNull({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toStringOrNull">toStringOrNull</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toStringOrNull({})}.
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_STRING_OR_NULL, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for {@code toFloat({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tofloat">toFloat</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toFloat({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toFloat(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_FLOAT, expression);
	}
	/**
	 * Creates a function invocation for {@code toBoolean({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-toboolean">toBoolean</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toBoolean({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toBoolean(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_BOOLEAN, expression);
	}
	/**
	 * Creates a function invocation for {@code linenumber({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code linenumber({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation linenumber() {
		return FunctionInvocation.create(() -> "linenumber");
	}
	/**
	 * Creates a function invocation for {@code file({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code file({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation file() {
		return FunctionInvocation.create(() -> "file");
	}
	/**
	 * Creates a function invocation for {@code randomUUID({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code randomUUID({})}.
	 * @since 2022.2.1
	 */
	static FunctionInvocation randomUUID() {
		return FunctionInvocation.create(() -> "randomUUID");
	}
	/**
	 * Creates a function invocation for {@code length()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-length">length</a>.
	 *
	 * @param path The path for which the length should be retrieved
	 * @return A function call for {@code length()} on a path.
	 * @since 2023.0.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation length(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for length is required.");
		return FunctionInvocation.create(Scalars.LENGTH,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code graph.names()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names">graph.names</a>.
	 *
	 * @return A function call for {@code graph.names()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphNames() {
		return FunctionInvocation.create(BuiltInFunctions.Graph.NAMES);
	}
	/**
	 * Creates a function invocation for {@code graph.propertiesByName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-propertiesByName">graph.propertiesByName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.propertiesByName()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphPropertiesByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.PROPERTIES_BY_NAME, name);
	}
	/**
	 * Creates a function invocation for {@code graph.byName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-byname">graph.byName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.byName()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.BY_NAME, name);
	}
	private Functions() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * A container having properties. A property container must be {@link Named} with a non empty name to be able to refer
 * to properties.
 *
 * @author Andreas Berger
 * @author Michael J. Simons
 * @since 1.1
 */
@API(status = STABLE, since = "1.1")
public interface PropertyContainer extends Named, PropertyAccessor {
	/**
	 * Creates an {@link Operation} mutating the properties of this container to a new value. The container does not
	 * track the operations created with this method.
	 *
	 * @param parameter the new properties
	 * @return A new operation.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	Operation mutate(Parameter<?> parameter);
	/**
	 * Creates an {@link Operation} mutating the properties of this container to a new value. The container does not
	 * track the operations created with this method.
	 *
	 * @param properties the new properties
	 * @return A new operation.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	Operation mutate(MapExpression properties);
	/**
	 * Creates an {@link Operation SET operation} setting the properties of this container to a new value. The container does not
	 * track the operations created with this method.
	 *
	 * @param parameter the new properties
	 * @return A new operation.
	 * @since 2022.5.0
	 */
	@NotNull @Contract(pure = true)
	Operation set(Parameter<?> parameter);
	/**
	 * Creates an {@link Operation SET operation} setting the properties of this container to a new value. The container does not
	 * track the operations created with this method.
	 *
	 * @param properties the new properties
	 * @return A new operation.
	 * @since 2022.5.0
	 */
	@NotNull @Contract(pure = true)
	Operation set(MapExpression properties);
	/**
	 * Unwraps the list of entries into an array before creating a projection out of it.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @see SymbolicName#project(List)
	 */
	@NotNull @Contract(pure = true)
	MapProjection project(List<Object> entries);
	/**
	 * Creates a map projection based on this container. The container needs a symbolic name for this to work.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @see SymbolicName#project(Object...)
	 */
	@NotNull @Contract(pure = true)
	MapProjection project(Object... entries);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * A marker interface for things that expose methods to create new relationships to other elements.
 *
 * @author Michael J. Simons
 * @param <T> The type of the resulting {@link RelationshipPattern}.
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface ExposesRelationships<T extends RelationshipPattern & ExposesPatternLengthAccessors<?>> {
	/**
	 * Starts building an outgoing relationship to the {@code other} {@link Node node}.
	 *
	 * @param other The other end of the outgoing relationship
	 * @param types The types to match
	 * @return An ongoing relationship definition, that can be used to specify the type
	 */
	@NotNull @Contract(pure = true)
	T relationshipTo(Node other, String... types);
	/**
	 * Starts building an incoming relationship starting at the {@code other} {@link Node node}.
	 *
	 * @param other The source of the incoming relationship
	 * @param types The types to match
	 * @return An ongoing relationship definition, that can be used to specify the type
	 */
	@NotNull @Contract(pure = true)
	T relationshipFrom(Node other, String... types);
	/**
	 * Starts building an undirected relationship between this {@link Node node} and the {@code other}.
	 *
	 * @param other The other end of the relationship
	 * @param types The types to match
	 * @return An ongoing relationship definition, that can be used to specify the type
	 */
	@NotNull @Contract(pure = true)
	T relationshipBetween(Node other, String... types);
	/**
	 * A convenience method for creating relationships between nodes avoiding going through the fluent API by allowing
	 * to pass in the type directly.
	 *
	 * @param other The other end of the relationship
	 * @param direction The direction of the relationship, seen from {@code this} node
	 * @param types The type of the relationship to create or the types to match
	 * @return An ongoing relationship definition, that can be used to specify details of the relationship
	 * @since 2023.5.0
	 */
	default T relationshipWith(Node other, Relationship.Direction direction, String... types) {
		return switch (direction) {
			case LTR -> this.relationshipTo(other, types);
			case RTL -> this.relationshipFrom(other, types);
			case UNI -> this.relationshipBetween(other, types);
		};
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.parser;
import org.neo4j.cypherdsl.core.ExposesPatternLengthAccessors;
import org.neo4j.cypherdsl.core.ExposesProperties;
import org.neo4j.cypherdsl.core.ExposesRelationships;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.Relationship.Direction;
import org.neo4j.cypherdsl.core.RelationshipChain;
import org.neo4j.cypherdsl.core.SymbolicName;
/**
 * A value object for the details of a path.
 *
 * @author Michael J. Simons
 * @soundtrack Pink Floyd - The Division Bell
 * @since 2021.3.0
 */
final class PathAtom implements PatternAtom {
	@SuppressWarnings("squid:S107") // Totally fine with that number of args for this internal API.
	static PathAtom of(SymbolicName name, PathLength length, boolean left, boolean right,
		String[] relTypes, MapExpression properties, boolean negatedType, Expression predicate) {
		if (left && right) {
			throw new IllegalArgumentException("Only left-to-right, right-to-left or unidirectional path elements are supported.");
		}
		Direction direction;
		if (left) {
			direction = Direction.RTL;
		} else if (right) {
			direction = Direction.LTR;
		} else {
			direction = Direction.UNI;
		}
		return new PathAtom(name, length, direction, negatedType, relTypes, properties, predicate, null);
	}
	private final SymbolicName name;
	private final PathLength length;
	private final Direction direction;
	private final boolean negatedType;
	private final String[] types;
	private final MapExpression properties;
	private final Expression predicate;
	private final QuantifiedPathPattern.Quantifier quantifier;
	private PathAtom(SymbolicName name, PathLength length, Direction direction, boolean negatedType, String[] types,
		MapExpression properties, Expression predicate, QuantifiedPathPattern.Quantifier quantifier) {
		this.name = name;
		this.length = length;
		this.direction = direction;
		this.negatedType = negatedType;
		this.types = types;
		this.properties = properties;
		this.predicate = predicate;
		this.quantifier = quantifier;
	}
	ExposesRelationships<?> asRelationshipBetween(ExposesRelationships<?> previous, NodeAtom nodeAtom, boolean alwaysLtr) {
		var node = nodeAtom.value();
		ExposesRelationships<?> relationshipPattern = switch (this.getDirection()) {
			case LTR -> previous.relationshipTo(node, this.getTypes());
			case RTL -> alwaysLtr ?
				node.relationshipTo((Node) previous, this.getTypes()) :
				previous.relationshipFrom(node, this.getTypes());
			case UNI -> previous.relationshipBetween(node, this.getTypes());
		};
		relationshipPattern = applyOptionalName(relationshipPattern);
		relationshipPattern = applyOptionalProperties(relationshipPattern);
		relationshipPattern = applyOptionalPredicate(relationshipPattern);
		relationshipPattern = applyOptionalLength(relationshipPattern);
		return applyOptionalQuantifier(relationshipPattern);
	}
	private ExposesRelationships<?> applyOptionalLength(ExposesRelationships<?> relationshipPattern) {
		if (length == null) {
			return relationshipPattern;
		}
		if (length.isUnbounded()) {
			return ((ExposesPatternLengthAccessors<?>) relationshipPattern).unbounded();
		}
		return ((ExposesPatternLengthAccessors<?>) relationshipPattern).length(length.getMinimum(), length.getMaximum());
	}
	private ExposesRelationships<?> applyOptionalProperties(ExposesRelationships<?> relationshipPattern) {
		if (properties == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof ExposesProperties<?> exposesProperties) {
			return (ExposesRelationships<?>) exposesProperties.withProperties(properties);
		}
		return ((RelationshipChain) relationshipPattern).properties(properties);
	}
	private ExposesRelationships<?> applyOptionalName(ExposesRelationships<?> relationshipPattern) {
		if (name == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return relationship.named(name);
		}
		return ((RelationshipChain) relationshipPattern).named(name);
	}
	private ExposesRelationships<?> applyOptionalPredicate(ExposesRelationships<?> relationshipPattern) {
		if (predicate == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return (ExposesRelationships<?>) relationship.where(predicate);
		}
		return ((RelationshipChain) relationshipPattern).where(predicate);
	}
	private ExposesRelationships<?> applyOptionalQuantifier(ExposesRelationships<?> relationshipPattern) {
		if (quantifier == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return (ExposesRelationships<?>) relationship.quantifyRelationship(quantifier);
		}
		return ((RelationshipChain) relationshipPattern).quantifyRelationship(quantifier);
	}
	public Direction getDirection() {
		return direction;
	}
	public String[] getTypes() {
		return types;
	}
	public MapExpression getProperties() {
		return this.properties;
	}
	public SymbolicName getName() {
		return name;
	}
	public PathAtom withQuantifier(QuantifiedPathPattern.Quantifier newQuantifier) {
		return newQuantifier == null ?
			this :
			new PathAtom(name, length, direction, negatedType, types, properties, predicate, newQuantifier);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.renderer;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.AliasedExpression;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.CollectExpression;
import org.neo4j.cypherdsl.core.Condition;
import org.neo4j.cypherdsl.core.CountExpression;
import org.neo4j.cypherdsl.core.Create;
import org.neo4j.cypherdsl.core.Delete;
import org.neo4j.cypherdsl.core.ExistentialSubquery;
import org.neo4j.cypherdsl.core.Foreach;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.InTransactions;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.Limit;
import org.neo4j.cypherdsl.core.ListComprehension;
import org.neo4j.cypherdsl.core.ListExpression;
import org.neo4j.cypherdsl.core.Literal;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.Match;
import org.neo4j.cypherdsl.core.Merge;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.Named;
import org.neo4j.cypherdsl.core.NestedExpression;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.NodeLabel;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Operator;
import org.neo4j.cypherdsl.core.Order;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternExpression;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.ProcedureCall;
import org.neo4j.cypherdsl.core.Properties;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.Remove;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.Skip;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Subquery;
import org.neo4j.cypherdsl.core.SubqueryExpression;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.UnionPart;
import org.neo4j.cypherdsl.core.Unwind;
import org.neo4j.cypherdsl.core.Use;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.With;
import org.neo4j.cypherdsl.core.internal.NameResolvingStrategy;
import org.neo4j.cypherdsl.core.internal.SchemaNamesBridge;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.CaseElse;
import org.neo4j.cypherdsl.core.internal.CaseWhenThen;
import org.neo4j.cypherdsl.core.internal.ConstantParameterHolder;
import org.neo4j.cypherdsl.core.internal.Distinct;
import org.neo4j.cypherdsl.core.internal.LoadCSV;
import org.neo4j.cypherdsl.core.internal.Namespace;
import org.neo4j.cypherdsl.core.internal.ProcedureName;
import org.neo4j.cypherdsl.core.internal.ReflectiveVisitor;
import org.neo4j.cypherdsl.core.internal.RelationshipLength;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.internal.RelationshipTypes;
import org.neo4j.cypherdsl.core.internal.ScopingStrategy;
import org.neo4j.cypherdsl.core.StatementContext;
import org.neo4j.cypherdsl.core.internal.UsingPeriodicCommit;
import org.neo4j.cypherdsl.core.internal.YieldItems;
/**
 * This is  a simple (some would  call it naive) implementation  of a visitor to  the Cypher AST created  by the Cypher
 * builder based on the {@link ReflectiveVisitor reflective visitor}.
 * <p>
 * It takes care of separating elements of subtrees containing  the element type with a separator and provides pairs of
 * {@code enter} / {@code leave} for the structuring elements of the Cypher AST as needed.
 * <p>
 * This rendering  visitor is not  meant to be  used outside framework code,  and we don't  give any guarantees  on the
 * format being output apart from that it works within the constraints of SDN-RX respectively SDN 6 and later.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @since 1.0
 */
@SuppressWarnings({ "unused", "squid:S1172" })
@RegisterForReflection
class DefaultVisitor extends ReflectiveVisitor implements RenderingVisitor {
	private static final EnumSet<Operator> SKIP_SPACES = EnumSet.of(Operator.EXPONENTIATION, Operator.UNARY_MINUS,
		Operator.UNARY_PLUS);
	/**
	 * Target of all rendering.
	 */
	protected final StringBuilder builder = new StringBuilder();
	record SeparatorAndSupplier(AtomicReference<String> seperator, Supplier<String> supplier) {
	}
	/**
	 * This keeps track on which level of the tree a separator is needed.
	 */
	private final Map<Integer, SeparatorAndSupplier> separatorOnLevel = new ConcurrentHashMap<>();
	/**
	 * Keeps track of scoped, named variables.
	 */
	private final ScopingStrategy scopingStrategy;
	/**
	 * A set of aliased expressions that already have been seen and for which an alias must be used on each following
	 * appearance.
	 */
	protected final java.util.Set<AliasedExpression> visitableToAliased = new HashSet<>();
	/**
	 * Keeps track if currently in an aliased expression so that the content can be skipped when already visited.
	 */
	private final Deque<AliasedExpression> currentAliasedElements = new ArrayDeque<>();
	/**
	 * A cache of delegates, avoiding unnecessary object creation.
	 */
	private final Map<Class<? extends Visitor>, Visitor> delegateCache = new ConcurrentHashMap<>();
	private final NameResolvingStrategy nameResolvingStrategy;
	private final boolean enforceSchema;
	private final Map<String, List<Configuration.RelationshipDefinition>> relationshipDefinitions;
	/**
	 * The current level in the tree of cypher elements.
	 */
	private int currentLevel = 0;
	/**
	 * Will be set to true when entering an already visited node.
	 */
	private boolean skipNodeContent = false;
	/**
	 * Will be set to true when entering an already visited relationship.
	 */
	private boolean skipRelationshipContent = false;
	/**
	 * Will be true when inside a {@link RelationshipPatternCondition}.
	 */
	private boolean inRelationshipCondition = false;
	private final Deque<Boolean> inPatternExpression = new ArrayDeque<>();
	/**
	 * Rendering parameters is not a config property due to some needs in Spring Data Neo4j: This needs to be configured
	 * per statement, not per config  there.
	 */
	private final boolean renderConstantsAsParameters;
	private final boolean alwaysEscapeNames;
	private final Dialect dialect;
	private boolean inEntity;
	private boolean inPropertyLookup;
	private Relationship.Direction directionOverride;
	DefaultVisitor(StatementContext statementContext) {
		this(statementContext, false);
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters) {
		this(statementContext, renderConstantsAsParameters, Configuration.newConfig().alwaysEscapeNames(true).build());
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters,
		Configuration configuration) {
		this.nameResolvingStrategy = configuration.isUseGeneratedNames() ?
			NameResolvingStrategy.useGeneratedNames(statementContext, configuration.getGeneratedNames()) :
			NameResolvingStrategy.useGivenNames(statementContext);
		this.scopingStrategy = ScopingStrategy.create(
			List.of(nameResolvingStrategy::enterScope),
			List.of(nameResolvingStrategy::leaveScope)
		);
		this.renderConstantsAsParameters = renderConstantsAsParameters;
		this.alwaysEscapeNames = configuration.isAlwaysEscapeNames();
		this.dialect = configuration.getDialect();
		this.enforceSchema = configuration.isEnforceSchema();
		this.relationshipDefinitions = configuration.getRelationshipDefinitions();
	}
	private void enableSeparator(int level, boolean on, Supplier<String> supplier) {
		if (on) {
			separatorOnLevel.put(level,
				new SeparatorAndSupplier(new AtomicReference<>(""), supplier == null ? () -> "" : supplier));
		} else {
			separatorOnLevel.remove(level);
		}
	}
	private Optional<SeparatorAndSupplier> separatorOnCurrentLevel() {
		return Optional.ofNullable(separatorOnLevel.get(currentLevel));
	}
	@Override
	protected boolean preEnter(Visitable visitable) {
		Visitable lastAliased = currentAliasedElements.peek();
		if (skipNodeContent || visitableToAliased.contains(lastAliased)) {
			return false;
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			currentAliasedElements.push(aliasedExpression);
		}
		int nextLevel = ++currentLevel + 1;
		if (visitable instanceof TypedSubtree<?> ts) {
			enableSeparator(nextLevel, true, ts::separator);
		}
		separatorOnCurrentLevel().ifPresent(ref -> builder.append(ref.seperator().getAndSet("")));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getPrefix().ifPresent(this::doWithPrefix);
		}
		boolean doEnter = !skipNodeContent;
		if (doEnter) {
			scopingStrategy.doEnter(visitable);
		}
		return doEnter;
	}
	@Override
	protected final PreEnterResult getPreEnterResult(Visitable visitable) {
		boolean doEnter = preEnter(visitable);
		if (!doEnter) {
			return PreEnterResult.skip();
		}
		Class<? extends Visitor> handlerType = dialect.getHandler(visitable);
		if (handlerType != null) {
			Visitor handler = this.delegateCache.computeIfAbsent(handlerType, this::newHandler);
			return PreEnterResult.delegateTo(handler);
		}
		return PreEnterResult.doEnter();
	}
	private Visitor newHandler(Class<? extends Visitor> handlerType) {
		try {
			Constructor<? extends Visitor> ctor = handlerType.getDeclaredConstructor(DefaultVisitor.class);
			return ctor.newInstance(this);
		} catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
			throw new IllegalArgumentException(
				dialect.name() + " has defined an illegal handler not providing a constructor accepting a delegate.");
		}
	}
	@Override
	protected void postLeave(Visitable visitable) {
		scopingStrategy.doLeave(visitable);
		separatorOnCurrentLevel().ifPresent(ref -> ref.seperator().set(ref.supplier().get()));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getSuffix().ifPresent(this::doWithSuffix);
		}
		if (visitable instanceof TypedSubtree) {
			enableSeparator(currentLevel + 1, false, null);
		}
		if (currentAliasedElements.peek() == visitable) {
			currentAliasedElements.pop();
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			visitableToAliased.add(aliasedExpression);
		}
		--currentLevel;
	}
	protected void doWithPrefix(String prefix) {
		this.builder.append(prefix);
	}
	protected void doWithSuffix(String suffix) {
		this.builder.append(suffix);
	}
	void enter(Match match) {
		if (match.isOptional()) {
			builder.append("OPTIONAL ");
		}
		builder.append("MATCH ");
	}
	void leave(Match match) {
		builder.append(" ");
	}
	void enter(Where where) {
		builder.append(" WHERE ");
	}
	void enter(Create create) {
		builder.append("CREATE ");
	}
	void leave(Create create) {
		builder.append(" ");
	}
	void enter(Merge merge) {
		builder.append("MERGE ");
	}
	void leave(Merge merge) {
		if (!merge.hasEvents()) { // The last SET will include this
			builder.append(" ");
		}
	}
	void enter(MergeAction onCreateOrMatchEvent) {
		switch (onCreateOrMatchEvent.getType()) {
			case ON_CREATE -> builder.append("ON CREATE");
			case ON_MATCH -> builder.append("ON MATCH");
		}
		builder.append(" ");
	}
	void enter(Condition condition) {
		inRelationshipCondition = condition instanceof RelationshipPatternCondition;
	}
	void leave(Condition condition) {
		inRelationshipCondition = false;
	}
	void enter(Distinct distinct) {
		builder.append("DISTINCT ");
	}
	boolean inReturn;
	void enter(Return returning) {
		inReturn = true;
		if (!returning.isRaw()) {
			builder.append("RETURN ");
		}
	}
	void leave(Return returning) {
		inReturn = false;
	}
	void enter(With with) {
		builder.append("WITH ");
	}
	void leave(With with) {
		builder.append(" ");
	}
	void enter(Delete delete) {
		if (delete.isDetach()) {
			builder.append("DETACH ");
		}
		builder.append("DELETE ");
	}
	void leave(Delete match) {
		builder.append(" ");
	}
	boolean inLastReturn() {
		return inReturn && !inSubquery;
	}
	void enter(AliasedExpression aliased) {
		if (this.visitableToAliased.contains(aliased)) {
			builder.append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, false, inLastReturn())));
		}
	}
	void leave(AliasedExpression aliased) {
		if (!(this.visitableToAliased.contains(aliased) || scopingStrategy.isSkipAliasing())) {
			builder.append(" AS ").append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, true, inLastReturn())));
		}
	}
	void enter(NestedExpression nested) {
		builder.append("(");
	}
	void leave(NestedExpression nested) {
		builder.append(")");
	}
	void enter(Order order) {
		builder.append(" ORDER BY ");
	}
	void enter(Skip skip) {
		builder.append(" SKIP ");
	}
	void enter(Limit limit) {
		builder.append(" LIMIT ");
	}
	void enter(SortItem.Direction direction) {
		builder
			.append(" ")
			.append(direction.getSymbol());
	}
	void enter(PropertyLookup propertyLookup) {
		inPropertyLookup = true;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("[");
		} else {
			builder.append(".");
		}
	}
	void leave(PropertyLookup propertyLookup) {
		inPropertyLookup = false;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("]");
		}
	}
	void enter(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			functionName = "toString(id";
		}
		builder
			.append(functionName)
			.append("(");
	}
	void leave(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			builder.append(")");
		}
		builder.append(")");
	}
	void enter(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append("(");
		}
	}
	void enter(Operator operator) {
		Operator.Type type = operator.getType();
		if (type == Operator.Type.LABEL) {
			return;
		}
		boolean skipSpaces = SKIP_SPACES.contains(operator);
		if (type != Operator.Type.PREFIX && !skipSpaces) {
			builder.append(" ");
		}
		builder.append(operator.getRepresentation());
		if (type != Operator.Type.POSTFIX && !skipSpaces) {
			builder.append(" ");
		}
	}
	void leave(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append(")");
		}
	}
	void enter(Literal<?> expression) {
		builder.append(expression.asString());
	}
	void enter(Node node) {
		builder.append("(");
		// This is only relevant for nodes in relationships.
		// Otherwise, all the labels would be rendered again.
		skipNodeContent = scopingStrategy.hasVisitedBefore(node);
		if (skipNodeContent) {
			builder.append(nameResolvingStrategy.resolve(
				node.getSymbolicName().orElseGet(node::getRequiredSymbolicName), true, false));
		}
		inEntity = true;
	}
	void leave(Node node) {
		builder.append(")");
		skipNodeContent = false;
		inEntity = false;
	}
	void enter(NodeLabel nodeLabel) {
		escapeName(nodeLabel.getValue()).ifPresent(label -> builder.append(Symbols.NODE_LABEL_START).append(label));
	}
	void enter(LabelExpression labelExpression) {
		builder.append(":");
		renderLabelExpression(labelExpression, null);
	}
	@SuppressWarnings("squid:S3776")
	void renderLabelExpression(LabelExpression l, LabelExpression.Type parent) {
		if (l == null) {
			return;
		}
		if (l.negated()) {
			builder.append("!");
		}
		var current = l.type();
		boolean close = false;
		if (current != LabelExpression.Type.LEAF) {
			close = (parent != null || l.negated()) && l.type() != parent;
			if (close && !l.negated() && (current == LabelExpression.Type.CONJUNCTION || parent == LabelExpression.Type.DISJUNCTION)) {
				close = false;
			}
		}
		if (close) {
			builder.append("(");
		}
		renderLabelExpression(l.lhs(), current);
		if (current == LabelExpression.Type.LEAF) {
			l.value().forEach(v ->
				escapeName(v).ifPresent(builder::append)
			);
		}  else {
			builder.append(current.getValue());
		}
		renderLabelExpression(l.rhs(), current);
		if (close) {
			builder.append(")");
		}
	}
	void enter(Properties properties) {
		builder.append(" ");
	}
	void enter(SymbolicName symbolicName) {
		if (!inRelationshipCondition || nameResolvingStrategy.isResolved(symbolicName)) {
			if (Boolean.TRUE.equals(inPatternExpression.peek()) && !scopingStrategy.hasVisitedBefore(new Named() {
				@Override
				public @NotNull Optional<SymbolicName> getSymbolicName() {
					return Optional.of(symbolicName);
				}
			})) {
				return;
			}
			builder.append(nameResolvingStrategy.resolve(symbolicName, inEntity, inPropertyLookup));
		}
	}
	void enter(PatternExpression p) {
		this.inPatternExpression.push(true);
	}
	void leave(PatternExpression p) {
		this.inPatternExpression.pop();
	}
	void enter(Relationship relationship) {
		skipRelationshipContent = scopingStrategy.hasVisitedBefore(relationship);
		if (enforceSchema && relationship.getDetails().getDirection() != Relationship.Direction.UNI) {
			directionOverride = computeDirectionOverride(relationship);
		}
	}
	/**
	 * Helper to retrieve a nodes label
	 *
	 * @param node the node
	 * @return A set of labels
	 */
	private java.util.Set<String> getLabels(Node node) {
		var nl = node.getLabels();
		if (nl.isEmpty()) {
			var patternElement = scopingStrategy.lookup(node);
			if (patternElement instanceof Node boundNode) {
				nl = boundNode.getLabels();
			}
		}
		return nl.stream().map(NodeLabel::getValue).collect(Collectors.toSet());
	}
	/**
	 * Computes an overwrite for enforcing a schema
	 * @param relationship the relationship to potentially override
	 * @return A new direction
	 */
	Relationship.Direction computeDirectionOverride(Relationship relationship) {
		var sourceLabels = getLabels(relationship.getLeft());
		var targetLabels = getLabels(relationship.getRight());
		var details = relationship.getDetails();
		// Bail out on equal labels
		if (sourceLabels.equals(targetLabels)) {
			return details.getDirection();
		}
		for (String type : details.getTypes()) {
			outer:
			if (relationshipDefinitions.containsKey(type)) {
				var knownRelationships = relationshipDefinitions.get(type).stream().toList();
				for (var knownRelationship : knownRelationships) {
					if (knownRelationship.selfReferential() && (sourceLabels.isEmpty() || targetLabels.isEmpty())) {
						break outer;
					}
					if (
						sourceLabels.contains(knownRelationship.targetLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.sourceLabel())) ||
						targetLabels.contains(knownRelationship.sourceLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.RTL;
					} else if (
						sourceLabels.contains(knownRelationship.sourceLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.targetLabel())) ||
						targetLabels.contains(knownRelationship.targetLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.LTR;
					}
				}
			}
			if (!sourceLabels.isEmpty() && !targetLabels.isEmpty()) {
				throw new SchemaEnforcementFailedException();
			}
		}
		if (details.getTypes().isEmpty()) {
			var knownRelationships = this.relationshipDefinitions.values().stream().flatMap(List::stream).toList();
			for (var knownRelationship : knownRelationships) {
				if (sourceLabels.contains(knownRelationship.targetLabel()) && targetLabels.contains(knownRelationship.sourceLabel())) {
					return Relationship.Direction.RTL;
				} else if (sourceLabels.contains(knownRelationship.sourceLabel()) && targetLabels.contains(knownRelationship.targetLabel())) {
					return Relationship.Direction.LTR;
				}
			}
		}
		return details.getDirection();
	}
	void enter(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		builder.append(direction.getSymbolLeft());
		if (details.hasContent()) {
			builder.append("[");
		}
		inEntity = true;
	}
	void enter(RelationshipTypes types) {
		if (skipRelationshipContent) {
			return;
		}
		builder
			.append(types.getValues().stream()
				.map(this::escapeName)
				.map(Optional::orElseThrow)
				.collect(Collectors.joining(Symbols.REL_TYP_SEPARATOR, Symbols.REL_TYPE_START, "")));
	}
	void enter(RelationshipLength length) {
		if (skipRelationshipContent) {
			return;
		}
		Integer minimum = length.getMinimum();
		Integer maximum = length.getMaximum();
		if (length.isUnbounded()) {
			builder.append("*");
			return;
		}
		if (minimum == null && maximum == null) {
			return;
		}
		builder.append("*");
		if (minimum != null) {
			builder.append(minimum);
		}
		builder.append("..");
		if (maximum != null) {
			builder.append(maximum);
		}
	}
	void leave(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		if (details.hasContent()) {
			builder.append("]");
		}
		builder.append(direction.getSymbolRight());
		inEntity = false;
	}
	void leave(Relationship relationship) {
		skipRelationshipContent = false;
		directionOverride = null;
	}
	void enter(Parameter<?> parameter) {
		Object value = parameter.getValue();
		if (value instanceof ConstantParameterHolder constantParameterHolder && !renderConstantsAsParameters) {
			builder.append(constantParameterHolder.asString());
		} else {
			builder.append("$").append(nameResolvingStrategy.resolve(parameter));
		}
	}
	void enter(MapExpression map) {
		builder.append("{");
	}
	void enter(KeyValueMapEntry map) {
		builder.append(escapeIfNecessary(map.getKey())).append(": ");
	}
	void leave(MapExpression map) {
		builder.append("}");
	}
	void enter(ListExpression list) {
		builder.append("[");
	}
	void leave(ListExpression list) {
		builder.append("]");
	}
	void enter(Unwind unwind) {
		builder.append("UNWIND ");
	}
	void leave(Unwind unwind) {
		builder
			.append(" ");
	}
	void enter(UnionPart unionPart) {
		builder.append(" UNION ");
		if (unionPart.isAll()) {
			builder.append("ALL ");
		}
	}
	void enter(Set set) {
		builder.append("SET ");
	}
	void leave(Set set) {
		builder.append(" ");
	}
	void enter(Remove remove) {
		builder.append("REMOVE ");
	}
	void leave(Remove remove) {
		builder.append(" ");
	}
	void enter(PatternComprehension patternComprehension) {
		builder.append("[");
	}
	void leave(PatternComprehension patternComprehension) {
		builder.append("]");
	}
	void enter(ListComprehension listComprehension) {
		builder.append("[");
	}
	void leave(ListComprehension listComprehension) {
		builder.append("]");
	}
	void enter(Case genericCase) {
		builder.append("CASE");
	}
	void enter(Case.SimpleCase simpleCase) {
		builder.append("CASE ");
	}
	void enter(CaseWhenThen caseWhenExpression) {
		builder.append(" WHEN ");
	}
	void leave(CaseWhenThen caseWhenExpression) {
		builder.append(" THEN ");
	}
	void enter(CaseElse caseElseExpression) {
		builder.append(" ELSE ");
	}
	void leave(Case caseExpression) {
		builder.append(" END");
	}
	void enter(ProcedureCall procedureCall) {
		builder.append("CALL ");
	}
	void leave(Namespace namespace) {
		builder.append(".");
	}
	void leave(ProcedureName procedureName) {
		builder.append(procedureName.getValue());
	}
	void enter(YieldItems yieldItems) {
		builder.append(" YIELD ");
	}
	void leave(ProcedureCall procedureCall) {
		builder.append(" ");
	}
	void enter(Enum<?> anEnum) {
		builder.append(anEnum.name().replace("_", " ")).append(" ");
	}
	boolean inSubquery;
	void enter(Subquery subquery) {
		this.inSubquery = true;
		builder.append("CALL {");
	}
	void leave(Subquery subquery) {
		this.inSubquery = false;
		int l = builder.length() - 1;
		if (builder.charAt(l) == ' ' && !subquery.doesReturnOrYield()) {
			builder.replace(l, builder.length(), "} ");
		} else {
			builder.append("} ");
		}
	}
	void leave(InTransactions inTransactions) {
		int l = builder.length() - 1;
		if (builder.charAt(l) != ' ') {
			builder.append(" ");
		}
		builder.append("IN TRANSACTIONS ");
		if (inTransactions.getRows() != null) {
			builder.append("OF ").append(inTransactions.getRows()).append(" ROWS ");
		}
	}
	void enter(Foreach foreach) {
		builder.append("FOREACH (");
	}
	void leave(Foreach foreach) {
		builder.setCharAt(builder.length() - 1, ')'); // replace trailing space with ')'
		builder.append(" ");
	}
	void enter(SubqueryExpression subquery) {
		if (subquery instanceof CountExpression) {
			builder.append("COUNT");
		} else if (subquery instanceof ExistentialSubquery) {
			builder.append("EXISTS");
		} else if (subquery instanceof CollectExpression) {
			builder.append("COLLECT");
		}
		builder.append(" { ");
	}
	void leave(SubqueryExpression subquery) {
		// Trimming the inner match without having to do this in the match (looking up if inside subquery).
		if (builder.charAt(builder.length() - 1) == ' ') {
			builder.replace(builder.length() - 1, builder.length(), " }");
		} else {
			builder.append(" }");
		}
	}
	void enter(Hint hint) {
		builder.append(" USING ");
	}
	void enter(LoadCSV loadCSV) {
		builder.append("LOAD CSV");
		if (loadCSV.isWithHeaders()) {
			builder.append(" WITH HEADERS");
		}
		builder.append(" FROM '")
			.append(loadCSV.getUri().toString())
			.append("' AS ")
			.append(loadCSV.getAlias());
		if (loadCSV.getFieldTerminator() != null) {
			builder.append(" FIELDTERMINATOR '")
				.append(loadCSV.getFieldTerminator())
				.append("'");
		}
		builder.append(" ");
	}
	void enter(UsingPeriodicCommit usingPeriodicCommit) {
		builder.append("USING PERIODIC COMMIT ");
		if (usingPeriodicCommit.rate() != null) {
			builder.append(usingPeriodicCommit.rate()).append(" ");
		}
	}
	void enter(Use use) {
		builder.append("USE ");
		if (use.dynamic()) {
			builder.append("graph.byName(");
		}
	}
	void leave(Use use) {
		if (use.dynamic()) {
			builder.append(")");
		}
		builder.append(" ");
	}
	void enter(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append("(");
	}
	void leave(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append(")");
	}
	void enter(QuantifiedPathPattern.Quantifier quantifier) {
		builder.append(quantifier.toString());
	}
	@Override
	public String getRenderedContent() {
		return this.builder.toString();
	}
	/**
	 * Escapes a symbolic name. Such a symbolic name is either used for a nodes label, the type of a relationship or a
	 * variable.
	 *
	 * @param unescapedName The name to escape.
	 * @return An empty optional when the unescaped name is {@literal null}, otherwise the correctly escaped name, safe to be used in statements.
	 */
	protected final Optional<String> escapeName(String unescapedName) {
		return SchemaNamesBridge.sanitize(unescapedName, alwaysEscapeNames);
	}
	protected final String escapeIfNecessary(String potentiallyNonIdentifier) {
		return SchemaNamesBridge.sanitize(potentiallyNonIdentifier, false).orElse(null);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * Represents the properties of a {@link Node node} or a {@link Relationship relationship} when used as part of the
 * whole pattern (inside a {@code MATCH}, {@code CREATE} or {@code MERGE} clause as {@code {p1: v1, p2: v2, pn: vn}}.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class Properties implements Visitable {
	private final MapExpression value;
	/**
	 * Wraps an expression into a {@link Properties} node.
	 *
	 * @param expression Nullable expression
	 * @return A properties expression
	 */
	@Contract(pure = true)
	public static Properties create(MapExpression expression) {
		return expression == null ? null : new Properties(expression);
	}
	private Properties(MapExpression value) {
		this.value = value;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.value.accept(visitor);
		visitor.leave(this);
	}
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Map;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * This is the base class for all relationships. It can be used with generics, specifying valid start and end nodes.
 * This is useful when using it as a base class for a static meta model.
 *
 * @author Michael J. Simons
 * @param <S> The type at the start of the relationship
 * @param <E> The type at the pointy end of the relationship
 * @param <SELF> The type of the persistent relationship itself
 * @since 2021.1.0
 */
@API(status = STABLE, since = "2021.1.0")
public abstract class RelationshipBase<S extends NodeBase<?>, E extends NodeBase<?>, SELF extends RelationshipBase<S, E, SELF>>
		extends AbstractPropertyContainer implements Relationship {
	final Node left;
	final Node right;
	final Details details;
	@Nullable
	final QuantifiedPathPattern.Quantifier quantifier;
	// ------------------------------------------------------------------------
	// Public API to be used by the static meta model.
	// Non-final methods are ok to be overwritten.
	// ------------------------------------------------------------------------
	/**
	 * Always creates a relationship from start to end (left to right).
	 *
	 * @param start           start node
	 * @param end             end node
	 * @param type            type of the relationship
	 * @param additionalTypes additional types to add to the relationship
	 */
	protected RelationshipBase(S start, String type, E end, String... additionalTypes) {
		this(null, start, Direction.LTR, null, end, mergeTypesIfNecessary(type, additionalTypes));
	}
	private static String[] mergeTypesIfNecessary(String type, String... additionalTypes) {
		if (additionalTypes != null && additionalTypes.length > 0) {
			String[] result = new String[1 + additionalTypes.length];
			result[0] = type;
			System.arraycopy(additionalTypes, 0, result, 1, additionalTypes.length);
			return result;
		}
		return new String[] { type };
	}
	/**
	 * Always creates a relationship from start to end (left to right).
	 *
	 * @param symbolicName    an optional symbolic name
	 * @param start           start node
	 * @param properties      The properties for the relationship
	 * @param end             end node
	 * @param type            type of the relationship
	 * @param additionalTypes Additional types to be added to the relationship, only meaningfull when the object is used
	 *                        for querying, when used in a {@literal CREATE} or {@literal MERGE} clause the runtime will
	 *                        throw an exception.
	 */
	protected RelationshipBase(SymbolicName symbolicName, Node start, String type, Properties properties, Node end,
		String... additionalTypes) {
		this(symbolicName, start, Direction.LTR, properties, null, end, mergeTypesIfNecessary(type, additionalTypes));
	}
	/**
	 * Always creates a relationship from start to end (left to right).
	 *
	 * @param symbolicName an optional symbolic name
	 * @param start        start node
	 * @param properties   The properties for the relationship
	 * @param end          end node
	 * @param type         type of the relationship
	 */
	protected RelationshipBase(SymbolicName symbolicName, String type, Node start, Properties properties, Node end) {
		this(symbolicName, start, Direction.LTR, properties, null, end, type);
	}
	@NotNull
	@Override
	public final SELF named(String newSymbolicName) {
		Assertions.hasText(newSymbolicName, "Symbolic name is required.");
		return named(SymbolicName.of(newSymbolicName));
	}
	/**
	 * This method needs to be implemented to provide new, type safe instances of this relationship.
	 * @param newSymbolicName the new symbolic name.
	 * @return A new relationship
	 */
	@NotNull
	@Override
	public abstract SELF named(SymbolicName newSymbolicName);
	@NotNull
	@Override
	public final SELF withProperties(Object... keysAndValues) {
		MapExpression newProperties = null;
		if (keysAndValues != null && keysAndValues.length != 0) {
			newProperties = MapExpression.create(false, keysAndValues);
		}
		return withProperties(newProperties);
	}
	@NotNull
	@Override
	public final SELF withProperties(Map<String, Object> newProperties) {
		return withProperties(MapExpression.create(newProperties));
	}
	/**
	 * This method needs to be implemented to provide new, type safe instances of this relationship.
	 * @param newProperties the new properties (can be {@literal null} to remove exiting properties).
	 * @return A new relationship
	 */
	@NotNull
	@Override
	public abstract SELF withProperties(MapExpression newProperties);
	@NotNull
	@Override
	public final Node getLeft() {
		return left;
	}
	@NotNull
	@Override
	public final Node getRight() {
		return right;
	}
	@Nullable
	@Override
	public final QuantifiedPathPattern.Quantifier getQuantifier() {
		return quantifier;
	}
	@NotNull
	@Override
	public final Details getDetails() {
		return details;
	}
	@NotNull
	@Override
	public final Relationship unbounded() {
		return new InternalRelationshipImpl(this.left, this.details.unbounded(), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship min(Integer minimum) {
		return new InternalRelationshipImpl(this.left, this.details.min(minimum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship max(Integer maximum) {
		return new InternalRelationshipImpl(this.left, this.details.max(maximum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship length(Integer minimum, Integer maximum) {
		return new InternalRelationshipImpl(this.left, this.details.min(minimum).max(maximum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship inverse() {
		return new InternalRelationshipImpl(this.right, this.details.inverse(), this.quantifier, this.left);
	}
	@NotNull
	@Override
	public final Optional<SymbolicName> getSymbolicName() {
		return details.getSymbolicName();
	}
	@NotNull
	@Override
	public final SymbolicName getRequiredSymbolicName() {
		return details.getRequiredSymbolicName();
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipTo(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipTo(other, types));
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipFrom(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipFrom(other, types));
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipBetween(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipBetween(other, types));
	}
	@NotNull
	@Override
	public final Condition asCondition() {
		return RelationshipPatternCondition.of(this);
	}
	// ------------------------------------------------------------------------
	// Internal API.
	// ------------------------------------------------------------------------
	RelationshipBase(SymbolicName symbolicName, Node left, Direction direction, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		this(symbolicName, left, direction, null, quantifier, right, types);
	}
	RelationshipBase(SymbolicName symbolicName, Node left, Direction direction, Properties properties, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		this(left, Details.create(direction, symbolicName, types).with(properties), quantifier, right);
	}
	RelationshipBase(Node left, Details details, QuantifiedPathPattern.Quantifier quantifier, Node right) {
		Assertions.notNull(left, "Left node is required.");
		Assertions.notNull(details, "Details are required.");
		Assertions.notNull(right, "Right node is required.");
		this.left = left;
		this.right = right;
		this.details = details;
		this.quantifier = quantifier;
	}
	@Override
	public final void accept(Visitor visitor) {
		visitor.enter(this);
		left.accept(visitor);
		details.accept(visitor);
		Visitable.visitIfNotNull(this.quantifier, visitor);
		right.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	@Override
	public @NotNull Relationship where(@Nullable Expression predicate) {
		if (predicate == null) {
			return this;
		}
		return new InternalRelationshipImpl(this.left, this.details.where(predicate), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public RelationshipPattern quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		if (newQuantifier == null) {
			return this;
		}
		return new InternalRelationshipImpl(this.left, this.details, newQuantifier, this.right);
	}
	@NotNull
	@Override
	public QuantifiedPathPattern quantify(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		return QuantifiedPathPattern.of(this, newQuantifier);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
/**
 * An internal implementation of the {@link RelationshipBase}. It's primary purpose is to have {@link RelationshipBase#named(SymbolicName)}
 * and {@link RelationshipBase#withProperties(MapExpression)} abstract method to enforce the correct return type. Otherwise, one
 * could extend {@link RelationshipBase} without overriding those, ignoring unchecked casts and eventually running into a {@link ClassCastException}.
 *
 * @author Michael J. Simons
 * @since 2021.1.0
 */
@API(status = INTERNAL, since = "2021.1.0")
final class InternalRelationshipImpl extends RelationshipBase<NodeBase<?>, NodeBase<?>, InternalRelationshipImpl> {
	InternalRelationshipImpl(SymbolicName symbolicName, Node left,
		Direction direction, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		super(symbolicName, left, direction, quantifier, right, types);
	}
	InternalRelationshipImpl(SymbolicName symbolicName, Node left,
		Direction direction, Properties properties, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		super(symbolicName, left, direction, properties, quantifier, right, types);
	}
	InternalRelationshipImpl(Node left, Details details, QuantifiedPathPattern.Quantifier quantifier, Node right) {
		super(left, details, quantifier, right);
	}
	@NotNull
	@Override
	public InternalRelationshipImpl named(SymbolicName newSymbolicName) {
		return new InternalRelationshipImpl(this.left, this.details.named(newSymbolicName), quantifier, this.right);
	}
	@NotNull
	@Override
	public InternalRelationshipImpl withProperties(MapExpression newProperties) {
		return new InternalRelationshipImpl(this.left, this.details.with(Properties.create(newProperties)), quantifier, this.right);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import static org.apiguardian.api.API.Status.INTERNAL;
/**
 * Abstract base class for the {@link NodeBase node implementation} to avoid default interface methods to be overridable
 * in inheritors.
 *
 * @author Michael J. Simons
 * @since 2021.1.0
 */
@API(status = INTERNAL, since = "2021.1.0")
abstract class AbstractNode extends AbstractPropertyContainer implements Node {
	@NotNull
	@Override
	public final Condition hasLabels(String... labelsToQuery) {
		return HasLabelCondition.create(this.getSymbolicName()
						.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
				labelsToQuery);
	}
	@NotNull
	@Override
	public final Condition hasLabels(LabelExpression labels) {
		return new HasLabelExpressionCondition(this.getSymbolicName()
			.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
			labels);
	}
	@NotNull
	@Override
	public final Condition isEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNotEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isNotEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNull() {
		return this.getRequiredSymbolicName().isNull();
	}
	@NotNull
	@Override
	public final Condition isNotNull() {
		return this.getRequiredSymbolicName().isNotNull();
	}
	@NotNull
	@Override
	public final SortItem descending() {
		return this.getRequiredSymbolicName().descending();
	}
	@NotNull
	@Override
	public final SortItem ascending() {
		return this.getRequiredSymbolicName().ascending();
	}
	@NotNull
	@Override
	public final AliasedExpression as(String alias) {
		return this.getRequiredSymbolicName().as(alias);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation") // IDEA is stupid.
	public final FunctionInvocation internalId() {
		return Functions.id(this);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final FunctionInvocation labels() {
		return Functions.labels(this);
	}
	@NotNull
	@Override
	public final Relationship relationshipTo(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.LTR, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipFrom(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.RTL, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipBetween(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.UNI, null, other, types);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAmount;
import java.time.temporal.TemporalUnit;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.driver.Value;
import org.neo4j.driver.types.TypeSystem;
/**
 * @author Michael J. Simons
 * @soundtrack Prezident - Gesunder Eskapismus
 * @since 2023.2.1
 */
@API(status = INTERNAL, since = "2023.2.1")
@SuppressWarnings("unused")
@RegisterForReflection(allDeclaredConstructors = true)
class DriverValueAdapter implements ForeignAdapter<Value> {
	private final Value value;
	DriverValueAdapter(Value value) {
		this.value = value;
	}
	@Override
	@NotNull
	public Condition asCondition() {
		if (value.hasType(TypeSystem.getDefault().BOOLEAN())) {
			return asExpression().asCondition();
		}
		throw new UnsupportedOperationException("Only Boolean values can be adapted as condition");
	}
	@Override
	@NotNull
	public Expression asExpression() {
		return asExpression0(value);
	}
	private static Expression asExpression0(Value value) {
		var typeSystem = TypeSystem.getDefault();
		if (value.hasType(typeSystem.NODE())) {
			throw new IllegalArgumentException("Node values can only be adapted with asNode");
		}
		if (value.hasType(typeSystem.RELATIONSHIP())) {
			throw new IllegalArgumentException("Relationship values can only be adapted with asRelationship");
		}
		if (value.hasType(typeSystem.POINT())) {
			var p = value.asPoint();
			if (Double.isNaN(p.z())) {
				return new PointLiteral(new TreeMap<>(Map.of("srid", p.srid(), "x", p.x(), "y", p.y())));
			} else {
				return new PointLiteral(new TreeMap<>(Map.of("srid", p.srid(), "x", p.x(), "y", p.y(), "z", p.z())));
			}
		}
		if (value.hasType(typeSystem.FLOAT())) {
			return asFloatOrDouble(value);
		}
		if (value.hasType(typeSystem.DURATION())) {
			var d = value.asIsoDuration();
			return Cypher.literalOf(new TemporalAmountAdapter().apply(d));
		}
		if (value.hasType(typeSystem.BYTES())) {
			throw new IllegalArgumentException("byte[] values cannot be represented as expression.");
		}
		if (value.hasType(typeSystem.LIST())) {
			return Cypher.literalOf(value.asList(DriverValueAdapter::asExpression0));
		}
		if (value.hasType(typeSystem.MAP())) {
			return Cypher.literalOf(value.asMap(DriverValueAdapter::asExpression0));
		}
		return Cypher.literalOf(value.asObject());
	}
	@SuppressWarnings("squid:S1872") // See below error checking, it's a bug in the Neo4j Java driver not exporting that exception in the module path
	private static Literal<Object> asFloatOrDouble(Value value) {
		Number number;
		try {
			number = value.asFloat();
		} catch (Exception e) {
			if (!"org.neo4j.driver.exceptions.value.LossyCoercion".equals(e.getClass().getName())) {
				throw e;
			}
			number = value.asDouble();
		}
		return Cypher.literalOf(number);
	}
	@Override
	@NotNull
	public Node asNode() {
		if (!value.hasType(TypeSystem.getDefault().NODE())) {
			throw new IllegalArgumentException("Cannot adopt value with type " + value.type().name() + " as node");
		}
		var node = value.asNode();
		var labels = node.labels();
		String primaryLabel = null;
		var additionalLabels = new ArrayList<String>();
		for (String label : labels) {
			if (primaryLabel == null) {
				primaryLabel = label;
			} else {
				additionalLabels.add(label);
			}
		}
		var properties = node.size() == 0 ? null : MapExpression.create(node.asMap(DriverValueAdapter::asExpression0));
		if (primaryLabel != null) {
			return Cypher.node(primaryLabel, properties, additionalLabels);
		}
		return Cypher.anyNode().withProperties(properties);
	}
	@Override
	@NotNull
	public Relationship asRelationship() {
		if (!value.hasType(TypeSystem.getDefault().RELATIONSHIP())) {
			throw new IllegalArgumentException("Cannot adopt value with type " + value.type().name() + " as relationship");
		}
		var relationship = value.asRelationship();
		var properties = relationship.size() == 0 ? null : MapExpression.create(relationship.asMap(DriverValueAdapter::asExpression0));
		return Cypher.anyNode()
			.relationshipTo(Cypher.anyNode(), relationship.type()).withProperties(properties);
	}
	@Override
	@NotNull
	public SymbolicName asName() {
		throw new UnsupportedOperationException();
	}
	/**
	 * This adapter maps a Driver or embedded based {@link TemporalAmount} to a valid Java temporal amount. It tries to be
	 * as specific as possible: If the amount can be reliable mapped to a {@link Period}, it returns a period. If only
	 * fields are present that are no estimated time unites, then it returns a {@link Duration}. <br>
	 * <br>
	 * In cases a user has used Cypher and its <code>duration()</code> function, i.e. like so
	 * <code>CREATE (s:SomeTime {isoPeriod: duration('P13Y370M45DT25H120M')}) RETURN s</code> a duration object has been
	 * created that cannot be represented by either a {@link Period} or {@link Duration}. The user has to map it to a plain
	 * {@link TemporalAmount} in these cases. <br>
	 * The Java Driver uses a <code>org.neo4j.driver.types.IsoDuration</code>, embedded uses
	 * <code>org.neo4j.values.storable.DurationValue</code> for representing a temporal amount, but in the end, they can be
	 * treated the same. However, be aware that the temporal amount returned in that case may not be equal to the other one,
	 * only represents the same amount after normalization.
	 * <p>
	 * From Neo4j-OGM, to SDN6, to Cypher-DSL… The joy.
	 */
	static final class TemporalAmountAdapter implements UnaryOperator<TemporalAmount> {
		private static final int PERIOD_MASK = 0b11100;
		private static final int DURATION_MASK = 0b00011;
		private static final TemporalUnit[] SUPPORTED_UNITS = {ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS,
			ChronoUnit.SECONDS, ChronoUnit.NANOS};
		private static final short FIELD_YEAR = 0;
		private static final short FIELD_MONTH = 1;
		private static final short FIELD_DAY = 2;
		private static final short FIELD_SECONDS = 3;
		private static final short FIELD_NANOS = 4;
		private static final BiFunction<TemporalAmount, TemporalUnit, Integer> TEMPORAL_UNIT_EXTRACTOR = (d, u) -> {
			if (!d.getUnits().contains(u)) {
				return 0;
			}
			return Math.toIntExact(d.get(u));
		};
		@Override
		public TemporalAmount apply(TemporalAmount internalTemporalAmountRepresentation) {
			int[] values = new int[SUPPORTED_UNITS.length];
			int type = 0;
			for (int i = 0; i < SUPPORTED_UNITS.length; ++i) {
				values[i] = TEMPORAL_UNIT_EXTRACTOR.apply(internalTemporalAmountRepresentation, SUPPORTED_UNITS[i]);
				type |= (values[i] == 0) ? 0 : (0b10000 >> i);
			}
			boolean couldBePeriod = couldBePeriod(type);
			boolean couldBeDuration = couldBeDuration(type);
			if (couldBePeriod && !couldBeDuration) {
				return Period.of(values[FIELD_YEAR], values[FIELD_MONTH], values[FIELD_DAY]).normalized();
			} else if (couldBeDuration && !couldBePeriod) {
				return Duration.ofSeconds(values[FIELD_SECONDS]).plusNanos(values[FIELD_NANOS]);
			} else {
				return internalTemporalAmountRepresentation;
			}
		}
		private static boolean couldBePeriod(int type) {
			return (PERIOD_MASK & type) > 0;
		}
		private static boolean couldBeDuration(int type) {
			return (DURATION_MASK & type) > 0;
		}
	}
	private static final class PointLiteral extends LiteralBase<Map<String, Object>> {
		private PointLiteral(Map<String, Object> content) {
			super(content);
		}
		@Override
		@NotNull
		public String asString() {
			return content.entrySet().stream()
				.map(e -> e.getKey() + ": " + e.getValue())
				.collect(Collectors.joining(", ", "point({", "})"));
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.ParameterCollectingVisitor.ParameterInformation;
import org.neo4j.cypherdsl.core.StatementCatalog.Clause;
import org.neo4j.cypherdsl.core.StatementCatalog.PropertyFilter;
import org.neo4j.cypherdsl.core.StatementCatalog.Token;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.Namespace;
import org.neo4j.cypherdsl.core.internal.ReflectiveVisitor;
import org.neo4j.cypherdsl.core.internal.ScopingStrategy;
/**
 * This visitor  creates a  {@link StatementCatalog  statement catalog}.  It is  not thread  safe and  must not  be used
 * multiple times. Please create a new instance on each invocation.
 *
 * @author Michael J. Simons
 * @soundtrack Avenger - Prayers Of Steel
 * @since 2023.1.0
 */
@RegisterForReflection
@SuppressWarnings({"unused", "squid:S1172"})
class StatementCatalogBuildingVisitor extends ReflectiveVisitor {
	/**
	 * Constant class name for skipping compounds, not inclined to make this type public.
	 */
	private static final String TYPE_OF_COMPOUND_CONDITION = "org.neo4j.cypherdsl.core.CompoundCondition";
	/**
	 * Current clause the visitor is in.
	 */
	private final AtomicReference<Clause> currentClause = new AtomicReference<>(Clause.UNKNOWN);
	/**
	 * The current pattern element visited.
	 */
	private final Deque<PatternElement> currentPatternElement = new ArrayDeque<>();
	private final Set<Token> tokens = new LinkedHashSet<>();
	private final Set<StatementCatalog.Property> properties = new LinkedHashSet<>();
	private final Set<StatementCatalog.LabelFilter> labelFilters = new LinkedHashSet<>();
	private final Map<StatementCatalog.Property, Set<PropertyFilter>> propertyFilters = new LinkedHashMap<>();
	/**
	 * Scoped lookup tables from symbolic name to pattern elements (nodes or relationships).
	 */
	private final Deque<Map<SymbolicName, PatternElement>> patternLookup = new ArrayDeque<>();
	/**
	 * A stack of conditions (keeping track of the latest entered).
	 */
	private final Deque<org.neo4j.cypherdsl.core.Condition> currentConditions = new ArrayDeque<>();
	private final AtomicReference<Set<Token>> currentHasLabelCondition = new AtomicReference<>();
	/**
	 * Required for resolving parameter names, must be from the same statement that is analyzed.
	 */
	private final StatementContext statementContext;
	private final boolean renderConstantsAsParameters;
	/**
	 * Delegating the hard work to the shared scope strategy in most cases.
	 */
	private final ScopingStrategy scopingStrategy;
	private final ParameterCollectingVisitor allParameters;
	private final Map<Node, Set<Token>> currentUndirectedRelations = new HashMap<>();
	private final Map<Node, Set<Token>> currentIncomingRelations = new HashMap<>();
	private final Map<Node, Set<Token>> currentOutgoingRelations = new HashMap<>();
	private final Map<Token, Relationships> relationships = new HashMap<>();
	private final Set<Literal<?>> literals = new LinkedHashSet<>();
	StatementCatalogBuildingVisitor(StatementContext statementContext, boolean renderConstantsAsParameters) {
		this.statementContext = statementContext;
		this.renderConstantsAsParameters = renderConstantsAsParameters;
		this.scopingStrategy = ScopingStrategy.create(
			List.of((cause, imports) -> patternLookup.push(createNewScope(imports))),
			List.of((cause, exports) -> importIntoCurrentScope(exports))
		);
		this.patternLookup.push(new HashMap<>());
		this.allParameters = new ParameterCollectingVisitor(statementContext, renderConstantsAsParameters);
	}
	private Map<SymbolicName, PatternElement> createNewScope(Collection<IdentifiableElement> imports) {
		addRelationsInCurrentScope();
		Map<SymbolicName, PatternElement> currentScope = patternLookup.isEmpty() ? Collections.emptyMap() : patternLookup.peek();
		Map<SymbolicName, PatternElement> newScope = new HashMap<>();
		copyIdentifiableElements(imports, currentScope, newScope);
		return newScope;
	}
	private void importIntoCurrentScope(Collection<IdentifiableElement> exports) {
		Map<SymbolicName, PatternElement> previousScope = patternLookup.pop();
		Map<SymbolicName, PatternElement> currentScope = patternLookup.isEmpty() ? new HashMap<>() : patternLookup.peek();
		copyIdentifiableElements(exports, previousScope, currentScope);
	}
	private static void copyIdentifiableElements(Collection<IdentifiableElement> elements, Map<SymbolicName, PatternElement> source, Map<SymbolicName, PatternElement> target) {
		for (IdentifiableElement e : elements) {
			if (e instanceof SymbolicName s && source.containsKey(s)) {
				target.put(s, source.get(s));
			} else if (e instanceof Named n && e instanceof PatternElement p) {
				target.put(n.getRequiredSymbolicName(), p);
			}
		}
	}
	/**
	 * A holder for the relationship types connected to node labels
	 * @param outgoing Outgoing types
	 * @param incoming Incoming types
	 * @param undirected Undirected connections
	 */
	record Relationships(Set<Token> outgoing, Set<Token> incoming, Set<Token> undirected) {
		static Relationships empty() {
			return new Relationships(Set.of(), Set.of(), Set.of());
		}
		Relationships() {
			this(new HashSet<>(), new HashSet<>(), new HashSet<>());
		}
		Relationships copy() {
			return new Relationships(Set.copyOf(this.outgoing), Set.copyOf(this.incoming), Set.copyOf(this.undirected));
		}
	}
	StatementCatalog getResult() {
		addRelationsInCurrentScope();
		var parameterInformation = allParameters.getResult();
		return new DefaultStatementCatalog(this.tokens, this.labelFilters, this.properties, this.propertyFilters, scopingStrategy.getIdentifiables(), parameterInformation, relationships, literals);
	}
	void addRelationsInCurrentScope() {
		finish(currentOutgoingRelations, Relationships::outgoing);
		finish(currentIncomingRelations, Relationships::incoming);
		finish(currentUndirectedRelations, Relationships::undirected);
	}
	/**
	 * Finishes up the relationship's storage (retrieval of actual labels from the nodes)
	 *
	 * @param nodesToRelations The map to process
	 * @param targetProvider   The target where to store the tokens
	 */
	private void finish(Map<Node, Set<Token>> nodesToRelations, Function<Relationships, Set<Token>> targetProvider) {
		nodesToRelations.forEach((k, v) -> {
			var labels = getAllLabels((Node) k.getSymbolicName().map(this::lookup).orElse(k));
			labels.forEach(t -> {
				var rels = relationships.computeIfAbsent(t, unused -> new Relationships());
				targetProvider.apply(rels).addAll(v);
			});
		});
		nodesToRelations.clear();
	}
	@Override
	protected boolean preEnter(Visitable visitable) {
		scopingStrategy.doEnter(visitable);
		return true;
	}
	@Override
	protected void postLeave(Visitable visitable) {
		scopingStrategy.doLeave(visitable);
	}
	void enter(Match match) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.MATCH);
	}
	void leave(Match match) {
		currentClause.compareAndSet(Clause.MATCH, Clause.UNKNOWN);
	}
	void enter(Create create) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.CREATE);
	}
	void leave(Create create) {
		currentClause.compareAndSet(Clause.CREATE, Clause.UNKNOWN);
	}
	void enter(Merge merge) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.MERGE);
	}
	void leave(Merge merge) {
		currentClause.compareAndSet(Clause.MERGE, Clause.UNKNOWN);
	}
	void enter(Delete delete) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.DELETE);
	}
	void leave(Delete delete) {
		currentClause.compareAndSet(Clause.DELETE, Clause.UNKNOWN);
	}
	void enter(With with) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.WITH);
	}
	void leave(With with) {
		currentClause.compareAndSet(Clause.WITH, Clause.UNKNOWN);
	}
	void enter(Node node) {
		node.getSymbolicName().ifPresent(s -> store(s, node));
		currentPatternElement.push(node);
	}
	void enter(KeyValueMapEntry mapEntry) {
		var owner = currentPatternElement.peek();
		if (owner == null) {
			return;
		}
		StatementCatalog.Property property;
		if (owner instanceof Node node) {
			property = new StatementCatalog.Property(getAllLabels(node), mapEntry.getKey());
		} else if (owner instanceof Relationship relationship) {
			property = new StatementCatalog.Property(relationship.getDetails().getTypes().stream().map(Token::type).collect(Collectors.toSet()), mapEntry.getKey());
		} else {
			property = null;
		}
		if (property == null) {
			return;
		}
		this.properties.add(property);
		Expression left;
		if (((PropertyContainer) owner).getSymbolicName().isPresent()) {
			left = ((PropertyContainer) owner).property(mapEntry.getKey());
		} else {
			left = PropertyLookup.forName(mapEntry.getKey());
		}
		var parameterInformation = extractParameters(mapEntry.getValue());
		this.propertyFilters.computeIfAbsent(property, ignored -> new HashSet<>())
			.add(new PropertyFilter(currentClause.get(), left, Operator.EQUALITY, mapEntry.getValue(), parameterInformation.names, parameterInformation.values));
	}
	void leave(Node node) {
		currentPatternElement.removeFirstOccurrence(node);
	}
	void enter(Relationship relationship) {
		relationship.getSymbolicName().ifPresent(s -> store(s, relationship));
		currentPatternElement.push(relationship);
		var types = relationship.getDetails().getTypes().stream().map(Token::type).toList();
		tokens.addAll(types);
		storeRelations(relationship.getLeft(), relationship.getRight(), types, relationship.getDetails().getDirection());
	}
	/**
	 * Stores the source and target of this relationships in incoming/outgoing and undirected lists for processing
	 * after leaving the scope / statement (when all labels are known).
	 *
	 * @param left      Left hand side of the relation
	 * @param right     Right hand side of the relation
	 * @param types     Types of the relation
	 * @param direction Direction of the relation
	 */
	private void storeRelations(Node left, Node right, List<Token> types, Relationship.Direction direction) {
		final Function<Node, Set<Token>> targetSupplier = unused -> new HashSet<>();
		switch (direction) {
			case UNI -> {
				currentUndirectedRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentUndirectedRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
			case LTR -> {
				currentOutgoingRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentIncomingRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
			case RTL -> {
				currentIncomingRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentOutgoingRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
		}
	}
	void leave(Relationship relationship) {
		currentPatternElement.removeFirstOccurrence(relationship);
	}
	void enter(org.neo4j.cypherdsl.core.Property property) {
		if (property.getNames().size() != 1) {
			return;
		}
		var lookup = property.getNames().get(0);
		if (lookup.isDynamicLookup()) {
			return;
		}
		if (!(property.getContainerReference() instanceof SymbolicName s)) {
			return;
		}
		var propertyName = new AtomicReference<String>();
		lookup.accept(segment -> {
			if (segment instanceof SymbolicName name) {
				propertyName.compareAndSet(null, name.getValue());
			}
		});
		StatementCatalog.Property newProperty;
		var patternElement = lookup(s);
		if (patternElement instanceof Node node) {
			newProperty = new StatementCatalog.Property(
				getAllLabels(node),
				propertyName.get()
			);
		} else if (patternElement instanceof Relationship relationship) {
			newProperty = new StatementCatalog.Property(
				relationship.getDetails().getTypes().stream().map(Token::type).collect(Collectors.toSet()),
				propertyName.get()
			);
		} else {
			return;
		}
		properties.add(newProperty);
		if (inCurrentCondition(property)) {
			propertyFilters.computeIfAbsent(newProperty, ignored -> new HashSet<>())
				.add(extractPropertyCondition(newProperty, currentConditions.peek()));
		}
	}
	private static Set<Token> getAllLabels(Node node) {
		Set<Token> result = new TreeSet<>();
		if (node.getLabels().isEmpty()) {
			node.accept(segment -> {
				if (segment instanceof LabelExpression l) {
					collectLabels(l, null, result);
				}
			});
		} else {
			node.getLabels().stream()
				.map(NodeLabel::getValue)
				.map(Token::label)
				.forEach(result::add);
		}
		return result;
	}
	private static void collectLabels(LabelExpression l, LabelExpression.Type parent, Set<Token> labels) {
		if (l == null) {
			return;
		}
		var current = l.type();
		collectLabels(l.lhs(), current, labels);
		if (current == LabelExpression.Type.LEAF) {
			l.value().stream().map(Token::label).forEach(labels::add);
		}
		collectLabels(l.rhs(), current, labels);
	}
	void enter(Parameter<?> parameter) {
		this.allParameters.enter(parameter);
	}
	private boolean inCurrentCondition(org.neo4j.cypherdsl.core.Property property) {
		var currentCondition = this.currentConditions.peek();
		if (currentCondition == null) {
			return false;
		}
		var result = new AtomicBoolean();
		currentCondition.accept(segment -> {
			if (segment == property) {
				result.compareAndSet(false, true);
			}
		});
		return result.get();
	}
	private PropertyFilter extractPropertyCondition(StatementCatalog.Property property, org.neo4j.cypherdsl.core.Condition condition) {
		var left = new AtomicReference<Expression>();
		var op = new AtomicReference<Operator>();
		var right = new AtomicReference<Expression>();
		condition.accept(new Visitor() {
			int cnt;
			@Override
			public void enter(Visitable segment) {
				if (++cnt != 2) {
					return;
				}
				if (segment instanceof Operator operator) {
					op.compareAndSet(null, operator);
				} else if (segment instanceof Expression expression && !left.compareAndSet(null, expression)) {
					right.compareAndSet(null, expression);
				}
			}
			@Override
			public void leave(Visitable segment) {
				--cnt;
			}
		});
		var parameterInformation = extractParameters(left.get(), right.get());
		return new PropertyFilter(currentClause.get(), left.get(), op.get(), right.get(), parameterInformation.names, parameterInformation.values);
	}
	void enter(NodeLabel label) {
		this.tokens.add(new Token(Token.Type.NODE_LABEL, label.getValue()));
		var currentCondition = currentConditions.peek();
		if (currentCondition instanceof HasLabelCondition hasLabelCondition) {
			this.currentHasLabelCondition.get().add(Token.label(label));
		}
	}
	void enter(LabelExpression labelExpression) {
		collectLabels(labelExpression, null, tokens);
	}
	PatternElement lookup(SymbolicName s) {
		if (patternLookup.isEmpty()) {
			throw new IllegalStateException("Invalid scope");
		}
		return patternLookup.peek().get(s);
	}
	void enter(org.neo4j.cypherdsl.core.Condition condition) {
		if (TYPE_OF_COMPOUND_CONDITION.equals(condition.getClass().getName())) {
			return;
		}
		this.currentConditions.push(condition);
		if (condition instanceof HasLabelCondition) {
			this.currentHasLabelCondition.compareAndSet(null, new TreeSet<>());
		}
	}
	void enter(Literal<?> literal) {
		if (literal instanceof Asterisk || literal instanceof PeriodLiteral || literal instanceof RawLiteral.RawElement || literal == LiteralBase.BLANK || literal == ListOperator.DOTS || literal instanceof Namespace) {
			return;
		}
		this.literals.add(literal);
	}
	void leave(org.neo4j.cypherdsl.core.Condition condition) {
		if (TYPE_OF_COMPOUND_CONDITION.equals(condition.getClass().getName())) {
			return;
		}
		this.currentConditions.pop();
		var setOfRequiredTokens = currentHasLabelCondition.getAndSet(null);
		if (condition instanceof HasLabelCondition hasLabelCondition && setOfRequiredTokens != null) {
			AtomicReference<String> symbolicName = new AtomicReference<>();
			hasLabelCondition.accept(segment -> {
				if (segment instanceof SymbolicName s) {
					symbolicName.compareAndSet(null, s.getValue());
				}
			});
			this.labelFilters.add(new StatementCatalog.LabelFilter(symbolicName.get(), setOfRequiredTokens));
		}
	}
	void store(SymbolicName s, PatternElement patternElement) {
		if (patternLookup.isEmpty()) {
			throw new IllegalStateException("Invalid scope");
		}
		var currentScope = patternLookup.peek();
		// Don't overwrite in same scope or when imported,
		// size == 1 catering for with clauses on top level
		if (currentScope.containsKey(s) && (scopingStrategy.getCurrentImports().contains(s) || patternLookup.size() == 1)) {
			return;
		}
		currentScope.put(s, patternElement);
	}
	private ParameterInformation extractParameters(Expression... expressions) {
		var parameterCollectingVisitor = new ParameterCollectingVisitor(this.statementContext, this.renderConstantsAsParameters);
		for (Expression expression : expressions) {
			if (expression == null) {
				continue;
			}
			expression.accept(parameterCollectingVisitor);
		}
		return parameterCollectingVisitor.getResult();
	}
	static final class DefaultStatementCatalog implements StatementCatalog {
		private final Set<Token> tokens;
		private final Set<Property> properties;
		private final Collection<LabelFilter> labelFilters;
		private final Map<Property, Collection<PropertyFilter>> propertyFilters;
		private final Set<Expression> identifiableExpressions;
		private final ParameterInformation parameterInformation;
		private final Map<Token, Relationships> relationships;
		private final Set<Literal<?>> literals;
		@SuppressWarnings("squid:S107") // Totally fine with that number of args.
		DefaultStatementCatalog(
			Set<Token> tokens,
			Set<LabelFilter> labelFilters,
			Set<Property> properties,
			Map<Property, Set<PropertyFilter>> propertyFilters,
			Collection<Expression> identifiableExpressions,
			ParameterInformation parameterInformation,
			Map<Token, Relationships> relationships,
			Set<Literal<?>> literals
		) {
			this.tokens = Collections.unmodifiableSet(tokens);
			this.labelFilters = Collections.unmodifiableSet(labelFilters);
			this.properties = Collections.unmodifiableSet(properties);
			this.propertyFilters = propertyFilters.entrySet().stream()
				.collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, e -> Collections.unmodifiableSet(e.getValue())));
			this.identifiableExpressions = identifiableExpressions instanceof Set<Expression> s ? Collections.unmodifiableSet(s) : Set.copyOf(identifiableExpressions);
			this.parameterInformation = parameterInformation;
			this.relationships = relationships.entrySet().stream()
				.collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, e -> e.getValue().copy()));
			this.literals = Collections.unmodifiableSet(literals);
		}
		@Override
		public Set<Token> getAllTokens() {
			return tokens;
		}
		@Override
		public Set<Property> getProperties() {
			return properties;
		}
		@Override
		public Collection<LabelFilter> getAllLabelFilters() {
			return this.labelFilters;
		}
		@Override
		public Map<Property, Collection<PropertyFilter>> getAllPropertyFilters() {
			return this.propertyFilters;
		}
		@Override
		public Set<Expression> getIdentifiableExpressions() {
			return identifiableExpressions;
		}
		@Override
		public Map<String, Object> getParameters() {
			return parameterInformation.values;
		}
		@Override
		public Collection<String> getParameterNames() {
			return parameterInformation.names;
		}
		@Override
		public Map<String, String> getRenamedParameters() {
			return parameterInformation.renames;
		}
		@Override
		public Collection<Token> getOutgoingRelations(Token label) {
			return extractRelations(label, Relationships::outgoing);
		}
		private Collection<Token> extractRelations(Token label, Function<Relationships, Set<Token>> tokenProvider) {
			if (label.type() != Token.Type.NODE_LABEL) {
				throw new IllegalArgumentException(label + " must be a node label, not a relationship type");
			}
			return tokenProvider.apply(relationships.getOrDefault(label, Relationships.empty()));
		}
		@Override
		public Collection<Token> getTargetNodes(Token type) {
			if (type.type() != Token.Type.RELATIONSHIP_TYPE) {
				throw new IllegalArgumentException(type + " must be a relationship type, not a node label");
			}
			return relationships
				.entrySet()
				.stream()
				.filter(e -> e.getValue().incoming().contains(type))
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet());
		}
		@Override
		public Collection<Token> getIncomingRelations(Token label) {
			return extractRelations(label, Relationships::incoming);
		}
		@Override
		public Collection<Token> getSourceNodes(Token type) {
			if (type.type() != Token.Type.RELATIONSHIP_TYPE) {
				throw new IllegalArgumentException(type + " must be a relationship type, not a node label");
			}
			return relationships
				.entrySet()
				.stream()
				.filter(e -> e.getValue().outgoing().contains(type))
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet());
		}
		@Override
		public Collection<Token> getUndirectedRelations(Token label) {
			return extractRelations(label, Relationships::undirected);
		}
		@Override
		public Set<Literal<?>> getLiterals() {
			return literals;
		}
	}
}